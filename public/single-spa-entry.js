var ip = Object.defineProperty;
var Sl = (e) => {
  throw TypeError(e);
};
var op = (e, t, s) => t in e ? ip(e, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : e[t] = s;
var Js = (e, t, s) => op(e, typeof t != "symbol" ? t + "" : t, s), Jn = (e, t, s) => t.has(e) || Sl("Cannot " + s);
var ee = (e, t, s) => (Jn(e, t, "read from private field"), s ? s.call(e) : t.get(e)), Le = (e, t, s) => t.has(e) ? Sl("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, s), Ye = (e, t, s, i) => (Jn(e, t, "write to private field"), i ? i.call(e, s) : t.set(e, s), s), ws = (e, t, s) => (Jn(e, t, "access private method"), s);
var In = Array.isArray, np = Array.prototype.indexOf, aa = Array.from, Lr = Object.defineProperty, ni = Object.getOwnPropertyDescriptor, rp = Object.prototype, ap = Array.prototype, lp = Object.getPrototypeOf, xl = Object.isExtensible;
function dp(e) {
  for (var t = 0; t < e.length; t++)
    e[t]();
}
function cp() {
  var e, t, s = new Promise((i, o) => {
    e = i, t = o;
  });
  return { promise: s, resolve: e, reject: t };
}
const je = 2, la = 4, da = 8, wo = 16, zt = 32, _s = 64, Yd = 128, et = 256, en = 512, ye = 1024, mt = 2048, ps = 4096, ht = 8192, Ws = 16384, ca = 32768, ua = 65536, Rl = 1 << 17, up = 1 << 18, ha = 1 << 19, Zd = 1 << 20, kr = 1 << 21, ga = 1 << 22, Ps = 1 << 23, Ds = Symbol("$state"), hp = Symbol("legacy props"), pa = new class extends Error {
  constructor() {
    super(...arguments);
    Js(this, "name", "StaleReactionError");
    Js(this, "message", "The reaction that called `getAbortSignal()` was re-run or destroyed");
  }
}();
function gp() {
  throw new Error("https://svelte.dev/e/await_outside_boundary");
}
function pp(e) {
  throw new Error("https://svelte.dev/e/lifecycle_outside_component");
}
function fp() {
  throw new Error("https://svelte.dev/e/async_derived_orphan");
}
function mp(e) {
  throw new Error("https://svelte.dev/e/effect_in_teardown");
}
function Cp() {
  throw new Error("https://svelte.dev/e/effect_in_unowned_derived");
}
function vp(e) {
  throw new Error("https://svelte.dev/e/effect_orphan");
}
function wp() {
  throw new Error("https://svelte.dev/e/effect_update_depth_exceeded");
}
function bp(e) {
  throw new Error("https://svelte.dev/e/props_invalid_value");
}
function yp() {
  throw new Error("https://svelte.dev/e/state_descriptors_fixed");
}
function Sp() {
  throw new Error("https://svelte.dev/e/state_prototype_fixed");
}
function xp() {
  throw new Error("https://svelte.dev/e/state_unsafe_mutation");
}
const Rp = 1, Fp = 2, Pp = 16, Dp = 1, Mp = 4, Ep = 8, Ap = 16, Ip = 1, Tp = 2, be = Symbol(), Lp = "http://www.w3.org/1999/xhtml";
function kp() {
  console.warn("https://svelte.dev/e/select_multiple_invalid_value");
}
let Gp = !1;
function Qd(e) {
  return e === this.v;
}
function Op(e, t) {
  return e != e ? t == t : e !== t || e !== null && typeof e == "object" || typeof e == "function";
}
function Xd(e) {
  return !Op(e, this.v);
}
let tt = null;
function tn(e) {
  tt = e;
}
function _e(e, t = !1, s) {
  tt = {
    p: tt,
    c: null,
    e: null,
    s: e,
    x: null,
    l: null
  };
}
function We(e) {
  var t = (
    /** @type {ComponentContext} */
    tt
  ), s = t.e;
  if (s !== null) {
    t.e = null;
    for (var i of s)
      pc(i);
  }
  return tt = t.p, /** @type {T} */
  {};
}
function Jd() {
  return !0;
}
const Bp = /* @__PURE__ */ new WeakMap();
function Np(e) {
  var t = X;
  if (t === null)
    return Y.f |= Ps, e;
  if (t.f & ca)
    fa(e, t);
  else {
    if (!(t.f & Yd))
      throw !t.parent && e instanceof Error && ec(e), e;
    t.b.error(e);
  }
}
function fa(e, t) {
  for (; t !== null; ) {
    if (t.f & Yd)
      try {
        t.b.error(e);
        return;
      } catch (s) {
        e = s;
      }
    t = t.parent;
  }
  throw e instanceof Error && ec(e), e;
}
function ec(e) {
  const t = Bp.get(e);
  t && (Lr(e, "message", {
    value: t.message
  }), Lr(e, "stack", {
    value: t.stack
  }));
}
let sn = [];
function Hp() {
  var e = sn;
  sn = [], dp(e);
}
function tc(e) {
  sn.length === 0 && queueMicrotask(Hp), sn.push(e);
}
function Vp() {
  for (var e = (
    /** @type {Effect} */
    X.b
  ); e !== null && !e.has_pending_snippet(); )
    e = e.parent;
  return e === null && gp(), e;
}
// @__NO_SIDE_EFFECTS__
function ma(e) {
  var t = je | mt, s = Y !== null && Y.f & je ? (
    /** @type {Derived} */
    Y
  ) : null;
  return X === null || s !== null && s.f & et ? t |= et : X.f |= ha, {
    ctx: tt,
    deps: null,
    effects: null,
    equals: Qd,
    f: t,
    fn: e,
    reactions: null,
    rv: 0,
    v: (
      /** @type {V} */
      be
    ),
    wv: 0,
    parent: s ?? X,
    ac: null
  };
}
// @__NO_SIDE_EFFECTS__
function _p(e, t) {
  let s = (
    /** @type {Effect | null} */
    X
  );
  s === null && fp();
  var i = (
    /** @type {Boundary} */
    s.b
  ), o = (
    /** @type {Promise<V>} */
    /** @type {unknown} */
    void 0
  ), n = Xi(
    /** @type {V} */
    be
  ), r = null, a = !Y;
  return ef(() => {
    try {
      var l = e();
    } catch (g) {
      l = Promise.reject(g);
    }
    var d = () => l;
    o = (r == null ? void 0 : r.then(d, d)) ?? Promise.resolve(l), r = o;
    var c = (
      /** @type {Batch} */
      he
    ), u = i.pending;
    a && (i.update_pending_count(1), u || c.increment());
    const h = (g, p = void 0) => {
      r = null, u || c.activate(), p ? p !== pa && (n.f |= Ps, nn(n, p)) : (n.f & Ps && (n.f ^= Ps), nn(n, g)), a && (i.update_pending_count(-1), u || c.decrement()), nc();
    };
    if (o.then(h, (g) => h(null, g || "unknown")), c)
      return () => {
        queueMicrotask(() => c.neuter());
      };
  }), new Promise((l) => {
    function d(c) {
      function u() {
        c === o ? l(n) : d(o);
      }
      c.then(u, u);
    }
    d(o);
  });
}
// @__NO_SIDE_EFFECTS__
function sc(e) {
  const t = /* @__PURE__ */ ma(e);
  return t.equals = Xd, t;
}
function ic(e) {
  var t = e.effects;
  if (t !== null) {
    e.effects = null;
    for (var s = 0; s < t.length; s += 1)
      _t(
        /** @type {Effect} */
        t[s]
      );
  }
}
function Wp(e) {
  for (var t = e.parent; t !== null; ) {
    if (!(t.f & je))
      return (
        /** @type {Effect} */
        t
      );
    t = t.parent;
  }
  return null;
}
function Ca(e) {
  var t, s = X;
  us(Wp(e));
  try {
    ic(e), t = Fc(e);
  } finally {
    us(s);
  }
  return t;
}
function oc(e) {
  var t = Ca(e);
  if (e.equals(t) || (e.v = t, e.wv = xc()), !zs)
    if (rs !== null)
      rs.set(e, e.v);
    else {
      var s = (as || e.f & et) && e.deps !== null ? ps : ye;
      Oe(e, s);
    }
}
function zp(e, t, s) {
  const i = ma;
  if (t.length === 0) {
    s(e.map(i));
    return;
  }
  var o = he, n = (
    /** @type {Effect} */
    X
  ), r = Up(), a = Vp();
  Promise.all(t.map((l) => /* @__PURE__ */ _p(l))).then((l) => {
    o == null || o.activate(), r();
    try {
      s([...e.map(i), ...l]);
    } catch (d) {
      n.f & Ws || fa(d, n);
    }
    o == null || o.deactivate(), nc();
  }).catch((l) => {
    a.error(l);
  });
}
function Up() {
  var e = X, t = Y, s = tt;
  return function() {
    us(e), It(t), tn(s);
  };
}
function nc() {
  us(null), It(null), tn(null);
}
const Ni = /* @__PURE__ */ new Set();
let he = null, rs = null, Fl = /* @__PURE__ */ new Set(), on = [];
function rc() {
  const e = (
    /** @type {() => void} */
    on.shift()
  );
  on.length > 0 && queueMicrotask(rc), e();
}
let Zi = [], va = null, Gr = !1;
var mi, Ci, os, fo, mo, Rs, vi, Fs, ns, wi, Co, vo, ft, ac, zo, Or;
const An = class An {
  constructor() {
    Le(this, ft);
    /**
     * The current values of any sources that are updated in this batch
     * They keys of this map are identical to `this.#previous`
     * @type {Map<Source, any>}
     */
    Js(this, "current", /* @__PURE__ */ new Map());
    /**
     * The values of any sources that are updated in this batch _before_ those updates took place.
     * They keys of this map are identical to `this.#current`
     * @type {Map<Source, any>}
     */
    Le(this, mi, /* @__PURE__ */ new Map());
    /**
     * When the batch is committed (and the DOM is updated), we need to remove old branches
     * and append new ones by calling the functions added inside (if/each/key/etc) blocks
     * @type {Set<() => void>}
     */
    Le(this, Ci, /* @__PURE__ */ new Set());
    /**
     * The number of async effects that are currently in flight
     */
    Le(this, os, 0);
    /**
     * A deferred that resolves when the batch is committed, used with `settled()`
     * TODO replace with Promise.withResolvers once supported widely enough
     * @type {{ promise: Promise<void>, resolve: (value?: any) => void, reject: (reason: unknown) => void } | null}
     */
    Le(this, fo, null);
    /**
     * True if an async effect inside this batch resolved and
     * its parent branch was already deleted
     */
    Le(this, mo, !1);
    /**
     * Async effects (created inside `async_derived`) encountered during processing.
     * These run after the rest of the batch has updated, since they should
     * always have the latest values
     * @type {Effect[]}
     */
    Le(this, Rs, []);
    /**
     * The same as `#async_effects`, but for effects inside a newly-created
     * `<svelte:boundary>` â€” these do not prevent the batch from committing
     * @type {Effect[]}
     */
    Le(this, vi, []);
    /**
     * Template effects and `$effect.pre` effects, which run when
     * a batch is committed
     * @type {Effect[]}
     */
    Le(this, Fs, []);
    /**
     * The same as `#render_effects`, but for `$effect` (which runs after)
     * @type {Effect[]}
     */
    Le(this, ns, []);
    /**
     * Block effects, which may need to re-run on subsequent flushes
     * in order to update internal sources (e.g. each block items)
     * @type {Effect[]}
     */
    Le(this, wi, []);
    /**
     * Deferred effects (which run after async work has completed) that are DIRTY
     * @type {Effect[]}
     */
    Le(this, Co, []);
    /**
     * Deferred effects that are MAYBE_DIRTY
     * @type {Effect[]}
     */
    Le(this, vo, []);
    /**
     * A set of branches that still exist, but will be destroyed when this batch
     * is committed â€” we skip over these during `process`
     * @type {Set<Effect>}
     */
    Js(this, "skipped_effects", /* @__PURE__ */ new Set());
  }
  /**
   *
   * @param {Effect[]} root_effects
   */
  process(t) {
    var n;
    Zi = [];
    var s = null;
    if (Ni.size > 1) {
      s = /* @__PURE__ */ new Map(), rs = /* @__PURE__ */ new Map();
      for (const [r, a] of this.current)
        s.set(r, { v: r.v, wv: r.wv }), r.v = a;
      for (const r of Ni)
        if (r !== this)
          for (const [a, l] of ee(r, mi))
            s.has(a) || (s.set(a, { v: a.v, wv: a.wv }), a.v = l);
    }
    for (const r of t)
      ws(this, ft, ac).call(this, r);
    if (ee(this, Rs).length === 0 && ee(this, os) === 0) {
      ws(this, ft, Or).call(this);
      var i = ee(this, Fs), o = ee(this, ns);
      Ye(this, Fs, []), Ye(this, ns, []), Ye(this, wi, []), he = null, Pl(i), Pl(o), he === null ? he = this : Ni.delete(this), (n = ee(this, fo)) == null || n.resolve();
    } else
      ws(this, ft, zo).call(this, ee(this, Fs)), ws(this, ft, zo).call(this, ee(this, ns)), ws(this, ft, zo).call(this, ee(this, wi));
    if (s) {
      for (const [r, { v: a, wv: l }] of s)
        r.wv <= l && (r.v = a);
      rs = null;
    }
    for (const r of ee(this, Rs))
      ji(r);
    for (const r of ee(this, vi))
      ji(r);
    Ye(this, Rs, []), Ye(this, vi, []);
  }
  /**
   * Associate a change to a given source with the current
   * batch, noting its previous and current values
   * @param {Source} source
   * @param {any} value
   */
  capture(t, s) {
    ee(this, mi).has(t) || ee(this, mi).set(t, s), this.current.set(t, t.v);
  }
  activate() {
    he = this;
  }
  deactivate() {
    he = null;
    for (const t of Fl)
      if (Fl.delete(t), t(), he !== null)
        break;
  }
  neuter() {
    Ye(this, mo, !0);
  }
  flush() {
    Zi.length > 0 ? jp() : ws(this, ft, Or).call(this), he === this && (ee(this, os) === 0 && Ni.delete(this), this.deactivate());
  }
  increment() {
    Ye(this, os, ee(this, os) + 1);
  }
  decrement() {
    if (Ye(this, os, ee(this, os) - 1), ee(this, os) === 0) {
      for (const t of ee(this, Co))
        Oe(t, mt), Os(t);
      for (const t of ee(this, vo))
        Oe(t, ps), Os(t);
      Ye(this, Fs, []), Ye(this, ns, []), this.flush();
    } else
      this.deactivate();
  }
  /** @param {() => void} fn */
  add_callback(t) {
    ee(this, Ci).add(t);
  }
  settled() {
    return (ee(this, fo) ?? Ye(this, fo, cp())).promise;
  }
  static ensure() {
    if (he === null) {
      const t = he = new An();
      Ni.add(he), An.enqueue(() => {
        he === t && t.flush();
      });
    }
    return he;
  }
  /** @param {() => void} task */
  static enqueue(t) {
    on.length === 0 && queueMicrotask(rc), on.unshift(t);
  }
};
mi = new WeakMap(), Ci = new WeakMap(), os = new WeakMap(), fo = new WeakMap(), mo = new WeakMap(), Rs = new WeakMap(), vi = new WeakMap(), Fs = new WeakMap(), ns = new WeakMap(), wi = new WeakMap(), Co = new WeakMap(), vo = new WeakMap(), ft = new WeakSet(), /**
 * Traverse the effect tree, executing effects or stashing
 * them for later execution as appropriate
 * @param {Effect} root
 */
ac = function(t) {
  var c;
  t.f ^= ye;
  for (var s = t.first; s !== null; ) {
    var i = s.f, o = (i & (zt | _s)) !== 0, n = o && (i & ye) !== 0, r = n || (i & ht) !== 0 || this.skipped_effects.has(s);
    if (!r && s.fn !== null) {
      if (o)
        s.f ^= ye;
      else if (!(i & ye))
        if (i & la)
          ee(this, ns).push(s);
        else if (i & ga) {
          var a = (c = s.b) != null && c.pending ? ee(this, vi) : ee(this, Rs);
          a.push(s);
        } else Ln(s) && (s.f & wo && ee(this, wi).push(s), ji(s));
      var l = s.first;
      if (l !== null) {
        s = l;
        continue;
      }
    }
    var d = s.parent;
    for (s = s.next; s === null && d !== null; )
      s = d.next, d = d.parent;
  }
}, /**
 * @param {Effect[]} effects
 */
zo = function(t) {
  for (const s of t)
    (s.f & mt ? ee(this, Co) : ee(this, vo)).push(s), Oe(s, ye);
  t.length = 0;
}, /**
 * Append and remove branches to/from the DOM
 */
Or = function() {
  if (!ee(this, mo))
    for (const t of ee(this, Ci))
      t();
  ee(this, Ci).clear();
};
let Qi = An;
function jp() {
  var e = ri;
  Gr = !0;
  try {
    var t = 0;
    for (El(!0); Zi.length > 0; ) {
      var s = Qi.ensure();
      if (t++ > 1e3) {
        var i, o;
        $p();
      }
      s.process(Zi), Ms.clear();
    }
  } finally {
    Gr = !1, El(e), va = null;
  }
}
function $p() {
  try {
    wp();
  } catch (e) {
    fa(e, va);
  }
}
function Pl(e) {
  var t = e.length;
  if (t !== 0) {
    for (var s = 0; s < t; ) {
      var i = e[s++];
      if (!(i.f & (Ws | ht)) && Ln(i)) {
        var o = he ? he.current.size : 0;
        if (ji(i), i.deps === null && i.first === null && i.nodes_start === null && (i.teardown === null && i.ac === null ? wc(i) : i.fn = null), he !== null && he.current.size > o && i.f & Zd)
          break;
      }
    }
    for (; s < t; )
      Os(e[s++]);
  }
}
function Os(e) {
  for (var t = va = e; t.parent !== null; ) {
    t = t.parent;
    var s = t.f;
    if (Gr && t === X && s & wo)
      return;
    if (s & (_s | zt)) {
      if (!(s & ye)) return;
      t.f ^= ye;
    }
  }
  Zi.push(t);
}
const Ms = /* @__PURE__ */ new Map();
function Xi(e, t) {
  var s = {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v: e,
    reactions: null,
    equals: Qd,
    rv: 0,
    wv: 0
  };
  return s;
}
// @__NO_SIDE_EFFECTS__
function U(e, t) {
  const s = Xi(e);
  return nf(s), s;
}
// @__NO_SIDE_EFFECTS__
function Kp(e, t = !1, s = !0) {
  const i = Xi(e);
  return t || (i.equals = Xd), i;
}
function O(e, t, s = !1) {
  Y !== null && // since we are untracking the function inside `$inspect.with` we need to add this check
  // to ensure we error if state is set inside an inspect effect
  (!Pt || Y.f & Rl) && Jd() && Y.f & (je | wo | ga | Rl) && !(Me != null && Me.includes(e)) && xp();
  let i = s ? xs(t) : t;
  return nn(e, i);
}
function nn(e, t) {
  if (!e.equals(t)) {
    var s = e.v;
    zs ? Ms.set(e, t) : Ms.set(e, s), e.v = t;
    var i = Qi.ensure();
    i.capture(e, s), e.f & je && (e.f & mt && Ca(
      /** @type {Derived} */
      e
    ), Oe(e, e.f & et ? ps : ye)), e.wv = xc(), lc(e, mt), X !== null && X.f & ye && !(X.f & (zt | _s)) && (Xe === null ? rf([e]) : Xe.push(e));
  }
  return t;
}
function er(e) {
  O(e, e.v + 1);
}
function lc(e, t) {
  var s = e.reactions;
  if (s !== null)
    for (var i = s.length, o = 0; o < i; o++) {
      var n = s[o], r = n.f, a = (r & mt) === 0;
      a && Oe(n, t), r & je ? lc(
        /** @type {Derived} */
        n,
        ps
      ) : a && Os(
        /** @type {Effect} */
        n
      );
    }
}
function xs(e) {
  if (typeof e != "object" || e === null || Ds in e)
    return e;
  const t = lp(e);
  if (t !== rp && t !== ap)
    return e;
  var s = /* @__PURE__ */ new Map(), i = In(e), o = /* @__PURE__ */ U(0), n = Es, r = (a) => {
    if (Es === n)
      return a();
    var l = Y, d = Es;
    It(null), Il(n);
    var c = a();
    return It(l), Il(d), c;
  };
  return i && s.set("length", /* @__PURE__ */ U(
    /** @type {any[]} */
    e.length
  )), new Proxy(
    /** @type {any} */
    e,
    {
      defineProperty(a, l, d) {
        (!("value" in d) || d.configurable === !1 || d.enumerable === !1 || d.writable === !1) && yp();
        var c = s.get(l);
        return c === void 0 ? c = r(() => {
          var u = /* @__PURE__ */ U(d.value);
          return s.set(l, u), u;
        }) : O(c, d.value, !0), !0;
      },
      deleteProperty(a, l) {
        var d = s.get(l);
        if (d === void 0) {
          if (l in a) {
            const c = r(() => /* @__PURE__ */ U(be));
            s.set(l, c), er(o);
          }
        } else
          O(d, be), er(o);
        return !0;
      },
      get(a, l, d) {
        var g;
        if (l === Ds)
          return e;
        var c = s.get(l), u = l in a;
        if (c === void 0 && (!u || (g = ni(a, l)) != null && g.writable) && (c = r(() => {
          var p = xs(u ? a[l] : be), f = /* @__PURE__ */ U(p);
          return f;
        }), s.set(l, c)), c !== void 0) {
          var h = A(c);
          return h === be ? void 0 : h;
        }
        return Reflect.get(a, l, d);
      },
      getOwnPropertyDescriptor(a, l) {
        var d = Reflect.getOwnPropertyDescriptor(a, l);
        if (d && "value" in d) {
          var c = s.get(l);
          c && (d.value = A(c));
        } else if (d === void 0) {
          var u = s.get(l), h = u == null ? void 0 : u.v;
          if (u !== void 0 && h !== be)
            return {
              enumerable: !0,
              configurable: !0,
              value: h,
              writable: !0
            };
        }
        return d;
      },
      has(a, l) {
        var h;
        if (l === Ds)
          return !0;
        var d = s.get(l), c = d !== void 0 && d.v !== be || Reflect.has(a, l);
        if (d !== void 0 || X !== null && (!c || (h = ni(a, l)) != null && h.writable)) {
          d === void 0 && (d = r(() => {
            var g = c ? xs(a[l]) : be, p = /* @__PURE__ */ U(g);
            return p;
          }), s.set(l, d));
          var u = A(d);
          if (u === be)
            return !1;
        }
        return c;
      },
      set(a, l, d, c) {
        var C;
        var u = s.get(l), h = l in a;
        if (i && l === "length")
          for (var g = d; g < /** @type {Source<number>} */
          u.v; g += 1) {
            var p = s.get(g + "");
            p !== void 0 ? O(p, be) : g in a && (p = r(() => /* @__PURE__ */ U(be)), s.set(g + "", p));
          }
        if (u === void 0)
          (!h || (C = ni(a, l)) != null && C.writable) && (u = r(() => /* @__PURE__ */ U(void 0)), O(u, xs(d)), s.set(l, u));
        else {
          h = u.v !== be;
          var f = r(() => xs(d));
          O(u, f);
        }
        var m = Reflect.getOwnPropertyDescriptor(a, l);
        if (m != null && m.set && m.set.call(c, d), !h) {
          if (i && typeof l == "string") {
            var b = (
              /** @type {Source<number>} */
              s.get("length")
            ), w = Number(l);
            Number.isInteger(w) && w >= b.v && O(b, w + 1);
          }
          er(o);
        }
        return !0;
      },
      ownKeys(a) {
        A(o);
        var l = Reflect.ownKeys(a).filter((u) => {
          var h = s.get(u);
          return h === void 0 || h.v !== be;
        });
        for (var [d, c] of s)
          c.v !== be && !(d in a) && l.push(d);
        return l;
      },
      setPrototypeOf() {
        Sp();
      }
    }
  );
}
function Dl(e) {
  try {
    if (e !== null && typeof e == "object" && Ds in e)
      return e[Ds];
  } catch {
  }
  return e;
}
function qp(e, t) {
  return Object.is(Dl(e), Dl(t));
}
var Ml, dc, cc, uc;
function Yp() {
  if (Ml === void 0) {
    Ml = window, dc = /Firefox/.test(navigator.userAgent);
    var e = Element.prototype, t = Node.prototype, s = Text.prototype;
    cc = ni(t, "firstChild").get, uc = ni(t, "nextSibling").get, xl(e) && (e.__click = void 0, e.__className = void 0, e.__attributes = null, e.__style = void 0, e.__e = void 0), xl(s) && (s.__t = void 0);
  }
}
function Mi(e = "") {
  return document.createTextNode(e);
}
// @__NO_SIDE_EFFECTS__
function rn(e) {
  return cc.call(e);
}
// @__NO_SIDE_EFFECTS__
function Tn(e) {
  return uc.call(e);
}
function B(e, t) {
  return /* @__PURE__ */ rn(e);
}
function Nt(e, t) {
  {
    var s = (
      /** @type {DocumentFragment} */
      /* @__PURE__ */ rn(
        /** @type {Node} */
        e
      )
    );
    return s instanceof Comment && s.data === "" ? /* @__PURE__ */ Tn(s) : s;
  }
}
function V(e, t = 1, s = !1) {
  let i = e;
  for (; t--; )
    i = /** @type {TemplateNode} */
    /* @__PURE__ */ Tn(i);
  return i;
}
function Zp(e) {
  e.textContent = "";
}
function hc() {
  return !1;
}
function Qp(e) {
  X === null && Y === null && vp(), Y !== null && Y.f & et && X === null && Cp(), zs && mp();
}
function Xp(e, t) {
  var s = t.last;
  s === null ? t.last = t.first = e : (s.next = e, e.prev = s, t.last = e);
}
function Ut(e, t, s, i = !0) {
  var o = X;
  o !== null && o.f & ht && (e |= ht);
  var n = {
    ctx: tt,
    deps: null,
    nodes_start: null,
    nodes_end: null,
    f: e | mt,
    first: null,
    fn: t,
    last: null,
    next: null,
    parent: o,
    b: o && o.b,
    prev: null,
    teardown: null,
    transitions: null,
    wv: 0,
    ac: null
  };
  if (s)
    try {
      ji(n), n.f |= ca;
    } catch (l) {
      throw _t(n), l;
    }
  else t !== null && Os(n);
  var r = s && n.deps === null && n.first === null && n.nodes_start === null && n.teardown === null && (n.f & ha) === 0;
  if (!r && i && (o !== null && Xp(n, o), Y !== null && Y.f & je && !(e & _s))) {
    var a = (
      /** @type {Derived} */
      Y
    );
    (a.effects ?? (a.effects = [])).push(n);
  }
  return n;
}
function gc(e) {
  const t = Ut(da, null, !1);
  return Oe(t, ye), t.teardown = e, t;
}
function st(e) {
  Qp();
  var t = (
    /** @type {Effect} */
    X.f
  ), s = !Y && (t & zt) !== 0 && (t & ca) === 0;
  if (s) {
    var i = (
      /** @type {ComponentContext} */
      tt
    );
    (i.e ?? (i.e = [])).push(e);
  } else
    return pc(e);
}
function pc(e) {
  return Ut(la | Zd, e, !1);
}
function Jp(e) {
  Qi.ensure();
  const t = Ut(_s, e, !0);
  return (s = {}) => new Promise((i) => {
    s.outro ? wa(t, () => {
      _t(t), i(void 0);
    }) : (_t(t), i(void 0));
  });
}
function fc(e) {
  return Ut(la, e, !1);
}
function ef(e) {
  return Ut(ga | ha, e, !0);
}
function tf(e, t = 0) {
  return Ut(da | t, e, !0);
}
function Se(e, t = [], s = []) {
  zp(t, s, (i) => {
    Ut(da, () => e(...i.map(A)), !0);
  });
}
function mc(e, t = 0) {
  var s = Ut(wo | t, e, !0);
  return s;
}
function Ji(e, t = !0) {
  return Ut(zt, e, !0, t);
}
function Cc(e) {
  var t = e.teardown;
  if (t !== null) {
    const s = zs, i = Y;
    Al(!0), It(null);
    try {
      t.call(null);
    } finally {
      Al(s), It(i);
    }
  }
}
function vc(e, t = !1) {
  var o;
  var s = e.first;
  for (e.first = e.last = null; s !== null; ) {
    (o = s.ac) == null || o.abort(pa);
    var i = s.next;
    s.f & _s ? s.parent = null : _t(s, t), s = i;
  }
}
function sf(e) {
  for (var t = e.first; t !== null; ) {
    var s = t.next;
    t.f & zt || _t(t), t = s;
  }
}
function _t(e, t = !0) {
  var s = !1;
  (t || e.f & up) && e.nodes_start !== null && e.nodes_end !== null && (of(
    e.nodes_start,
    /** @type {TemplateNode} */
    e.nodes_end
  ), s = !0), vc(e, t && !s), an(e, 0), Oe(e, Ws);
  var i = e.transitions;
  if (i !== null)
    for (const n of i)
      n.stop();
  Cc(e);
  var o = e.parent;
  o !== null && o.first !== null && wc(e), e.next = e.prev = e.teardown = e.ctx = e.deps = e.fn = e.nodes_start = e.nodes_end = e.ac = null;
}
function of(e, t) {
  for (; e !== null; ) {
    var s = e === t ? null : (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Tn(e)
    );
    e.remove(), e = s;
  }
}
function wc(e) {
  var t = e.parent, s = e.prev, i = e.next;
  s !== null && (s.next = i), i !== null && (i.prev = s), t !== null && (t.first === e && (t.first = i), t.last === e && (t.last = s));
}
function wa(e, t) {
  var s = [];
  ba(e, s, !0), bc(s, () => {
    _t(e), t && t();
  });
}
function bc(e, t) {
  var s = e.length;
  if (s > 0) {
    var i = () => --s || t();
    for (var o of e)
      o.out(i);
  } else
    t();
}
function ba(e, t, s) {
  if (!(e.f & ht)) {
    if (e.f ^= ht, e.transitions !== null)
      for (const r of e.transitions)
        (r.is_global || s) && t.push(r);
    for (var i = e.first; i !== null; ) {
      var o = i.next, n = (i.f & ua) !== 0 || (i.f & zt) !== 0;
      ba(i, t, n ? s : !1), i = o;
    }
  }
}
function ya(e) {
  yc(e, !0);
}
function yc(e, t) {
  if (e.f & ht) {
    e.f ^= ht, e.f & ye || (Oe(e, mt), Os(e));
    for (var s = e.first; s !== null; ) {
      var i = s.next, o = (s.f & ua) !== 0 || (s.f & zt) !== 0;
      yc(s, o ? t : !1), s = i;
    }
    if (e.transitions !== null)
      for (const n of e.transitions)
        (n.is_global || t) && n.in();
  }
}
let ri = !1;
function El(e) {
  ri = e;
}
let zs = !1;
function Al(e) {
  zs = e;
}
let Y = null, Pt = !1;
function It(e) {
  Y = e;
}
let X = null;
function us(e) {
  X = e;
}
let Me = null;
function nf(e) {
  Y !== null && (Me === null ? Me = [e] : Me.push(e));
}
let Pe = null, ze = 0, Xe = null;
function rf(e) {
  Xe = e;
}
let Sc = 1, eo = 0, Es = eo;
function Il(e) {
  Es = e;
}
let as = !1;
function xc() {
  return ++Sc;
}
function Ln(e) {
  var u;
  var t = e.f;
  if (t & mt)
    return !0;
  if (t & ps) {
    var s = e.deps, i = (t & et) !== 0;
    if (s !== null) {
      var o, n, r = (t & en) !== 0, a = i && X !== null && !as, l = s.length;
      if ((r || a) && (X === null || !(X.f & Ws))) {
        var d = (
          /** @type {Derived} */
          e
        ), c = d.parent;
        for (o = 0; o < l; o++)
          n = s[o], (r || !((u = n == null ? void 0 : n.reactions) != null && u.includes(d))) && (n.reactions ?? (n.reactions = [])).push(d);
        r && (d.f ^= en), a && c !== null && !(c.f & et) && (d.f ^= et);
      }
      for (o = 0; o < l; o++)
        if (n = s[o], Ln(
          /** @type {Derived} */
          n
        ) && oc(
          /** @type {Derived} */
          n
        ), n.wv > e.wv)
          return !0;
    }
    (!i || X !== null && !as) && Oe(e, ye);
  }
  return !1;
}
function Rc(e, t, s = !0) {
  var i = e.reactions;
  if (i !== null && !(Me != null && Me.includes(e)))
    for (var o = 0; o < i.length; o++) {
      var n = i[o];
      n.f & je ? Rc(
        /** @type {Derived} */
        n,
        t,
        !1
      ) : t === n && (s ? Oe(n, mt) : n.f & ye && Oe(n, ps), Os(
        /** @type {Effect} */
        n
      ));
    }
}
function Fc(e) {
  var p;
  var t = Pe, s = ze, i = Xe, o = Y, n = as, r = Me, a = tt, l = Pt, d = Es, c = e.f;
  Pe = /** @type {null | Value[]} */
  null, ze = 0, Xe = null, as = (c & et) !== 0 && (Pt || !ri || Y === null), Y = c & (zt | _s) ? null : e, Me = null, tn(e.ctx), Pt = !1, Es = ++eo, e.ac !== null && (e.ac.abort(pa), e.ac = null);
  try {
    e.f |= kr;
    var u = (
      /** @type {Function} */
      (0, e.fn)()
    ), h = e.deps;
    if (Pe !== null) {
      var g;
      if (an(e, ze), h !== null && ze > 0)
        for (h.length = ze + Pe.length, g = 0; g < Pe.length; g++)
          h[ze + g] = Pe[g];
      else
        e.deps = h = Pe;
      if (!as || // Deriveds that already have reactions can cleanup, so we still add them as reactions
      c & je && /** @type {import('#client').Derived} */
      e.reactions !== null)
        for (g = ze; g < h.length; g++)
          ((p = h[g]).reactions ?? (p.reactions = [])).push(e);
    } else h !== null && ze < h.length && (an(e, ze), h.length = ze);
    if (Jd() && Xe !== null && !Pt && h !== null && !(e.f & (je | ps | mt)))
      for (g = 0; g < /** @type {Source[]} */
      Xe.length; g++)
        Rc(
          Xe[g],
          /** @type {Effect} */
          e
        );
    return o !== null && o !== e && (eo++, Xe !== null && (i === null ? i = Xe : i.push(.../** @type {Source[]} */
    Xe))), e.f & Ps && (e.f ^= Ps), u;
  } catch (f) {
    return Np(f);
  } finally {
    e.f ^= kr, Pe = t, ze = s, Xe = i, Y = o, as = n, Me = r, tn(a), Pt = l, Es = d;
  }
}
function af(e, t) {
  let s = t.reactions;
  if (s !== null) {
    var i = np.call(s, e);
    if (i !== -1) {
      var o = s.length - 1;
      o === 0 ? s = t.reactions = null : (s[i] = s[o], s.pop());
    }
  }
  s === null && t.f & je && // Destroying a child effect while updating a parent effect can cause a dependency to appear
  // to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`
  // allows us to skip the expensive work of disconnecting and immediately reconnecting it
  (Pe === null || !Pe.includes(t)) && (Oe(t, ps), t.f & (et | en) || (t.f ^= en), ic(
    /** @type {Derived} **/
    t
  ), an(
    /** @type {Derived} **/
    t,
    0
  ));
}
function an(e, t) {
  var s = e.deps;
  if (s !== null)
    for (var i = t; i < s.length; i++)
      af(e, s[i]);
}
function ji(e) {
  var t = e.f;
  if (!(t & Ws)) {
    Oe(e, ye);
    var s = X, i = ri;
    X = e, ri = !0;
    try {
      t & wo ? sf(e) : vc(e), Cc(e);
      var o = Fc(e);
      e.teardown = typeof o == "function" ? o : null, e.wv = Sc;
      var n;
    } finally {
      ri = i, X = s;
    }
  }
}
function A(e) {
  var t = e.f, s = (t & je) !== 0;
  if (Y !== null && !Pt) {
    var i = X !== null && (X.f & Ws) !== 0;
    if (!i && !(Me != null && Me.includes(e))) {
      var o = Y.deps;
      if (Y.f & kr)
        e.rv < eo && (e.rv = eo, Pe === null && o !== null && o[ze] === e ? ze++ : Pe === null ? Pe = [e] : (!as || !Pe.includes(e)) && Pe.push(e));
      else {
        (Y.deps ?? (Y.deps = [])).push(e);
        var n = e.reactions;
        n === null ? e.reactions = [Y] : n.includes(Y) || n.push(Y);
      }
    }
  } else if (s && /** @type {Derived} */
  e.deps === null && /** @type {Derived} */
  e.effects === null) {
    var r = (
      /** @type {Derived} */
      e
    ), a = r.parent;
    a !== null && !(a.f & et) && (r.f ^= et);
  }
  if (zs) {
    if (Ms.has(e))
      return Ms.get(e);
    if (s) {
      r = /** @type {Derived} */
      e;
      var l = r.v;
      return (!(r.f & ye) && r.reactions !== null || Pc(r)) && (l = Ca(r)), Ms.set(r, l), l;
    }
  } else if (s) {
    if (r = /** @type {Derived} */
    e, rs != null && rs.has(r))
      return rs.get(r);
    Ln(r) && oc(r);
  }
  if (e.f & Ps)
    throw e.v;
  return e.v;
}
function Pc(e) {
  if (e.v === be) return !0;
  if (e.deps === null) return !1;
  for (const t of e.deps)
    if (Ms.has(t) || t.f & je && Pc(
      /** @type {Derived} */
      t
    ))
      return !0;
  return !1;
}
function Sa(e) {
  var t = Pt;
  try {
    return Pt = !0, e();
  } finally {
    Pt = t;
  }
}
const lf = -7169;
function Oe(e, t) {
  e.f = e.f & lf | t;
}
const df = ["touchstart", "touchmove"];
function cf(e) {
  return df.includes(e);
}
function uf(e) {
  var t = Y, s = X;
  It(null), us(null);
  try {
    return e();
  } finally {
    It(t), us(s);
  }
}
const Dc = /* @__PURE__ */ new Set(), Br = /* @__PURE__ */ new Set();
function hf(e, t, s, i = {}) {
  function o(n) {
    if (i.capture || Wi.call(t, n), !n.cancelBubble)
      return uf(() => s == null ? void 0 : s.call(this, n));
  }
  return e.startsWith("pointer") || e.startsWith("touch") || e === "wheel" ? tc(() => {
    t.addEventListener(e, o, i);
  }) : t.addEventListener(e, o, i), o;
}
function gf(e, t, s, i, o) {
  var n = { capture: i, passive: o }, r = hf(e, t, s, n);
  (t === document.body || // @ts-ignore
  t === window || // @ts-ignore
  t === document || // Firefox has quirky behavior, it can happen that we still get "canplay" events when the element is already removed
  t instanceof HTMLMediaElement) && gc(() => {
    t.removeEventListener(e, r, n);
  });
}
function xa(e) {
  for (var t = 0; t < e.length; t++)
    Dc.add(e[t]);
  for (var s of Br)
    s(e);
}
let Tl = null;
function Wi(e) {
  var w;
  var t = this, s = (
    /** @type {Node} */
    t.ownerDocument
  ), i = e.type, o = ((w = e.composedPath) == null ? void 0 : w.call(e)) || [], n = (
    /** @type {null | Element} */
    o[0] || e.target
  );
  Tl = e;
  var r = 0, a = Tl === e && e.__root;
  if (a) {
    var l = o.indexOf(a);
    if (l !== -1 && (t === document || t === /** @type {any} */
    window)) {
      e.__root = t;
      return;
    }
    var d = o.indexOf(t);
    if (d === -1)
      return;
    l <= d && (r = l);
  }
  if (n = /** @type {Element} */
  o[r] || e.target, n !== t) {
    Lr(e, "currentTarget", {
      configurable: !0,
      get() {
        return n || s;
      }
    });
    var c = Y, u = X;
    It(null), us(null);
    try {
      for (var h, g = []; n !== null; ) {
        var p = n.assignedSlot || n.parentNode || /** @type {any} */
        n.host || null;
        try {
          var f = n["__" + i];
          if (f != null && (!/** @type {any} */
          n.disabled || // DOM could've been updated already by the time this is reached, so we check this as well
          // -> the target could not have been disabled because it emits the event in the first place
          e.target === n))
            if (In(f)) {
              var [m, ...b] = f;
              m.apply(n, [e, ...b]);
            } else
              f.call(n, e);
        } catch (C) {
          h ? g.push(C) : h = C;
        }
        if (e.cancelBubble || p === t || p === null)
          break;
        n = p;
      }
      if (h) {
        for (let C of g)
          queueMicrotask(() => {
            throw C;
          });
        throw h;
      }
    } finally {
      e.__root = t, delete e.currentTarget, It(c), us(u);
    }
  }
}
function pf(e) {
  var t = document.createElement("template");
  return t.innerHTML = e.replaceAll("<!>", "<!---->"), t.content;
}
function ln(e, t) {
  var s = (
    /** @type {Effect} */
    X
  );
  s.nodes_start === null && (s.nodes_start = e, s.nodes_end = t);
}
// @__NO_SIDE_EFFECTS__
function re(e, t) {
  var s = (t & Ip) !== 0, i = (t & Tp) !== 0, o, n = !e.startsWith("<!>");
  return () => {
    o === void 0 && (o = pf(n ? e : "<!>" + e), s || (o = /** @type {Node} */
    /* @__PURE__ */ rn(o)));
    var r = (
      /** @type {TemplateNode} */
      i || dc ? document.importNode(o, !0) : o.cloneNode(!0)
    );
    if (s) {
      var a = (
        /** @type {TemplateNode} */
        /* @__PURE__ */ rn(r)
      ), l = (
        /** @type {TemplateNode} */
        r.lastChild
      );
      ln(a, l);
    } else
      ln(r, r);
    return r;
  };
}
function ff(e = "") {
  {
    var t = Mi(e + "");
    return ln(t, t), t;
  }
}
function Ht() {
  var e = document.createDocumentFragment(), t = document.createComment(""), s = Mi();
  return e.append(t, s), ln(t, s), e;
}
function $(e, t) {
  e !== null && e.before(
    /** @type {Node} */
    t
  );
}
function it(e, t) {
  var s = t == null ? "" : typeof t == "object" ? t + "" : t;
  s !== (e.__t ?? (e.__t = e.nodeValue)) && (e.__t = s, e.nodeValue = s + "");
}
function mf(e, t) {
  return Cf(e, t);
}
const ei = /* @__PURE__ */ new Map();
function Cf(e, { target: t, anchor: s, props: i = {}, events: o, context: n, intro: r = !0 }) {
  Yp();
  var a = /* @__PURE__ */ new Set(), l = (u) => {
    for (var h = 0; h < u.length; h++) {
      var g = u[h];
      if (!a.has(g)) {
        a.add(g);
        var p = cf(g);
        t.addEventListener(g, Wi, { passive: p });
        var f = ei.get(g);
        f === void 0 ? (document.addEventListener(g, Wi, { passive: p }), ei.set(g, 1)) : ei.set(g, f + 1);
      }
    }
  };
  l(aa(Dc)), Br.add(l);
  var d = void 0, c = Jp(() => {
    var u = s ?? t.appendChild(Mi());
    return Ji(() => {
      if (n) {
        _e({});
        var h = (
          /** @type {ComponentContext} */
          tt
        );
        h.c = n;
      }
      o && (i.$$events = o), d = e(u, i) || {}, n && We();
    }), () => {
      var p;
      for (var h of a) {
        t.removeEventListener(h, Wi);
        var g = (
          /** @type {number} */
          ei.get(h)
        );
        --g === 0 ? (document.removeEventListener(h, Wi), ei.delete(h)) : ei.set(h, g);
      }
      Br.delete(l), u !== s && ((p = u.parentNode) == null || p.removeChild(u));
    };
  });
  return Nr.set(d, c), d;
}
let Nr = /* @__PURE__ */ new WeakMap();
function vf(e, t) {
  const s = Nr.get(e);
  return s ? (Nr.delete(e), s(t)) : Promise.resolve();
}
function le(e, t, s = !1) {
  var i = e, o = null, n = null, r = be, a = s ? ua : 0, l = !1;
  const d = (g, p = !0) => {
    l = !0, h(p, g);
  };
  var c = null;
  function u() {
    c !== null && (c.lastChild.remove(), i.before(c), c = null);
    var g = r ? o : n, p = r ? n : o;
    g && ya(g), p && wa(p, () => {
      r ? n = null : o = null;
    });
  }
  const h = (g, p) => {
    if (r !== (r = g)) {
      var f = hc(), m = i;
      if (f && (c = document.createDocumentFragment(), c.append(m = Mi())), r ? o ?? (o = p && Ji(() => p(m))) : n ?? (n = p && Ji(() => p(m))), f) {
        var b = (
          /** @type {Batch} */
          he
        ), w = r ? o : n, C = r ? n : o;
        w && b.skipped_effects.delete(w), C && b.skipped_effects.add(C), b.add_callback(u);
      } else
        u();
    }
  };
  mc(() => {
    l = !1, t(d), l || h(null, null);
  }, a);
}
function wf(e, t) {
  return t;
}
function bf(e, t, s) {
  for (var i = e.items, o = [], n = t.length, r = 0; r < n; r++)
    ba(t[r].e, o, !0);
  var a = n > 0 && o.length === 0 && s !== null;
  if (a) {
    var l = (
      /** @type {Element} */
      /** @type {Element} */
      s.parentNode
    );
    Zp(l), l.append(
      /** @type {Element} */
      s
    ), i.clear(), xt(e, t[0].prev, t[n - 1].next);
  }
  bc(o, () => {
    for (var d = 0; d < n; d++) {
      var c = t[d];
      a || (i.delete(c.k), xt(e, c.prev, c.next)), _t(c.e, !a);
    }
  });
}
function yf(e, t, s, i, o, n = null) {
  var r = e, a = { flags: t, items: /* @__PURE__ */ new Map(), first: null };
  {
    var l = (
      /** @type {Element} */
      e
    );
    r = l.appendChild(Mi());
  }
  var d = null, c = !1, u = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ sc(() => {
    var m = s();
    return In(m) ? m : m == null ? [] : aa(m);
  }), g, p;
  function f() {
    Sf(
      p,
      g,
      a,
      u,
      r,
      o,
      t,
      i,
      s
    ), n !== null && (g.length === 0 ? d ? ya(d) : d = Ji(() => n(r)) : d !== null && wa(d, () => {
      d = null;
    }));
  }
  mc(() => {
    p ?? (p = /** @type {Effect} */
    X), g = A(h);
    var m = g.length;
    if (!(c && m === 0)) {
      c = m === 0;
      var b, w, C, v;
      if (hc()) {
        var F = /* @__PURE__ */ new Set(), R = (
          /** @type {Batch} */
          he
        );
        for (w = 0; w < m; w += 1) {
          C = g[w], v = i(C, w);
          var D = a.items.get(v) ?? u.get(v);
          D ? Mc(D, C, w) : (b = Ec(
            null,
            a,
            null,
            null,
            C,
            v,
            w,
            o,
            t,
            s,
            !0
          ), u.set(v, b)), F.add(v);
        }
        for (const [M, I] of a.items)
          F.has(M) || R.skipped_effects.add(I.e);
        R.add_callback(f);
      } else
        f();
      A(h);
    }
  });
}
function Sf(e, t, s, i, o, n, r, a, l) {
  var d = t.length, c = s.items, u = s.first, h = u, g, p = null, f = [], m = [], b, w, C, v;
  for (v = 0; v < d; v += 1) {
    if (b = t[v], w = a(b, v), C = c.get(w), C === void 0) {
      var F = i.get(w);
      if (F !== void 0) {
        i.delete(w), c.set(w, F);
        var R = p ? p.next : h;
        xt(s, p, F), xt(s, F, R), tr(F, R, o), p = F;
      } else {
        var D = h ? (
          /** @type {TemplateNode} */
          h.e.nodes_start
        ) : o;
        p = Ec(
          D,
          s,
          p,
          p === null ? s.first : p.next,
          b,
          w,
          v,
          n,
          r,
          l
        );
      }
      c.set(w, p), f = [], m = [], h = p.next;
      continue;
    }
    if (Mc(C, b, v), C.e.f & ht && ya(C.e), C !== h) {
      if (g !== void 0 && g.has(C)) {
        if (f.length < m.length) {
          var M = m[0], I;
          p = M.prev;
          var J = f[0], W = f[f.length - 1];
          for (I = 0; I < f.length; I += 1)
            tr(f[I], M, o);
          for (I = 0; I < m.length; I += 1)
            g.delete(m[I]);
          xt(s, J.prev, W.next), xt(s, p, J), xt(s, W, M), h = M, p = W, v -= 1, f = [], m = [];
        } else
          g.delete(C), tr(C, h, o), xt(s, C.prev, C.next), xt(s, C, p === null ? s.first : p.next), xt(s, p, C), p = C;
        continue;
      }
      for (f = [], m = []; h !== null && h.k !== w; )
        h.e.f & ht || (g ?? (g = /* @__PURE__ */ new Set())).add(h), m.push(h), h = h.next;
      if (h === null)
        continue;
      C = h;
    }
    f.push(C), p = C, h = C.next;
  }
  if (h !== null || g !== void 0) {
    for (var E = g === void 0 ? [] : aa(g); h !== null; )
      h.e.f & ht || E.push(h), h = h.next;
    var oe = E.length;
    if (oe > 0) {
      var j = d === 0 ? o : null;
      bf(s, E, j);
    }
  }
  e.first = s.first && s.first.e, e.last = p && p.e;
  for (var Ce of i.values())
    _t(Ce.e);
  i.clear();
}
function Mc(e, t, s, i) {
  nn(e.v, t), e.i = s;
}
function Ec(e, t, s, i, o, n, r, a, l, d, c) {
  var u = (l & Rp) !== 0, h = (l & Pp) === 0, g = u ? h ? /* @__PURE__ */ Kp(o, !1, !1) : Xi(o) : o, p = l & Fp ? Xi(r) : r, f = {
    i: p,
    v: g,
    k: n,
    a: null,
    // @ts-expect-error
    e: null,
    prev: s,
    next: i
  };
  try {
    if (e === null) {
      var m = document.createDocumentFragment();
      m.append(e = Mi());
    }
    return f.e = Ji(() => a(
      /** @type {Node} */
      e,
      g,
      p,
      d
    ), Gp), f.e.prev = s && s.e, f.e.next = i && i.e, s === null ? c || (t.first = f) : (s.next = f, s.e.next = f.e), i !== null && (i.prev = f, i.e.prev = f.e), f;
  } finally {
  }
}
function tr(e, t, s) {
  for (var i = e.next ? (
    /** @type {TemplateNode} */
    e.next.e.nodes_start
  ) : s, o = t ? (
    /** @type {TemplateNode} */
    t.e.nodes_start
  ) : s, n = (
    /** @type {TemplateNode} */
    e.e.nodes_start
  ); n !== null && n !== i; ) {
    var r = (
      /** @type {TemplateNode} */
      /* @__PURE__ */ Tn(n)
    );
    o.before(n), n = r;
  }
}
function xt(e, t, s) {
  t === null ? e.first = s : (t.next = s, t.e.next = s && s.e), s !== null && (s.prev = t, s.e.prev = t && t.e);
}
function $e(e, t) {
  fc(() => {
    var s = e.getRootNode(), i = (
      /** @type {ShadowRoot} */
      s.host ? (
        /** @type {ShadowRoot} */
        s
      ) : (
        /** @type {Document} */
        s.head ?? /** @type {Document} */
        s.ownerDocument.head
      )
    );
    if (!i.querySelector("#" + t.hash)) {
      const o = document.createElement("style");
      o.id = t.hash, o.textContent = t.code, i.appendChild(o);
    }
  });
}
const Ll = [...` 	
\r\fÂ \v\uFEFF`];
function xf(e, t, s) {
  var i = "" + e;
  if (s) {
    for (var o in s)
      if (s[o])
        i = i ? i + " " + o : o;
      else if (i.length)
        for (var n = o.length, r = 0; (r = i.indexOf(o, r)) >= 0; ) {
          var a = r + n;
          (r === 0 || Ll.includes(i[r - 1])) && (a === i.length || Ll.includes(i[a])) ? i = (r === 0 ? "" : i.substring(0, r)) + i.substring(a + 1) : r = a;
        }
  }
  return i === "" ? null : i;
}
function Rf(e, t) {
  return e == null ? null : String(e);
}
function yt(e, t, s, i, o, n) {
  var r = e.__className;
  if (r !== s || r === void 0) {
    var a = xf(s, i, n);
    a == null ? e.removeAttribute("class") : e.className = a, e.__className = s;
  } else if (n && o !== n)
    for (var l in n) {
      var d = !!n[l];
      (o == null || d !== !!o[l]) && e.classList.toggle(l, d);
    }
  return n;
}
function Ff(e, t, s, i) {
  var o = e.__style;
  if (o !== t) {
    var n = Rf(t);
    n == null ? e.removeAttribute("style") : e.style.cssText = n, e.__style = t;
  }
  return i;
}
function Ac(e, t, s = !1) {
  if (e.multiple) {
    if (t == null)
      return;
    if (!In(t))
      return kp();
    for (var i of e.options)
      i.selected = t.includes(kl(i));
    return;
  }
  for (i of e.options) {
    var o = kl(i);
    if (qp(o, t)) {
      i.selected = !0;
      return;
    }
  }
  (!s || t !== void 0) && (e.selectedIndex = -1);
}
function Pf(e) {
  var t = new MutationObserver(() => {
    Ac(e, e.__value);
  });
  t.observe(e, {
    // Listen to option element changes
    childList: !0,
    subtree: !0,
    // because of <optgroup>
    // Listen to option element value attribute changes
    // (doesn't get notified of select value changes,
    // because that property is not reflected as an attribute)
    attributes: !0,
    attributeFilter: ["value"]
  }), gc(() => {
    t.disconnect();
  });
}
function kl(e) {
  return "__value" in e ? e.__value : e.value;
}
const Df = Symbol("is custom element"), Mf = Symbol("is html");
function Ef(e, t) {
  var s = Af(e);
  s.value === (s.value = // treat null and undefined the same for the initial value
  t ?? void 0) || // @ts-expect-error
  // `progress` elements always need their value set when it's `0`
  e.value === t && (t !== 0 || e.nodeName !== "PROGRESS") || (e.value = t ?? "");
}
function Af(e) {
  return (
    /** @type {Record<string | symbol, unknown>} **/
    // @ts-expect-error
    e.__attributes ?? (e.__attributes = {
      [Df]: e.nodeName.includes("-"),
      [Mf]: e.namespaceURI === Lp
    })
  );
}
function Gl(e, t) {
  return e === t || (e == null ? void 0 : e[Ds]) === t;
}
function If(e = {}, t, s, i) {
  return fc(() => {
    var o, n;
    return tf(() => {
      o = n, n = [], Sa(() => {
        e !== s(...n) && (t(e, ...n), o && Gl(s(...o), e) && t(null, ...o));
      });
    }), () => {
      tc(() => {
        n && Gl(s(...n), e) && t(null, ...n);
      });
    };
  }), e;
}
let Eo = !1;
function Tf(e) {
  var t = Eo;
  try {
    return Eo = !1, [e(), Eo];
  } finally {
    Eo = t;
  }
}
function ge(e, t, s, i) {
  var w;
  var o = (s & Ep) !== 0, n = (s & Ap) !== 0, r = (
    /** @type {V} */
    i
  ), a = !0, l = () => (a && (a = !1, r = n ? Sa(
    /** @type {() => V} */
    i
  ) : (
    /** @type {V} */
    i
  )), r), d;
  if (o) {
    var c = Ds in e || hp in e;
    d = ((w = ni(e, t)) == null ? void 0 : w.set) ?? (c && t in e ? (C) => e[t] = C : void 0);
  }
  var u, h = !1;
  o ? [u, h] = Tf(() => (
    /** @type {V} */
    e[t]
  )) : u = /** @type {V} */
  e[t], u === void 0 && i !== void 0 && (u = l(), d && (bp(), d(u)));
  var g;
  if (g = () => {
    var C = (
      /** @type {V} */
      e[t]
    );
    return C === void 0 ? l() : (a = !0, C);
  }, !(s & Mp))
    return g;
  if (d) {
    var p = e.$$legacy;
    return function(C, v) {
      return arguments.length > 0 ? ((!v || p || h) && d(v ? g() : C), C) : g();
    };
  }
  var f = !1, m = (s & Dp ? ma : sc)(() => (f = !1, g()));
  o && A(m);
  var b = (
    /** @type {Effect} */
    X
  );
  return function(C, v) {
    if (arguments.length > 0) {
      const F = v ? A(m) : o ? xs(C) : C;
      return O(m, F), f = !0, r !== void 0 && (r = F), C;
    }
    return zs && f || b.f & Ws ? m.v : A(m);
  };
}
function Ic(e) {
  tt === null && pp(), st(() => {
    const t = Sa(e);
    if (typeof t == "function") return (
      /** @type {() => void} */
      t
    );
  });
}
const Lf = "5";
var $d;
typeof window < "u" && (($d = window.__svelte ?? (window.__svelte = {})).v ?? ($d.v = /* @__PURE__ */ new Set())).add(Lf);
function kf(e, t) {
  const s = e.target;
  O(t, s.value, !0);
}
var Gf = /* @__PURE__ */ re('<span class="loading-spinner svelte-1tyomw2"></span> Searching...', 1), Of = /* @__PURE__ */ re('<form class="search-form svelte-1tyomw2"><div class="search-container svelte-1tyomw2"><input type="text" placeholder="Search FIX dictionary..." class="search-input svelte-1tyomw2"/> <button type="submit" class="search-button svelte-1tyomw2"><!></button></div></form>');
const Bf = {
  hash: "svelte-1tyomw2",
  code: `.search-form.svelte-1tyomw2 {width:100%;margin-bottom:20px;}.search-container.svelte-1tyomw2 {display:flex;gap:10px;}.search-input.svelte-1tyomw2 {flex:1;padding:12px 16px;border:2px solid #34495e;border-radius:6px;font-size:1rem;background:#2c3e50;color:#ecf0f1;transition:border-color 0.2s ease;}.search-input.svelte-1tyomw2:focus {outline:none;border-color:#3498db;box-shadow:0 0 0 3px rgba(52, 152, 219, 0.25);}.search-input.svelte-1tyomw2:disabled {background-color:#1a1a1a;cursor:not-allowed;opacity:0.6;}.search-input.svelte-1tyomw2::placeholder {color:#95a5a6;}.search-button.svelte-1tyomw2 {padding:12px 24px;background:#3498db;color:white;border:none;border-radius:6px;font-size:1rem;font-weight:500;cursor:pointer;transition:background-color 0.2s ease;display:flex;align-items:center;gap:8px;}.search-button.svelte-1tyomw2:hover:not(:disabled) {background:#2980b9;}.search-button.svelte-1tyomw2:disabled {background:#5d6d7e;cursor:not-allowed;}.loading-spinner.svelte-1tyomw2 {width:16px;height:16px;border:2px solid transparent;border-top:2px solid white;border-radius:50%;
    animation: svelte-1tyomw2-spin 1s linear infinite;}

  @keyframes svelte-1tyomw2-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }`
};
function Nf(e, t) {
  _e(t, !0), $e(e, Bf);
  let s = ge(t, "isSearching", 3, !1), i = /* @__PURE__ */ U(xs(t.searchQuery));
  function o(h) {
    h.preventDefault(), t.onSearch(A(i));
  }
  var n = Of(), r = B(n), a = B(r);
  a.__input = [kf, i];
  var l = V(a, 2), d = B(l);
  {
    var c = (h) => {
      var g = Gf();
      $(h, g);
    }, u = (h) => {
      var g = ff("Search");
      $(h, g);
    };
    le(d, (h) => {
      s() ? h(c) : h(u, !1);
    });
  }
  Se(
    (h) => {
      Ef(a, A(i)), a.disabled = s(), l.disabled = h;
    },
    [() => s() || !A(i).trim()]
  ), gf("submit", n, o), $(e, n), We();
}
xa(["input"]);
function Hf(e, t) {
  const s = e.target;
  t.onVersionChange(s.value);
}
var Vf = /* @__PURE__ */ re('<option class="svelte-1i7av9q"> </option>'), _f = /* @__PURE__ */ re('<div class="version-selector svelte-1i7av9q"><label for="version-select" class="svelte-1i7av9q">FIX Version:</label> <select id="version-select" class="version-select svelte-1i7av9q"></select></div>');
const Wf = {
  hash: "svelte-1i7av9q",
  code: ".version-selector.svelte-1i7av9q {display:flex;align-items:center;gap:10px;}label.svelte-1i7av9q {font-weight:500;color:#ecf0f1;}.version-select.svelte-1i7av9q {padding:8px 12px;border:2px solid #34495e;border-radius:6px;font-size:1rem;background:#2c3e50;color:#ecf0f1;cursor:pointer;transition:border-color 0.2s ease;}.version-select.svelte-1i7av9q:hover {border-color:#3498db;}.version-select.svelte-1i7av9q:focus {outline:none;border-color:#3498db;box-shadow:0 0 0 3px rgba(52, 152, 219, 0.25);}.version-select.svelte-1i7av9q option:where(.svelte-1i7av9q) {background:#2c3e50;color:#ecf0f1;}"
};
function zf(e, t) {
  _e(t, !0), $e(e, Wf);
  const s = ["FIX.4.4", "FIX.5.0SP2", "FIX.Z"];
  var i = _f(), o = V(B(i), 2);
  o.__change = [Hf, t], yf(o, 21, () => s, wf, (r, a) => {
    var l = Vf(), d = B(l), c = {};
    Se(() => {
      it(d, A(a)), c !== (c = A(a)) && (l.value = (l.__value = A(a)) ?? "");
    }), $(r, l);
  });
  var n;
  Pf(o), Se(() => {
    n !== (n = t.selectedVersion) && (o.value = (o.__value = t.selectedVersion) ?? "", Ac(o, t.selectedVersion));
  }), $(e, i), We();
}
xa(["change"]);
var hs = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, s) {
    const i = t ? this.allAsyncListeners : this.allSyncListeners;
    let o = i.get(e);
    return !o && s && (o = /* @__PURE__ */ new Set(), i.set(e, o)), o;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, s = !1) {
    this.getListeners(e, s, !0).add(t);
  }
  removeEventListener(e, t, s = !1) {
    const i = this.getListeners(e, s, !1);
    i && (i.delete(t), i.size === 0 && (s ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    this.getGlobalListeners(t).add(e);
  }
  removeGlobalListener(e, t = !1) {
    this.getGlobalListeners(t).delete(e);
  }
  dispatchEvent(e) {
    const t = e;
    this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const s = e.type;
    if (t && "event" in e) {
      const a = e.event;
      a instanceof Event && (e.eventPath = a.composedPath());
    }
    const { frameworkOverrides: i } = this, o = (a) => {
      const l = i ? () => i.wrapIncoming(a) : a;
      t ? this.dispatchAsync(l) : l();
    }, n = this.getListeners(s, t, !1);
    if (((n == null ? void 0 : n.size) ?? 0) > 0) {
      const a = new Set(n);
      for (const l of a)
        n != null && n.has(l) && o(() => l(e));
    }
    const r = this.getGlobalListeners(t);
    if (r.size > 0) {
      const a = new Set(r);
      for (const l of a)
        o(() => l(s, e));
    }
  }
  getGlobalListeners(e) {
    return e ? this.globalAsyncListeners : this.globalSyncListeners;
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    if (this.asyncFunctionsQueue.push(e), !this.scheduled) {
      const t = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(), this.scheduled = !0;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
};
function Uf(e, t) {
  return t;
}
function Tc(e) {
  return (e == null ? void 0 : e.getLocaleTextFunc()) ?? Uf;
}
function rt(e, t, s) {
  s == null || typeof s == "string" && s == "" ? Ra(e, t) : at(e, t, s);
}
function at(e, t, s) {
  e.setAttribute(Lc(t), s.toString());
}
function Ra(e, t) {
  e.removeAttribute(Lc(t));
}
function Lc(e) {
  return `aria-${e}`;
}
function Ne(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function jf(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function $f(e) {
  return parseInt(e.getAttribute("aria-posinset"), 10);
}
function Kf(e) {
  return e.getAttribute("aria-label");
}
function Ee(e, t) {
  rt(e, "label", t);
}
function to(e, t) {
  rt(e, "labelledby", t);
}
function kc(e, t) {
  rt(e, "describedby", t);
}
function Gc(e, t) {
  rt(e, "live", t);
}
function qf(e, t) {
  rt(e, "atomic", t);
}
function Yf(e, t) {
  rt(e, "relevant", t);
}
function Zf(e, t) {
  rt(e, "level", t);
}
function Qf(e, t) {
  rt(e, "disabled", t);
}
function Fa(e, t) {
  rt(e, "hidden", t);
}
function ot(e, t) {
  at(e, "expanded", t);
}
function Xf(e) {
  Ra(e, "expanded");
}
function Pa(e, t) {
  at(e, "setsize", t);
}
function Da(e, t) {
  at(e, "posinset", t);
}
function Jf(e, t) {
  at(e, "multiselectable", t);
}
function em(e, t) {
  at(e, "rowcount", t);
}
function Oc(e, t) {
  at(e, "rowindex", t);
}
function tm(e, t) {
  at(e, "colcount", t);
}
function Bc(e, t) {
  at(e, "colindex", t);
}
function sm(e, t) {
  at(e, "colspan", t);
}
function im(e, t) {
  at(e, "sort", t);
}
function om(e) {
  Ra(e, "sort");
}
function Hr(e, t) {
  rt(e, "selected", t);
}
function nm(e, t) {
  at(e, "checked", t === void 0 ? "mixed" : t);
}
function Nc(e, t) {
  rt(e, "controls", t.id), to(t, e.id);
}
function rm(e, t) {
  rt(e, "haspopup", t === !1 ? null : t);
}
function Hc(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === !0 ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var sr, ir, or, nr, Vr, _r, rr;
function kn() {
  return sr === void 0 && (sr = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), sr;
}
function Ma() {
  return ir === void 0 && (ir = /(firefox)/i.test(navigator.userAgent)), ir;
}
function Vc() {
  return or === void 0 && (or = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), or;
}
function As() {
  return nr === void 0 && (nr = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), nr;
}
function Ol(e) {
  if (!e)
    return null;
  const t = e.tabIndex, s = e.getAttribute("tabIndex");
  return t === -1 && (s === null || s === "" && !Ma()) ? null : t.toString();
}
function am() {
  if (rr !== void 0)
    return rr;
  if (!document.body)
    return -1;
  let e = 1e6;
  const t = Ma() ? 6e6 : 1e9, s = document.createElement("div");
  for (document.body.appendChild(s); ; ) {
    const i = e * 2;
    if (s.style.height = i + "px", i > t || s.clientHeight !== i)
      break;
    e = i;
  }
  return document.body.removeChild(s), rr = e, e;
}
function lm() {
  return _r == null && _c(), _r;
}
function _c() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let s = t.offsetWidth - t.clientWidth;
  s === 0 && t.clientWidth === 0 && (s = null), t.parentNode && t.parentNode.removeChild(t), s != null && (_r = s, Vr = s === 0);
}
function Wc() {
  return Vr == null && _c(), Vr;
}
function Bl(e, t, s) {
  const i = e.parentElement;
  let o = i && i.firstChild;
  for (; o; )
    t && o.classList.toggle(t, o === e), o = o.nextSibling;
}
var dm = "[tabindex], input, select, button, textarea, [href]", zc = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function Ea(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, i = t.call(e, "input, select, button, textarea"), o = t.call(e, zc), n = He(e);
  return i && !o && n;
}
function G(e, t, s = {}) {
  const { skipAriaHidden: i } = s;
  e.classList.toggle("ag-hidden", !t), i || Fa(e, !t);
}
function cm(e, t, s = {}) {
  const { skipAriaHidden: i } = s;
  e.classList.toggle("ag-invisible", !t), i || Fa(e, !t);
}
function so(e, t) {
  const s = "disabled", i = t ? (n) => n.setAttribute(s, "") : (n) => n.removeAttribute(s);
  i(e);
  const o = e.querySelectorAll("input") ?? [];
  for (const n of o)
    i(n);
}
function Is(e, t, s) {
  let i = 0;
  for (; e; ) {
    if (e.classList.contains(t))
      return !0;
    if (e = e.parentElement, typeof s == "number") {
      if (++i > s)
        break;
    } else if (e === s)
      break;
  }
  return !1;
}
function Ei(e) {
  const {
    height: t,
    width: s,
    borderTopWidth: i,
    borderRightWidth: o,
    borderBottomWidth: n,
    borderLeftWidth: r,
    paddingTop: a,
    paddingRight: l,
    paddingBottom: d,
    paddingLeft: c,
    marginTop: u,
    marginRight: h,
    marginBottom: g,
    marginLeft: p,
    boxSizing: f
  } = window.getComputedStyle(e);
  return {
    height: parseFloat(t || "0"),
    width: parseFloat(s || "0"),
    borderTopWidth: parseFloat(i || "0"),
    borderRightWidth: parseFloat(o || "0"),
    borderBottomWidth: parseFloat(n || "0"),
    borderLeftWidth: parseFloat(r || "0"),
    paddingTop: parseFloat(a || "0"),
    paddingRight: parseFloat(l || "0"),
    paddingBottom: parseFloat(d || "0"),
    paddingLeft: parseFloat(c || "0"),
    marginTop: parseFloat(u || "0"),
    marginRight: parseFloat(h || "0"),
    marginBottom: parseFloat(g || "0"),
    marginLeft: parseFloat(p || "0"),
    boxSizing: f
  };
}
function Gn(e) {
  const t = Ei(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function io(e) {
  const t = Ei(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function Uc(e) {
  const { height: t, marginBottom: s, marginTop: i } = Ei(e);
  return Math.floor(t + s + i);
}
function dn(e) {
  const { width: t, marginLeft: s, marginRight: i } = Ei(e);
  return Math.floor(t + s + i);
}
function jc(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: s, borderLeftWidth: i, borderRightWidth: o, borderBottomWidth: n } = Ei(e);
  return {
    top: t.top + (s || 0),
    left: t.left + (i || 0),
    right: t.right + (o || 0),
    bottom: t.bottom + (n || 0)
  };
}
function cn(e, t) {
  let s = e.scrollLeft;
  return t && (s = Math.abs(s)), s;
}
function un(e, t, s) {
  s && (t *= -1), e.scrollLeft = t;
}
function de(e) {
  for (; e && e.firstChild; )
    e.removeChild(e.firstChild);
}
function De(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function $c(e) {
  return !!e.offsetParent;
}
function He(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: !0 }) : !(!$c(e) || window.getComputedStyle(e).visibility !== "visible");
}
function Aa(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function Kc(e, t, s) {
  s && s.nextSibling === t || (e.firstChild ? s ? s.nextSibling ? e.insertBefore(t, s.nextSibling) : e.appendChild(t) : e.firstChild && e.firstChild !== t && e.insertAdjacentElement("afterbegin", t) : e.appendChild(t));
}
function qc(e, t) {
  for (let s = 0; s < t.length; s++) {
    const i = t[s], o = e.children[s];
    o !== i && e.insertBefore(i, o);
  }
}
function um(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLocaleLowerCase()}`);
}
function bo(e, t) {
  if (t)
    for (const s of Object.keys(t)) {
      const i = t[s];
      if (!s || !s.length || i == null)
        continue;
      const o = um(s), n = i.toString(), r = n.replace(/\s*!important/g, ""), a = r.length != n.length ? "important" : void 0;
      e.style.setProperty(o, r, a);
    }
}
function hm(e) {
  return e.clientWidth < e.scrollWidth;
}
function gm(e) {
  return e.clientHeight < e.scrollHeight;
}
function hn(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : Et(e, t);
}
function Et(e, t) {
  t = Ia(t), e.style.width = t, e.style.maxWidth = t, e.style.minWidth = t;
}
function $i(e, t) {
  t = Ia(t), e.style.height = t, e.style.maxHeight = t, e.style.minHeight = t;
}
function Ia(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function On(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function ai(e, t, s) {
  s == null || s === "" ? e.removeAttribute(t) : e.setAttribute(t, s.toString());
}
function fs(e, t, s) {
  const o = iu(e).ResizeObserver, n = o ? new o(s) : null;
  return n == null || n.observe(t), () => n == null ? void 0 : n.disconnect();
}
function pm(e) {
  const t = Ns(e), s = "getSelection" in t ? t.getSelection() : null, i = [];
  for (let o = 0; o < ((s == null ? void 0 : s.rangeCount) ?? 0); o++) {
    const n = s == null ? void 0 : s.getRangeAt(o);
    n && i.push(n);
  }
  return { selection: s, ranges: i };
}
function Bn(e, t) {
  if (!e.gos.get("enableCellTextSelection") || !Ma() && !kn())
    return t();
  const { selection: i, ranges: o } = pm(e);
  t(), i == null || i.removeAllRanges();
  for (const n of o)
    i == null || i.addRange(n);
}
function Ct(e, t) {
  const s = iu(e);
  s.requestAnimationFrame ? s.requestAnimationFrame(t) : s.webkitRequestAnimationFrame ? s.webkitRequestAnimationFrame(t) : s.setTimeout(t, 0);
}
var Yc = "data-ref", ar;
function Nl() {
  return ar ?? (ar = document.createTextNode(" ")), ar.cloneNode();
}
function _(e) {
  const { attrs: t, children: s, cls: i, ref: o, role: n, tag: r } = e, a = document.createElement(r);
  if (i && (a.className = i), o && a.setAttribute(Yc, o), n && a.setAttribute("role", n), t)
    for (const l of Object.keys(t))
      a.setAttribute(l, t[l]);
  if (s)
    if (typeof s == "string")
      a.textContent = s;
    else {
      let l = !0;
      for (const d of s)
        d && (typeof d == "string" ? (a.appendChild(document.createTextNode(d)), l = !1) : (l && (a.appendChild(Nl()), l = !1), a.append(_(d)), a.appendChild(Nl())));
    }
  return a;
}
var Hl = {};
function Nn(e, t) {
  Hl[t] || (e(), Hl[t] = !0);
}
function oo(e, t, ...s) {
  e.get("debug") && console.log("AG Grid: " + t, ...s);
}
function Ki(e, ...t) {
  Nn(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function li(e, ...t) {
  Nn(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
var fm = {
  pending: !1,
  funcs: []
}, mm = {
  pending: !1,
  funcs: []
};
function Wr(e, t = "setTimeout", s) {
  const i = t === "raf" ? mm : fm;
  if (i.funcs.push(e), i.pending)
    return;
  i.pending = !0;
  const o = () => {
    const n = i.funcs.slice();
    i.funcs.length = 0, i.pending = !1, n.forEach((r) => r());
  };
  t === "raf" ? Ct(s, o) : window.setTimeout(o, 0);
}
function ct(e, t, s) {
  let i;
  return function(...o) {
    const n = this;
    window.clearTimeout(i), i = window.setTimeout(function() {
      e.isAlive() && t.apply(n, o);
    }, s);
  };
}
function Vl(e, t) {
  let s = 0;
  return function(...i) {
    const o = this, n = Date.now();
    n - s < t || (s = n, e.apply(o, i));
  };
}
function Zc(e, t, s = 100, i) {
  const o = Date.now();
  let n = null, r = !1;
  const a = () => {
    const l = Date.now() - o > s;
    (e() || l) && (t(), r = !0, n != null && (window.clearInterval(n), n = null));
  };
  a(), r || (n = window.setInterval(a, 10));
}
function ls(e) {
  return e == null || e === "" ? null : e;
}
function T(e) {
  return e != null && e !== "";
}
function ie(e) {
  return !T(e);
}
function zr(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function Ta(e, t) {
  const s = e ? JSON.stringify(e) : null, i = t ? JSON.stringify(t) : null;
  return s === i;
}
function Cm(e, t, s = !1) {
  const i = e == null, o = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), i && o)
    return 0;
  if (i)
    return -1;
  if (o)
    return 1;
  function n(r, a) {
    return r > a ? 1 : r < a ? -1 : 0;
  }
  if (typeof e != "string" || !s)
    return n(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return n(e, t);
  }
}
var Qc = "https://www.ag-grid.com", Q = "33.3.2", _l = 2e3, Wl = 100, Xc = "_version_", Uo = null, di = `${Qc}/javascript-data-grid`;
function vm(e) {
  Uo = e;
}
function wm(e) {
  di = e;
}
function Jc(e, t, s) {
  return (Uo == null ? void 0 : Uo.getConsoleMessage(e, t)) ?? [xm(e, t, s)];
}
function La(e, t, s, i) {
  e(`error #${t}`, ...Jc(t, s, i));
}
function bm(e) {
  if (!e)
    return String(e);
  const t = {};
  for (const s of Object.keys(e))
    typeof e[s] != "object" && typeof e[s] != "function" && (t[s] = e[s]);
  return JSON.stringify(t);
}
function ym(e) {
  let t = e;
  return e instanceof Error ? t = e.toString() : typeof e == "object" && (t = bm(e)), t;
}
function gn(e) {
  return e === void 0 ? "undefined" : e === null ? "null" : e;
}
function Ur(e, t) {
  return `${e}?${t.toString()}`;
}
function Sm(e, t, s) {
  const i = Array.from(t.entries()).sort((n, r) => r[1].length - n[1].length);
  let o = Ur(e, t);
  for (const [n, r] of i) {
    if (n === Xc)
      continue;
    const a = o.length - s;
    if (a <= 0)
      break;
    const l = "...", d = a + l.length, c = r.length - d > Wl ? r.slice(0, r.length - d) + l : r.slice(0, Wl) + l;
    t.set(n, c), o = Ur(e, t);
  }
  return o;
}
function eu(e, t) {
  const s = new URLSearchParams();
  if (s.append(Xc, Q), t)
    for (const n of Object.keys(t))
      s.append(n, ym(t[n]));
  const i = `${di}/errors/${e}`, o = Ur(i, s);
  return o.length <= _l ? o : Sm(i, s, _l);
}
var xm = (e, t, s) => {
  const i = eu(e, t);
  return `${s ? s + ` 
` : ""}Visit ${i}${s ? "" : ` 
  Alternatively register the ValidationModule to see the full message in the console.`}`;
};
function P(...e) {
  La(Ki, e[0], e[1]);
}
function K(...e) {
  La(li, e[0], e[1]);
}
function zi(e, t, s) {
  La(li, e, t, s);
}
function Rm(e, t) {
  const s = t[0];
  return `error #${s} ` + Jc(s, t[1], e).join(" ");
}
function ds(...e) {
  return Rm(void 0, e);
}
function tu(e, t) {
  return e.get("rowModelType") === t;
}
function Ke(e, t) {
  return tu(e, "clientSide");
}
function nt(e, t) {
  return tu(e, "serverSide");
}
function xe(e, t) {
  return e.get("domLayout") === t;
}
function Dt(e) {
  return pn(e) !== void 0;
}
function ka(e) {
  return typeof e.get("getRowHeight") == "function";
}
function Fm(e, t) {
  return t ? !e.get("enableStrictPivotColumnOrder") : e.get("maintainColumnOrder");
}
function Je(e, t, s = !1, i) {
  const { gos: o, environment: n } = e;
  if (i == null && (i = n.getDefaultRowHeight()), ka(o)) {
    if (s)
      return { height: i, estimated: !0 };
    const l = {
      node: t,
      data: t.data
    }, d = o.getCallback("getRowHeight")(l);
    if (jr(d))
      return d === 0 && P(23), { height: Math.max(1, d), estimated: !1 };
  }
  if (t.detail && o.get("masterDetail"))
    return Pm(o);
  const r = o.get("rowHeight");
  return { height: r && jr(r) ? r : i, estimated: !1 };
}
function Pm(e) {
  if (e.get("detailRowAutoHeight"))
    return { height: 1, estimated: !1 };
  const t = e.get("detailRowHeight");
  return jr(t) ? { height: t, estimated: !1 } : { height: 300, estimated: !1 };
}
function Bs(e) {
  const { environment: t, gos: s } = e, i = s.get("rowHeight");
  if (!i || ie(i))
    return t.getDefaultRowHeight();
  const o = t.refreshRowHeightVariable();
  return o !== -1 ? o : (P(24), t.getDefaultRowHeight());
}
function jr(e) {
  return !isNaN(e) && typeof e == "number" && isFinite(e);
}
function su(e, t, s) {
  const i = t[e.getDomDataKey()];
  return i ? i[s] : void 0;
}
function bi(e, t, s, i) {
  const o = e.getDomDataKey();
  let n = t[o];
  ie(n) && (n = {}, t[o] = n), n[s] = i;
}
function pe(e) {
  const { gos: t, eGridDiv: s } = e;
  let i = null;
  const o = t.get("getDocument");
  return o && T(o) ? i = o() : s && (i = s.ownerDocument), i && T(i) ? i : document;
}
function iu(e) {
  return pe(e).defaultView || window;
}
function Ns(e) {
  return e.eGridDiv.getRootNode();
}
function te(e) {
  return Ns(e).activeElement;
}
function Hn(e) {
  let t = null, s = null;
  try {
    t = pe(e).fullscreenElement;
  } catch {
  } finally {
    t || (t = Ns(e));
    const i = t.querySelector("body");
    i ? s = i : t instanceof ShadowRoot ? s = t : t instanceof Document ? s = t == null ? void 0 : t.documentElement : s = t;
  }
  return s;
}
function Dm(e) {
  const t = Hn(e);
  return (t == null ? void 0 : t.clientWidth) ?? (window.innerHeight || -1);
}
function Mm(e) {
  const t = Hn(e);
  return (t == null ? void 0 : t.clientHeight) ?? (window.innerHeight || -1);
}
function $r(e, t, s) {
  const o = e.getBoundingClientRect().height, n = Dm(s) - 2, r = Mm(s) - 2;
  if (!e.offsetParent)
    return;
  const l = jc(e.offsetParent), { clientY: d, clientX: c } = t;
  let u = d - l.top - o / 2, h = c - l.left - 10;
  const g = pe(s), p = g.defaultView || window, f = p.pageYOffset || g.documentElement.scrollTop, m = p.pageXOffset || g.documentElement.scrollLeft;
  n > 0 && h + e.clientWidth > n + m && (h = n + m - e.clientWidth), h < 0 && (h = 0), r > 0 && u + e.clientHeight > r + f && (u = r + f - e.clientHeight), u < 0 && (u = 0), e.style.left = `${h}px`, e.style.top = `${u}px`;
}
function yi(e) {
  const t = te(e);
  return t === null || t === pe(e).body;
}
function ci(e) {
  return e.get("ensureDomOrder") ? !1 : e.get("animateRows");
}
function Vn(e) {
  return !(e.get("paginateChildRows") || e.get("groupHideOpenParents") || xe(e, "print"));
}
function dt(e) {
  const t = e.get("autoGroupColumnDef");
  return !(t != null && t.comparator) && !e.get("treeData");
}
function no(e) {
  const t = e.get("groupAggFiltering");
  if (typeof t == "function")
    return e.getCallback("groupAggFiltering");
  if (t === !0)
    return () => !0;
}
function Ga(e) {
  return e.get("grandTotalRow");
}
function Si(e) {
  const t = e.get("groupTotalRow");
  return typeof t == "function" ? e.getCallback("groupTotalRow") : () => t ?? void 0;
}
function ou(e) {
  return e.get("groupHideOpenParents") ? !0 : e.get("groupDisplayType") === "multipleColumns";
}
function Oa(e, t) {
  return t ? !1 : e.get("groupDisplayType") === "groupRows";
}
function Em(e, t, s) {
  return !!t.group && !t.footer && Oa(e, s);
}
function ro(e) {
  const t = e.getCallback("getRowId");
  return t === void 0 ? t : (s) => {
    let i = t(s);
    return typeof i != "string" && (Nn(() => P(25, { id: i }), "getRowIdString"), i = String(i)), i;
  };
}
function Am(e) {
  const t = e.get("maxConcurrentDatasourceRequests");
  return t > 0 ? t : void 0;
}
function nu(e, t) {
  const s = e.get("suppressGroupChangesColumnVisibility");
  if (s === !0 || t && s === "suppressHideOnGroup" || !t && s === "suppressShowOnUngroup")
    return !1;
  const i = e.get("suppressRowGroupHidesColumns");
  if (t && i === !0)
    return !1;
  const o = e.get("suppressMakeColumnVisibleAfterUnGroup");
  return !(!t && o === !0);
}
function Ts(e) {
  return (e == null ? void 0 : e.checkboxes) ?? !0;
}
function jo(e) {
  return (e == null ? void 0 : e.mode) === "multiRow" && (e.headerCheckbox ?? !0);
}
function ao(e) {
  if (typeof e == "object")
    return e.checkboxLocation ?? "selectionColumn";
}
function lr(e) {
  return (e == null ? void 0 : e.hideDisabledCheckboxes) ?? !1;
}
function ru(e) {
  return typeof e.get("rowSelection") != "string";
}
function xi(e) {
  const t = e.get("cellSelection");
  return t !== void 0 ? !!t : e.get("enableRangeSelection");
}
function au(e) {
  const t = e.get("rowSelection") ?? "single";
  if (typeof t == "string") {
    const s = e.get("suppressRowClickSelection"), i = e.get("suppressRowDeselection");
    return s && i ? !1 : s ? "enableDeselection" : i ? "enableSelection" : !0;
  }
  return t.mode === "singleRow" || t.mode === "multiRow" ? t.enableClickSelection ?? !1 : !1;
}
function Im(e) {
  const t = au(e);
  return t === !0 || t === "enableSelection";
}
function Tm(e) {
  const t = au(e);
  return t === !0 || t === "enableDeselection";
}
function Kr(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("isRowSelectable") : t == null ? void 0 : t.isRowSelectable;
}
function pn(e) {
  const t = "beanName" in e && e.beanName === "gos" ? e.get("rowSelection") : e.rowSelection;
  if (typeof t == "string")
    switch (t) {
      case "multiple":
        return "multiRow";
      case "single":
        return "singleRow";
      default:
        return;
    }
  switch (t == null ? void 0 : t.mode) {
    case "multiRow":
    case "singleRow":
      return t.mode;
    default:
      return;
  }
}
function Hs(e) {
  return pn(e) === "multiRow";
}
function Lm(e) {
  const t = e.get("rowSelection");
  return typeof t == "string" ? e.get("rowMultiSelectWithClick") : (t == null ? void 0 : t.enableSelectionWithoutKeys) ?? !1;
}
function lu(e) {
  const t = e.get("rowSelection");
  if (typeof t == "string") {
    const s = e.get("groupSelectsChildren"), i = e.get("groupSelectsFiltered");
    return s && i ? "filteredDescendants" : s ? "descendants" : "self";
  }
  return (t == null ? void 0 : t.mode) === "multiRow" ? t.groupSelects : void 0;
}
function du(e, t = !0) {
  const s = e.get("rowSelection");
  return typeof s != "object" ? t ? "all" : void 0 : s.mode === "multiRow" ? s.selectAll : "all";
}
function lo(e) {
  const t = lu(e);
  return t === "descendants" || t === "filteredDescendants";
}
function dr(e) {
  return e.isModuleRegistered("SetFilter") && !e.get("suppressSetFilterByDefault");
}
function fe(e) {
  return e.get("columnMenu") === "legacy";
}
function cu(e) {
  return !fe(e);
}
function uu(e) {
  return !e || e.length < 2 ? e : "on" + e[0].toUpperCase() + e.substring(1);
}
function N(e, t) {
  return e.addGridCommonParams(t);
}
function hu(e) {
  return e.get("treeData") ? e.get("treeDataParentIdField") ? "treeSelfRef" : e.get("treeDataChildrenField") ? "treeNested" : "treePath" : "group";
}
var gu = "__ag_Grid_Stop_Propagation", km = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], Gm = ["wheel"], cr = {};
function vt(e) {
  e[gu] = !0;
}
function gt(e) {
  return e[gu] === !0;
}
var pu = /* @__PURE__ */ (() => {
  const e = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (s) => {
    if (typeof cr[s] == "boolean")
      return cr[s];
    const i = document.createElement(e[s] || "div");
    return s = "on" + s, cr[s] = s in i;
  };
})();
function fu(e, t, s) {
  let i = t;
  for (; i; ) {
    const o = su(e, i, s);
    if (o)
      return o;
    i = i.parentElement;
  }
  return null;
}
function qr(e, t) {
  return !t || !e ? !1 : Bm(t).indexOf(e) >= 0;
}
function Om(e) {
  const t = [];
  let s = e.target;
  for (; s; )
    t.push(s), s = s.parentElement;
  return t;
}
function Bm(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : Om(t);
}
function Nm(e, t, s, i) {
  const o = mu(s);
  let n;
  o != null && (n = { passive: o }), e && e.addEventListener && e.addEventListener(t, s, i, n);
}
var mu = (e) => {
  const t = km.includes(e), s = Gm.includes(e);
  if (t)
    return !0;
  if (s)
    return !1;
}, S = class {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.propertyListenerId = 0, this.lastChangeSetIdLookup = {}, this.isAlive = () => !this.destroyed;
  }
  preWireBeans(e) {
    this.beans = e, this.stubContext = e.context, this.eventSvc = e.eventSvc, this.gos = e.gos;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  destroy() {
    const { destroyFunctions: e } = this;
    for (let t = 0; t < e.length; t++)
      e[t]();
    e.length = 0, this.destroyed = !0, this.dispatchLocalEvent({ type: "destroyed" });
  }
  // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
  // eventSvc to have the best typing at the expense of BeanStub local events
  /** Add a local event listener against this BeanStub */
  addEventListener(e, t, s) {
    this.localEventService || (this.localEventService = new hs()), this.localEventService.addEventListener(e, t, s);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(e, t, s) {
    var i;
    (i = this.localEventService) == null || i.removeEventListener(e, t, s);
  }
  dispatchLocalEvent(e) {
    var t;
    (t = this.localEventService) == null || t.dispatchEvent(e);
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t);
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventSvc, e);
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t);
  }
  _setupListeners(e, t) {
    const s = [];
    for (const i of Object.keys(t)) {
      const o = t[i];
      o && s.push(this._setupListener(e, i, o));
    }
    return s;
  }
  _setupListener(e, t, s) {
    if (this.destroyed)
      return () => null;
    let i;
    return Hm(e) ? (e.__addEventListener(t, s), i = () => (e.__removeEventListener(t, s), null)) : (e instanceof HTMLElement ? Nm(this.beans.frameworkOverrides, e, t, s) : e.addEventListener(t, s), i = () => (e.removeEventListener(t, s), null)), this.destroyFunctions.push(i), () => (i(), this.destroyFunctions = this.destroyFunctions.filter((o) => o !== i), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the GridOptionsService is destroyed.
   */
  setupGridOptionListener(e, t) {
    const { gos: s } = this;
    s.addPropertyEventListener(e, t);
    const i = () => (s.removePropertyEventListener(e, t), null);
    return this.destroyFunctions.push(i), () => (i(), this.destroyFunctions = this.destroyFunctions.filter((o) => o !== i), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupGridOptionListener(e, t);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(e, t) {
    if (this.destroyed)
      return;
    const s = e.join("-") + this.propertyListenerId++, i = (o) => {
      if (o.changeSet) {
        if (o.changeSet && o.changeSet.id === this.lastChangeSetIdLookup[s])
          return;
        this.lastChangeSetIdLookup[s] = o.changeSet.id;
      }
      const n = {
        type: "gridPropertyChanged",
        changeSet: o.changeSet,
        source: o.source
      };
      t(n);
    };
    e.forEach((o) => this.setupGridOptionListener(o, i));
  }
  getLocaleTextFunc() {
    return Tc(this.beans.localeSvc);
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  /** doesn't throw an error if `bean` is undefined */
  createOptionalManagedBean(e, t) {
    return e ? this.createManagedBean(e, t) : void 0;
  }
  createManagedBean(e, t) {
    const s = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), s;
  }
  createBean(e, t, s) {
    return (t || this.stubContext).createBean(e, s);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e);
  }
};
function Hm(e) {
  return e.__addEventListener !== void 0;
}
var Vm = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function _m(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let s = 0; s < e.length; s++)
        t(s.toString(), e[s]);
      return;
    }
    for (const s of Object.keys(e))
      t(s, e[s]);
  }
}
function me(e, t, s = !0, i = !1) {
  T(t) && _m(t, (o, n) => {
    if (Vm.has(o))
      return;
    let r = e[o];
    r !== n && (i && r == null && n != null && typeof n == "object" && n.constructor === Object && (r = {}, e[o] = r), zl(n) && zl(r) && !Array.isArray(r) ? me(r, n, s, i) : (s || n !== void 0) && (e[o] = n));
  });
}
function $o(e, t, s) {
  if (!t || !e)
    return;
  if (!s)
    return e[t];
  const i = t.split(".");
  let o = e;
  for (let n = 0; n < i.length; n++) {
    if (o == null)
      return;
    o = o[i[n]];
  }
  return o;
}
function zl(e) {
  return typeof e == "object" && e !== null;
}
var Wm = /[&<>"']/g, zm = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function _n(e) {
  return (e == null ? void 0 : e.toString().toString()) ?? null;
}
function Ko(e) {
  var t;
  return ((t = _n(e)) == null ? void 0 : t.replace(Wm, (s) => zm[s])) ?? null;
}
var Um = {
  resizable: !0,
  sortable: !0
}, jm = 0;
function Cu() {
  return jm++;
}
function wt(e) {
  return e instanceof Ai;
}
var Ai = class extends S {
  constructor(e, t, s, i) {
    super(), this.colDef = e, this.userProvidedColDef = t, this.colId = s, this.primary = i, this.isColumn = !0, this.instanceId = Cu(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.colEventSvc = new hs(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.flex = null, this.colIdSanitised = Ko(s);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.beans.rowSpanSvc) == null || e.deregister(this);
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState() {
    const {
      colDef: e,
      beans: { sortSvc: t, pinnedCols: s, colFlex: i }
    } = this;
    t == null || t.initCol(this);
    const o = e.hide;
    o !== void 0 ? this.visible = !o : this.visible = !e.initialHide, s == null || s.initCol(this), i == null || i.initCol(this);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(e, t, s) {
    var o;
    const i = e.spanRows !== this.colDef.spanRows;
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), i && ((o = this.beans.rowSpanSvc) == null || o.deregister(this), this.initRowSpan()), this.dispatchColEvent("colDefChanged", s);
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  getParent() {
    return this.parent;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.setState(), this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip(), this.initRowSpan();
  }
  initDotNotation() {
    const {
      gos: e,
      colDef: { field: t, tooltipField: s }
    } = this, i = e.get("suppressFieldDotNotation");
    this.fieldContainsDots = T(t) && t.indexOf(".") >= 0 && !i, this.tooltipFieldContainsDots = T(s) && s.indexOf(".") >= 0 && !i;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = e.minWidth ?? this.beans.environment.getDefaultColumnMinWidth(), this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    var e;
    (e = this.beans.tooltipSvc) == null || e.initCol(this);
  }
  initRowSpan() {
    var e;
    this.colDef.spanRows && ((e = this.beans.rowSpanSvc) == null || e.register(this));
  }
  resetActualWidth(e) {
    const t = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, !0);
  }
  calculateColInitialWidth(e) {
    let t;
    const s = e.width, i = e.initialWidth;
    return s != null ? t = s : i != null ? t = i : t = 200, Math.max(Math.min(t, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(e) {
    var t;
    return ((t = this.beans.showRowGroupCols) == null ? void 0 : t.isRowGroupDisplayed(this, e)) ?? !1;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  getHighlighted() {
    return this.highlighted;
  }
  __addEventListener(e, t) {
    this.colEventSvc.addEventListener(e, t);
  }
  __removeEventListener(e, t) {
    this.colEventSvc.removeEventListener(e, t);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  addEventListener(e, t) {
    var i, o, n;
    this.frameworkEventListenerService = (o = (i = this.beans.frameworkOverrides).createLocalEventListenerWrapper) == null ? void 0 : o.call(
      i,
      this.frameworkEventListenerService,
      this.colEventSvc
    );
    const s = ((n = this.frameworkEventListenerService) == null ? void 0 : n.wrap(e, t)) ?? t;
    this.colEventSvc.addEventListener(e, s);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  removeEventListener(e, t) {
    var i;
    const s = ((i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(e, t)) ?? t;
    this.colEventSvc.removeEventListener(e, s);
  }
  createColumnFunctionCallbackParams(e) {
    return N(this.gos, {
      node: e,
      data: e.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(e) {
    var t;
    return ((t = this.beans.cellNavigation) == null ? void 0 : t.isSuppressNavigable(this, e)) ?? !1;
  }
  isCellEditable(e) {
    var t;
    return ((t = this.beans.editSvc) == null ? void 0 : t.isCellEditable(this, e)) ?? !1;
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    var t;
    return ((t = this.beans.selectionSvc) == null ? void 0 : t.isCellCheckboxSelection(this, e)) ?? !1;
  }
  isSuppressPaste(e) {
    var t;
    return this.isColumnFunc(e, ((t = this.colDef) == null ? void 0 : t.suppressPaste) ?? null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(e) {
    return this.colDef[e] ?? Um[e];
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function") {
      const s = this.createColumnFunctionCallbackParams(e);
      return t(s);
    }
    return !1;
  }
  createColumnEvent(e, t) {
    return N(this.gos, {
      type: e,
      column: this,
      columns: [this],
      source: t
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return ie(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return T(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchColEvent("leftChanged", t));
  }
  isFilterActive() {
    return this.filterActive;
  }
  /** @deprecated v33 Use `api.isColumnHovered(column)` instead. */
  isHovered() {
    var e;
    return P(261), !!((e = this.beans.colHover) != null && e.isHovered(this));
  }
  setFirstRightPinned(e, t) {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.dispatchColEvent("firstRightPinnedChanged", t));
  }
  setLastLeftPinned(e, t) {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.dispatchColEvent("lastLeftPinnedChanged", t));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t) {
    const s = e === !0;
    this.visible !== s && (this.visible = s, this.dispatchColEvent("visibleChanged", t)), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    return !this.getColDef().suppressSpanHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let e = this.getParent();
    if (!e || !e.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const t = e.getPaddingLevel() + 1;
    let s = !0;
    for (; e; ) {
      if (!e.isPadding()) {
        s = !1;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: s };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return N(this.gos, {
      node: e,
      data: e.data,
      colDef: this.colDef,
      column: this
    });
  }
  getColSpan(e) {
    if (ie(this.colDef.colSpan))
      return 1;
    const t = this.createBaseColDefParams(e), s = this.colDef.colSpan(t);
    return Math.max(s, 1);
  }
  getRowSpan(e) {
    if (ie(this.colDef.rowSpan))
      return 1;
    const t = this.createBaseColDefParams(e), s = this.colDef.rowSpan(t);
    return Math.max(s, 1);
  }
  setActualWidth(e, t, s = !1) {
    e = Math.max(e, this.minWidth), e = Math.min(e, this.maxWidth), this.actualWidth !== e && (this.actualWidth = e, this.flex != null && t !== "flex" && t !== "gridInitializing" && (this.flex = null), s || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.dispatchColEvent("widthChanged", e);
  }
  isGreaterThanMax(e) {
    return e > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex;
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  dispatchColEvent(e, t, s) {
    const i = this.createColumnEvent(e, t);
    s && me(i, s), this.colEventSvc.dispatchEvent(i);
  }
  dispatchStateUpdatedEvent(e) {
    this.colEventSvc.dispatchEvent({
      type: "columnStateUpdated",
      key: e
    });
  }
};
function ae(e) {
  return e instanceof ui;
}
var ui = class extends S {
  constructor(e, t, s, i) {
    super(), this.colGroupDef = e, this.groupId = t, this.padding = s, this.level = i, this.isColumn = !1, this.expandable = !1, this.instanceId = Cu(), this.expandableListenerRemoveCallback = null, this.expanded = !!(e != null && e.openByDefault);
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0), super.destroy();
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? !1 : e, this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  forEachLeafColumn(e) {
    if (this.children)
      for (const t of this.children)
        wt(t) ? e(t) : ae(t) && t.forEachLeafColumn(e);
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      wt(t) ? e.push(t) : ae(t) && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e)
      return e.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.__addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.__removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let e = !1, t = !1, s = !1;
    const i = this.findChildrenRemovingPadding();
    for (let n = 0, r = i.length; n < r; n++) {
      const a = i[n];
      if (!a.isVisible())
        continue;
      const l = a.getColumnGroupShow();
      l === "open" ? (e = !0, s = !0) : l === "closed" ? (t = !0, s = !0) : (e = !0, t = !0);
    }
    const o = e && t && s;
    this.expandable !== o && (this.expandable = o, this.dispatchLocalEvent({ type: "expandableChanged" }));
  }
  findChildrenRemovingPadding() {
    const e = [], t = (s) => {
      s.forEach((i) => {
        ae(i) && i.isPadding() ? t(i.children) : e.push(i);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
}, $m = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
};
function Yr(e, t, s) {
  const i = {}, o = e.gos;
  return Object.assign(i, o.get("defaultColGroupDef")), Object.assign(i, t), o.validateColDef(i, s), i;
}
var Km = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = zr(e);
    let s = 0;
    for (; ; ) {
      let i = e ?? t;
      if (i ? s !== 0 && (i += "_" + s) : i = s, !this.existingKeys[i]) {
        const o = String(i);
        return e && s > 0 && P(273, { providedId: e, usedId: o }), this.existingKeys[o] = !0, o;
      }
      s++;
    }
  }
}, Zr = Object.freeze([]);
function Z(e) {
  if (e != null && e.length)
    return e[e.length - 1];
}
function pt(e, t, s) {
  return e == null && t == null ? !0 : e != null && t != null && e.length === t.length && e.every((i, o) => s ? s(i, t[o]) : t[o] === i);
}
function Ao(e, t) {
  if (e)
    for (const s of e)
      t(s);
}
function Ae(e, t) {
  const s = e.indexOf(t);
  s >= 0 && e.splice(s, 1);
}
function Ul(e, t, s) {
  for (let i = 0; i < t.length; i++)
    Ae(e, t[i]);
  for (let i = t.length - 1; i >= 0; i--)
    e.splice(s, 0, t[i]);
}
var Ri = "ag-Grid-AutoColumn", vu = "ag-Grid-SelectionColumn", wu = "ag-Grid-RowNumbersColumn";
function Ba(e) {
  const t = [], s = (i) => {
    for (let o = 0; o < i.length; o++) {
      const n = i[o];
      wt(n) ? t.push(n) : ae(n) && s(n.getChildren());
    }
  };
  return s(e), t;
}
function ti(e) {
  return e.reduce((t, s) => t + s.getActualWidth(), 0);
}
function gs(e, t, s) {
  const i = {};
  if (!t)
    return;
  At(null, t, (n) => {
    i[n.getInstanceId()] = n;
  }), s && At(null, s, (n) => {
    i[n.getInstanceId()] = null;
  });
  const o = Object.values(i).filter((n) => n != null);
  e.context.destroyBeans(o);
}
function Na(e) {
  return e.getId().startsWith(Ri);
}
function yo(e) {
  const t = typeof e == "string" ? e : "getColId" in e ? e.getColId() : e.colId;
  return (t == null ? void 0 : t.startsWith(vu)) ?? !1;
}
function qi(e) {
  const t = typeof e == "string" ? e : "getColId" in e ? e.getColId() : e.colId;
  return (t == null ? void 0 : t.startsWith(wu)) ?? !1;
}
function fn(e) {
  let t = [];
  return e instanceof Array ? t = e : typeof e == "string" && (t = e.split(",")), t;
}
function bu(e, t) {
  return pt(e, t, (s, i) => s.getColId() === i.getColId());
}
function yu(e) {
  e.map = {}, e.list.forEach((t) => e.map[t.getId()] = t);
}
function Ls(e) {
  return e === "gridOptionsUpdated" ? "gridOptionsChanged" : e;
}
function Ha(e, t) {
  const s = e === t, i = e.getColDef() === t, o = e.getColId() == t;
  return s || i || o;
}
var qm = (e, t) => (s, i) => {
  const o = {
    value1: void 0,
    value2: void 0
  };
  let n = !1;
  return e && (e[s] !== void 0 && (o.value1 = e[s], n = !0), T(i) && e[i] !== void 0 && (o.value2 = e[i], n = !0)), !n && t && (t[s] !== void 0 && (o.value1 = t[s]), T(i) && t[i] !== void 0 && (o.value2 = t[i])), o;
};
function Ym(e, t = null, s, i, o) {
  const { existingCols: n, existingGroups: r } = xu(i), a = new Map(n.map((m) => [m.getId(), m])), l = new Map(r.map((m) => [m.getId(), m]));
  let d = 0;
  const c = (m, b) => {
    var v;
    if (d = Math.max(d, b), Du(m)) {
      if (!e.colGroupSvc)
        return null;
      const F = m.groupId, R = l.get(F), D = Yr(e, m, F), M = new ui(D, F, !1, b);
      return e.context.createBean(M), R && M.setExpanded(R.isExpanded()), M.setChildren(m.children.map((I) => c(I, b + 1))), M;
    }
    const w = m.colId;
    let C = a.get(w);
    if (C) {
      const F = Fi(e, m, C.getColId());
      C.setColDef(F, m, o), Pu(e, C, F, o);
    } else {
      const F = Fi(e, m, w);
      C = new Ai(F, m, w, s), e.context.createBean(C);
    }
    return (v = e.dataTypeSvc) == null || v.addColumnListeners(C), C;
  }, u = (t == null ? void 0 : t.map((m) => c(m, 0))) ?? [];
  let h = 0;
  const g = {
    getUniqueKey: (m, b) => String(++h)
  }, p = e.colGroupSvc ? e.colGroupSvc.balanceColumnTree(u, 0, d, g) : u;
  return At(null, p, (m, b) => {
    ae(m) && m.setupExpandable(), m.originalParent = b;
  }), {
    columnTree: p,
    treeDepth: d
  };
}
function Su(e, t = null, s, i, o) {
  const n = new Km(), { existingCols: r, existingGroups: a, existingColKeys: l } = xu(i);
  n.addExistingKeys(l);
  const d = Ru(
    e,
    t,
    0,
    s,
    r,
    n,
    a,
    o
  ), { colGroupSvc: c } = e, u = (c == null ? void 0 : c.findMaxDepth(d, 0)) ?? 0, h = c ? c.balanceColumnTree(d, 0, u, n) : d;
  return At(null, h, (p, f) => {
    ae(p) && p.setupExpandable(), p.originalParent = f;
  }), {
    columnTree: h,
    treeDepth: u
  };
}
function xu(e) {
  const t = [], s = [], i = [];
  return e && At(null, e, (o) => {
    if (ae(o)) {
      const n = o;
      s.push(n);
    } else {
      const n = o;
      i.push(n.getId()), t.push(n);
    }
  }), { existingCols: t, existingGroups: s, existingColKeys: i };
}
function Ru(e, t, s, i, o, n, r, a) {
  if (!t)
    return [];
  const { colGroupSvc: l } = e, d = new Array(t.length);
  for (let c = 0; c < d.length; c++) {
    const u = t[c];
    l && Du(u) ? d[c] = l.createProvidedColumnGroup(
      i,
      u,
      s,
      o,
      n,
      r,
      a
    ) : d[c] = Zm(e, i, u, o, n, a);
  }
  return d;
}
function Zm(e, t, s, i, o, n) {
  var l;
  const r = Qm(s, i);
  r && (i == null || i.splice(r.idx, 1));
  let a = r == null ? void 0 : r.column;
  if (a) {
    const d = Fi(e, s, a.getColId());
    a.setColDef(d, s, n), Pu(e, a, d, n);
  } else {
    const d = o.getUniqueKey(s.colId, s.field), c = Fi(e, s, d);
    a = new Ai(c, s, d, t), e.context.createBean(a);
  }
  return (l = e.dataTypeSvc) == null || l.addColumnListeners(a), a;
}
function Fu(e, t, s, i, o, n, r, a) {
  const { sortSvc: l, pinnedCols: d, colFlex: c } = e;
  s !== void 0 && t.setVisible(!s, a), l && (l.updateColSort(t, i, a), o !== void 0 && l.setColSortIndex(t, o)), n !== void 0 && (d == null || d.setColPinned(t, n)), r !== void 0 && (c == null || c.setColFlex(t, r));
}
function Pu(e, t, s, i) {
  Fu(
    e,
    t,
    s.hide,
    s.sort,
    s.sortIndex,
    s.pinned,
    s.flex,
    i
  );
  const o = t.getFlex();
  if (!(o != null && o > 0))
    if (s.width != null)
      t.setActualWidth(s.width, i);
    else {
      const n = t.getActualWidth();
      t.setActualWidth(n, i);
    }
}
function Qm(e, t) {
  if (t)
    for (let s = 0; s < t.length; s++) {
      const i = t[s].getUserProvidedColDef();
      if (!i)
        continue;
      if (e.colId != null) {
        if (t[s].getId() === e.colId)
          return { idx: s, column: t[s] };
        continue;
      }
      if (e.field != null) {
        if (i.field === e.field)
          return { idx: s, column: t[s] };
        continue;
      }
      if (i === e)
        return { idx: s, column: t[s] };
    }
}
function Fi(e, t, s, i) {
  const { gos: o, dataTypeSvc: n } = e, r = {}, a = o.get("defaultColDef");
  me(r, a, !1, !0);
  const l = Xm(e, r, t, s);
  l && Jm(e, l, r), me(r, t, !1, !0);
  const d = o.get("autoGroupColumnDef"), c = dt(o);
  return t.rowGroup && d && c && me(
    r,
    { sort: d.sort, initialSort: d.initialSort },
    !1,
    !0
  ), n == null || n.validateColDef(r), o.validateColDef(r, s, i), r;
}
function Xm(e, t, s, i) {
  var r;
  const o = (r = e.dataTypeSvc) == null ? void 0 : r.updateColDefAndGetColumnType(t, s, i), n = s.type ?? o ?? t.type;
  return t.type = n, n ? fn(n) : void 0;
}
function Jm(e, t, s) {
  if (!t.length)
    return;
  const i = Object.assign({}, $m), o = e.gos.get("columnTypes") || {};
  for (const n of Object.keys(o)) {
    const r = o[n];
    n in i ? P(34, { key: n }) : (r.type && P(35), i[n] = r);
  }
  t.forEach((n) => {
    const r = i[n.trim()];
    r ? me(s, r, !1, !0) : P(36, { t: n });
  });
}
function Du(e) {
  return e.children !== void 0;
}
function At(e, t, s) {
  if (t)
    for (let i = 0; i < t.length; i++) {
      const o = t[i];
      ae(o) && At(o, o.getChildren(), s), s(o, e);
    }
}
function Mu(e, t) {
  const s = [], i = [], o = [];
  return e.forEach((r) => {
    const a = r.getColDef().lockPosition;
    a === "right" ? o.push(r) : a === "left" || a === !0 ? s.push(r) : i.push(r);
  }), t.get("enableRtl") ? [...o, ...i, ...s] : [...s, ...i, ...o];
}
function Eu(e, t) {
  let s = !0;
  return At(null, t, (i) => {
    if (!ae(i))
      return;
    const o = i, n = o.getColGroupDef();
    if (!(n && n.marryChildren))
      return;
    const a = [];
    o.getLeafColumns().forEach((h) => {
      const g = e.indexOf(h);
      a.push(g);
    });
    const l = Math.max.apply(Math, a), d = Math.min.apply(Math, a), c = l - d, u = o.getLeafColumns().length - 1;
    c > u && (s = !1);
  }), s;
}
function Au(e, t) {
  if (!e || e.length == 0)
    return;
  const s = t(e[0]);
  for (let i = 1; i < e.length; i++)
    if (s !== t(e[i]))
      return;
  return s;
}
function Iu(e, t, s) {
  if (!t.length)
    return;
  const i = t.length === 1 ? t[0] : null, o = Au(t, (n) => n.getPinned());
  e.dispatchEvent({
    type: "columnPinned",
    // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
    pinned: o ?? null,
    columns: t,
    column: i,
    source: s
  });
}
function eC(e, t, s) {
  if (!t.length)
    return;
  const i = t.length === 1 ? t[0] : null, o = Au(t, (n) => n.isVisible());
  e.dispatchEvent({
    type: "columnVisible",
    visible: o,
    columns: t,
    column: i,
    source: s
  });
}
function Tu(e, t, s, i) {
  e.dispatchEvent({
    type: t,
    columns: s,
    column: s && s.length == 1 ? s[0] : null,
    source: i
  });
}
function mn(e, t, s, i, o = null) {
  t != null && t.length && e.dispatchEvent({
    type: "columnResized",
    columns: t,
    column: t.length === 1 ? t[0] : null,
    flexColumns: o,
    finished: s,
    source: i
  });
}
function Wt(e, t, s) {
  var F;
  const {
    colModel: i,
    rowGroupColsSvc: o,
    pivotColsSvc: n,
    autoColSvc: r,
    selectionColSvc: a,
    colAnimation: l,
    visibleCols: d,
    pivotResultCols: c,
    environment: u,
    valueColsSvc: h,
    eventSvc: g,
    gos: p
  } = e, f = i.getColDefCols() ?? [], m = a == null ? void 0 : a.getColumns();
  if (!(f != null && f.length) && !(m != null && m.length))
    return !1;
  if (t != null && t.state && !t.state.forEach)
    return P(32), !1;
  const b = (R, D, M, I, J) => {
    if (!R)
      return;
    const W = qm(D, t.defaultState), E = W("flex").value1;
    if (Fu(
      e,
      R,
      W("hide").value1,
      W("sort").value1,
      W("sortIndex").value1,
      W("pinned").value1,
      E,
      s
    ), E == null) {
      const oe = W("width").value1;
      if (oe != null) {
        const j = R.getColDef().minWidth ?? u.getDefaultColumnMinWidth();
        j != null && oe >= j && R.setActualWidth(oe, s);
      }
    }
    J || !R.isPrimary() || (h == null || h.syncColumnWithState(R, s, W), o == null || o.syncColumnWithState(R, s, W, M), n == null || n.syncColumnWithState(R, s, W, I));
  }, w = (R, D, M) => {
    var Bt, js;
    const I = Lu(e, s), J = D.slice(), W = {}, E = {}, oe = [], j = [], Ce = [];
    let z = 0;
    const se = (o == null ? void 0 : o.columns.slice()) ?? [], Re = (n == null ? void 0 : n.columns.slice()) ?? [];
    R.forEach((ve) => {
      const Cs = ve.colId;
      if (Cs.startsWith(Ri)) {
        oe.push(ve), Ce.push(ve);
        return;
      }
      if (yo(Cs)) {
        j.push(ve), Ce.push(ve);
        return;
      }
      const ne = M(Cs);
      ne ? (b(ne, ve, W, E, !1), Ae(J, ne)) : (Ce.push(ve), z += 1);
    });
    const bt = (ve) => b(ve, null, W, E, !1);
    J.forEach(bt), o == null || o.sortColumns($l.bind(o, W, se)), n == null || n.sortColumns($l.bind(n, E, Re)), i.refreshCols(!1);
    const Ot = (ve, Cs, Li = []) => {
      Cs.forEach((ne) => {
        const Te = ve(ne.colId);
        Ae(Li, Te), b(Te, ne, null, null, !0);
      }), Li.forEach(bt);
    };
    return Ot(
      (ve) => (r == null ? void 0 : r.getColumn(ve)) ?? null,
      oe,
      (Bt = r == null ? void 0 : r.getColumns()) == null ? void 0 : Bt.slice()
    ), Ot(
      (ve) => (a == null ? void 0 : a.getColumn(ve)) ?? null,
      j,
      (js = a == null ? void 0 : a.getColumns()) == null ? void 0 : js.slice()
    ), sC(t, i, p), d.refresh(s), g.dispatchEvent({
      type: "columnEverythingChanged",
      source: s
    }), I(), { unmatchedAndAutoStates: Ce, unmatchedCount: z };
  };
  l == null || l.start();
  let { unmatchedAndAutoStates: C, unmatchedCount: v } = w(
    t.state || [],
    f,
    (R) => i.getColDefCol(R)
  );
  if (C.length > 0 || T(t.defaultState)) {
    const R = ((F = c == null ? void 0 : c.getPivotResultCols()) == null ? void 0 : F.list) ?? [];
    v = w(
      C,
      R,
      (D) => (c == null ? void 0 : c.getPivotResultCol(D)) ?? null
    ).unmatchedCount;
  }
  return l == null || l.finish(), v === 0;
}
function tC(e, t) {
  var m, b;
  const { colModel: s, autoColSvc: i, selectionColSvc: o } = e, n = s.getColDefCols();
  if (!(n != null && n.length))
    return;
  const r = s.getColDefColTree(), a = Ba(r), l = [];
  let d = 1e3, c = 1e3;
  const u = (w) => {
    const C = ku(w);
    ie(C.rowGroupIndex) && C.rowGroup && (C.rowGroupIndex = d++), ie(C.pivotIndex) && C.pivot && (C.pivotIndex = c++), l.push(C);
  };
  (m = i == null ? void 0 : i.getColumns()) == null || m.forEach(u), (b = o == null ? void 0 : o.getColumns()) == null || b.forEach(u), a == null || a.forEach(u), Wt(e, { state: l }, t);
  const h = (i == null ? void 0 : i.getColumns()) ?? [], f = [...(o == null ? void 0 : o.getColumns()) ?? [], ...h, ...n].map((w) => ({ colId: w.colId }));
  Wt(e, { state: f, applyOrder: !0 }, t);
}
function Lu(e, t) {
  const { rowGroupColsSvc: s, pivotColsSvc: i, valueColsSvc: o, colModel: n, sortSvc: r, eventSvc: a } = e, l = {
    rowGroupColumns: (s == null ? void 0 : s.columns.slice()) ?? [],
    pivotColumns: (i == null ? void 0 : i.columns.slice()) ?? [],
    valueColumns: (o == null ? void 0 : o.columns.slice()) ?? []
  }, d = jl(e), c = {};
  return d.forEach((u) => {
    c[u.colId] = u;
  }), () => {
    const u = (R, D, M, I) => {
      const J = D.map(I), W = M.map(I);
      if (pt(J, W))
        return;
      const oe = new Set(D);
      M.forEach((Ce) => {
        oe.delete(Ce) || oe.add(Ce);
      });
      const j = [...oe];
      a.dispatchEvent({
        type: R,
        columns: j,
        column: j.length === 1 ? j[0] : null,
        source: t
      });
    }, h = (R) => {
      const D = [];
      return n.forAllCols((M) => {
        const I = c[M.getColId()];
        I && R(I, M) && D.push(M);
      }), D;
    }, g = (R) => R.getColId();
    u(
      "columnRowGroupChanged",
      l.rowGroupColumns,
      (s == null ? void 0 : s.columns) ?? [],
      g
    ), u(
      "columnPivotChanged",
      l.pivotColumns,
      (i == null ? void 0 : i.columns) ?? [],
      g
    );
    const f = h((R, D) => {
      const M = R.aggFunc != null, I = M != D.isValueActive(), J = M && R.aggFunc != D.getAggFunc();
      return I || J;
    });
    f.length > 0 && Tu(a, "columnValueChanged", f, t), mn(a, h((R, D) => R.width != D.getActualWidth()), !0, t), Iu(a, h((R, D) => R.pinned != D.getPinned()), t), eC(a, h((R, D) => R.hide == D.isVisible()), t);
    const v = h((R, D) => R.sort != D.getSort() || R.sortIndex != D.getSortIndex());
    v.length > 0 && (r == null || r.dispatchSortChangedEvents(t, v));
    const F = jl(e);
    oC(d, F, t, n, a);
  };
}
function jl(e) {
  const { colModel: t, rowGroupColsSvc: s, pivotColsSvc: i } = e, o = t.getColDefCols();
  if (ie(o) || !t.isAlive())
    return [];
  const n = s == null ? void 0 : s.columns, r = i == null ? void 0 : i.columns, a = [], l = (c) => {
    const u = c.isRowGroupActive() && n ? n.indexOf(c) : null, h = c.isPivotActive() && r ? r.indexOf(c) : null, g = c.isValueActive() ? c.getAggFunc() : null, p = c.getSort() != null ? c.getSort() : null, f = c.getSortIndex() != null ? c.getSortIndex() : null;
    a.push({
      colId: c.getColId(),
      width: c.getActualWidth(),
      hide: !c.isVisible(),
      pinned: c.getPinned(),
      sort: p,
      sortIndex: f,
      aggFunc: g,
      rowGroup: c.isRowGroupActive(),
      rowGroupIndex: u,
      pivot: c.isPivotActive(),
      pivotIndex: h,
      flex: c.getFlex() ?? null
    });
  };
  t.forAllCols((c) => l(c));
  const d = new Map(
    t.getCols().map((c, u) => [c.getColId(), u])
  );
  return a.sort((c, u) => {
    const h = d.has(c.colId) ? d.get(c.colId) : -1, g = d.has(u.colId) ? d.get(u.colId) : -1;
    return h - g;
  }), a;
}
function ku(e) {
  const t = (p, f) => p ?? f ?? null, s = e.getColDef(), i = t(s.sort, s.initialSort), o = t(s.sortIndex, s.initialSortIndex), n = t(s.hide, s.initialHide), r = t(s.pinned, s.initialPinned), a = t(s.width, s.initialWidth), l = t(s.flex, s.initialFlex);
  let d = t(s.rowGroupIndex, s.initialRowGroupIndex), c = t(s.rowGroup, s.initialRowGroup);
  d == null && (c == null || c == !1) && (d = null, c = null);
  let u = t(s.pivotIndex, s.initialPivotIndex), h = t(s.pivot, s.initialPivot);
  u == null && (h == null || h == !1) && (u = null, h = null);
  const g = t(s.aggFunc, s.initialAggFunc);
  return {
    colId: e.getColId(),
    sort: i,
    sortIndex: o,
    hide: n,
    pinned: r,
    width: a,
    flex: l,
    rowGroup: c,
    rowGroupIndex: d,
    pivot: h,
    pivotIndex: u,
    aggFunc: g
  };
}
function sC(e, t, s) {
  if (!e.applyOrder || !e.state)
    return;
  const i = [];
  e.state.forEach((o) => {
    o.colId != null && i.push(o.colId);
  }), iC(t.cols, i, t, s);
}
function iC(e, t, s, i) {
  if (e == null)
    return;
  let o = [];
  const n = {};
  t.forEach((a) => {
    if (n[a])
      return;
    const l = e.map[a];
    l && (o.push(l), n[a] = !0);
  });
  let r = 0;
  if (e.list.forEach((a) => {
    const l = a.getColId();
    if (n[l] != null)
      return;
    l.startsWith(Ri) ? o.splice(r++, 0, a) : o.push(a);
  }), o = Mu(o, i), !Eu(o, s.getColTree())) {
    P(39);
    return;
  }
  e.list = o;
}
function oC(e, t, s, i, o) {
  const n = {};
  t.forEach((c) => n[c.colId] = c);
  const r = {};
  e.forEach((c) => {
    n[c.colId] && (r[c.colId] = !0);
  });
  const a = e.filter((c) => r[c.colId]), l = t.filter((c) => r[c.colId]), d = [];
  l.forEach((c, u) => {
    const h = a && a[u];
    if (h && h.colId !== c.colId) {
      const g = i.getCol(h.colId);
      g && d.push(g);
    }
  }), d.length && o.dispatchEvent({
    type: "columnMoved",
    columns: d,
    column: d.length === 1 ? d[0] : null,
    finished: !0,
    source: s
  });
}
var $l = (e, t, s, i) => {
  const o = e[s.getId()], n = e[i.getId()], r = o != null, a = n != null;
  if (r && a)
    return o - n;
  if (r)
    return -1;
  if (a)
    return 1;
  const l = t.indexOf(s), d = t.indexOf(i), c = l >= 0, u = d >= 0;
  return c && u ? l - d : c ? -1 : 1;
}, nC = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colModel", this.pivotMode = !1, this.ready = !1, this.changeEventsDispatching = !1;
  }
  postConstruct() {
    this.pivotMode = this.gos.get("pivotMode"), this.addManagedPropertyListeners(
      ["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"],
      (e) => this.refreshAll(Ls(e.source))
    ), this.addManagedPropertyListeners(
      ["defaultColDef", "defaultColGroupDef", "columnTypes", "suppressFieldDotNotation"],
      this.recreateColumnDefs.bind(this)
    ), this.addManagedPropertyListener(
      "pivotMode",
      (e) => this.setPivotMode(this.gos.get("pivotMode"), Ls(e.source))
    );
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(e) {
    var w, C, v;
    const { beans: t } = this, {
      valueCache: s,
      colAutosize: i,
      rowGroupColsSvc: o,
      pivotColsSvc: n,
      valueColsSvc: r,
      visibleCols: a,
      colViewport: l,
      eventSvc: d
    } = t, c = this.colDefs ? Lu(t, e) : void 0;
    s == null || s.expire();
    const u = (w = this.colDefCols) == null ? void 0 : w.list, h = (C = this.colDefCols) == null ? void 0 : C.tree, g = Su(t, this.colDefs, !0, h, e);
    gs(t, (v = this.colDefCols) == null ? void 0 : v.tree, g.columnTree);
    const p = g.columnTree, f = g.treeDepth, m = Ba(p), b = {};
    m.forEach((F) => b[F.getId()] = F), this.colDefCols = { tree: p, treeDepth: f, list: m, map: b }, o == null || o.extractCols(e, u), n == null || n.extractCols(e, u), r == null || r.extractCols(e, u), this.ready = !0, this.refreshCols(!0), a.refresh(e), l.checkViewportColumns(), d.dispatchEvent({
      type: "columnEverythingChanged",
      source: e
    }), c && (this.changeEventsDispatching = !0, c(), this.changeEventsDispatching = !1), d.dispatchEvent({
      type: "newColumnsLoaded",
      source: e
    }), e === "gridInitializing" && (i == null || i.applyAutosizeStrategy());
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultCols.setPivotResultCols
  refreshCols(e) {
    var f;
    if (!this.colDefCols)
      return;
    const t = (f = this.cols) == null ? void 0 : f.tree;
    this.saveColOrder();
    const {
      autoColSvc: s,
      selectionColSvc: i,
      rowNumbersSvc: o,
      quickFilter: n,
      pivotResultCols: r,
      showRowGroupCols: a,
      rowAutoHeight: l,
      visibleCols: d,
      colViewport: c,
      eventSvc: u
    } = this.beans, h = this.selectCols(r, this.colDefCols);
    this.createColumnsForService([s, i, o], h);
    const g = Fm(this.gos, this.showingPivotResult);
    (!e || g) && this.restoreColOrder(h), this.positionLockedCols(h), a == null || a.refresh(), n == null || n.refreshCols(), this.setColSpanActive(), l == null || l.setAutoHeightActive(h), d.clear(), c.clear(), !pt(t, this.cols.tree) && u.dispatchEvent({
      type: "gridColumnsChanged"
    });
  }
  createColumnsForService(e, t) {
    for (const s of e)
      s && (s.createColumns(t, (i) => {
        this.lastOrder = i(this.lastOrder), this.lastPivotOrder = i(this.lastPivotOrder);
      }), s.addColumns(t));
  }
  selectCols(e, t) {
    const s = (e == null ? void 0 : e.getPivotResultCols()) ?? null;
    this.showingPivotResult = s != null;
    const { map: i, list: o, tree: n, treeDepth: r } = s ?? t;
    return this.cols = {
      list: o.slice(),
      map: { ...i },
      tree: n.slice(),
      treeDepth: r
    }, s && (s.list.some((l) => {
      var d;
      return ((d = this.cols) == null ? void 0 : d.map[l.getColId()]) !== void 0;
    }) || (this.lastPivotOrder = null)), this.cols;
  }
  getColsToShow() {
    var i;
    if (!this.cols)
      return [];
    const e = this.isPivotMode() && !this.showingPivotResult, t = (i = this.beans.valueColsSvc) == null ? void 0 : i.columns;
    return this.cols.list.filter((o) => {
      const n = Na(o);
      if (e) {
        const r = t == null ? void 0 : t.includes(o);
        return n || r;
      } else
        return n || o.isVisible();
    });
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(e) {
    this.ready && (this.refreshCols(!1), this.beans.visibleCols.refresh(e));
  }
  setColsVisible(e, t = !1, s) {
    Wt(
      this.beans,
      {
        state: e.map((i) => ({
          colId: typeof i == "string" ? i : i.getColId(),
          hide: !t
        }))
      },
      s
    );
  }
  /**
   * Restores provided columns order to the previous order in this.lastPivotOrder / this.lastOrder
   * If columns are not in the last order:
   *  - Check column groups, and apply column after the last column in the lowest shared group
   *  - If no sibling is found, apply the column at the end of the cols
   */
  restoreColOrder(e) {
    const t = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!t)
      return;
    const s = t.filter((u) => e.map[u.getId()] != null);
    if (s.length === 0)
      return;
    if (s.length === e.list.length) {
      e.list = s;
      return;
    }
    const i = (u) => {
      const h = u.getOriginalParent();
      return h ? h.getChildren().length > 1 ? !0 : i(h) : !1;
    };
    if (!s.some((u) => i(u))) {
      const u = new Set(s);
      for (const h of e.list)
        u.has(h) || s.push(h);
      e.list = s;
      return;
    }
    const o = /* @__PURE__ */ new Map();
    for (let u = 0; u < s.length; u++) {
      const h = s[u];
      o.set(h, u);
    }
    const n = e.list.filter((u) => !o.has(u));
    if (n.length === 0) {
      e.list = s;
      return;
    }
    const r = (u, h) => {
      const g = h ? h.getOriginalParent() : u.getOriginalParent();
      if (!g)
        return null;
      let p = null, f = null;
      for (const m of g.getChildren())
        if (!(m === h || m === u)) {
          if (m instanceof Ai) {
            const b = o.get(m);
            if (b == null)
              continue;
            (p == null || p < b) && (p = b, f = m);
            continue;
          }
          m.forEachLeafColumn((b) => {
            const w = o.get(b);
            w != null && (p == null || p < w) && (p = w, f = b);
          });
        }
      return f ?? r(u, g);
    }, a = [], l = /* @__PURE__ */ new Map();
    for (const u of n) {
      const h = r(u, null);
      if (h == null) {
        a.push(u);
        continue;
      }
      const g = l.get(h);
      g === void 0 ? l.set(h, u) : Array.isArray(g) ? g.push(u) : l.set(h, [g, u]);
    }
    const d = new Array(e.list.length);
    let c = d.length - 1;
    for (let u = a.length - 1; u >= 0; u--)
      d[c--] = a[u];
    for (let u = s.length - 1; u >= 0; u--) {
      const h = s[u], g = l.get(h);
      if (g)
        if (Array.isArray(g))
          for (let p = g.length - 1; p >= 0; p--) {
            const f = g[p];
            d[c--] = f;
          }
        else
          d[c--] = g;
      d[c--] = h;
    }
    e.list = d;
  }
  positionLockedCols(e) {
    e.list = Mu(e.list, this.gos);
  }
  saveColOrder() {
    var e, t;
    this.showingPivotResult ? this.lastPivotOrder = ((e = this.cols) == null ? void 0 : e.list) ?? null : this.lastOrder = ((t = this.cols) == null ? void 0 : t.list) ?? null;
  }
  getColumnDefs() {
    var e, t;
    return this.colDefCols ? (t = this.beans.colDefFactory) == null ? void 0 : t.getColumnDefs(
      this.colDefCols.list,
      this.showingPivotResult,
      this.lastOrder,
      ((e = this.cols) == null ? void 0 : e.list) ?? []
    ) : void 0;
  }
  setColSpanActive() {
    var e;
    this.colSpanActive = !!((e = this.cols) != null && e.list.some((t) => t.getColDef().colSpan != null));
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(e, t) {
    if (e === this.pivotMode || (this.pivotMode = e, !this.ready))
      return;
    this.refreshCols(!1);
    const { visibleCols: s, eventSvc: i } = this.beans;
    s.refresh(t), i.dispatchEvent({
      type: "columnPivotModeChanged"
    });
  }
  // + clientSideRowModel
  isPivotActive() {
    var t;
    const e = (t = this.beans.pivotColsSvc) == null ? void 0 : t.columns;
    return this.pivotMode && !!(e != null && e.length);
  }
  // called when dataTypes change
  recreateColumnDefs(e) {
    var s;
    if (!this.cols)
      return;
    (s = this.beans.autoColSvc) == null || s.updateColumns(e);
    const t = Ls(e.source);
    this.createColsFromColDefs(t);
  }
  setColumnDefs(e, t) {
    this.colDefs = e, this.createColsFromColDefs(t);
  }
  destroy() {
    var e;
    gs(this.beans, (e = this.colDefCols) == null ? void 0 : e.tree), super.destroy();
  }
  getColTree() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.tree) ?? [];
  }
  // + columnSelectPanel
  getColDefColTree() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.tree) ?? [];
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.list) ?? null;
  }
  // + moveColumnController
  getCols() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.list) ?? [];
  }
  forAllCols(e) {
    var o, n, r, a;
    const { pivotResultCols: t, autoColSvc: s, selectionColSvc: i } = this.beans;
    Ao((o = this.colDefCols) == null ? void 0 : o.list, e), Ao((n = s == null ? void 0 : s.columns) == null ? void 0 : n.list, e), Ao((r = i == null ? void 0 : i.columns) == null ? void 0 : r.list, e), Ao((a = t == null ? void 0 : t.getPivotResultCols()) == null ? void 0 : a.list, e);
  }
  getColsForKeys(e) {
    return e ? e.map((t) => this.getCol(t)).filter((t) => t != null) : [];
  }
  getColDefCol(e) {
    var t;
    return (t = this.colDefCols) != null && t.list ? this.getColFromCollection(e, this.colDefCols) : null;
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols);
  }
  /**
   * Get column exclusively by ID.
   *
   * Note getCol/getColFromCollection have poor performance when col has been removed.
   */
  getColById(e) {
    var t;
    return ((t = this.cols) == null ? void 0 : t.map[e]) ?? null;
  }
  getColFromCollection(e, t) {
    var o, n;
    if (t == null)
      return null;
    const { map: s, list: i } = t;
    if (typeof e == "string" && s[e])
      return s[e];
    for (let r = 0; r < i.length; r++)
      if (Ha(i[r], e))
        return i[r];
    return ((o = this.beans.autoColSvc) == null ? void 0 : o.getColumn(e)) ?? ((n = this.beans.selectionColSvc) == null ? void 0 : n.getColumn(e)) ?? null;
  }
}, Va = class extends S {
  constructor() {
    super(...arguments), this.dispatchColumnChangedEvent = Tu, this.columns = [], this.columnIndexMap = {}, this.updateIndexMap = () => {
      this.columnIndexMap = {}, this.columns.forEach((e, t) => this.columnIndexMap[e.getId()] = t);
    };
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.aggFuncSvc = e.aggFuncSvc, this.visibleCols = e.visibleCols;
  }
  sortColumns(e) {
    this.columns.sort(e), this.updateIndexMap();
  }
  setColumns(e, t) {
    this.setColList(e, this.columns, this.eventName, !0, !0, this.columnProcessors.set, t);
  }
  addColumns(e, t) {
    this.updateColList(e, this.columns, !0, !0, this.columnProcessors.add, this.eventName, t);
  }
  removeColumns(e, t) {
    this.updateColList(e, this.columns, !1, !0, this.columnProcessors.remove, this.eventName, t);
  }
  getColumnIndex(e) {
    return this.columnIndexMap[e];
  }
  setColList(e = [], t, s, i, o, n, r) {
    const a = this.colModel.getCols();
    if (!a || a.length === 0)
      return;
    const l = /* @__PURE__ */ new Map();
    t.forEach((c, u) => l.set(c, u)), t.length = 0, T(e) && e.forEach((c) => {
      const u = this.colModel.getColDefCol(c);
      u && t.push(u);
    }), t.forEach((c, u) => {
      const h = l.get(c);
      if (h === void 0) {
        l.set(c, 0);
        return;
      }
      i && h !== u || l.delete(c);
    }), this.updateIndexMap(), (this.colModel.getColDefCols() || []).forEach((c) => {
      const u = t.indexOf(c) >= 0;
      n(c, u, r);
    }), o && this.colModel.refreshCols(!1), this.visibleCols.refresh(r), this.dispatchColumnChangedEvent(this.eventSvc, s, [...l.keys()], r);
  }
  updateColList(e = [], t, s, i, o, n, r) {
    if (!e || e.length === 0)
      return;
    let a = !1;
    const l = /* @__PURE__ */ new Set();
    if (e.forEach((c) => {
      if (!c)
        return;
      const u = this.colModel.getColDefCol(c);
      if (u) {
        if (l.add(u), s) {
          if (t.indexOf(u) >= 0)
            return;
          t.push(u);
        } else {
          const h = t.indexOf(u);
          if (h < 0)
            return;
          for (let g = h + 1; g < t.length; g++)
            l.add(t[g]);
          Ae(t, u);
        }
        o(u, s, r), a = !0;
      }
    }), !a)
      return;
    this.updateIndexMap(), i && this.colModel.refreshCols(!1), this.visibleCols.refresh(r);
    const d = Array.from(l);
    this.eventSvc.dispatchEvent({
      type: n,
      columns: d,
      column: d.length === 1 ? d[0] : null,
      source: r
    });
  }
  extractCols(e, t = []) {
    const s = this.columns, i = [], o = [], { setFlagFunc: n, getIndexFunc: r, getInitialIndexFunc: a, getValueFunc: l, getInitialValueFunc: d } = this.columnExtractors;
    (this.colModel.getColDefCols() || []).forEach((g) => {
      const p = t.indexOf(g) < 0, f = g.getColDef(), m = l(f), b = d(f), w = r(f), C = a(f);
      let v;
      m !== void 0 ? v = m : w !== void 0 ? w === null ? v = !1 : v = w >= 0 : p ? b !== void 0 ? v = b : C !== void 0 ? v = C != null && C >= 0 : v = !1 : v = s.indexOf(g) >= 0, v && ((p ? w != null || C != null : w != null) ? i.push(g) : o.push(g));
    });
    const u = (g) => {
      const p = r(g.getColDef()), f = a(g.getColDef());
      return p ?? f;
    };
    i.sort((g, p) => {
      const f = u(g), m = u(p);
      return f === m ? 0 : f < m ? -1 : 1;
    });
    const h = [].concat(i);
    return s.forEach((g) => {
      o.indexOf(g) >= 0 && h.push(g);
    }), o.forEach((g) => {
      h.indexOf(g) < 0 && h.push(g);
    }), s.forEach((g) => {
      h.indexOf(g) < 0 && n(g, !1, e);
    }), h.forEach((g) => {
      s.indexOf(g) < 0 && n(g, !0, e);
    }), this.columns = h, this.updateIndexMap(), this.columns;
  }
  restoreColumnOrder(e, t) {
    const s = this.columns, i = this.colModel.getColDefCols();
    if (!s.length || !i)
      return e;
    const o = Object.keys(t), n = new Set(o), r = new Set(o), a = new Set(
      s.map((C) => {
        const v = C.getColId();
        return r.delete(v), v;
      }).concat(o)
    ), l = [], d = {};
    let c = 0;
    for (let C = 0; C < i.length; C++) {
      const v = i[C].getColId();
      a.has(v) && (l.push(v), d[v] = c++);
    }
    let u = 1e3, h = !1, g = 0;
    const p = this.columnOrdering.enableProp, f = this.columnOrdering.initialEnableProp, m = this.columnOrdering.indexProp, b = this.columnOrdering.initialIndexProp, w = (C) => {
      const v = d[C];
      for (let F = g; F < v; F++) {
        const R = l[F];
        r.has(R) && (t[R][m] = u++, r.delete(R));
      }
      g = v;
    };
    return s.forEach((C) => {
      const v = C.getColId();
      if (n.has(v))
        w(v), t[v][m] = u++;
      else {
        const F = C.getColDef();
        (F[m] === null || F[m] === void 0 && F[b] == null) && (h || (F[p] || F[p] === void 0 && F[f] ? w(v) : (r.forEach((M) => {
          t[M][m] = u + d[M];
        }), u += l.length, h = !0)), e[v] || (e[v] = { colId: v }), e[v][m] = u++);
      }
    }), e;
  }
}, rC = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let s;
    return typeof t != "number" ? s = 0 : s = t + 1, this.existingIds[e] = s, s;
  }
};
function So(e, t, s) {
  return s && e.addDestroyFunc(() => t.destroyBean(s)), s ?? e;
}
var Gu = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  toggleCss(e, t) {
    var i;
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const o = (e || "").split(" ");
      if (o.length > 1) {
        o.forEach((n) => this.toggleCss(n, t));
        return;
      }
    }
    this.cssClassStates[e] !== t && e.length && ((i = this.getGui()) == null || i.classList.toggle(e, t), this.cssClassStates[e] = t);
  }
}, aC = 0, x = null, L = class extends S {
  constructor(e, t) {
    super(), this.suppressDataRefValidation = !1, this.displayed = !0, this.visible = !0, this.compId = aC++, this.cssManager = new Gu(() => this.eGui), this.componentSelectors = new Map((t ?? []).map((s) => [s.selector, s])), e && this.setTemplate(e);
  }
  preConstruct() {
    var t, s, i;
    this.wireTemplate(this.getGui());
    const e = "component-" + ((s = (t = Object.getPrototypeOf(this)) == null ? void 0 : t.constructor) == null ? void 0 : s.name);
    (i = this.css) == null || i.forEach((o) => this.beans.environment.addGlobalCSS(o, e));
  }
  wireTemplate(e, t) {
    e && this.gos && (this.applyElementsToComponent(e), this.createChildComponentsFromTags(e, t));
  }
  getCompId() {
    return this.compId;
  }
  getDataRefAttribute(e) {
    return e.getAttribute ? e.getAttribute(Yc) : null;
  }
  applyElementsToComponent(e, t, s, i = null) {
    if (t === void 0 && (t = this.getDataRefAttribute(e)), t) {
      const o = this[t];
      if (o === x)
        this[t] = i ?? e;
      else {
        const n = s && s[t];
        if (!this.suppressDataRefValidation && !n)
          throw new Error(`data-ref: ${t} on ${this.constructor.name} with ${o}`);
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(e, t) {
    const s = [];
    for (const i of e.childNodes ?? [])
      s.push(i);
    s.forEach((i) => {
      if (!(i instanceof HTMLElement))
        return;
      const o = this.createComponentFromElement(
        i,
        (n) => {
          const r = n.getGui();
          if (r)
            for (const a of i.attributes ?? [])
              r.setAttribute(a.name, a.value);
        },
        t
      );
      if (o) {
        if (o.addItems && i.children.length) {
          this.createChildComponentsFromTags(i, t);
          const n = Array.prototype.slice.call(i.children);
          o.addItems(n);
        }
        this.swapComponentForNode(o, e, i);
      } else i.childNodes && this.createChildComponentsFromTags(i, t);
    });
  }
  createComponentFromElement(e, t, s) {
    const i = e.nodeName, o = this.getDataRefAttribute(e), n = i.indexOf("AG-") === 0, r = n ? this.componentSelectors.get(i) : null;
    let a = null;
    if (r) {
      const l = s && o ? s[o] : void 0;
      a = new r.component(l), a.setParentComponent(this), this.createBean(a, null, t);
    } else if (n)
      throw new Error(`selector: ${i}`);
    return this.applyElementsToComponent(e, o, s, a), a;
  }
  swapComponentForNode(e, t, s) {
    const i = e.getGui();
    t.replaceChild(i, s), t.insertBefore(document.createComment(s.nodeName), i), this.addDestroyFunc(this.destroyBean.bind(this, e));
  }
  activateTabIndex(e) {
    const t = this.gos.get("tabIndex");
    e || (e = []), e.length || e.push(this.getGui()), e.forEach((s) => s.setAttribute("tabindex", t.toString()));
  }
  setTemplate(e, t, s) {
    let i;
    typeof e == "string" || e == null ? i = Aa(e) : i = _(e), this.setTemplateFromElement(i, t, s);
  }
  setTemplateFromElement(e, t, s, i = !1) {
    if (this.eGui = e, this.suppressDataRefValidation = i, t)
      for (let o = 0; o < t.length; o++) {
        const n = t[o];
        this.componentSelectors.set(n.selector, n);
      }
    this.wireTemplate(e, s);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(e) {
    this.parentComponent = e;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(e) {
    this.eGui = e;
  }
  queryForHtmlElement(e) {
    return this.eGui.querySelector(e);
  }
  getContainerAndElement(e, t) {
    let s = t;
    return e == null ? null : (s || (s = this.eGui), On(e) ? {
      element: e,
      parent: s
    } : {
      element: e.getGui(),
      parent: s
    });
  }
  prependChild(e, t) {
    const { element: s, parent: i } = this.getContainerAndElement(e, t) || {};
    !s || !i || i.insertAdjacentElement("afterbegin", s);
  }
  appendChild(e, t) {
    const { element: s, parent: i } = this.getContainerAndElement(e, t) || {};
    !s || !i || i.appendChild(s);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(e, t = {}) {
    if (e !== this.visible) {
      this.visible = e;
      const { skipAriaHidden: s } = t;
      cm(this.eGui, e, { skipAriaHidden: s });
    }
  }
  setDisplayed(e, t = {}) {
    if (e !== this.displayed) {
      this.displayed = e;
      const { skipAriaHidden: s } = t;
      G(this.eGui, e, { skipAriaHidden: s });
      const i = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(i);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), super.destroy();
  }
  addGuiEventListener(e, t, s) {
    this.eGui.addEventListener(e, t, s), this.addDestroyFunc(() => this.eGui.removeEventListener(e, t));
  }
  addCss(e) {
    this.cssManager.toggleCss(e, !0);
  }
  removeCss(e) {
    this.cssManager.toggleCss(e, !1);
  }
  toggleCss(e, t) {
    this.cssManager.toggleCss(e, t);
  }
  registerCSS(e) {
    this.css || (this.css = []), this.css.push(e);
  }
};
function lC(e) {
  return typeof e.then == "function";
}
var q = class Ui {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t(
      (s) => this.onDone(s),
      (s) => this.onReject(s)
    );
  }
  static all(t) {
    return t.length ? new Ui((s) => {
      let i = t.length;
      const o = new Array(i);
      t.forEach((n, r) => {
        n.then((a) => {
          o[r] = a, i--, i === 0 && s(o);
        });
      });
    }) : Ui.resolve();
  }
  static resolve(t = null) {
    return new Ui((s) => s(t));
  }
  then(t) {
    return new Ui((s) => {
      this.status === 1 ? s(t(this.resolution)) : this.waiters.push((i) => s(t(i)));
    });
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((s) => s(t));
  }
  onReject(t) {
  }
};
function dC(e) {
  return e ? e.prototype && "getGui" in e.prototype : !1;
}
function Ou(e, t, s, i) {
  const { name: o } = s;
  let n, r, a, l, d, c;
  if (t) {
    const u = t, h = u[o + "Selector"], g = h ? h(i) : null, p = (f) => {
      typeof f == "string" ? n = f : f != null && f !== !0 && (e.isFrameworkComponent(f) ? a = f : r = f);
    };
    g ? (p(g.component), l = g.params, d = g.popup, c = g.popupPosition) : p(u[o]);
  }
  return { compName: n, jsComp: r, fwComp: a, paramsFromSelector: l, popupFromSelector: d, popupPositionFromSelector: c };
}
var cC = class extends S {
  constructor() {
    super(...arguments), this.beanName = "userCompFactory";
  }
  wireBeans(e) {
    this.agCompUtils = e.agCompUtils, this.registry = e.registry, this.frameworkCompWrapper = e.frameworkCompWrapper, this.gridOptions = e.gridOptions;
  }
  getCompDetailsFromGridOptions(e, t, s, i = !1) {
    return this.getCompDetails(this.gridOptions, e, t, s, i);
  }
  getCompDetails(e, t, s, i, o = !1) {
    var w;
    const { name: n, cellRenderer: r } = t;
    let { compName: a, jsComp: l, fwComp: d, paramsFromSelector: c, popupFromSelector: u, popupPositionFromSelector: h } = Ou(this.beans.frameworkOverrides, e, t, i), g;
    const p = (C) => {
      const v = this.registry.getUserComponent(n, C);
      v && (l = v.componentFromFramework ? void 0 : v.component, d = v.componentFromFramework ? v.component : void 0, g = v.params);
    };
    if (a != null && p(a), l == null && d == null && s != null && p(s), l && r && !dC(l) && (l = (w = this.agCompUtils) == null ? void 0 : w.adaptFunction(t, l)), !l && !d) {
      const { validation: C } = this.beans;
      o && (a !== s || !s) ? a ? C != null && C.isProvidedUserComp(a) || K(50, { compName: a }) : s ? C || K(260, {
        ...this.gos.getModuleErrorParams(),
        propName: n,
        compName: s
      }) : K(216, { name: n }) : s && !C && K(146, { comp: s });
      return;
    }
    const f = this.mergeParams(e, t, i, c, g), m = l == null, b = l ?? d;
    return {
      componentFromFramework: m,
      componentClass: b,
      params: f,
      type: t,
      popupFromSelector: u,
      popupPositionFromSelector: h,
      newAgStackInstance: () => this.newAgStackInstance(b, m, f, t)
    };
  }
  newAgStackInstance(e, t, s, i) {
    var a;
    const o = !t;
    let n;
    o ? n = new e() : n = this.frameworkCompWrapper.wrap(
      e,
      i.mandatoryMethods,
      i.optionalMethods,
      i
    ), this.createBean(n);
    const r = (a = n.init) == null ? void 0 : a.call(n, s);
    return r == null ? q.resolve(n) : r.then(() => n);
  }
  /**
   * merges params with application provided params
   * used by Floating Filter
   */
  mergeParams(e, t, s, i = null, o) {
    const n = { ...s, ...o }, r = e, a = r && r[t.name + "Params"];
    if (typeof a == "function") {
      const l = a(s);
      me(n, l);
    } else typeof a == "object" && me(n, a);
    return me(n, i), n;
  }
}, uC = {
  name: "dragAndDropImageComponent",
  mandatoryMethods: ["setIcon", "setLabel"]
}, hC = { name: "headerComponent", optionalMethods: ["refresh"] }, gC = { name: "innerHeaderComponent" }, pC = { name: "innerHeaderGroupComponent" }, fC = { name: "headerGroupComponent" }, mC = {
  name: "innerRenderer",
  cellRenderer: !0,
  optionalMethods: ["afterGuiAttached"]
}, CC = {
  name: "cellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: !0
}, vC = { name: "loadingCellRenderer", cellRenderer: !0 }, wC = { name: "loadingOverlayComponent", optionalMethods: ["refresh"] }, bC = { name: "noRowsOverlayComponent", optionalMethods: ["refresh"] }, _a = {
  name: "filter",
  mandatoryMethods: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
  optionalMethods: [
    "afterGuiAttached",
    "afterGuiDetached",
    "onNewRowsLoaded",
    "getModelAsString",
    "onFloatingFilterChanged",
    "onAnyFilterChanged",
    "refresh"
  ]
}, yC = {
  name: "floatingFilterComponent",
  mandatoryMethods: ["onParentModelChanged"],
  optionalMethods: ["afterGuiAttached", "refresh"]
}, SC = {
  name: "fullWidthCellRenderer",
  optionalMethods: ["refresh", "afterGuiAttached"],
  cellRenderer: !0
}, xC = { name: "loadingCellRenderer", cellRenderer: !0 }, RC = {
  name: "groupRowRenderer",
  optionalMethods: ["afterGuiAttached"],
  cellRenderer: !0
}, FC = { name: "detailCellRenderer", optionalMethods: ["refresh"], cellRenderer: !0 };
function PC(e, t) {
  return e.getCompDetailsFromGridOptions(uC, "agDragAndDropImage", t, !0);
}
function Io(e, t, s) {
  return e.getCompDetails(t, mC, void 0, s);
}
function DC(e, t, s) {
  return e.getCompDetails(t, hC, "agColumnHeader", s);
}
function MC(e, t, s) {
  return e.getCompDetails(t, gC, void 0, s);
}
function EC(e, t) {
  const s = t.columnGroup.getColGroupDef();
  return e.getCompDetails(s, fC, "agColumnGroupHeader", t);
}
function AC(e, t, s) {
  return e.getCompDetails(t, pC, void 0, s);
}
function IC(e, t) {
  return e.getCompDetailsFromGridOptions(SC, void 0, t, !0);
}
function TC(e, t) {
  return e.getCompDetailsFromGridOptions(xC, "agLoadingCellRenderer", t, !0);
}
function LC(e, t) {
  return e.getCompDetailsFromGridOptions(RC, "agGroupRowRenderer", t, !0);
}
function kC(e, t) {
  return e.getCompDetailsFromGridOptions(FC, "agDetailCellRenderer", t, !0);
}
function Cn(e, t, s) {
  return e.getCompDetails(t, CC, void 0, s);
}
function GC(e, t, s) {
  return e.getCompDetails(t, vC, "agSkeletonCellRenderer", s, !0);
}
function Bu(e, t, s, i) {
  return e.getCompDetails(t, _a, i, s, !0);
}
function OC(e, t) {
  return e.getCompDetailsFromGridOptions(wC, "agLoadingOverlay", t, !0);
}
function BC(e, t) {
  return e.getCompDetailsFromGridOptions(bC, "agNoRowsOverlay", t, !0);
}
function Nu(e, t, s, i) {
  return e.getCompDetails(t, yC, i, s);
}
function NC(e, t) {
  return Ou(e, t, _a);
}
function HC(e, t, s) {
  return e.mergeParams(t, _a, s);
}
function vn(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
var Hu = /* @__PURE__ */ new Set(), wn = {}, hi = {}, qo, Vu = !1, _u = !1, VC = !1;
function _C(e) {
  const [t, s] = e.version.split(".") || [], [i, o] = qo.split(".") || [];
  return t === i && s === o;
}
function WC(e) {
  qo || (qo = e.version);
  const t = (s) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${s} Please update all modules to the same version.`;
  if (e.version ? _C(e) || li(
    t(
      `'${e.moduleName}' is version ${e.version} but the other modules are version ${qo}.`
    )
  ) : li(t(`'${e.moduleName}' is incompatible.`)), e.validate) {
    const s = e.validate();
    s.isValid || li(`${s.message}`);
  }
}
function co(e, t, s = !1) {
  s || (Vu = !0), WC(e);
  const i = e.rowModels ?? ["all"];
  Hu.add(e);
  let o;
  t !== void 0 ? (_u = !0, hi[t] === void 0 && (hi[t] = {}), o = hi[t]) : o = wn, i.forEach((n) => {
    o[n] === void 0 && (o[n] = {}), o[n][e.moduleName] = e;
  }), e.dependsOn && e.dependsOn.forEach((n) => co(n, t, s));
}
function zC(e) {
  delete hi[e];
}
function Qr(e, t, s) {
  const i = (o) => {
    var n, r, a;
    return !!((n = wn[o]) != null && n[e]) || !!((a = (r = hi[t]) == null ? void 0 : r[o]) != null && a[e]);
  };
  return i(s) || i("all");
}
function Wa() {
  return _u;
}
function UC(e, t) {
  const s = hi[e] ?? {};
  return [
    ...Object.values(wn.all ?? {}),
    ...Object.values(s.all ?? {}),
    ...Object.values(wn[t] ?? {}),
    ...Object.values(s[t] ?? {})
  ];
}
function jC() {
  return new Set(Hu);
}
function $C() {
  return Vu;
}
function KC() {
  return VC;
}
var qC = class {
  /**
   * @deprecated v33 Use `registerModules([module])` instead.
   */
  static register(e) {
    co(e, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(e) {
    e.forEach((t) => co(t, void 0));
  }
}, YC = class {
  constructor(e) {
    this.beans = {}, this.createdBeans = [], this.destroyed = !1, !(!e || !e.beanClasses) && (this.beanDestroyComparator = e.beanDestroyComparator, this.init(e));
  }
  init(e) {
    var t;
    for (const s of Object.keys(e.providedBeanInstances))
      this.beans[s] = e.providedBeanInstances[s];
    e.beanClasses.forEach((s) => {
      const i = new s();
      i.beanName ? this.beans[i.beanName] = i : console.error(`Bean ${s.name} is missing beanName`), this.createdBeans.push(i);
    }), (t = e.derivedBeans) == null || t.forEach((s) => {
      const { beanName: i, bean: o } = s(this);
      this.beans[i] = o, this.createdBeans.push(o);
    }), e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator), this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(e, t) {
    if (!e)
      throw Error("null bean");
    return this.initBeans([e], t), e;
  }
  initBeans(e, t) {
    e.forEach((s) => {
      var i, o;
      (i = s.preWireBeans) == null || i.call(s, this.beans), (o = s.wireBeans) == null || o.call(s, this.beans);
    }), e.forEach((s) => {
      var i;
      return (i = s.preConstruct) == null ? void 0 : i.call(s);
    }), t && e.forEach(t), e.forEach((s) => {
      var i;
      return (i = s.postConstruct) == null ? void 0 : i.call(s);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(e) {
    return this.beans[e];
  }
  destroy() {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const e = this.getBeanInstances();
    this.beanDestroyComparator && e.sort(this.beanDestroyComparator), this.destroyBeans(e), this.beans = {}, this.createdBeans = [];
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e) {
    var t;
    (t = e == null ? void 0 : e.destroy) == null || t.call(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        this.destroyBean(e[t]);
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
}, ZC = class extends YC {
  init(e) {
    this.gridId = e.gridId, this.beans.context = this, this.destroyCallback = e.destroyCallback, super.init(e);
  }
  destroy() {
    var e;
    super.destroy(), zC(this.gridId), (e = this.destroyCallback) == null || e.call(this);
  }
  getGridId() {
    return this.gridId;
  }
}, QC = "ag-column-first", XC = "ag-column-last";
function Wu(e, t, s, i) {
  return ie(e) ? [] : ju(e.headerClass, e, t, s, i);
}
function zu(e, t, s, i) {
  return ie(e) ? [] : ju(e.toolPanelClass, e, t, s, i);
}
function Uu(e, t, s) {
  e.toggleCss(QC, s.isColAtEdge(t, "first")), e.toggleCss(XC, s.isColAtEdge(t, "last"));
}
function JC(e, t, s, i) {
  return N(t, {
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: e,
    column: s,
    columnGroup: i
  });
}
function ju(e, t, s, i, o) {
  if (ie(e))
    return [];
  let n;
  if (typeof e == "function") {
    const r = JC(t, s, i, o);
    n = e(r);
  } else
    n = e;
  return typeof n == "string" ? [n] : Array.isArray(n) ? [...n] : [];
}
function za(e) {
  return !!(e.rowPinned && e.pinnedSibling);
}
function Ze(e, t, s, i) {
  const o = t === "top";
  if (!s)
    return Ze(
      e,
      t,
      o ? e.getPinnedTopRow(0) : e.getPinnedBottomRow(0),
      i
    );
  if (!i) {
    const l = o ? e.getPinnedTopRowCount() : e.getPinnedBottomRowCount();
    return Ze(
      e,
      t,
      s,
      o ? e.getPinnedTopRow(l - 1) : e.getPinnedBottomRow(l - 1)
    );
  }
  let n = !1, r = !1;
  const a = [];
  return e.forEachPinnedRow(t, (l) => {
    if (l === s && !n) {
      n = !0, a.push(l);
      return;
    }
    if (n && l === i) {
      r = !0, a.push(l);
      return;
    }
    n && !r && a.push(l);
  }), a;
}
var y = {
  BACKSPACE: "Backspace",
  TAB: "Tab",
  ENTER: "Enter",
  ESCAPE: "Escape",
  SPACE: " ",
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown",
  DELETE: "Delete",
  F2: "F2",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown",
  PAGE_HOME: "Home",
  PAGE_END: "End",
  // these should be used with `event.code` instead of `event.key`
  // as `event.key` changes when non-latin keyboards are used
  A: "KeyA",
  C: "KeyC",
  D: "KeyD",
  V: "KeyV",
  X: "KeyX",
  Y: "KeyY",
  Z: "KeyZ"
}, Xr = !1, bn = 0;
function ev(e) {
  bn > 0 || (e.addEventListener("keydown", yn), e.addEventListener("mousedown", yn));
}
function tv(e) {
  bn > 0 || (e.removeEventListener("keydown", yn), e.removeEventListener("mousedown", yn));
}
function yn(e) {
  const t = Xr, s = e.type === "keydown";
  s && (e.ctrlKey || e.metaKey || e.altKey) || t !== s && (Xr = s);
}
function sv(e) {
  const t = pe(e);
  return ev(t), bn++, () => {
    bn--, tv(t);
  };
}
function Wn() {
  return Xr;
}
function iv(e, t, s) {
  t.addManagedElementListeners(s, {
    keydown: (i) => {
      if (!i.defaultPrevented && i.key === y.TAB) {
        const o = i.shiftKey;
        Be(e, s, !1, o) || Tt(e, o) && i.preventDefault();
      }
    }
  });
}
function cs(e, t, s = !1) {
  const i = dm;
  let o = zc;
  t && (o += ", " + t), s && (o += ', [tabindex="-1"]');
  const n = Array.prototype.slice.apply(e.querySelectorAll(i)).filter((l) => He(l)), r = Array.prototype.slice.apply(e.querySelectorAll(o));
  return r.length ? ((l, d) => l.filter((c) => d.indexOf(c) === -1))(n, r) : n;
}
function Ve(e, t = !1, s = !1, i = !1) {
  const o = cs(
    e,
    i ? ".ag-tab-guard" : null,
    s
  ), n = t ? Z(o) : o[0];
  return n ? (n.focus({ preventScroll: !0 }), !0) : !1;
}
function Be(e, t, s, i) {
  const o = cs(t, s ? ':not([tabindex="-1"])' : null), n = te(e);
  let r;
  s ? r = o.findIndex((l) => l.contains(n)) : r = o.indexOf(n);
  const a = r + (i ? -1 : 1);
  return a < 0 || a >= o.length ? null : o[a];
}
function Ua(e, t = 5) {
  let s = 0;
  for (; e && Ol(e) === null && ++s <= t; )
    e = e.parentElement;
  return Ol(e) === null ? null : e;
}
function ks(e) {
  var t;
  return e.gos.get("suppressHeaderFocus") || !!((t = e.overlays) != null && t.isExclusive());
}
function ja(e) {
  var t;
  return e.gos.get("suppressCellFocus") || !!((t = e.overlays) != null && t.isExclusive());
}
function Tt(e, t, s = !1) {
  const i = e.ctrlsSvc.get("gridCtrl");
  return !s && i.focusNextInnerContainer(t) ? !0 : ((s || !t && !i.isDetailGrid()) && i.forceFocusOutOfContainer(t), !1);
}
function ov(e, t = !1) {
  return e === y.DELETE ? !0 : !t && e === y.BACKSPACE ? Vc() : !1;
}
var nv = class extends S {
  constructor(e, t, s, i) {
    super(), this.cellCtrl = e, this.rowNode = s, this.rowCtrl = i, this.beans = t;
  }
  init() {
    this.eGui = this.cellCtrl.eGui;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case y.ENTER:
        this.onEnterKeyDown(e);
        break;
      case y.F2:
        this.onF2KeyDown(e);
        break;
      case y.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case y.TAB:
        this.onTabKeyDown(e);
        break;
      case y.BACKSPACE:
      case y.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case y.DOWN:
      case y.UP:
      case y.RIGHT:
      case y.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    var s;
    if (!this.cellCtrl.editing) {
      if (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled())
        this.onShiftRangeSelect(e);
      else {
        const i = this.cellCtrl.getFocusedCellPosition();
        (s = this.beans.navigation) == null || s.navigateToNextCell(e, t, i, !0);
      }
      e.preventDefault();
    }
  }
  onShiftRangeSelect(e) {
    const { rangeSvc: t, navigation: s } = this.beans;
    if (!t)
      return;
    const i = t.extendLatestRangeInDirection(e);
    i && (s == null || s.ensureCellVisible(i));
  }
  onTabKeyDown(e) {
    var t;
    (t = this.beans.navigation) == null || t.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    var l;
    const { cellCtrl: s, beans: i, rowNode: o } = this, { gos: n, rangeSvc: r, eventSvc: a } = i;
    if (!s.editing) {
      if (a.dispatchEvent({ type: "keyShortcutChangedCellStart" }), ov(e, n.get("enableCellEditingOnBackspace"))) {
        if (r && xi(n))
          r.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" });
        else if (s.isCellEditable()) {
          const { column: d } = s, c = this.beans.valueSvc.getDeleteValue(d, o);
          o.setDataValue(d, c, "cellClear");
        }
      } else
        (l = i.editSvc) == null || l.startRowOrCellEdit(s, e, t);
      a.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
    }
  }
  onEnterKeyDown(e) {
    var i, o, n;
    const { cellCtrl: t, beans: s } = this;
    if (t.editing || this.rowCtrl.editing)
      (i = this.beans.editSvc) == null || i.stopRowOrCellEdit(t, !1, !1, e.shiftKey);
    else if (s.gos.get("enterNavigatesVertically")) {
      const r = e.shiftKey ? y.UP : y.DOWN;
      (o = s.navigation) == null || o.navigateToNextCell(null, r, t.cellPosition, !1);
    } else
      (n = s.editSvc) == null || n.startRowOrCellEdit(t, y.ENTER, e), t.editing && e.preventDefault();
  }
  onF2KeyDown(e) {
    var i;
    const { cellCtrl: t, beans: s } = this;
    t.editing || (i = s.editSvc) == null || i.startRowOrCellEdit(t, y.F2, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onEscapeKeyDown(e) {
    var i;
    const { cellCtrl: t, beans: s } = this;
    t.editing && ((i = s.editSvc) == null || i.stopRowOrCellEdit(t, !0));
  }
  processCharacter(e) {
    var o;
    if (e.target !== this.eGui || this.cellCtrl.editing)
      return;
    const i = e.key;
    i === y.SPACE ? this.onSpaceKeyDown(e) : (o = this.beans.editSvc) != null && o.startRowOrCellEdit(this.cellCtrl, i, e) && e.preventDefault();
  }
  onSpaceKeyDown(e) {
    var s;
    const { gos: t } = this.beans;
    !this.cellCtrl.editing && Dt(t) && ((s = this.beans.selectionSvc) == null || s.handleSelectionEvent(e, this.rowNode, "spaceKey")), e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}, rv = class extends S {
  constructor(e, t, s) {
    super(), this.cellCtrl = e, this.column = s, this.beans = t;
  }
  onMouseEvent(e, t) {
    if (!gt(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    var d;
    if ((d = this.beans.touchSvc) != null && d.handleCellDoubleClick(this, e))
      return;
    const { eventSvc: t, rangeSvc: s, gos: i, editSvc: o } = this.beans, n = e.ctrlKey || e.metaKey;
    s && n && s.getCellRangeCount(this.cellCtrl.cellPosition) > 1 && s.intersectLastRange(!0);
    const r = this.cellCtrl.createEvent(e, "cellClicked");
    t.dispatchEvent(r);
    const a = this.column.getColDef();
    a.onCellClicked && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        a.onCellClicked(r);
      });
    }, 0), (i.get("singleClickEdit") || a.singleClickEdit) && !i.get("suppressClickEdit") && !(e.shiftKey && (s == null ? void 0 : s.getCellRanges().length) != 0) && (o == null || o.startRowOrCellEdit(this.cellCtrl, void 0, e));
  }
  onCellDoubleClicked(e) {
    const { column: t, beans: s, cellCtrl: i } = this, { eventSvc: o, frameworkOverrides: n, gos: r, editSvc: a } = s, l = t.getColDef(), d = i.createEvent(e, "cellDoubleClicked");
    o.dispatchEvent(d), typeof l.onCellDoubleClicked == "function" && window.setTimeout(() => {
      n.wrapOutgoing(() => {
        l.onCellDoubleClicked(d);
      });
    }, 0), !r.get("singleClickEdit") && !r.get("suppressClickEdit") && (a == null || a.startRowOrCellEdit(i, null, e));
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: s, shiftKey: i } = e, o = e.target, { cellCtrl: n, beans: r } = this, { eventSvc: a, rangeSvc: l, rowNumbersSvc: d, focusSvc: c, gos: u } = r;
    if (this.isRightClickInExistingRange(e))
      return;
    const h = l && !l.isEmpty(), g = this.containsWidget(o), { cellPosition: p } = n, f = qi(p.column);
    if (d && f && !d.handleMouseDownOnCell(p, e)) {
      l && e.preventDefault(), e.stopImmediatePropagation();
      return;
    }
    if (!i || !h) {
      const b = u.get("enableCellTextSelection") && e.defaultPrevented, w = (kn() || b) && !n.editing && !Ea(o) && !g;
      n.focusCell(w);
    }
    if (i && h && !c.isCellFocused(p)) {
      e.preventDefault();
      const m = c.getFocusedCell();
      if (m) {
        const { column: b, rowIndex: w, rowPinned: C } = m, v = r.rowRenderer.getRowByPosition({ rowIndex: w, rowPinned: C }), F = v == null ? void 0 : v.getCellCtrl(b);
        F != null && F.editing && F.stopEditing(), c.setFocusedCell({
          column: b,
          rowIndex: w,
          rowPinned: C,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      }
    }
    if (!g) {
      if (l)
        if (f && e.preventDefault(), i)
          l.extendLatestRangeToCell(p);
        else {
          const m = t || s;
          l.setRangeToCell(p, m);
        }
      a.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseDown"));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeSvc: t } = this.beans;
    if (t) {
      const s = t.isCellInAnyRange(this.cellCtrl.cellPosition), i = e.button === 2 || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (s && i)
        return !0;
    }
    return !1;
  }
  containsWidget(e) {
    return Is(e, "ag-selection-checkbox", 3) || Is(e, "ag-drag-handle", 3);
  }
  onMouseOut(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const { eventSvc: t, colHover: s } = this.beans;
    t.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOut")), s == null || s.clearMouseOver();
  }
  onMouseOver(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const { eventSvc: t, colHover: s } = this.beans;
    t.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseOver")), s == null || s.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const t = this.cellCtrl.eGui, s = t.contains(e.target), i = t.contains(e.relatedTarget);
    return s && i;
  }
  destroy() {
    super.destroy();
  }
}, av = class extends S {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.column, this.rowNode = e.rowNode;
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListeners(this.beans.eventSvc, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  init() {
    this.eSetLeft = this.cellCtrl.getRootElement(), this.eContent = this.cellCtrl.eGui;
    const e = this.cellCtrl.getCellSpan();
    if (e || (this.setupColSpan(), this.setupRowSpan()), this.onLeftChanged(), this.onWidthChanged(), e || this._legacyApplyRowSpan(), e) {
      const t = this.refreshSpanHeight.bind(this, e);
      t(), this.addManagedListeners(this.beans.eventSvc, {
        paginationChanged: t,
        recalculateRowBounds: t,
        pinnedHeightChanged: t
      });
    }
  }
  refreshSpanHeight(e) {
    const t = e.getCellHeight();
    t != null && (this.eContent.style.height = `${t}px`);
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this._legacyApplyRowSpan(!0));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    pt(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListeners(this.beans.eventSvc, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    }));
  }
  onWidthChanged() {
    if (!this.eContent)
      return;
    const e = this.getCellWidth();
    this.eContent.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const { column: e, rowNode: t } = this, s = e.getColSpan(t), i = [];
    if (s === 1)
      i.push(e);
    else {
      let o = e;
      const n = e.getPinned();
      for (let r = 0; o && r < s && (i.push(o), o = this.beans.visibleCols.getColAfter(o), !(!o || ie(o) || n !== o.getPinned())); r++)
        ;
    }
    return i;
  }
  onLeftChanged() {
    if (!this.eSetLeft)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eSetLeft.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = Z(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.printLayout || this.column.getPinned() === "left")
      return e;
    const { visibleCols: t } = this.beans, s = t.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const i = t.bodyWidth;
      return s + i + (e || 0);
    }
    return s + (e || 0);
  }
  _legacyApplyRowSpan(e) {
    if (this.rowSpan === 1 && !e)
      return;
    const s = Bs(this.beans) * this.rowSpan;
    this.eContent.style.height = `${s}px`, this.eContent.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, lv = "ag-cell", dv = "ag-cell-auto-height", cv = "ag-cell-normal-height", uv = "ag-cell-focus", hv = "ag-cell-first-right-pinned", gv = "ag-cell-last-left-pinned", pv = "ag-cell-not-inline-editing", fv = "ag-cell-wrap-text", Sn = "cellCtrl";
function $u(e, t) {
  return fu(e, t, Sn);
}
var mv = 0, Yo = class extends S {
  constructor(e, t, s, i) {
    super(), this.column = e, this.rowNode = t, this.rowCtrl = i, this.rangeFeature = void 0, this.rowResizeFeature = void 0, this.positionFeature = void 0, this.customStyleFeature = void 0, this.tooltipFeature = void 0, this.mouseListener = void 0, this.keyboardListener = void 0, this.suppressRefreshCell = !1, this.onCompAttachedFuncs = [], this.onEditorAttachedFuncs = [], this.focusEventWhileNotReady = null, this.hasBeenFocused = !1, this.beans = s;
    const { colId: o } = e;
    this.instanceId = o + "-" + mv++, this.createCellPosition(), this.updateAndFormatValue(!1);
  }
  addFeatures() {
    var i;
    const { beans: e } = this;
    this.positionFeature = new av(this, e), this.customStyleFeature = (i = e.cellStyles) == null ? void 0 : i.createCellCustomStyleFeature(this, e), this.mouseListener = new rv(this, e, this.column), this.keyboardListener = new nv(this, e, this.rowNode, this.rowCtrl), this.column.isTooltipEnabled() && this.enableTooltipFeature();
    const { rangeSvc: t } = e;
    t && xi(e.gos) && (this.rangeFeature = t.createCellRangeFeature(e, this)), qi(this.column) && (this.rowResizeFeature = this.beans.rowNumbersSvc.createRowNumbersRowResizerFeature(e, this));
  }
  isCellSpanning() {
    return !1;
  }
  getCellSpan() {
  }
  removeFeatures() {
    const e = this.beans.context;
    this.positionFeature = e.destroyBean(this.positionFeature), this.customStyleFeature = e.destroyBean(this.customStyleFeature), this.mouseListener = e.destroyBean(this.mouseListener), this.keyboardListener = e.destroyBean(this.keyboardListener), this.rangeFeature = e.destroyBean(this.rangeFeature), this.rowResizeFeature = e.destroyBean(this.rowResizeFeature), this.disableTooltipFeature();
  }
  enableTooltipFeature(e, t) {
    var s;
    this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.enableCellTooltipFeature(this, e, t);
  }
  disableTooltipFeature() {
    this.tooltipFeature = this.beans.context.destroyBean(this.tooltipFeature);
  }
  setComp(e, t, s, i, o, n, r) {
    var a, l, d, c, u, h, g;
    this.comp = e, this.eGui = t, this.printLayout = o, r ?? (r = this), this.addDomData(r), this.addFeatures(), r.addDestroyFunc(() => this.removeFeatures()), this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.setupFocus(), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(i, r), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (a = this.positionFeature) == null || a.init(), (l = this.customStyleFeature) == null || l.setComp(e), (d = this.tooltipFeature) == null || d.refreshTooltip(), (c = this.keyboardListener) == null || c.init(), (u = this.rangeFeature) == null || u.setComp(e), (h = this.rowResizeFeature) == null || h.refreshRowResizer(), n && this.isCellEditable() ? (g = this.beans.editSvc) == null || g.startEditing(this) : this.showValue(!1, !0), this.onCompAttachedFuncs.length && (this.onCompAttachedFuncs.forEach((p) => p()), this.onCompAttachedFuncs = []);
  }
  setupAutoHeight(e, t) {
    var s;
    this.isAutoHeight = ((s = this.beans.rowAutoHeight) == null ? void 0 : s.setupCellAutoHeight(this, e, t)) ?? !1;
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  isCellRenderer() {
    const e = this.column.getColDef();
    return e.cellRenderer != null || e.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  showValue(e, t) {
    var u, h, g;
    const { beans: s, column: i, rowNode: o, rangeFeature: n } = this, { userCompFactory: r } = s, a = this.getValueToDisplay();
    let l;
    const d = o.stub && ((u = o.groupData) == null ? void 0 : u[i.getId()]) == null, c = i.getColDef();
    if (d || this.isCellRenderer()) {
      const p = this.createCellRendererParams();
      !d || qi(i) ? l = Cn(r, c, p) : l = GC(r, c, p);
    }
    if (!l && !d && ((h = s.findSvc) != null && h.isMatch(o, i))) {
      const p = this.createCellRendererParams();
      l = Cn(
        r,
        { ...i.getColDef(), cellRenderer: "agFindCellRenderer" },
        p
      );
    }
    this.comp.setRenderDetails(l, a, e), !t && n && Ct(s, () => n == null ? void 0 : n.refreshHandle()), (g = this.rowResizeFeature) == null || g.refreshRowResizer();
  }
  setupControlComps() {
    const e = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(this.isCheckboxSelection(e), !0), this.includeRowDrag = this.isIncludeControl(e.rowDrag), this.includeDndSource = this.isIncludeControl(e.dndSource), this.comp.setIncludeSelection(this.includeSelection), this.comp.setIncludeDndSource(this.includeDndSource), this.comp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  /**
   * Wrapper providing general conditions under which control elements (e.g. checkboxes and drag handles)
   * are rendered for a particular cell.
   * @param value Whether to render the control in the specific context of the caller
   * @param allowManuallyPinned Whether manually pinned rows are permitted this form of control element
   */
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(e, t = !1) {
    return (this.rowNode.rowPinned == null || t && za(this.rowNode)) && !!e;
  }
  isCheckboxSelection(e) {
    const { rowSelection: t, groupDisplayType: s } = this.beans.gridOptions, i = ao(t), o = yo(this.column);
    return s === "custom" && i !== "selectionColumn" && o ? !1 : e.checkboxSelection || o && typeof t == "object" && Ts(t);
  }
  refreshShouldDestroy() {
    const e = this.column.getColDef(), t = this.includeSelection != this.isIncludeControl(this.isCheckboxSelection(e), !0), s = this.includeRowDrag != this.isIncludeControl(e.rowDrag), i = this.includeDndSource != this.isIncludeControl(e.dndSource), o = this.isAutoHeight != this.column.isAutoHeight();
    return t || s || i || o;
  }
  onPopupEditorClosed() {
    var e;
    this.editing && ((e = this.beans.editSvc) == null || e.stopRowOrCellEdit(this));
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(e = !1) {
    var t;
    return ((t = this.beans.editSvc) == null ? void 0 : t.stopEditing(this, e)) ?? !1;
  }
  createCellRendererParams() {
    const {
      value: e,
      valueFormatted: t,
      column: s,
      rowNode: i,
      comp: o,
      eGui: n,
      beans: { valueSvc: r, gos: a }
    } = this;
    return N(a, {
      value: e,
      valueFormatted: t,
      getValue: () => r.getValueForDisplay(s, i).value,
      setValue: (d) => r.setValue(i, s, d),
      formatValue: this.formatValue.bind(this),
      data: i.data,
      node: i,
      pinned: s.getPinned(),
      colDef: s.getColDef(),
      column: s,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: n,
      eParentOfValue: o.getParentOfValue(),
      registerRowDragger: (d, c, u, h) => this.registerRowDragger(d, c, h),
      setTooltip: (d, c) => {
        var u;
        a.assertModuleRegistered("Tooltip", 3), this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(d, c), (u = this.tooltipFeature) == null || u.refreshTooltip();
      }
    });
  }
  onCellChanged(e) {
    e.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(e) {
    var t;
    this.refreshShouldDestroy() ? (t = this.rowCtrl) == null || t.recreateCell(this) : this.refreshCell(e);
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(e) {
    var d, c, u, h, g, p;
    if (this.suppressRefreshCell || this.editing)
      return;
    const t = this.column.getColDef(), s = e != null && !!e.newData, i = e != null && !!e.suppressFlash, o = t.field == null && t.valueGetter == null && t.showRowGroup == null, n = e && e.forceRefresh || o || s, r = !!this.comp, a = this.updateAndFormatValue(r), l = n || a;
    if (r) {
      if (l) {
        this.showValue(s, !1);
        const f = (d = this.beans.filterManager) == null ? void 0 : d.isSuppressFlashingCellsBecauseFiltering();
        !i && !f && t.enableCellChangeFlash && ((c = this.beans.cellFlashSvc) == null || c.flashCell(this)), (u = this.customStyleFeature) == null || u.applyUserStyles(), (h = this.customStyleFeature) == null || h.applyClassesFromColDef();
      }
      (g = this.tooltipFeature) == null || g.refreshTooltip(), (p = this.customStyleFeature) == null || p.applyCellClassRules();
    }
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  formatValue(e) {
    return this.callValueFormatter(e) ?? e;
  }
  callValueFormatter(e) {
    return this.beans.valueSvc.formatValue(this.column, this.rowNode, e);
  }
  updateAndFormatValue(e) {
    const t = this.value, s = this.valueFormatted, { value: i, valueFormatted: o } = this.beans.valueSvc.getValueForDisplay(this.column, this.rowNode, !0);
    return this.value = i, this.valueFormatted = o, e ? !this.valuesAreEqual(t, this.value) || this.valueFormatted != s : !0;
  }
  valuesAreEqual(e, t) {
    const s = this.column.getColDef();
    return s.equals ? s.equals(e, t) : e === t;
  }
  addDomData(e) {
    const t = this.eGui;
    bi(this.beans.gos, t, Sn, this), e.addDestroyFunc(() => bi(this.beans.gos, t, Sn, null));
  }
  createEvent(e, t) {
    const { rowNode: s, column: i, value: o, beans: n } = this;
    return N(n.gos, {
      type: t,
      node: s,
      data: s.data,
      value: o,
      column: i,
      colDef: i.getColDef(),
      rowPinned: s.rowPinned,
      event: e,
      rowIndex: s.rowIndex
    });
  }
  processCharacter(e) {
    var t;
    (t = this.keyboardListener) == null || t.processCharacter(e);
  }
  onKeyDown(e) {
    var t;
    (t = this.keyboardListener) == null || t.onKeyDown(e);
  }
  onMouseEvent(e, t) {
    var s;
    (s = this.mouseListener) == null || s.onMouseEvent(e, t);
  }
  getColSpanningList() {
    return this.positionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var e;
    this.comp && ((e = this.positionFeature) == null || e.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { comp: e, column: t, beans: s } = this;
    Uu(e, t, s.visibleCols);
  }
  refreshAriaColIndex() {
    const e = this.beans.visibleCols.getAriaColIndex(this.column);
    Bc(this.eGui, e);
  }
  onWidthChanged() {
    var e;
    return (e = this.positionFeature) == null ? void 0 : e.onWidthChanged();
  }
  getRowPosition() {
    const { rowIndex: e, rowPinned: t } = this.cellPosition;
    return {
      rowIndex: e,
      rowPinned: t
    };
  }
  updateRangeBordersIfRangeCount() {
    var e;
    this.comp && ((e = this.rangeFeature) == null || e.updateRangeBordersIfRangeCount());
  }
  onCellSelectionChanged() {
    var e;
    this.comp && ((e = this.rangeFeature) == null || e.onCellSelectionChanged());
  }
  isRangeSelectionEnabled() {
    return this.rangeFeature != null;
  }
  focusCell(e = !1) {
    this.beans.focusSvc.setFocusedCell({
      ...this.getFocusedCellPosition(),
      forceBrowserFocus: e
    });
  }
  /**
   * Restores focus to the cell, if it should have it
   * @param waitForRender if the cell has just setComp, it may not be rendered yet, so we wait for the next render
   */
  restoreFocus(e = !1) {
    if (!this.comp || this.editing || !this.isCellFocused() || !this.beans.focusSvc.shouldTakeFocus())
      return;
    const t = () => {
      if (!this.isAlive())
        return;
      const s = this.comp.getFocusableElement();
      this.isCellFocused() && s.focus({ preventScroll: !0 });
    };
    if (e) {
      setTimeout(t, 0);
      return;
    }
    t();
  }
  onRowIndexChanged() {
    var e, t;
    this.createCellPosition(), this.onCellFocused(), this.restoreFocus(), (e = this.rangeFeature) == null || e.onCellSelectionChanged(), (t = this.rowResizeFeature) == null || t.refreshRowResizer();
  }
  onSuppressCellFocusChanged(e) {
    const t = this.eGui;
    t && (qi(this.column) && (e = !0), ai(t, "tabindex", e ? void 0 : -1));
  }
  onFirstRightPinnedChanged() {
    if (!this.comp)
      return;
    const e = this.column.isFirstRightPinned();
    this.comp.toggleCss(hv, e);
  }
  onLastLeftPinnedChanged() {
    if (!this.comp)
      return;
    const e = this.column.isLastLeftPinned();
    this.comp.toggleCss(gv, e);
  }
  /**
   * Returns whether cell is focused by the focusSvc, overridden by spannedCellCtrl
   */
  checkCellFocused() {
    return this.beans.focusSvc.isCellFocused(this.cellPosition);
  }
  isCellFocused() {
    const e = this.checkCellFocused();
    return this.hasBeenFocused || (this.hasBeenFocused = e), e;
  }
  setupFocus() {
    this.restoreFocus(!0), this.onCellFocused(this.focusEventWhileNotReady ?? void 0);
  }
  onCellFocused(e) {
    var o;
    const { beans: t } = this;
    if (ja(t))
      return;
    if (!this.comp) {
      e && (this.focusEventWhileNotReady = e);
      return;
    }
    const s = this.isCellFocused();
    if (this.comp.toggleCss(uv, s), s && e && e.forceBrowserFocus) {
      let n = this.comp.getFocusableElement();
      if (this.editing) {
        const r = cs(n, null, !0);
        r.length && (n = r[0]);
      }
      n.focus({ preventScroll: !!e.preventScrollOnBrowserFocus });
    }
    const i = t.gos.get("editType") === "fullRow";
    !s && !i && this.editing && ((o = t.editSvc) == null || o.stopRowOrCellEdit(this)), s && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    const { rowIndex: e, rowPinned: t } = this.rowNode;
    this.cellPosition = {
      rowIndex: e,
      rowPinned: ls(t),
      column: this.column
    };
  }
  setInlineEditingCss() {
    var e;
    (e = this.beans.editSvc) == null || e.setInlineEditingCss(this.rowCtrl);
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    const { comp: e } = this;
    e.toggleCss(lv, !0), e.toggleCss(pv, !0);
    const t = this.column.isAutoHeight() == !0;
    e.toggleCss(dv, t), e.toggleCss(cv, !t);
  }
  onColumnHover() {
    var e;
    (e = this.beans.colHover) == null || e.onCellColumnHover(this.column, this.comp);
  }
  onColDefChanged() {
    var e;
    this.comp && (this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), this.editing ? (e = this.beans.editSvc) == null || e.handleColDefChanged(this) : this.refreshOrDestroyCell({ forceRefresh: !0, suppressFlash: !0 }));
  }
  setWrapText() {
    const e = this.column.getColDef().wrapText == !0;
    this.comp.toggleCss(fv, e);
  }
  dispatchCellContextMenuEvent(e) {
    const t = this.column.getColDef(), s = this.createEvent(e, "cellContextMenu"), { beans: i } = this;
    i.eventSvc.dispatchEvent(s), t.onCellContextMenu && window.setTimeout(() => {
      i.frameworkOverrides.wrapOutgoing(() => {
        t.onCellContextMenu(s);
      });
    }, 0);
  }
  getCellRenderer() {
    var e;
    return ((e = this.comp) == null ? void 0 : e.getCellRenderer()) ?? null;
  }
  destroy() {
    this.onCompAttachedFuncs = [], this.onEditorAttachedFuncs = [], this.isCellFocused() && this.hasBrowserFocus() && this.beans.focusSvc.attemptToRecoverFocus(), super.destroy();
  }
  hasBrowserFocus() {
    var e;
    return ((e = this.eGui) == null ? void 0 : e.contains(te(this.beans))) ?? !1;
  }
  createSelectionCheckbox() {
    var t;
    const e = (t = this.beans.selectionSvc) == null ? void 0 : t.createCheckboxSelectionComponent();
    if (e)
      return this.beans.context.createBean(e), e.init({ rowNode: this.rowNode, column: this.column }), e;
  }
  createDndSource() {
    const e = this.beans.registry.createDynamicBean(
      "dndSourceComp",
      !1,
      this.rowNode,
      this.column,
      this.eGui
    );
    return e && this.beans.context.createBean(e), e;
  }
  registerRowDragger(e, t, s) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(e, t);
      return;
    }
    const i = this.createRowDragComp(e, t, s);
    i && (this.customRowDragComp = i, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(i), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(e, t, s) {
    var o;
    const i = (o = this.beans.rowDragSvc) == null ? void 0 : o.createRowDragCompForCell(
      this.rowNode,
      this.column,
      () => this.value,
      e,
      t,
      s
    );
    if (i)
      return this.beans.context.createBean(i), i;
  }
  cellEditorAttached() {
    this.onEditorAttachedFuncs.forEach((e) => e()), this.onEditorAttachedFuncs = [];
  }
  setFocusedCellPosition(e) {
  }
  getFocusedCellPosition() {
    return this.cellPosition;
  }
  // used by spannedCellCtrl
  refreshAriaRowIndex() {
  }
  /**
   * Returns the root element of the cell, could be a span container rather than the cell element.
   * @returns The root element of the cell.
   */
  getRootElement() {
    return this.eGui;
  }
}, Ku = "__ag_grid_instance";
function qu(e, t) {
  t[Ku] = e.gridInstanceId;
}
function uo(e, t) {
  return Cv(e, t.target);
}
function Cv(e, t) {
  let s = t;
  for (; s; ) {
    const i = s[Ku];
    if (T(i))
      return i === e.gridInstanceId;
    s = s.parentElement;
  }
  return !1;
}
function vv(e, t) {
  var s;
  return ((s = $u(e, t.target)) == null ? void 0 : s.getFocusedCellPosition()) ?? null;
}
var Vs = /* @__PURE__ */ ((e) => (e[e.ToolPanel = 0] = "ToolPanel", e[e.HeaderCell = 1] = "HeaderCell", e[e.RowDrag = 2] = "RowDrag", e[e.ChartPanel = 3] = "ChartPanel", e[e.AdvancedFilterBuilder = 4] = "AdvancedFilterBuilder", e))(Vs || {}), wv = class extends S {
  constructor() {
    super(...arguments), this.beanName = "dragAndDrop", this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.dragSvc = e.dragSvc, this.environment = e.environment, this.userCompFactory = e.userCompFactory;
  }
  addDragSource(e, t = !1) {
    const s = {
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push({ params: s, dragSource: e }), this.dragSvc.addDragSource(s);
  }
  getDragAndDropImageComponent() {
    const { dragAndDropImageComp: e } = this;
    return !e || !e.comp ? null : e.comp;
  }
  removeDragSource(e) {
    const { dragSourceAndParamsList: t, dragSvc: s } = this, i = t.find((o) => o.dragSource === e);
    i && (s.removeDragSource(i.params), Ae(t, i));
  }
  destroy() {
    const { dragSourceAndParamsList: e, dragSvc: t, dropTargets: s } = this;
    e.forEach((i) => t.removeDragSource(i.params)), e.length = 0, s.length = 0, this.clearDragAndDropProperties(), super.destroy();
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, !0);
  }
  onDragStart(e, t) {
    var s;
    this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = e.getDragItem(), (s = e.onDragStarted) == null || s.call(e), this.createDragAndDropImageComponent();
  }
  onDragStop(e) {
    var s, i;
    (i = (s = this.dragSource) == null ? void 0 : s.onDragStopped) == null || i.call(s);
    const { lastDropTarget: t } = this;
    if (t != null && t.onDragStop) {
      const o = this.createDropTargetEvent(t, e, null, null, !1);
      t.onDragStop(o);
    }
    this.clearDragAndDropProperties();
  }
  onDragCancel() {
    var s;
    const { dragSource: e, lastDropTarget: t } = this;
    (s = e == null ? void 0 : e.onDragCancelled) == null || s.call(e), t != null && t.onDragCancel && t.onDragCancel(
      this.createDropTargetEvent(t, this.eventLastTime, null, null, !1)
    ), this.clearDragAndDropProperties();
  }
  clearDragAndDropProperties() {
    this.eventLastTime = null, this.dragging = !1, this.lastDropTarget = void 0, this.dragItem = null, this.dragSource = null, this.removeDragAndDropImageComponent();
  }
  onDragging(e, t = !1) {
    var c, u;
    const s = this.getHorizontalDirection(e), i = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionDragAndDropImageComp(e);
    const o = this.dropTargets.filter((h) => this.isMouseOnDropTarget(e, h)), n = this.findCurrentDropTarget(e, o), { lastDropTarget: r, dragSource: a, dragAndDropImageComp: l, dragItem: d } = this;
    if (n !== r) {
      if (this.leaveLastTargetIfExists(e, s, i, t), r !== null && n === null && ((c = a == null ? void 0 : a.onGridExit) == null || c.call(a, d)), r === null && n !== null && ((u = a == null ? void 0 : a.onGridEnter) == null || u.call(a, d)), this.enterDragTargetIfExists(n, e, s, i, t), n && l) {
        const { comp: h, promise: g } = l;
        h ? h.setIcon(n.getIconName ? n.getIconName() : null, !1) : g.then((p) => {
          p && p.setIcon(n.getIconName ? n.getIconName() : null, !1);
        });
      }
      this.lastDropTarget = n;
    } else if (n && n.onDragging) {
      const h = this.createDropTargetEvent(n, e, s, i, t);
      n.onDragging(h);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, s = [[e.getContainer()]];
    return t ? s.concat(t) : s;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const s = this.getAllContainersFromDropTarget(t);
    let i = !1;
    const o = (a, l) => {
      for (const d of l) {
        const { width: c, height: u, left: h, right: g, top: p, bottom: f } = d.getBoundingClientRect();
        if (c === 0 || u === 0)
          return !1;
        const m = a.clientX >= h && a.clientX < g, b = a.clientY >= p && a.clientY < f;
        if (!m || !b)
          return !1;
      }
      return !0;
    };
    for (const a of s)
      if (o(e, a)) {
        i = !0;
        break;
      }
    const { eElement: n, type: r } = this.dragSource;
    return t.targetContainsSource && !t.getContainer().contains(n) ? !1 : i && t.isInterestedIn(r, n);
  }
  findCurrentDropTarget(e, t) {
    const s = t.length;
    if (s === 0)
      return null;
    if (s === 1)
      return t[0];
    const o = Ns(this.beans).elementsFromPoint(e.clientX, e.clientY);
    for (const n of o)
      for (const r of t)
        if (this.getAllContainersFromDropTarget(r).flatMap((l) => l).indexOf(n) !== -1)
          return r;
    return null;
  }
  enterDragTargetIfExists(e, t, s, i, o) {
    if (e && e.onDragEnter) {
      const n = this.createDropTargetEvent(
        e,
        t,
        s,
        i,
        o
      );
      e.onDragEnter(n);
    }
  }
  leaveLastTargetIfExists(e, t, s, i) {
    const { lastDropTarget: o } = this;
    if (!o)
      return;
    if (o.onDragLeave) {
      const r = this.createDropTargetEvent(
        o,
        e,
        t,
        s,
        i
      );
      o.onDragLeave(r);
    }
    const n = this.getDragAndDropImageComponent();
    n && n.setIcon(null, !1);
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((s) => s.external).find((s) => s.getContainer() === e.getContainer()) || null;
  }
  isDropZoneWithinThisGrid(e) {
    const s = this.ctrlsSvc.getGridBodyCtrl().eGridBody, { dropZoneTarget: i } = e;
    return s.contains(i);
  }
  getHorizontalDirection(e) {
    var i;
    const t = (i = this.eventLastTime) == null ? void 0 : i.clientX, s = e.clientX;
    return t === s ? null : t > s ? "left" : "right";
  }
  getVerticalDirection(e) {
    var i;
    const t = (i = this.eventLastTime) == null ? void 0 : i.clientY, s = e.clientY;
    return t === s ? null : t > s ? "up" : "down";
  }
  createDropTargetEvent(e, t, s, i, o) {
    const n = e.getContainer(), r = n.getBoundingClientRect(), { dragItem: a, dragSource: l, gos: d } = this, c = t.clientX - r.left, u = t.clientY - r.top;
    return N(d, {
      event: t,
      x: c,
      y: u,
      vDirection: i,
      hDirection: s,
      dragSource: l,
      fromNudge: o,
      dragItem: a,
      dropZoneTarget: n
    });
  }
  positionDragAndDropImageComp(e) {
    const t = this.getDragAndDropImageComponent();
    t && $r(t.getGui(), e, this.beans);
  }
  removeDragAndDropImageComponent() {
    var t;
    const { dragAndDropImageComp: e } = this;
    if (e) {
      const { comp: s } = e;
      if (s) {
        const i = s.getGui();
        (t = this.dragAndDropImageParent) == null || t.removeChild(i), this.destroyBean(s);
      }
    }
    this.dragAndDropImageComp = null;
  }
  createDragAndDropImageComponent() {
    const { dragSource: e, gos: t, userCompFactory: s } = this;
    if (!e)
      return;
    const i = PC(
      s,
      N(t, {
        dragSource: e
      })
    );
    if (!i)
      return;
    const o = i.newAgStackInstance();
    this.dragAndDropImageComp = {
      promise: o
    }, o.then((n) => {
      !n || !this.isAlive() || (this.processDragAndDropImageComponent(n), this.dragAndDropImageComp.comp = n);
    });
  }
  processDragAndDropImageComponent(e) {
    const { dragSource: t, environment: s } = this;
    if (!t)
      return;
    const i = e.getGui();
    i.style.setProperty("position", "absolute"), i.style.setProperty("z-index", "9999"), qu(this.gos, i), s.applyThemeClasses(i), e.setIcon(null, !1);
    let { dragItemName: o } = t;
    typeof o == "function" && (o = o()), e.setLabel(o || ""), i.style.top = "20px", i.style.left = "20px";
    const n = Hn(this.beans);
    this.dragAndDropImageParent = n, n ? n.appendChild(i) : P(54);
  }
  registerGridDropTarget(e, t) {
    const s = {
      getContainer: e,
      isInterestedIn: (i) => i === 1 || i === 0,
      getIconName: () => "notAllowed"
    };
    this.addDropTarget(s), t.addDestroyFunc(() => this.removeDropTarget(s));
  }
}, bv = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const s = t || this.shouldSkipVerticalScroll();
    if (s && this.shouldSkipHorizontalScroll())
      return;
    const i = this.scrollContainer.getBoundingClientRect(), o = this.scrollByTick;
    this.tickLeft = e.clientX < i.left + o, this.tickRight = e.clientX > i.right - o, this.tickUp = e.clientY < i.top + o && !s, this.tickDown = e.clientY > i.bottom - o && !s, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
};
function yv(e) {
  const { rowIndex: t, rowPinned: s, column: i } = e;
  return `${t}.${s ?? "null"}.${i.getId()}`;
}
function Yu(e, t) {
  const s = e.column === t.column, i = e.rowPinned === t.rowPinned, o = e.rowIndex === t.rowIndex;
  return s && i && o;
}
function Zu(e, t) {
  switch (e.rowPinned) {
    case "top":
      if (t.rowPinned !== "top")
        return !0;
      break;
    case "bottom":
      if (t.rowPinned !== "bottom")
        return !1;
      break;
    default:
      if (T(t.rowPinned))
        return t.rowPinned !== "top";
      break;
  }
  return e.rowIndex < t.rowIndex;
}
function Sv(e) {
  let t = 0, s;
  const { pinnedRowModel: i, rowModel: o, pageBounds: n } = e;
  return i != null && i.getPinnedTopRowCount() ? s = "top" : o.getRowCount() ? (s = null, t = n.getFirstRow()) : i != null && i.getPinnedBottomRowCount() && (s = "bottom"), s === void 0 ? null : { rowIndex: t, rowPinned: s };
}
function xv(e) {
  let t, s = null;
  const { pinnedRowModel: i, pageBounds: o } = e, n = i == null ? void 0 : i.getPinnedBottomRowCount(), r = i == null ? void 0 : i.getPinnedTopRowCount();
  return n ? (s = "bottom", t = n - 1) : e.rowModel.getRowCount() ? (s = null, t = o.getLastRow()) : r && (s = "top", t = r - 1), t === void 0 ? null : { rowIndex: t, rowPinned: s };
}
function zn(e, t) {
  var s, i;
  switch (t.rowPinned) {
    case "top":
      return (s = e.pinnedRowModel) == null ? void 0 : s.getPinnedTopRow(t.rowIndex);
    case "bottom":
      return (i = e.pinnedRowModel) == null ? void 0 : i.getPinnedBottomRow(t.rowIndex);
    default:
      return e.rowModel.getRow(t.rowIndex);
  }
}
function To(e, t) {
  var o;
  const s = (o = e.spannedRowRenderer) == null ? void 0 : o.getCellByPosition(t);
  if (s)
    return s;
  const i = e.rowRenderer.getRowByPosition(t);
  return i ? i.getCellCtrl(t.column) : null;
}
function xn(e, t) {
  const { rowIndex: s, rowPinned: i } = t, { pageBounds: o, pinnedRowModel: n, rowModel: r } = e;
  if (s === 0)
    return i === "top" ? null : i === "bottom" && r.isRowsToRender() ? { rowIndex: o.getLastRow(), rowPinned: null } : n != null && n.isRowsToRender("top") ? { rowIndex: n.getPinnedTopRowCount() - 1, rowPinned: "top" } : null;
  const a = i ? void 0 : r.getRow(s);
  return Qu(e, a, !0) ?? { rowIndex: s - 1, rowPinned: i };
}
function Jr(e, t) {
  const { rowIndex: s, rowPinned: i } = t, { pageBounds: o, pinnedRowModel: n, rowModel: r } = e;
  if (Rv(e, t))
    return i === "bottom" ? null : i === "top" && r.isRowsToRender() ? { rowIndex: o.getFirstRow(), rowPinned: null } : n != null && n.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
  const a = i ? void 0 : r.getRow(s);
  return Qu(e, a) ?? { rowIndex: s + 1, rowPinned: i };
}
function Qu(e, t, s) {
  const { gos: i, rowRenderer: o } = e;
  if (!(t != null && t.sticky) || !Vn(i))
    return;
  const n = s ? o.getStickyTopRowCtrls() : o.getStickyBottomRowCtrls();
  let r;
  for (let a = 0; a < n.length; a++)
    if (n[a].rowNode.rowIndex === t.rowIndex) {
      r = n[a + (s ? -1 : 1)];
      break;
    }
  return r ? { rowIndex: r.rowNode.rowIndex, rowPinned: null } : void 0;
}
function Rv(e, t) {
  const { rowPinned: s, rowIndex: i } = t, { pinnedRowModel: o, pageBounds: n } = e;
  return s === "top" ? ((o == null ? void 0 : o.getPinnedTopRowCount()) ?? 0) - 1 <= i : s === "bottom" ? ((o == null ? void 0 : o.getPinnedBottomRowCount()) ?? 0) - 1 <= i : n.getLastRow() <= i;
}
var Xu = class {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  depthFirstSearchChangedPath(e, t) {
    const { rowNode: s, children: i } = e;
    if (i)
      for (let o = 0; o < i.length; ++o)
        this.depthFirstSearchChangedPath(i[o], t);
    t(s);
  }
  depthFirstSearchEverything(e, t, s) {
    const i = e.childrenAfterGroup;
    if (i)
      for (let o = 0, n = i.length; o < n; ++o) {
        const r = i[o];
        r.childrenAfterGroup ? this.depthFirstSearchEverything(r, t, s) : s && t(r);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, s = !1) {
    this.active && !s ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, s = 0;
    for (; !this.mapToItems[t.id]; ) {
      const i = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = i, s++, t = t.parent;
    }
    return s;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let s = e;
    for (; s; )
      this.nodeIdsToColumns[s.id] || (this.nodeIdsToColumns[s.id] = {}), t.forEach((i) => this.nodeIdsToColumns[s.id][i.getId()] = !0), s = s.parent;
  }
  linkPathItems(e, t) {
    let s = e;
    for (let i = 0; i < t; i++) {
      const o = this.mapToItems[s.id], n = this.mapToItems[s.parent.id];
      n.children || (n.children = []), n.children.push(o), s = s.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const s = this.createPathItems(e);
    this.linkPathItems(e, s), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const s = this.nodeIdsToColumns[e.id];
    return t.filter((o) => s[o.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const s = this.nodeIdsToColumns[e.id];
    return t.filter((o) => !s[o.getId()]);
  }
};
function Ju(e, t, s) {
  if (s === 0)
    return !1;
  const i = Math.abs(e.clientX - t.clientX), o = Math.abs(e.clientY - t.clientY);
  return Math.max(i, o) <= s;
}
var Fv = class extends S {
  constructor() {
    super(...arguments), this.beanName = "dragSvc", this.dragEndFunctions = [], this.dragSources = [];
  }
  destroy() {
    const { dragSources: e } = this;
    e.forEach(this.removeListener.bind(this)), e.length = 0, super.destroy();
  }
  removeListener(e) {
    const t = e.dragSource.eElement, s = e.mouseDownListener;
    if (t.removeEventListener("mousedown", s), e.touchEnabled) {
      const i = e.touchStartListener;
      t.removeEventListener("touchstart", i, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const { dragSources: t } = this, s = t.find((i) => i.dragSource === e);
    s && (this.removeListener(s), Ae(t, s));
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: s, includeTouch: i, stopPropagationForTouch: o } = e;
    s.addEventListener("mousedown", t);
    let n = null;
    const r = this.gos.get("suppressTouch");
    i && !r && (n = (a) => {
      Ea(a.target) || (o && a.stopPropagation(), this.onTouchStart(e, a));
    }, s.addEventListener("touchstart", n, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: n,
      touchEnabled: !!i
    });
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const s = t.touches[0];
    this.touchLastTime = s, this.touchStart = s;
    const i = (l) => this.onTouchMove(l, e.eElement), o = (l) => this.onTouchUp(l, e.eElement), n = (l) => {
      l.cancelable && l.preventDefault();
    }, r = t.target, a = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: Ns(this.beans),
        type: "touchmove",
        listener: n,
        options: { passive: !1 }
      },
      { target: r, type: "touchmove", listener: i, options: { passive: !0 } },
      { target: r, type: "touchend", listener: o, options: { passive: !0 } },
      { target: r, type: "touchcancel", listener: o, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(a), e.dragStartPixels === 0 && this.onCommonMove(s, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const s = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || s._alreadyProcessedByDragService || (s._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const i = (d) => this.onMouseMove(d, e.eElement), o = (d) => this.onMouseUp(d, e.eElement), n = (d) => d.preventDefault(), r = (d) => {
      d.key === y.ESCAPE && this.cancelDrag(e.eElement);
    }, a = Ns(this.beans), l = [
      { target: a, type: "mousemove", listener: i },
      { target: a, type: "mouseup", listener: o },
      { target: a, type: "contextmenu", listener: n },
      { target: a, type: "keydown", listener: r }
    ];
    this.addTemporaryEvents(l), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: s, type: i, listener: o, options: n } = t;
      s.addEventListener(i, o, n);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: s, type: i, listener: o, options: n } = t;
        s.removeEventListener(i, o, n);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: s } = this.currentDragParams, i = T(s) ? s : 4;
    return Ju(e, t, i);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, s) {
    var i;
    if (!this.dragging) {
      if (this.isEventNearStartEvent(e, t))
        return;
      if (this.dragging = !0, this.eventSvc.dispatchEvent({
        type: "dragStarted",
        target: s
      }), this.currentDragParams.onDragStart(t), !this.currentDragParams) {
        this.dragging = !1;
        return;
      }
      this.currentDragParams.onDragging(t);
    }
    (i = this.currentDragParams) == null || i.onDragging(e);
  }
  onTouchMove(e, t) {
    const s = this.getFirstActiveTouch(e.touches);
    s && this.onCommonMove(s, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    var s;
    kn() && ((s = pe(this.beans).getSelection()) == null || s.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const { gos: t } = this, s = t.get("enableCellTextSelection"), i = e.type === "mousemove", o = (n) => {
      const r = n.target, a = r == null ? void 0 : r.tagName.toLocaleLowerCase();
      return !!(a != null && a.match("^a$|textarea|input|select|button"));
    };
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      s && i && e.cancelable && uo(t, e) && !o(e)
    );
  }
  onTouchUp(e, t) {
    let s = this.getFirstActiveTouch(e.changedTouches);
    s || (s = this.touchLastTime), this.onUpCommon(s, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    this.dragging && (this.dragging = !1, this.currentDragParams.onDragStop(e), this.eventSvc.dispatchEvent({
      type: "dragStopped",
      target: t
    })), this.resetDragProperties();
  }
  cancelDrag(e) {
    var t, s;
    this.eventSvc.dispatchEvent({
      type: "dragCancelled",
      target: e
    }), (s = (t = this.currentDragParams) == null ? void 0 : t.onDragCancel) == null || s.call(t), this.resetDragProperties();
  }
  resetDragProperties() {
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null;
    const { dragEndFunctions: e } = this;
    e.forEach((t) => t()), e.length = 0;
  }
};
function eh(e, t) {
  return e + "_" + t;
}
function ue(e) {
  return e instanceof th;
}
var th = class extends S {
  constructor(e, t, s, i) {
    super(), this.providedColumnGroup = e, this.groupId = t, this.partId = s, this.pinned = i, this.isColumn = !1, this.displayedChildren = [], this.autoHeaderHeight = null, this.parent = null;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  getUniqueId() {
    return eh(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      ue(e) && e.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gos.get("enableRtl")) {
        const t = Z(this.displayedChildren).getLeft();
        this.setLeft(t);
      } else {
        const e = this.displayedChildren[0].getLeft();
        this.setLeft(e);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchLocalEvent({ type: "leftChanged" }));
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    var t;
    let e = 0;
    return (t = this.displayedChildren) == null || t.forEach((s) => {
      e += s.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let e = !1;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = !0);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth();
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  isAutoHeaderHeight() {
    var e;
    return !!((e = this.getColGroupDef()) != null && e.autoHeaderHeight);
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      wt(t) ? e.push(t) : ue(t) && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      wt(t) ? e.push(t) : ue(t) && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); )
      e = e.getParent();
    if (!(e ? e.getProvidedColumnGroup().isExpandable() : !1)) {
      this.displayedChildren = this.children, this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((s) => {
      if (ue(s) && (!s.displayedChildren || !s.displayedChildren.length))
        return;
      switch (s.getColumnGroupShow()) {
        case "open":
          e.getProvidedColumnGroup().isExpanded() && this.displayedChildren.push(s);
          break;
        case "closed":
          e.getProvidedColumnGroup().isExpanded() || this.displayedChildren.push(s);
          break;
        default:
          this.displayedChildren.push(s);
          break;
      }
    }), this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
}, Rn = "row-group-", Pv = "t-", Dv = "b-", Mv = 0, Us = class {
  constructor(e) {
    this.master = !1, this.detail = void 0, this.rowIndex = null, this.key = null, this.sourceRowIndex = -1, this.childrenMapped = {}, this.treeNode = null, this.treeNodeFlags = 0, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = Mv++, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.__selected = !1, this.beans = e;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(e) {
    this.setDataCommon(e, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(e) {
    this.setDataCommon(e, !0);
  }
  setDataCommon(e, t) {
    var l, d, c;
    const { valueCache: s, selectionSvc: i, eventSvc: o } = this.beans, n = this.data;
    this.data = e, s == null || s.onDataChanged(), this.updateDataOnDetailNode(), i == null || i.updateRowSelectable(this), this.resetQuickFilterAggregateText();
    const r = this.createDataChangedEvent(e, n, t);
    if ((l = this.__localEventService) == null || l.dispatchEvent(r), this.sibling) {
      this.sibling.data = e;
      const u = this.sibling.createDataChangedEvent(e, n, t);
      (d = this.sibling.__localEventService) == null || d.dispatchEvent(u);
    }
    o.dispatchEvent({ type: "rowNodeDataChanged", node: this });
    const a = this.pinnedSibling;
    a && (a.data = e, (c = a.__localEventService) == null || c.dispatchEvent(
      a.createDataChangedEvent(e, n, t)
    ), o.dispatchEvent({ type: "rowNodeDataChanged", node: a }));
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(e, t, s) {
    return {
      type: "dataChanged",
      node: this,
      oldData: t,
      newData: e,
      update: s
    };
  }
  getRowIndexString() {
    return this.rowIndex == null ? (K(13), null) : this.rowPinned === "top" ? Pv + this.rowIndex : this.rowPinned === "bottom" ? Dv + this.rowIndex : this.rowIndex.toString();
  }
  setDataAndId(e, t) {
    var r, a;
    const { selectionSvc: s } = this.beans, i = (r = s == null ? void 0 : s.createDaemonNode) == null ? void 0 : r.call(s, this), o = this.data;
    this.data = e, this.updateDataOnDetailNode(), this.setId(t), s && (s.updateRowSelectable(this), s.syncInRowNode(this, i));
    const n = this.createDataChangedEvent(e, o, !1);
    (a = this.__localEventService) == null || a.dispatchEvent(n);
  }
  setId(e) {
    var s;
    const t = ro(this.beans.gos);
    if (t)
      if (this.data) {
        const i = ((s = this.parent) == null ? void 0 : s.getRoute()) ?? [];
        this.id = t({
          data: this.data,
          parentKeys: i.length > 0 ? i : void 0,
          level: this.level,
          rowPinned: this.rowPinned
        }), this.id.startsWith(Rn) && K(14, {
          groupPrefix: Rn
        });
      } else
        this.id = void 0;
    else
      this.id = e;
  }
  setRowTop(e) {
    this.oldRowTop = this.rowTop, this.rowTop !== e && (this.rowTop = e, this.dispatchRowEvent("topChanged"), this.setDisplayed(e !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setHovered(e) {
    this.hovered = e;
  }
  isHovered() {
    return this.hovered;
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(e, t = !1) {
    this.rowHeight = e, this.rowHeightEstimated = t, this.dispatchRowEvent("heightChanged");
  }
  setExpanded(e, t, s) {
    var i;
    (i = this.beans.expansionSvc) == null || i.setExpanded(this, e, t, s);
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(e, t, s) {
    const { colModel: i, valueSvc: o, gos: n, selectionSvc: r } = this.beans, a = typeof e != "string" ? e : i.getCol(e) ?? i.getColDefCol(e);
    if (!a)
      return !1;
    const l = o.getValueForDisplay(a, this).value;
    if (n.get("readOnlyEdit")) {
      const {
        beans: { eventSvc: h },
        data: g,
        rowIndex: p,
        rowPinned: f
      } = this;
      return h.dispatchEvent({
        type: "cellEditRequest",
        event: null,
        rowIndex: p,
        rowPinned: f,
        column: a,
        colDef: a.colDef,
        data: g,
        node: this,
        oldValue: l,
        newValue: t,
        value: t,
        source: s
      }), !1;
    }
    const d = o.setValue(this, a, t, s);
    this.dispatchCellChangedEvent(a, t, l);
    const c = r == null ? void 0 : r.updateRowSelectable(this), u = this.pinnedSibling;
    return u && (d && u.dispatchCellChangedEvent(a, t, l), u.selectable = c ?? !0), d;
  }
  updateHasChildren() {
    let e = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    const { rowChildrenSvc: t } = this.beans;
    t && (e = t.getHasChildrenValue(this)), e !== this.__hasChildren && (this.__hasChildren = !!e, this.dispatchRowEvent("hasChildrenChanged"));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  dispatchCellChangedEvent(e, t, s) {
    var o;
    const i = {
      type: "cellChanged",
      node: this,
      column: e,
      newValue: t,
      oldValue: s
    };
    (o = this.__localEventService) == null || o.dispatchEvent(i);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */
  isExpandable() {
    var e;
    return ((e = this.beans.expansionSvc) == null ? void 0 : e.isExpandable(this)) ?? !1;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.rowPinned && this.pinnedSibling ? this.pinnedSibling.isSelected() : this.__selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(e) {
    var t;
    (t = this.childrenAfterGroup) == null || t.forEach((s) => s.depthFirstSearch(e)), e(this);
  }
  dispatchRowEvent(e) {
    var t;
    (t = this.__localEventService) == null || t.dispatchEvent({
      type: e,
      node: this
    });
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(e, t = !1, s = "api") {
    var i;
    (i = this.beans.selectionSvc) == null || i.setNodesSelected({
      nodes: [this],
      newValue: e,
      clearSelection: t,
      source: s
    });
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return !!this.rowPinned;
  }
  __addEventListener(e, t) {
    this.__localEventService || (this.__localEventService = new hs()), this.__localEventService.addEventListener(e, t);
  }
  __removeEventListener(e, t) {
    this.removeLocalListener(e, t);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  addEventListener(e, t) {
    var i, o, n, r;
    (i = this.beans.validation) == null || i.checkRowEvents(e), this.__localEventService || (this.__localEventService = new hs()), this.frameworkEventListenerService = (n = (o = this.beans.frameworkOverrides).createLocalEventListenerWrapper) == null ? void 0 : n.call(
      o,
      this.frameworkEventListenerService,
      this.__localEventService
    );
    const s = ((r = this.frameworkEventListenerService) == null ? void 0 : r.wrap(e, t)) ?? t;
    this.__localEventService.addEventListener(e, s);
  }
  /**
   * PUBLIC USE ONLY: for internal use within AG Grid use the `__addEventListener` and `__removeEventListener` methods.
   */
  removeEventListener(e, t) {
    var i;
    const s = ((i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(e, t)) ?? t;
    this.removeLocalListener(e, s);
  }
  removeLocalListener(e, t) {
    var s, i;
    (s = this.__localEventService) == null || s.removeEventListener(e, t), (i = this.__localEventService) != null && i.noRegisteredListenersExist() && (this.__localEventService = null);
  }
  /**
   * @deprecated v32.2.0 Check `node.detail` then user provided callback `isFullWidthRow` instead.
   *
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    if (P(61), this.detail)
      return !0;
    const e = this.beans.gos.getCallback("isFullWidthRow");
    return e ? e({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of keys to the row node. Returns undefined if the node has no key.
   */
  getRoute() {
    if (this.level === -1)
      return [];
    if (this.key == null)
      return;
    const e = [];
    let t = this;
    for (; t && t.key != null; )
      e.push(t.key), t = t.parent;
    return e.reverse();
  }
  setFirstChild(e) {
    this.firstChild !== e && (this.firstChild = e, this.dispatchRowEvent("firstChildChanged"));
  }
  setDisplayed(e) {
    this.displayed !== e && (this.displayed = e, this.dispatchRowEvent("displayedChanged"));
  }
  setRowIndex(e) {
    this.rowIndex !== e && (this.rowIndex = e, this.dispatchRowEvent("rowIndexChanged"));
  }
  setAllChildrenCount(e) {
    this.allChildrenCount !== e && (this.allChildrenCount = e, this.dispatchRowEvent("allChildrenCountChanged"));
  }
  setUiLevel(e) {
    this.uiLevel !== e && (this.uiLevel = e, this.dispatchRowEvent("uiLevelChanged"));
  }
  getFirstChild() {
    var e;
    return this.childStore ? this.childStore.getFirstNode() : ((e = this.childrenAfterSort) == null ? void 0 : e[0]) ?? null;
  }
};
function sh(e, t, s) {
  return N(t, {
    type: s,
    node: e,
    data: e.data,
    rowIndex: e.rowIndex,
    rowPinned: e.rowPinned
  });
}
var Ev = /* @__PURE__ */ new Set(["__localEventService", "__objectId", "sticky", "__autoHeights", "__checkAutoHeightsDebounced", "childStore"]);
function Av(e, t) {
  const s = new Us(t);
  return Object.keys(e).forEach((i) => {
    Ev.has(i) || (s[i] = e[i]);
  }), s.oldRowTop = null, s;
}
var Iv = { tag: "div", cls: "ag-filter" }, $a = class extends L {
  constructor(e, t) {
    super(Iv), this.column = e, this.source = t, this.filterWrapper = null;
  }
  postConstruct() {
    this.createFilter(!0), this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    var e;
    return ((e = this.filterWrapper) == null ? void 0 : e.filterPromise) ?? null;
  }
  afterInit() {
    var e, t;
    return ((t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null ? void 0 : t.then(() => {
    })) ?? q.resolve();
  }
  afterGuiAttached(e) {
    var t, s;
    (s = (t = this.filterWrapper) == null ? void 0 : t.filterPromise) == null || s.then((i) => {
      var o;
      (o = i == null ? void 0 : i.afterGuiAttached) == null || o.call(i, e);
    });
  }
  afterGuiDetached() {
    var e, t;
    (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null || t.then((s) => {
      var i;
      (i = s == null ? void 0 : s.afterGuiDetached) == null || i.call(s);
    });
  }
  createFilter(e) {
    var i, o;
    const { column: t, source: s } = this;
    this.filterWrapper = ((i = this.beans.filterManager) == null ? void 0 : i.getOrCreateFilterWrapper(t)) ?? null, (o = this.filterWrapper) != null && o.filterPromise && this.filterWrapper.filterPromise.then((n) => {
      const r = n.getGui();
      T(r) || P(69, { guiFromFilter: r }), this.appendChild(r), e && this.eventSvc.dispatchEvent({
        type: "filterOpened",
        column: t,
        source: s,
        eGui: this.getGui()
      });
    });
  }
  onFilterDestroyed(e) {
    (e.source === "api" || e.source === "paramsUpdated") && e.column.getId() === this.column.getId() && this.beans.colModel.getColDefCol(this.column) && (de(this.getGui()), this.createFilter());
  }
  destroy() {
    this.filterWrapper = null, super.destroy();
  }
}, ih = "ag-resizer-wrapper", Yt = (e, t) => ({
  tag: "div",
  ref: `${e}Resizer`,
  cls: `ag-resizer ag-resizer-${t}`
}), Tv = {
  tag: "div",
  cls: ih,
  children: [
    Yt("eTopLeft", "topLeft"),
    Yt("eTop", "top"),
    Yt("eTopRight", "topRight"),
    Yt("eRight", "right"),
    Yt("eBottomRight", "bottomRight"),
    Yt("eBottom", "bottom"),
    Yt("eBottomLeft", "bottomLeft"),
    Yt("eLeft", "left")
  ]
}, Un = class extends S {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc, this.dragSvc = e.dragSvc;
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, s = t / 2 - this.getWidth() / 2, i = e / 2 - this.getHeight() / 2;
    this.offsetElement(s, i);
  }
  initialisePosition() {
    if (this.positioned)
      return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: s, width: i, minHeight: o, height: n, x: r, y: a } = this.config;
    this.offsetParent || this.setOffsetParent();
    let l = 0, d = 0;
    const c = He(this.element);
    if (c) {
      const u = this.findBoundaryElement(), h = window.getComputedStyle(u);
      if (h.minWidth != null) {
        const g = u.offsetWidth - this.element.offsetWidth;
        d = parseInt(h.minWidth, 10) - g;
      }
      if (h.minHeight != null) {
        const g = u.offsetHeight - this.element.offsetHeight;
        l = parseInt(h.minHeight, 10) - g;
      }
    }
    if (this.minHeight = o || l, this.minWidth = s || d, i && this.setWidth(i), n && this.setHeight(n), (!i || !n) && this.refreshSize(), e)
      this.center();
    else if (r || a)
      this.offsetElement(r, a);
    else if (c && t) {
      let u = this.boundaryEl, h = !0;
      if (u || (u = this.findBoundaryElement(), h = !1), u) {
        const g = parseFloat(u.style.top), p = parseFloat(u.style.left);
        h ? this.offsetElement(isNaN(p) ? 0 : p, isNaN(g) ? 0 : g) : this.setPosition(p, g);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    var i, o;
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const s = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? ((i = this.dragSvc) == null || i.addDragSource(s), this.moveElementDragListener = s) : ((o = this.dragSvc) == null || o.removeDragSource(s), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      var r;
      const i = !!e[t], o = this.getResizerElement(t), n = {
        dragStartPixels: 0,
        eElement: o,
        onDragStart: (a) => this.onResizeStart(a, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (a) => this.onResizeEnd(a, t)
      };
      (i || !this.isAlive() && !i) && (i ? ((r = this.dragSvc) == null || r.addDragSource(n), this.resizeListeners.push(n), o.style.pointerEvents = "all") : o.style.pointerEvents = "none", this.resizable[t] = i);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, s = this.element;
    let i = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      $i(s, e), e = Uc(s), i = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const o = this.getAvailableHeight();
      o && e > o && (e = o);
    }
    this.getHeight() !== e && (i ? (s.style.maxHeight = "unset", s.style.minHeight = "unset") : t ? $i(s, e) : (s.style.height = `${e}px`, s.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: s } = this.offsetParent;
    if (!s)
      return null;
    const i = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), n = e ? this.position.y : i.top, r = e ? 0 : o.top;
    let a = 0;
    if (t) {
      const d = this.element.parentElement;
      if (d) {
        const { bottom: c } = d.getBoundingClientRect();
        a = c - i.bottom;
      }
    }
    return s + r - n - a;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: s } = this.config;
    let i = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Et(t, e), e = dn(t), i = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: o } = this.offsetParent, n = s ? this.position.x : this.element.getBoundingClientRect().left;
      o && e + n > o && (e = o - n);
    }
    this.getWidth() !== e && (i ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? Et(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    var o;
    const { forcePopupParentAsOffsetParent: s } = this.config, i = s ? this.boundaryEl : this.element;
    i && ((o = this.popupSvc) == null || o.positionPopup({
      ePopup: i,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t })
    }), this.setPosition(parseFloat(i.style.left), parseFloat(i.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    var s;
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const i = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${i}px`);
    };
    e && this.popupSvc ? this.resizeObserverSubscriber = fs(
      this.beans,
      (s = this.popupSvc) == null ? void 0 : s.getPopupParent(),
      t
    ) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: s, isTop: i, anywhereWithin: o, topBuffer: n } = e, r = t.clientX - this.dragStartPosition.x, a = t.clientY - this.dragStartPosition.y, l = this.shouldSkipX(t, !!s, !!o, r) ? 0 : r, d = this.shouldSkipY(t, !!i, n, a) ? 0 : a;
    return { movementX: l, movementY: d };
  }
  shouldSkipX(e, t, s, i) {
    const o = this.element.getBoundingClientRect(), n = this.offsetParent.getBoundingClientRect(), r = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.x : o.left;
    let l = a <= 0 && n.left >= e.clientX || n.right <= e.clientX && n.right <= r.right;
    return l ? !0 : (t ? l = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    i < 0 && e.clientX > a + n.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    i > 0 && e.clientX < a + n.left : s ? l = i < 0 && e.clientX > r.right || i > 0 && e.clientX < a + n.left : l = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    i < 0 && e.clientX > r.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    i > 0 && e.clientX < r.right, l);
  }
  shouldSkipY(e, t, s = 0, i) {
    const o = this.element.getBoundingClientRect(), n = this.offsetParent.getBoundingClientRect(), r = this.boundaryEl.getBoundingClientRect(), a = this.config.popup ? this.position.y : o.top;
    let l = a <= 0 && n.top >= e.clientY || n.bottom <= e.clientY && n.bottom <= r.bottom;
    return l ? !0 : (t ? l = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    i < 0 && e.clientY > a + n.top + s || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    i > 0 && e.clientY < a + n.top : l = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    i < 0 && e.clientY > r.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    i > 0 && e.clientY < r.bottom, l);
  }
  createResizeMap() {
    const e = (t) => ({
      element: this.element.querySelector(`[data-ref=${t}Resizer]`)
    });
    this.resizerMap = {
      topLeft: e("eTopLeft"),
      top: e("eTop"),
      topRight: e("eTopRight"),
      right: e("eRight"),
      bottomRight: e("eBottomRight"),
      bottom: e("eBottom"),
      bottomLeft: e("eBottomLeft"),
      left: e("eLeft")
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    e && (e.appendChild(_(Tv)), this.createResizeMap(), this.resizersAdded = !0);
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${ih}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: s, forcePopupParentAsOffsetParent: i } = this.config;
    !s && !i && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((s) => !s.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, s = 0;
    for (let i = 0; i < e.length; i++) {
      const o = e[i], n = !!o.style.flex && o.style.flex !== "0 0 auto";
      if (o === this.element)
        continue;
      let r = this.minHeight || 0, a = this.minWidth || 0;
      if (n) {
        const l = window.getComputedStyle(o);
        l.minHeight && (r = parseInt(l.minHeight, 10)), l.minWidth && (a = parseInt(l.minWidth, 10));
      } else
        r = o.offsetHeight, a = o.offsetWidth;
      t += r, s += a;
    }
    return { height: t, width: s };
  }
  applySizeToSiblings(e) {
    let t = null;
    const s = this.getSiblings();
    if (s) {
      for (let i = 0; i < s.length; i++) {
        const o = s[i];
        o !== t && (e ? o.style.height = `${o.offsetHeight}px` : o.style.width = `${o.offsetWidth}px`, o.style.flex = "0 0 auto", o === this.element && (t = s[i + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: s } = this.config, { isTop: i, isRight: o, isBottom: n, isLeft: r } = this.currentResizer, a = o || r, l = n || i, { movementX: d, movementY: c } = this.calculateMouseMovement({ e, isLeft: r, isTop: i }), u = this.position.x, h = this.position.y;
    let g = 0, p = 0;
    if (a && d) {
      const f = r ? -1 : 1, m = this.getWidth(), b = m + d * f;
      let w = !1;
      r && (g = m - b, (u + g <= 0 || b <= this.minWidth) && (w = !0, g = 0)), w || this.setWidth(b);
    }
    if (l && c) {
      const f = i ? -1 : 1, m = this.getHeight(), b = m + c * f;
      let w = !1;
      i ? (p = m - b, (h + p <= 0 || b <= this.minHeight) && (w = !0, p = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && m < b && this.getMinSizeOfSiblings().height + b > this.element.parentElement.offsetHeight && (w = !0), w || this.setHeight(b);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || s) && g || p) && this.offsetElement(u + g, h + p);
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null, this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: s } = this.position;
    let i;
    this.config.calculateTopBuffer && (i = this.config.calculateTopBuffer());
    const { movementX: o, movementY: n } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: i
    });
    this.offsetElement(t + o, s + n), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent && this.popupSvc ? this.offsetParent = this.popupSvc.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    var e;
    for (; this.resizeListeners.length; ) {
      const t = this.resizeListeners.pop();
      (e = this.dragSvc) == null || e.removeDragSource(t);
    }
  }
  destroy() {
    var e;
    super.destroy(), this.moveElementDragListener && ((e = this.dragSvc) == null || e.removeDragSource(this.moveElementDragListener)), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
}, oh = "ag-focus-managed", ms = class extends S {
  constructor(e, t = {}) {
    super(), this.eFocusable = e, this.callbacks = t, this.callbacks = {
      shouldStopEventPropagation: () => !1,
      onTabKeyDown: (s) => {
        if (s.defaultPrevented)
          return;
        const i = Be(this.beans, this.eFocusable, !1, s.shiftKey);
        i && (i.focus(), s.preventDefault());
      },
      ...t
    };
  }
  postConstruct() {
    const {
      eFocusable: e,
      callbacks: { onFocusIn: t, onFocusOut: s }
    } = this;
    e.classList.add(oh), this.addKeyDownListeners(e), t && this.addManagedElementListeners(e, { focusin: t }), s && this.addManagedElementListeners(e, { focusout: s });
  }
  addKeyDownListeners(e) {
    this.addManagedElementListeners(e, {
      keydown: (t) => {
        if (t.defaultPrevented || gt(t))
          return;
        const { callbacks: s } = this;
        if (s.shouldStopEventPropagation(t)) {
          vt(t);
          return;
        }
        t.key === y.TAB ? s.onTabKeyDown(t) : s.handleKeyDown && s.handleKeyDown(t);
      }
    });
  }
}, nh = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
function rh(e, t) {
  const { debounceMs: s } = e;
  return Fn(e) ? (s != null && P(71), 0) : s ?? t;
}
function Fn(e) {
  var t;
  return (((t = e.buttons) == null ? void 0 : t.indexOf("apply")) ?? -1) >= 0;
}
var Ka = class extends L {
  constructor(e) {
    super(), this.filterNameKey = e, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null, this.eFilterBody = x, this.buttonListeners = [], this.defaultDebounceMs = 0;
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(
      new ms(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), this.positionableFeature = new Un(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: !0
    }), this.createBean(this.positionableFeature);
  }
  // override
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(e) {
    let t = this.getGui();
    t == null || t.removeEventListener("submit", this.onFormSubmit);
    const s = {
      tag: "form",
      cls: "ag-filter-wrapper",
      children: [
        {
          tag: "div",
          ref: "eFilterBody",
          cls: `ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper`,
          children: [this.createBodyTemplate()]
        }
      ]
    };
    this.setTemplate(s, this.getAgComponents(), e), t = this.getGui(), t == null || t.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.params.readOnly;
  }
  init(e) {
    this.setParams(e), this.resetUiToDefaults(!0).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(e) {
    this.params = e, this.applyActive = Fn(e), this.resetButtonsPanel(e);
  }
  updateParams(e) {
    this.params = e, this.applyActive = Fn(e), this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel(e, t) {
    const { buttons: s, readOnly: i } = t ?? {}, { buttons: o, readOnly: n } = e;
    if (i === n && Ta(s, o))
      return;
    const r = o && o.length > 0 && !this.isReadOnly();
    if (this.eButtonsPanel ? (de(this.eButtonsPanel), this.buttonListeners.forEach((d) => d()), this.buttonListeners = []) : r && (this.eButtonsPanel = _({ tag: "div", cls: "ag-filter-apply-panel" })), !r) {
      this.eButtonsPanel && De(this.eButtonsPanel);
      return;
    }
    const a = document.createDocumentFragment(), l = (d) => {
      let c;
      const u = d ? this.translate(`${d}Filter`) : void 0;
      switch (d) {
        case "apply":
          c = (p) => this.onBtApply(!1, !1, p);
          break;
        case "clear":
          c = () => this.onBtClear();
          break;
        case "reset":
          c = () => this.onBtReset();
          break;
        case "cancel":
          c = (p) => {
            this.onBtCancel(p);
          };
          break;
        default:
          P(75);
          return;
      }
      const g = _({
        tag: "button",
        attrs: { type: d === "apply" ? "submit" : "button" },
        ref: `${d}FilterButton`,
        cls: "ag-button ag-standard-button ag-filter-apply-panel-button",
        children: u
      });
      this.buttonListeners.push(...this.addManagedElementListeners(g, { click: c })), a.append(g);
    };
    o.forEach((d) => l(d)), this.eButtonsPanel.append(a), this.getGui().appendChild(this.eButtonsPanel);
  }
  setupOnBtApplyDebounce() {
    const e = rh(this.params, this.defaultDebounceMs), t = ct(this, this.checkApplyDebounce.bind(this), e);
    this.onBtApplyDebounce = () => {
      this.debouncePending = !0, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ?? null;
  }
  setModel(e) {
    return (e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    this.params.closeOnApply && this.close(e);
  }
  resetUiToActiveModel(e, t) {
    const s = () => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    };
    e != null ? this.setModelIntoUi(e).then(s) : this.resetUiToDefaults().then(s);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyModel(e = "api") {
    const t = this.getModelFromUi();
    if (!this.isModelValid(t))
      return !1;
    const s = this.appliedModel;
    return this.appliedModel = t, !this.areModelsEqual(s, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isModelValid(e) {
    return !0;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(e = !1, t = !1, s) {
    s && s.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui") && this.params.filterChangedCallback({ afterFloatingFilter: e, afterDataChange: t, source: "columnFilter" });
    const { closeOnApply: i } = this.params;
    i && this.applyActive && !e && !t && this.close(s);
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup)
      return;
    const t = e, s = t && t.key;
    let i;
    (s === "Enter" || s === "Space") && (i = { keyboardEvent: t }), this.hidePopup(i), this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(e = !1, t) {
    if (this.updateUiVisibility(), this.params.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const s = this.isModelValid(this.getModelFromUi()), i = this.queryForHtmlElement('[data-ref="applyFilterButton"]');
      i && so(i, !s);
    }
    e && !t || t === "immediately" ? this.onBtApply(e) : (!this.applyActive && !t || t === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    const { positionableFeature: t, gos: s } = this;
    if (!t || e === "toolPanel")
      return;
    e === "floatingFilter" || e === "columnFilter" ? (t.restoreLastSize(), t.setResizable(
      s.get("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 }
    )) : (t.removeSizeFromEl(), t.setResizable(!1)), t.constrainSizeToAvailableHeight(!0);
  }
  afterGuiDetached() {
    var e;
    this.checkApplyDebounce(), (e = this.positionableFeature) == null || e.constrainSizeToAvailableHeight(!1);
  }
  refresh(e) {
    const t = this.params;
    return this.params = e, this.resetButtonsPanel(e, t), !0;
  }
  destroy() {
    const e = this.getGui();
    e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy();
  }
  translate(e) {
    return this.getLocaleTextFunc()(e, nh[e]);
  }
  getCellValue(e) {
    return this.params.getValue(e);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
};
function ah(e, t, s) {
  if (t == null)
    return null;
  let i = null;
  const { compName: o, jsComp: n, fwComp: r } = NC(e, t);
  return o ? i = {
    agSetColumnFilter: "agSetColumnFloatingFilter",
    agMultiColumnFilter: "agMultiColumnFloatingFilter",
    agGroupColumnFilter: "agGroupColumnFloatingFilter",
    agNumberColumnFilter: "agNumberColumnFloatingFilter",
    agDateColumnFilter: "agDateColumnFloatingFilter",
    agTextColumnFilter: "agTextColumnFloatingFilter"
  }[o] : n == null && r == null && t.filter === !0 && (i = s()), i;
}
var lt = {
  AUTO_HEIGHT: "ag-layout-auto-height",
  NORMAL: "ag-layout-normal",
  PRINT: "ag-layout-print"
}, qa = class extends S {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.gos.get("domLayout"), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, s = t.autoHeight ? lt.AUTO_HEIGHT : t.print ? lt.PRINT : lt.NORMAL;
    this.view.updateLayoutClasses(s, t);
  }
}, Zt = "Viewport", Kl = "fakeVScrollComp", ql = [
  "fakeHScrollComp",
  "centerHeader",
  "topCenter",
  "bottomCenter",
  "stickyTopCenter",
  "stickyBottomCenter"
], Yl = 100, ur = 150, Lv = class extends S {
  constructor(e) {
    super(), this.clearRetryListenerFncs = [], this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.lastIsHorizontalScrollShowing = !1, this.scrollTimer = 0, this.isVerticalPositionInvalidated = !0, this.isHorizontalPositionInvalidated = !0, this.eBodyViewport = e, this.resetLastHScrollDebounced = ct(
      this,
      () => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null,
      ur
    ), this.resetLastVScrollDebounced = ct(
      this,
      () => this.lastScrollSource[
        0
        /* Vertical */
      ] = null,
      ur
    );
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.animationFrameSvc = e.animationFrameSvc, this.visibleCols = e.visibleCols;
  }
  destroy() {
    super.destroy(), this.clearRetryListenerFncs = [], window.clearTimeout(this.scrollTimer);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl");
    const e = this.invalidateVerticalScroll.bind(this), t = this.invalidateHorizontalScroll.bind(this);
    this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      gridSizeChanged: e,
      // We only invalidate horizontal scrolling when the viewport switches
      // between scrollable and non-scrollable, avoiding unnecessary
      // invalidation on every gridSizeChanged event. If more properties
      // require invalidation, read/write DOM cycles may be needed.
      scrollGapChanged: t
    }), this.addManagedElementListeners(this.eBodyViewport, {
      scroll: e
    }), this.ctrlsSvc.whenReady(this, (s) => {
      this.centerRowsCtrl = s.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  invalidateHorizontalScroll() {
    this.isHorizontalPositionInvalidated = !0;
  }
  invalidateVerticalScroll() {
    this.isVerticalPositionInvalidated = !0;
  }
  addScrollListener() {
    this.addHorizontalScrollListeners(), this.addVerticalScrollListeners();
  }
  addHorizontalScrollListeners() {
    this.addManagedElementListeners(this.centerRowsCtrl.eViewport, {
      scroll: this.onHScroll.bind(this, Zt)
    });
    for (const e of ql) {
      const t = this.ctrlsSvc.get(e);
      this.registerScrollPartner(t, this.onHScroll.bind(this, e));
    }
  }
  addVerticalScrollListeners() {
    const e = this.ctrlsSvc.get("fakeVScrollComp"), t = this.gos.get("debounceVerticalScrollbar"), s = t ? ct(this, this.onVScroll.bind(this, Zt), Yl) : this.onVScroll.bind(this, Zt), i = t ? ct(this, this.onVScroll.bind(this, Kl), Yl) : this.onVScroll.bind(this, Kl);
    this.addManagedElementListeners(this.eBodyViewport, { scroll: s }), this.registerScrollPartner(e, i);
  }
  registerScrollPartner(e, t) {
    e.onScrollCallback(t);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    this.centerRowsCtrl != null && (e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft()), this.setScrollLeftForAllContainersExceptCurrent(Math.abs(e)));
  }
  setScrollLeftForAllContainersExceptCurrent(e) {
    for (const t of [...ql, Zt]) {
      if (this.lastScrollSource[
        1
        /* Horizontal */
      ] === t)
        continue;
      const s = this.getViewportForSource(t);
      un(s, e, this.enableRtl);
    }
  }
  getViewportForSource(e) {
    return e === Zt ? this.centerRowsCtrl.eViewport : this.ctrlsSvc.get(e).eViewport;
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (t === 0 ? this.lastScrollSource[0] = e : this.lastScrollSource[1] = e, !0) : this.lastScrollSource[t] === e;
  }
  onHScroll(e) {
    if (!this.isControllingScroll(
      e,
      1
      /* Horizontal */
    ))
      return;
    const t = this.centerRowsCtrl.eViewport, { scrollLeft: s } = t;
    if (this.shouldBlockScrollUpdate(1, s, !0))
      return;
    const i = cn(this.getViewportForSource(e), this.enableRtl);
    this.doHorizontalScroll(i), this.resetLastHScrollDebounced();
  }
  onVScroll(e) {
    if (!this.isControllingScroll(
      e,
      0
      /* Vertical */
    ))
      return;
    let t;
    if (e === Zt ? t = this.eBodyViewport.scrollTop : t = this.ctrlsSvc.get("fakeVScrollComp").getScrollPosition(), this.shouldBlockScrollUpdate(0, t, !0))
      return;
    const { animationFrameSvc: s } = this;
    s == null || s.setScrollTop(t), this.nextScrollTop = t, e === Zt ? this.ctrlsSvc.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, s != null && s.active ? s.schedule() : this.scrollGridIfNeeded(!0), this.resetLastVScrollDebounced();
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsSvc.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(
      1
      /* Horizontal */
    ), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0));
  }
  fireScrollEvent(e) {
    const t = {
      type: "bodyScroll",
      direction: e === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventSvc.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = window.setTimeout(() => {
      this.scrollTimer = 0, this.eventSvc.dispatchEvent({
        ...t,
        type: "bodyScrollEnd"
      });
    }, ur);
  }
  shouldBlockScrollUpdate(e, t, s = !1) {
    return s && !As() ? !1 : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = Gn(this.eBodyViewport), { scrollHeight: s } = this.eBodyViewport;
    return e < 0 || e + t > s;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: s } = this.centerRowsCtrl.eViewport;
    if (this.enableRtl) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > s;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScroll(Zt);
  }
  scrollGridIfNeeded(e = !1) {
    const t = this.scrollTop != this.nextScrollTop;
    return t && (this.scrollTop = this.nextScrollTop, e && this.invalidateVerticalScroll(), this.redrawRowsAfterScroll()), t;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const i = this.centerRowsCtrl.eViewport.scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl ? e = e > 0 ? 0 : i : e = Math.min(Math.max(e, 0), i)), un(this.centerRowsCtrl.eViewport, Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.invalidateVerticalScroll(), this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    if (!this.isVerticalPositionInvalidated) {
      const { lastOffsetHeight: s, lastScrollTop: i } = this;
      return {
        top: i,
        bottom: i + s
      };
    }
    this.isVerticalPositionInvalidated = !1;
    const { scrollTop: e, offsetHeight: t } = this.eBodyViewport;
    return this.lastScrollTop = e, this.lastOffsetHeight = t, {
      top: e,
      bottom: e + t
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
      top: this.scrollTop,
      bottom: this.scrollTop + this.lastOffsetHeight
    } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.isHorizontalPositionInvalidated && (this.lastIsHorizontalScrollShowing = this.centerRowsCtrl.isHorizontalScrollShowing(), this.isHorizontalPositionInvalidated = !1), this.lastIsHorizontalScrollShowing;
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.eViewport.scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.eViewport.scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const { rowModel: s } = this.beans, i = s.getRowCount();
    let o = -1;
    for (let n = 0; n < i; n++) {
      const r = s.getRow(n);
      if (typeof e == "function") {
        if (r && e(r)) {
          o = n;
          break;
        }
      } else if (e === r || e === r.data) {
        o = n;
        break;
      }
    }
    o >= 0 && this.ensureIndexVisible(o, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t, s = 0) {
    if (xe(this.gos, "print"))
      return;
    const { rowModel: i } = this.beans, o = i.getRowCount();
    if (typeof e != "number" || e < 0 || e >= o) {
      P(88, { index: e });
      return;
    }
    this.clearRetryListeners();
    const { frameworkOverrides: n, pageBounds: r, rowContainerHeight: a, rowRenderer: l } = this.beans;
    n.wrapIncoming(() => {
      var p, f;
      const d = this.ctrlsSvc.getGridBodyCtrl(), c = i.getRow(e);
      let u, h, g = 0;
      this.invalidateVerticalScroll();
      do {
        const { stickyTopHeight: m, stickyBottomHeight: b } = d, w = c.rowTop, C = c.rowHeight, v = r.getPixelOffset(), F = c.rowTop - v, R = F + c.rowHeight, D = this.getVScrollPosition(), M = a.divStretchOffset, I = D.top + M, J = D.bottom + M, W = J - I, E = a.getScrollPositionForPixel(F), oe = a.getScrollPositionForPixel(R - W), j = Math.min((E + oe) / 2, F), Ce = I + m > F, z = J - b < R;
        let se = null;
        t === "top" ? se = E - m : t === "bottom" ? se = oe + b : t === "middle" ? se = j : Ce ? se = E - m : z && (se = oe + b), se !== null && (this.setVerticalScrollPosition(se), l.redraw({ afterScroll: !0 })), u = w !== c.rowTop || C !== c.rowHeight, h = m !== d.stickyTopHeight || b !== d.stickyBottomHeight, g++;
      } while ((u || h) && g < 10);
      if ((p = this.animationFrameSvc) == null || p.flushAllFrames(), s < 10 && (c != null && c.stub || !((f = this.beans.rowAutoHeight) != null && f.areRowsMeasured()))) {
        const m = this.getVScrollPosition().top;
        this.clearRetryListenerFncs = this.addManagedEventListeners({
          bodyScroll: () => {
            const b = this.getVScrollPosition().top;
            m !== b && this.clearRetryListeners();
          },
          modelUpdated: () => {
            this.clearRetryListeners(), !(e >= i.getRowCount()) && this.ensureIndexVisible(e, t, s + 1);
          }
        });
      }
    });
  }
  clearRetryListeners() {
    this.clearRetryListenerFncs.forEach((e) => e()), this.clearRetryListenerFncs = [];
  }
  ensureColumnVisible(e, t = "auto") {
    const { colModel: s, frameworkOverrides: i } = this.beans, o = s.getCol(e);
    if (!o || o.isPinned() || !this.visibleCols.isColDisplayed(o))
      return;
    const n = this.getPositionedHorizontalScroll(o, t);
    i.wrapIncoming(() => {
      var r;
      n !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(n), this.centerRowsCtrl.onHorizontalViewportChanged(), (r = this.animationFrameSvc) == null || r.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: s, columnAfterEnd: i } = this.isColumnOutsideViewport(e), o = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), n = this.centerRowsCtrl.getCenterWidth(), r = this.enableRtl;
    let a = (r ? s : i) || o, l = r ? i : s;
    t !== "auto" && (a = t === "start", l = t === "end");
    const d = t === "middle";
    if (a || l || d) {
      const { colLeft: c, colMiddle: u, colRight: h } = this.getColumnBounds(e);
      return d ? u - n / 2 : a ? r ? h : c : r ? c - n : h - n;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: s } = this.getViewportBounds(), { colLeft: i, colRight: o } = this.getColumnBounds(e), n = this.enableRtl, r = n ? t > o : s < o, a = n ? s < i : t > i;
    return { columnBeforeStart: r, columnAfterEnd: a };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, s = this.visibleCols.bodyWidth, i = e.getActualWidth(), o = e.getLeft(), n = t ? -1 : 1, r = t ? s - o : o, a = r + i * n, l = r + i / 2 * n;
    return { colLeft: r, colMiddle: l, colRight: a };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), s = t, i = e + t;
    return { start: s, end: i, width: e };
  }
}, Ya = class extends S {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedEventListeners({
      columnContainerWidthChanged: e,
      displayedColumnsChanged: e,
      leftPinnedWidthChanged: e
    }), this.addSpacer && this.addManagedEventListeners({
      rightPinnedWidthChanged: e,
      scrollVisibilityChanged: e,
      scrollbarWidthChanged: e
    }), this.setWidth();
  }
  setWidth() {
    const e = xe(this.gos, "print"), { visibleCols: t, scrollVisibleSvc: s } = this.beans, i = t.bodyWidth, o = t.getColsLeftWidth(), n = t.getDisplayedColumnsRightWidth();
    let r;
    e ? r = i + o + n : (r = i, this.addSpacer && (this.gos.get("enableRtl") ? o : n) === 0 && s.verticalScrollShowing && (r += s.getScrollbarWidth())), this.callback(r);
  }
}, kv = class extends S {
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  wireBeans(e) {
    this.scrollVisibleSvc = e.scrollVisibleSvc;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) }), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const { beans: e, centerContainerCtrl: t, gridBodyCtrl: s } = this, i = () => {
      Ct(e, () => {
        this.onCenterViewportResized();
      });
    };
    t.registerViewportResizeListener(i), s.registerBodyViewportResizeListener(i);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.scrollVisibleSvc.updateScrollGap(), this.centerContainerCtrl.isViewportInTheDOMTree()) {
      const { pinnedCols: e, colFlex: t } = this.beans;
      e == null || e.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const s = this.centerContainerCtrl.getCenterWidth();
      s !== this.centerWidth && (this.centerWidth = s, t == null || t.refreshFlexedColumns({
        viewportWidth: this.centerWidth,
        updateBodyWidths: !0,
        fireResizedEvent: !0
      }));
    } else
      this.bodyHeight = 0;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.scrollFeature.checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.eBodyViewport, t = Gn(e);
    this.bodyHeight !== t && (this.bodyHeight = t, this.eventSvc.dispatchEvent({
      type: "bodyHeightChanged"
    }));
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = {
      horizontalScrollShowing: this.centerContainerCtrl.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleSvc.setScrollsVisible(e);
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(e, t);
  }
};
function Zl(e) {
  if (e.group)
    return e.level;
  const t = e.parent;
  return t ? t.level + 1 : 0;
}
var Gv = 0, Pn = "renderedRow", ea = class extends S {
  constructor(e, t, s, i, o) {
    var n;
    super(), this.rowNode = e, this.useAnimationFrameForCreate = i, this.printLayout = o, this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKey = null, this.beans = t, this.gos = t.gos, this.paginationPage = ((n = t.pagination) == null ? void 0 : n.getCurrentPage()) ?? 0, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = e.id + "-" + Gv++, this.rowId = Ko(e.id), this.initRowBusinessKey(), this.rowFocused = t.focusSvc.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = Zl(this.rowNode), this.setRowType(), this.setAnimateFlags(s), this.rowStyles = this.processStylesFromGridOptions(), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const e = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKey = Ko(e);
  }
  updateGui(e, t) {
    e === "left" ? this.leftGui = t : e === "right" ? this.rightGui = t : e === "fullWidth" ? this.fullWidthGui = t : this.centerGui = t;
  }
  setComp(e, t, s, i) {
    var u;
    const { context: o, focusSvc: n } = this.beans;
    i = So(this, o, i);
    const r = { rowComp: e, element: t, containerType: s, compBean: i };
    this.allRowGuis.push(r), this.updateGui(s, r), this.initialiseRowComp(r);
    const a = this.rowNode, l = this.rowType === "FullWidthLoading" || a.stub, d = !a.data && this.beans.rowModel.getType() === "infinite";
    !l && !d && !a.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
    const c = (u = this.fullWidthGui) == null ? void 0 : u.element;
    c && !this.editing && n.isRowFocused(a.rowIndex, a.rowPinned) && n.shouldTakeFocus() && setTimeout(() => c.focus({ preventScroll: !0 }), 0);
  }
  unsetComp(e) {
    this.allRowGuis = this.allRowGuis.filter((t) => t.containerType !== e), this.updateGui(e, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(e) {
    const t = e ? "none" : "";
    this.allRowGuis.forEach((s) => s.element.style.display = t);
  }
  initialiseRowComp(e) {
    const t = this.gos;
    this.onSuppressCellFocusChanged(this.beans.gos.get("suppressCellFocus")), this.listenOnDomOrder(e), this.onRowHeightChanged(e), this.updateRowIndexes(e), this.setFocusedClasses(e), this.setStylesFromGridOptions(!1, e), Dt(t) && this.rowNode.selectable && this.onRowSelected(e), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const s = e.rowComp;
    this.getInitialRowClasses(e.containerType).forEach((o) => s.toggleCss(o, !0)), this.executeSlideAndFadeAnimations(e), this.rowNode.group && ot(e.element, this.rowNode.expanded == !0), this.setRowCompRowId(s), this.setRowCompRowBusinessKey(s), bi(t, e.element, Pn, this), e.compBean.addDestroyFunc(() => bi(t, e.element, Pn, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameSvc.createTask(
      this.addHoverFunctionality.bind(this, e),
      this.rowNode.rowIndex,
      "p2",
      !1
    ) : this.addHoverFunctionality(e), this.isFullWidth() && this.setupFullWidth(e), t.get("rowDragEntireRow") && this.addRowDraggerToRow(e), this.useAnimationFrameForCreate && this.beans.animationFrameSvc.addDestroyTask(() => {
      this.isAlive() && e.rowComp.toggleCss("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(e) {
    this.businessKey != null && e.setRowBusinessKey(this.businessKey);
  }
  setRowCompRowId(e) {
    const t = Ko(this.rowNode.id);
    this.rowId = t, t != null && e.setRowId(t);
  }
  executeSlideAndFadeAnimations(e) {
    const { containerType: t } = e;
    this.slideInAnimation[t] && (Wr(() => {
      this.onTopChanged();
    }), this.slideInAnimation[t] = !1), this.fadeInAnimation[t] && (Wr(() => {
      e.rowComp.toggleCss("ag-opacity-zero", !1);
    }), this.fadeInAnimation[t] = !1);
  }
  addRowDraggerToRow(e) {
    var i;
    const t = (i = this.beans.rowDragSvc) == null ? void 0 : i.createRowDragCompForRow(this.rowNode, e.element);
    if (!t)
      return;
    const s = this.createBean(t, this.beans.context);
    this.rowDragComps.push(s), e.compBean.addDestroyFunc(() => {
      this.rowDragComps = this.rowDragComps.filter((o) => o !== s), this.destroyBean(s, this.beans.context);
    });
  }
  setupFullWidth(e) {
    const t = this.getPinnedForContainer(e.containerType), s = this.createFullWidthCompDetails(e.element, t);
    e.rowComp.showFullWidth(s);
  }
  getFullWidthCellRenderers() {
    var e, t;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((s) => {
      var i;
      return (i = s == null ? void 0 : s.rowComp) == null ? void 0 : i.getFullWidthCellRenderer();
    }) : [(t = (e = this.fullWidthGui) == null ? void 0 : e.rowComp) == null ? void 0 : t.getFullWidthCellRenderer()];
  }
  executeProcessRowPostCreateFunc() {
    const e = this.gos.getCallback("processRowPostCreate");
    if (!e || !this.areAllContainersReady())
      return;
    const t = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    e(t);
  }
  areAllContainersReady() {
    const {
      leftGui: e,
      centerGui: t,
      rightGui: s,
      beans: { visibleCols: i }
    } = this, o = !!e || !i.isPinningLeft(), n = !!t, r = !!s || !i.isPinningRight();
    return o && n && r;
  }
  isNodeFullWidthCell() {
    if (this.rowNode.detail)
      return !0;
    const e = this.beans.gos.getCallback("isFullWidthRow");
    return e ? e({ rowNode: this.rowNode }) : !1;
  }
  setRowType() {
    const e = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow") && !this.gos.get("groupHideOpenParents"), t = this.isNodeFullWidthCell(), s = this.gos.get("masterDetail") && this.rowNode.detail, i = this.beans.colModel.isPivotMode(), o = Em(this.gos, this.rowNode, i);
    e ? this.rowType = "FullWidthLoading" : s ? this.rowType = "FullWidthDetail" : t ? this.rowType = "FullWidth" : o ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(e = !1, t = !1) {
    if (this.isFullWidth())
      return;
    const { animationFrameSvc: s } = this.beans;
    if (!(s != null && s.active) || e || this.printLayout) {
      this.updateColumnListsImpl(t);
      return;
    }
    this.updateColumnListsPending || (s.createTask(
      () => {
        this.active && this.updateColumnListsImpl(!0);
      },
      this.rowNode.rowIndex,
      "p1",
      !1
    ), this.updateColumnListsPending = !0);
  }
  /**
   * Overridden by SpannedRowCtrl
   */
  getNewCellCtrl(e) {
    var s;
    if (!((s = this.beans.rowSpanSvc) != null && s.isCellSpanning(e, this.rowNode)))
      return new Yo(e, this.rowNode, this.beans, this);
  }
  /**
   * Overridden by SpannedRowCtrl, if span context changes cell needs rebuilt
   */
  isCorrectCtrlForSpan(e) {
    var t;
    return !((t = this.beans.rowSpanSvc) != null && t.isCellSpanning(e.column, this.rowNode));
  }
  createCellCtrls(e, t, s = null) {
    const i = {
      list: [],
      map: {}
    }, o = (d, c, u) => {
      u != null ? i.list.splice(u, 0, c) : i.list.push(c), i.map[d] = c;
    }, n = [];
    for (const d of t) {
      const c = d.getInstanceId();
      let u = e.map[c];
      u && !this.isCorrectCtrlForSpan(u) && (u.destroy(), u = void 0), u || (u = this.getNewCellCtrl(d)), u && o(c, u);
    }
    for (const d of e.list) {
      const c = d.column.getInstanceId();
      if (i.map[c] != null)
        continue;
      !this.isCellEligibleToBeRemoved(d, s) ? n.push([c, d]) : d.destroy();
    }
    if (n.length)
      for (const [d, c] of n) {
        const u = i.list.findIndex((g) => g.column.getLeft() > c.column.getLeft()), h = u === -1 ? void 0 : Math.max(u - 1, 0);
        o(d, c, h);
      }
    const { focusSvc: r, visibleCols: a } = this.beans, l = r.getFocusedCell();
    if (l && l.column.getPinned() == s) {
      const d = l.column.getInstanceId();
      if (!i.map[d] && a.allCols.includes(l.column)) {
        const u = this.createFocusedCellCtrl();
        if (u) {
          const h = i.list.findIndex((p) => p.column.getLeft() > u.column.getLeft()), g = h === -1 ? void 0 : Math.max(h - 1, 0);
          o(d, u, g);
        }
      }
    }
    return i;
  }
  /**
   * Creates a new cell ctrl for the focused cell, if this is the correct row ctrl.
   * @returns a CellCtrl for the focused cell, if required.
   */
  createFocusedCellCtrl() {
    const { focusSvc: e, rowSpanSvc: t } = this.beans, s = e.getFocusedCell();
    if (!s)
      return;
    const i = t == null ? void 0 : t.getCellSpan(s.column, this.rowNode);
    if (i) {
      if (i.firstNode !== this.rowNode || !i.doesSpanContain(s))
        return;
    } else if (!e.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned))
      return;
    return this.getNewCellCtrl(s.column);
  }
  updateColumnListsImpl(e) {
    this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(e);
  }
  setCellCtrls(e) {
    this.allRowGuis.forEach((t) => {
      const s = this.getCellCtrlsForContainer(t.containerType);
      t.rowComp.setCellCtrls(s, e);
    });
  }
  getCellCtrlsForContainer(e) {
    switch (e) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const e = this.beans.colViewport, t = this.beans.visibleCols;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, t.allCols), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const s = e.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, s);
      const i = t.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, i, "left");
      const o = t.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, o, "right");
    }
  }
  isCellEligibleToBeRemoved(e, t) {
    const { column: o } = e;
    if (o.getPinned() != t || !this.isCorrectCtrlForSpan(e))
      return !0;
    const { editing: n } = e, { visibleCols: r } = this.beans, a = e.isCellFocused();
    return n || a ? !(r.allCols.indexOf(o) >= 0) : !0;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || xe(this.gos, "print");
  }
  listenOnDomOrder(e) {
    const t = () => {
      e.rowComp.setDomOrder(this.getDomOrder());
    };
    e.compBean.addManagedPropertyListeners(["domLayout", "ensureDomOrder"], t);
  }
  setAnimateFlags(e) {
    if (this.rowNode.sticky || !e)
      return;
    const t = T(this.rowNode.oldRowTop), { visibleCols: s } = this.beans, i = s.isPinningLeft(), o = s.isPinningRight();
    if (t) {
      const { slideInAnimation: n } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        n.fullWidth = !0;
        return;
      }
      n.center = !0, n.left = i, n.right = o;
    } else {
      const { fadeInAnimation: n } = this;
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        n.fullWidth = !0;
        return;
      }
      n.center = !0, n.left = i, n.right = o;
    }
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const e = (r, a) => r ? r.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(r.element, a).params) : !0, t = e(this.fullWidthGui, null), s = e(this.centerGui, null), i = e(this.leftGui, "left"), o = e(this.rightGui, "right");
    return t && s && i && o;
  }
  addListeners() {
    var e;
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      ...((e = this.beans.expansionSvc) == null ? void 0 : e.getRowExpandedListeners(this)) ?? {}
    }), this.rowNode.detail && this.addManagedListeners(this.rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) }), this.addManagedListeners(this.rowNode, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this),
      rowPinned: this.onRowPinned.bind(this)
    }), this.addManagedListeners(this.beans.eventSvc, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    }), this.beans.rowSpanSvc && this.addManagedListeners(this.beans.rowSpanSvc, {
      spannedCellsUpdated: ({ pinned: t }) => {
        t && !this.rowNode.rowPinned || this.updateColumnLists();
      }
    }), this.addDestroyFunc(() => {
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context);
    }), this.addManagedPropertyListeners(
      ["rowStyle", "getRowStyle", "rowClass", "getRowClass", "rowClassRules"],
      this.postProcessCss.bind(this)
    ), this.addManagedPropertyListener("rowDragEntireRow", () => {
      if (this.gos.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((s) => {
          this.addRowDraggerToRow(s);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onRowIndexChanged());
      },
      cellChanged: (e) => {
        this.getAllCellCtrls().forEach((t) => t.onCellChanged(e));
      }
    });
  }
  /** Should only ever be triggered on source rows (i.e. not on pinned siblings) */
  onRowPinned() {
    for (const e of this.allRowGuis)
      e.rowComp.toggleCss("ag-row-pinned-source", !!this.rowNode.pinnedSibling);
  }
  onRowNodeDataChanged(e) {
    if (this.isFullWidth() !== !!this.isNodeFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach(
      (s) => s.refreshCell({
        suppressFlash: !e.update,
        newData: !e.update
      })
    ), this.allRowGuis.forEach((s) => {
      this.setRowCompRowId(s.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(s.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const e = this.rowNode.highlighted;
    this.allRowGuis.forEach((t) => {
      const s = e === "Above", i = e === "Below";
      t.rowComp.toggleCss("ag-row-highlight-above", s), t.rowComp.toggleCss("ag-row-highlight-below", i);
    });
  }
  postProcessRowDragging() {
    const e = this.rowNode.dragging;
    this.allRowGuis.forEach((t) => t.rowComp.toggleCss("ag-row-dragging", e));
  }
  onDisplayedColumnsChanged() {
    var e;
    this.updateColumnLists(!0), (e = this.beans.rowAutoHeight) == null || e.requestCheckAutoHeight();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: ls(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(e) {
    const t = this.findFullWidthInfoForEvent(e);
    if (!t)
      return;
    const { rowGui: s, column: i } = t;
    if (!(s.element === e.target))
      return;
    const r = this.rowNode, { focusSvc: a, navigation: l } = this.beans, d = a.getFocusedCell(), c = {
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      column: (d == null ? void 0 : d.column) ?? i
    };
    l == null || l.navigateToNextCell(e, e.key, c, !0), e.preventDefault();
  }
  onTabKeyDown(e) {
    var a;
    if (e.defaultPrevented || gt(e))
      return;
    const t = this.allRowGuis.find(
      (l) => l.element.contains(e.target)
    ), s = t ? t.element : null, i = s === e.target, o = te(this.beans);
    let n = !1;
    s && o && (n = s.contains(o) && o.classList.contains("ag-cell"));
    let r = null;
    !i && !n && (r = Be(this.beans, s, !1, e.shiftKey)), (this.isFullWidth() && i || !r) && ((a = this.beans.navigation) == null || a.onTabKeyDown(this, e));
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var t;
    const e = (t = this.allRowGuis.find((s) => He(s.element))) == null ? void 0 : t.element;
    return e ? e.getBoundingClientRect().top : 0;
  }
  onSuppressCellFocusChanged(e) {
    const t = this.isFullWidth() && e ? void 0 : -1;
    this.allRowGuis.forEach((s) => {
      ai(s.element, "tabindex", t);
    });
  }
  onFullWidthRowFocused(e) {
    var o, n, r;
    const t = this.rowNode, s = e ? this.isFullWidth() && e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned : !1;
    let i;
    if (this.fullWidthGui)
      i = this.fullWidthGui.element;
    else {
      const a = this.beans.colModel.getCol(e == null ? void 0 : e.column), l = a == null ? void 0 : a.pinned;
      l ? i = l === "right" ? (o = this.rightGui) == null ? void 0 : o.element : (n = this.leftGui) == null ? void 0 : n.element : i = (r = this.centerGui) == null ? void 0 : r.element;
    }
    i && (i.classList.toggle("ag-full-width-focus", s), s && (e != null && e.forceBrowserFocus) && i.focus({ preventScroll: !0 }));
  }
  recreateCell(e) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, e), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, e), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, e), e.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(e, t) {
    const s = {
      list: [],
      map: {}
    };
    return e.list.forEach((i) => {
      i !== t && (s.list.push(i), s.map[i.column.getInstanceId()] = i);
    }), s;
  }
  onMouseEvent(e, t) {
    switch (e) {
      case "dblclick":
        this.onRowDblClick(t);
        break;
      case "click":
        this.onRowClick(t);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(t);
        break;
    }
  }
  createRowEvent(e, t) {
    const { rowNode: s } = this;
    return N(this.gos, {
      type: e,
      node: s,
      data: s.data,
      rowIndex: s.rowIndex,
      rowPinned: s.rowPinned,
      event: t
    });
  }
  createRowEventWithSource(e, t) {
    const s = this.createRowEvent(e, t);
    return s.source = this, s;
  }
  onRowDblClick(e) {
    gt(e) || this.beans.eventSvc.dispatchEvent(this.createRowEventWithSource("rowDoubleClicked", e));
  }
  findFullWidthInfoForEvent(e) {
    if (!e)
      return;
    const t = this.findFullWidthRowGui(e.target), s = this.getColumnForFullWidth(t);
    if (!(!t || !s))
      return { rowGui: t, column: s };
  }
  findFullWidthRowGui(e) {
    return this.allRowGuis.find((t) => t.element.contains(e));
  }
  getColumnForFullWidth(e) {
    const { visibleCols: t } = this.beans;
    switch (e == null ? void 0 : e.containerType) {
      case "center":
        return t.centerCols[0];
      case "left":
        return t.leftCols[0];
      case "right":
        return t.rightCols[0];
      default:
        return t.allCols[0];
    }
  }
  onRowMouseDown(e) {
    if (this.lastMouseDownOnDragger = Is(e.target, "ag-row-drag", 3), !this.isFullWidth())
      return;
    const t = this.rowNode, { rangeSvc: s, focusSvc: i } = this.beans;
    s == null || s.removeAllCellRanges();
    const o = this.findFullWidthInfoForEvent(e);
    if (!o)
      return;
    const { rowGui: n, column: r } = o, a = n.element, l = e.target;
    let d = e.defaultPrevented || kn();
    a && a.contains(l) && Ea(l) && (d = !1), i.setFocusedCell({
      rowIndex: t.rowIndex,
      column: r,
      rowPinned: t.rowPinned,
      forceBrowserFocus: d
    });
  }
  onRowClick(e) {
    if (gt(e) || this.lastMouseDownOnDragger)
      return;
    const { eventSvc: s, selectionSvc: i } = this.beans;
    s.dispatchEvent(this.createRowEventWithSource("rowClicked", e)), i == null || i.handleSelectionEvent(e, this.rowNode, "rowClicked");
  }
  setupDetailRowAutoHeight(e) {
    var t;
    this.rowType === "FullWidthDetail" && ((t = this.beans.masterDetailSvc) == null || t.setupDetailRowAutoHeight(this, e));
  }
  createFullWidthCompDetails(e, t) {
    const { gos: s, rowNode: i } = this, o = N(s, {
      fullWidth: !0,
      data: i.data,
      node: i,
      value: i.key,
      valueFormatted: i.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: e,
      eParentOfValue: e,
      pinned: t,
      addRenderedRowListener: this.addEventListener.bind(this),
      // This is not on the type of ICellRendererParams
      registerRowDragger: (r, a, l, d) => this.addFullWidthRowDragging(r, a, l, d),
      setTooltip: (r, a) => {
        s.assertModuleRegistered("Tooltip", 3), this.refreshRowTooltip(r, a);
      }
    }), n = this.beans.userCompFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return kC(n, o);
      case "FullWidthGroup": {
        const { value: r, valueFormatted: a } = this.beans.valueSvc.getValueForDisplay(void 0, this.rowNode, !0);
        return o.value = r, o.valueFormatted = a, LC(n, o);
      }
      case "FullWidthLoading":
        return TC(n, o);
      default:
        return IC(n, o);
    }
  }
  refreshRowTooltip(e, t) {
    var s;
    this.fullWidthGui && (this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.refreshRowTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    ));
  }
  addFullWidthRowDragging(e, t, s = "", i) {
    const { rowDragSvc: o, context: n } = this.beans;
    if (!o || !this.isFullWidth())
      return;
    const r = o.createRowDragComp(
      () => s,
      this.rowNode,
      void 0,
      e,
      t,
      i
    );
    this.createBean(r, n), this.addDestroyFunc(() => {
      this.destroyBean(r, n);
    });
  }
  onUiLevelChanged() {
    const e = Zl(this.rowNode);
    if (this.rowLevel != e) {
      const t = "ag-row-level-" + e, s = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((i) => {
        i.rowComp.toggleCss(t, !0), i.rowComp.toggleCss(s, !1);
      });
    }
    this.rowLevel = e;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBounds.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const e = this.isFirstRowOnPage(), t = this.isLastRowOnPage();
    this.firstRowOnPage !== e && (this.firstRowOnPage = e, this.allRowGuis.forEach((s) => s.rowComp.toggleCss("ag-row-first", e))), this.lastRowOnPage !== t && (this.lastRowOnPage = t, this.allRowGuis.forEach((s) => s.rowComp.toggleCss("ag-row-last", t)));
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    var t;
    const e = [];
    (t = this.beans.rowStyleSvc) == null || t.processClassesFromGridOptions(e, this.rowNode), e.length && e.forEach((s) => {
      this.allRowGuis.forEach((i) => i.rowComp.toggleCss(s, !0));
    });
  }
  postProcessRowClassRules() {
    var e;
    (e = this.beans.rowStyleSvc) == null || e.processRowClassRules(
      this.rowNode,
      (t) => {
        this.allRowGuis.forEach((s) => s.rowComp.toggleCss(t, !0));
      },
      (t) => {
        this.allRowGuis.forEach((s) => s.rowComp.toggleCss(t, !1));
      }
    );
  }
  setStylesFromGridOptions(e, t) {
    e && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(t, (s) => s.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(e) {
    return e === "left" || e === "right" ? e : null;
  }
  getInitialRowClasses(e) {
    var a, l;
    const t = this.getPinnedForContainer(e), s = this.isFullWidth(), { rowNode: i, beans: o } = this, n = [];
    n.push("ag-row"), n.push(this.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), this.fadeInAnimation[e] && n.push("ag-opacity-zero"), n.push(i.rowIndex % 2 === 0 ? "ag-row-even" : "ag-row-odd"), i.isRowPinned() && (n.push("ag-row-pinned"), (a = o.pinnedRowModel) != null && a.isManual() && n.push("ag-row-pinned-manual")), !i.isRowPinned() && i.pinnedSibling && n.push("ag-row-pinned-source"), i.isSelected() && n.push("ag-row-selected"), i.footer && n.push("ag-row-footer"), n.push("ag-row-level-" + this.rowLevel), i.stub && n.push("ag-row-loading"), s && n.push("ag-full-width-row"), (l = o.expansionSvc) == null || l.addExpandedCss(n, i), i.dragging && n.push("ag-row-dragging");
    const { rowStyleSvc: r } = o;
    return r && (r.processClassesFromGridOptions(n, i), r.preProcessRowClassRules(n, i)), n.push(this.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), this.isFirstRowOnPage() && n.push("ag-row-first"), this.isLastRowOnPage() && n.push("ag-row-last"), s && (t === "left" && n.push("ag-cell-last-left-pinned"), t === "right" && n.push("ag-cell-first-right-pinned")), n;
  }
  processStylesFromGridOptions() {
    var e;
    return ((e = this.beans.rowStyleSvc) == null ? void 0 : e.processStylesFromGridOptions(this.rowNode)) ?? this.emptyStyle;
  }
  onRowSelected(e) {
    var t;
    (t = this.beans.selectionSvc) == null || t.onRowCtrlSelected(
      this,
      (s) => {
        (s === this.centerGui || s === this.fullWidthGui) && this.announceDescription();
      },
      e
    );
  }
  announceDescription() {
    var e;
    (e = this.beans.selectionSvc) == null || e.announceAriaRowSelection(this.rowNode);
  }
  addHoverFunctionality(e) {
    if (!this.active)
      return;
    const { element: t, compBean: s } = e, { rowNode: i, beans: o, gos: n } = this;
    s.addManagedListeners(t, {
      mouseenter: () => i.dispatchRowEvent("mouseEnter"),
      mouseleave: () => i.dispatchRowEvent("mouseLeave")
    }), s.addManagedListeners(i, {
      mouseEnter: () => {
        var r;
        !((r = o.dragSvc) != null && r.dragging) && !n.get("suppressRowHoverHighlight") && (t.classList.add("ag-row-hover"), i.setHovered(!0));
      },
      mouseLeave: () => {
        this.resetHoveredStatus(t);
      }
    });
  }
  resetHoveredStatus(e) {
    const t = e ? [e] : this.allRowGuis.map((s) => s.element);
    for (const s of t)
      s.classList.remove("ag-row-hover");
    this.rowNode.setHovered(!1);
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(e) {
    const t = this.beans.ctrlsSvc.getScrollFeature().getApproximateVScollPosition(), s = this.applyPaginationOffset(t.top, !0) - 100, i = this.applyPaginationOffset(t.bottom, !0) + 100;
    return Math.min(Math.max(s, e), i);
  }
  forEachGui(e, t) {
    e ? t(e) : this.allRowGuis.forEach(t);
  }
  isRowRendered() {
    return this.allRowGuis.length > 0;
  }
  onRowHeightChanged(e) {
    if (this.rowNode.rowHeight == null)
      return;
    const t = this.rowNode.rowHeight, s = this.beans.environment.getDefaultRowHeight(), o = ka(this.gos) ? Je(this.beans, this.rowNode).height : void 0, n = o ? `${Math.min(s, o) - 2}px` : void 0;
    this.forEachGui(e, (r) => {
      r.element.style.height = `${t}px`, n && r.element.style.setProperty("--ag-line-height", n);
    });
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(e = !1) {
    var i;
    this.active = !1;
    const { rowNode: t } = this;
    if (!e && ci(this.gos) && !t.sticky)
      if (t.rowTop != null) {
        const n = this.roundRowTopToBounds(t.rowTop);
        this.setRowTop(n);
      } else
        this.allRowGuis.forEach((n) => n.rowComp.toggleCss("ag-opacity-zero", !0));
    (i = this.fullWidthGui) != null && i.element.contains(te(this.beans)) && this.beans.focusSvc.attemptToRecoverFocus(), t.setHovered(!1);
    const s = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(s), this.beans.eventSvc.dispatchEvent(s), super.destroy();
  }
  destroySecondPass() {
    var t;
    this.allRowGuis.length = 0, (t = this.beans.editSvc) == null || t.stopRowEditing(this);
    const e = (s) => (s.list.forEach((i) => i.destroy()), { list: [], map: {} });
    this.centerCellCtrls = e(this.centerCellCtrls), this.leftCellCtrls = e(this.leftCellCtrls), this.rightCellCtrls = e(this.rightCellCtrls);
  }
  setFocusedClasses(e) {
    this.forEachGui(e, (t) => {
      t.rowComp.toggleCss("ag-row-focus", this.rowFocused), t.rowComp.toggleCss("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const { focusSvc: e, editSvc: t } = this.beans, s = e.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    s !== this.rowFocused && (this.rowFocused = s, this.setFocusedClasses()), !s && this.editing && (t == null || t.stopRowEditing(this, !1));
  }
  onPaginationChanged() {
    var t;
    const e = ((t = this.beans.pagination) == null ? void 0 : t.getCurrentPage()) ?? 0;
    this.paginationPage !== e && (this.paginationPage = e, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(e, t = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return e;
    const s = this.beans.pageBounds.getPixelOffset();
    return e + s * (t ? 1 : -1);
  }
  setRowTop(e) {
    if (!this.printLayout && T(e)) {
      const t = this.applyPaginationOffset(e), o = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? t : this.beans.rowContainerHeight.getRealPixelPosition(t)}px`;
      this.setRowTopStyle(o);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(e) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(e) : void 0;
  }
  getInitialTransform(e) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(e)})`;
  }
  getInitialRowTopShared(e) {
    if (this.printLayout)
      return "";
    const t = this.rowNode;
    let s;
    if (t.sticky)
      s = t.stickyRowTop;
    else {
      const i = this.slideInAnimation[e] ? this.roundRowTopToBounds(t.oldRowTop) : t.rowTop, o = this.applyPaginationOffset(i);
      s = t.isRowPinned() ? o : this.beans.rowContainerHeight.getRealPixelPosition(o);
    }
    return s + "px";
  }
  setRowTopStyle(e) {
    this.allRowGuis.forEach(
      (t) => this.suppressRowTransform ? t.rowComp.setTop(e) : t.rowComp.setTransform(`translateY(${e})`)
    );
  }
  getCellCtrl(e, t = !1) {
    let s = null;
    return this.getAllCellCtrls().forEach((i) => {
      i.column == e && (s = i);
    }), s != null || t || this.getAllCellCtrls().forEach((i) => {
      i.getColSpanningList().indexOf(e) >= 0 && (s = i);
    }), s;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  updateRowIndexes(e) {
    var n, r;
    const t = this.rowNode.getRowIndexString();
    if (t === null)
      return;
    const s = (((n = this.beans.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : n.getRowCount()) ?? 0) + (((r = this.beans.filterManager) == null ? void 0 : r.getHeaderRowCount()) ?? 0), i = this.rowNode.rowIndex % 2 === 0, o = s + this.rowNode.rowIndex + 1;
    this.forEachGui(e, (a) => {
      a.rowComp.setRowIndex(t), a.rowComp.toggleCss("ag-row-even", i), a.rowComp.toggleCss("ag-row-odd", !i), Oc(a.element, o);
    });
  }
};
function lh(e) {
  var s;
  return e.altKey || e.ctrlKey || e.metaKey ? !1 : ((s = e.key) == null ? void 0 : s.length) === 1;
}
function Ql(e, t, s, i, o) {
  const n = i ? i.getColDef().suppressKeyboardEvent : void 0;
  if (!n)
    return !1;
  const r = N(e, {
    event: t,
    editing: o,
    column: i,
    node: s,
    data: s.data,
    colDef: i.getColDef()
  });
  return !!(n && n(r));
}
function Ov(e) {
  const { pinnedRowModel: t, rowModel: s } = e, [i, o] = [
    (t == null ? void 0 : t.isEmpty("top")) ?? !0,
    (t == null ? void 0 : t.isEmpty("bottom")) ?? !0
  ], n = i ? null : "top";
  let r, a;
  o ? (r = null, a = s.getRowCount() - 1) : (r = "bottom", a = (t == null ? void 0 : t.getPinnedBottomRowCount()) ?? -1);
  const { visibleCols: l, rangeSvc: d } = e, c = l.allCols;
  !d || !(c != null && c.length) || d.setCellRange({
    rowStartIndex: 0,
    rowStartPinned: n,
    rowEndIndex: a,
    rowEndPinned: r
  });
}
var Bv = 65, Nv = 67, Hv = 86, Vv = 68, _v = 90, Wv = 89;
function zv(e) {
  const { keyCode: t } = e;
  let s;
  switch (t) {
    case Bv:
      s = y.A;
      break;
    case Nv:
      s = y.C;
      break;
    case Hv:
      s = y.V;
      break;
    case Vv:
      s = y.D;
      break;
    case _v:
      s = y.Z;
      break;
    case Wv:
      s = y.Y;
      break;
    default:
      s = e.code;
  }
  return s;
}
var Uv = class extends S {
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    var e;
    this.addKeyboardListeners(), this.addMouseListeners(), (e = this.beans.touchSvc) == null || e.mockRowContextMenu(this);
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedElementListeners(this.element, { [e]: t });
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", pu("touchstart") ? "touchstart" : "mousedown"].forEach((s) => {
      const i = this.processMouseEvent.bind(this, s);
      this.addManagedElementListeners(this.element, { [s]: i });
    });
  }
  processMouseEvent(e, t) {
    var o;
    if (!uo(this.gos, t) || gt(t))
      return;
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    e === "contextmenu" ? (s != null && s.column && s.dispatchCellContextMenuEvent(t), (o = this.beans.contextMenuSvc) == null || o.handleContextMenuMouseEvent(t, void 0, i, s)) : (s && s.onMouseEvent(e, t), i && i.onMouseEvent(e, t));
  }
  getControlsForEventTarget(e) {
    const { gos: t } = this;
    return {
      cellCtrl: $u(t, e),
      rowCtrl: fu(t, e, Pn)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (s ? this.processCellKeyboardEvent(s, e, t) : i && i.isFullWidth() && this.processFullWidthRowKeyboardEvent(i, e, t));
  }
  processCellKeyboardEvent(e, t, s) {
    var a;
    const { rowNode: i, column: o, editing: n } = e;
    !Ql(
      this.gos,
      s,
      i,
      o,
      n
    ) && t === "keydown" && (!n && ((a = this.beans.navigation) != null && a.handlePageScrollingKey(s)) || e.onKeyDown(s), this.doGridOperations(s, e.editing), lh(s) && e.processCharacter(s)), t === "keydown" && this.eventSvc.dispatchEvent(e.createEvent(s, "cellKeyDown"));
  }
  processFullWidthRowKeyboardEvent(e, t, s) {
    const { rowNode: i } = e, { focusSvc: o, navigation: n } = this.beans, r = o.getFocusedCell(), a = r && r.column;
    if (!Ql(this.gos, s, i, a, !1)) {
      const d = s.key;
      if (t === "keydown")
        switch (d) {
          case y.PAGE_HOME:
          case y.PAGE_END:
          case y.PAGE_UP:
          case y.PAGE_DOWN:
            n == null || n.handlePageScrollingKey(s, !0);
            break;
          case y.LEFT:
          case y.RIGHT:
            if (!this.gos.get("embedFullWidthRows"))
              break;
          case y.UP:
          case y.DOWN:
            e.onKeyboardNavigate(s);
            break;
          case y.TAB:
            e.onTabKeyDown(s);
            break;
        }
    }
    t === "keydown" && this.eventSvc.dispatchEvent(e.createRowEvent("cellKeyDown", s));
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !uo(this.gos, e))
      return;
    const s = zv(e), { clipboardSvc: i, undoRedo: o } = this.beans;
    if (s === y.A)
      return this.onCtrlAndA(e);
    if (s === y.C)
      return this.onCtrlAndC(i, e);
    if (s === y.D)
      return this.onCtrlAndD(i, e);
    if (s === y.V)
      return this.onCtrlAndV(i, e);
    if (s === y.X)
      return this.onCtrlAndX(i, e);
    if (s === y.Y)
      return this.onCtrlAndY(o);
    if (s === y.Z)
      return this.onCtrlAndZ(o, e);
  }
  onCtrlAndA(e) {
    const {
      beans: { rowModel: t, rangeSvc: s, selectionSvc: i },
      gos: o
    } = this;
    s && xi(o) && t.isRowsToRender() ? Ov(this.beans) : i && (i == null || i.selectAllRowNodes({ source: "keyboardSelectAll", selectAll: du(o) })), e.preventDefault();
  }
  onCtrlAndC(e, t) {
    if (!e || this.gos.get("enableCellTextSelection"))
      return;
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    s != null && s.editing || i != null && i.editing || (t.preventDefault(), e.copyToClipboard());
  }
  onCtrlAndX(e, t) {
    if (!e || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard"))
      return;
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    s != null && s.editing || i != null && i.editing || (t.preventDefault(), e.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e, t) {
    const { cellCtrl: s, rowCtrl: i } = this.getControlsForEventTarget(t.target);
    s != null && s.editing || i != null && i.editing || e && !this.gos.get("suppressClipboardPaste") && e.pasteFromClipboard();
  }
  onCtrlAndD(e, t) {
    e && !this.gos.get("suppressClipboardPaste") && e.copyRangeDown(), t.preventDefault();
  }
  onCtrlAndZ(e, t) {
    !this.gos.get("undoRedoCellEditing") || !e || (t.preventDefault(), t.shiftKey ? e.redo("ui") : e.undo("ui"));
  }
  onCtrlAndY(e) {
    e == null || e.redo("ui");
  }
}, dh = class extends S {
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rowContainerHeightChanged: this.onHeightChanged.bind(this, this.beans.rowContainerHeight)
    });
  }
  onHeightChanged(e) {
    const t = e.uiContainerHeight, s = t != null ? `${t}px` : "";
    this.eContainer.style.height = s, this.eViewport && (this.eViewport.style.height = s);
  }
}, Lo = (e) => e.topRowCtrls, ko = (e) => e.getStickyTopRowCtrls(), Go = (e) => e.getStickyBottomRowCtrls(), Oo = (e) => e.bottomRowCtrls, Bo = (e) => e.allRowCtrls, hr = (e) => e.getCtrls("top"), gr = (e) => e.getCtrls("center"), pr = (e) => e.getCtrls("bottom"), jv = {
  center: {
    type: "center",
    name: "center-cols",
    getRowCtrls: Bo,
    getSpannedRowCtrls: gr
  },
  left: {
    type: "left",
    name: "pinned-left-cols",
    pinnedType: "left",
    getRowCtrls: Bo,
    getSpannedRowCtrls: gr
  },
  right: {
    type: "right",
    name: "pinned-right-cols",
    pinnedType: "right",
    getRowCtrls: Bo,
    getSpannedRowCtrls: gr
  },
  fullWidth: {
    type: "fullWidth",
    name: "full-width",
    fullWidth: !0,
    getRowCtrls: Bo
  },
  topCenter: {
    type: "center",
    name: "floating-top",
    getRowCtrls: Lo,
    getSpannedRowCtrls: hr
  },
  topLeft: {
    type: "left",
    name: "pinned-left-floating",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: Lo,
    getSpannedRowCtrls: hr
  },
  topRight: {
    type: "right",
    name: "pinned-right-floating",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: Lo,
    getSpannedRowCtrls: hr
  },
  topFullWidth: {
    type: "fullWidth",
    name: "floating-top-full-width",
    fullWidth: !0,
    getRowCtrls: Lo
  },
  stickyTopCenter: {
    type: "center",
    name: "sticky-top",
    getRowCtrls: ko
  },
  stickyTopLeft: {
    type: "left",
    name: "pinned-left-sticky-top",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: ko
  },
  stickyTopRight: {
    type: "right",
    name: "pinned-right-sticky-top",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: ko
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    name: "sticky-top-full-width",
    fullWidth: !0,
    getRowCtrls: ko
  },
  stickyBottomCenter: {
    type: "center",
    name: "sticky-bottom",
    getRowCtrls: Go
  },
  stickyBottomLeft: {
    type: "left",
    name: "pinned-left-sticky-bottom",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: Go
  },
  stickyBottomRight: {
    type: "right",
    name: "pinned-right-sticky-bottom",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: Go
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    name: "sticky-bottom-full-width",
    fullWidth: !0,
    getRowCtrls: Go
  },
  bottomCenter: {
    type: "center",
    name: "floating-bottom",
    getRowCtrls: Oo,
    getSpannedRowCtrls: pr
  },
  bottomLeft: {
    type: "left",
    name: "pinned-left-floating-bottom",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: Oo,
    getSpannedRowCtrls: pr
  },
  bottomRight: {
    type: "right",
    name: "pinned-right-floating-bottom",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: Oo,
    getSpannedRowCtrls: pr
  },
  bottomFullWidth: {
    type: "fullWidth",
    name: "floating-bottom-full-width",
    fullWidth: !0,
    getRowCtrls: Oo
  }
};
function ch(e) {
  return `ag-${xo(e).name}-viewport`;
}
function Zo(e) {
  const t = xo(e);
  return t.container ?? `ag-${t.name}-container`;
}
function $v(e) {
  return `ag-${xo(e).name}-spanned-cells-container`;
}
function xo(e) {
  return jv[e];
}
var Kv = ["topCenter", "topLeft", "topRight"], qv = ["bottomCenter", "bottomLeft", "bottomRight"], Yv = ["center", "left", "right"], Zv = ["center", "left", "right", "fullWidth"], Qv = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"], Xv = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], Jv = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], uh = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"], hh = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"], ew = [
  ...uh,
  "stickyTopFullWidth",
  ...hh,
  "stickyBottomFullWidth"
], tw = [
  ...Kv,
  ...qv,
  ...Yv,
  ...uh,
  ...hh
], sw = class extends S {
  constructor(e) {
    super(), this.name = e, this.visible = !0, this.EMPTY_CTRLS = [], this.options = xo(e);
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new kv(this)), this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(e) {
    this.comp.setOffsetTop(`${e.offset}px`);
  }
  registerWithCtrlsService() {
    this.options.fullWidth || this.beans.ctrlsSvc.register(this.name, this);
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  setComp(e, t, s, i) {
    this.comp = e, this.eContainer = t, this.eSpannedContainer = s, this.eViewport = i, this.createManagedBean(new Uv(this.eViewport ?? this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder();
    const { pinnedCols: o, rangeSvc: n } = this.beans, r = () => this.onPinnedWidthChanged();
    this.forContainers(Xv, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        o == null ? void 0 : o.createPinnedWidthFeature(!0, this.eContainer, this.eSpannedContainer)
      ), this.addManagedEventListeners({ leftPinnedWidthChanged: r });
    }), this.forContainers(Jv, () => {
      this.pinnedWidthFeature = this.createOptionalManagedBean(
        o == null ? void 0 : o.createPinnedWidthFeature(!1, this.eContainer, this.eSpannedContainer)
      ), this.addManagedEventListeners({ rightPinnedWidthChanged: r });
    }), this.forContainers(
      Zv,
      () => this.createManagedBean(
        new dh(this.eContainer, this.name === "center" ? i : void 0)
      )
    ), n && this.forContainers(
      tw,
      () => this.createManagedBean(n.createDragListenerFeature(this.eContainer))
    ), this.forContainers(
      Qv,
      () => this.createManagedBean(new Ya((a) => this.comp.setContainerWidth(`${a}px`)))
    ), this.visible = this.isContainerVisible(), this.addListeners(), this.registerWithCtrlsService();
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
  addListeners() {
    const { spannedRowRenderer: e, gos: t } = this.beans, s = this.onDisplayedColumnsChanged.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: s,
      displayedColumnsWidthChanged: s,
      displayedRowsChanged: (i) => this.onDisplayedRowsChanged(i.afterScroll)
    }), s(), this.onDisplayedRowsChanged(), e && this.options.getSpannedRowCtrls && t.get("enableCellSpan") && this.addManagedListeners(e, {
      spannedRowsUpdated: () => {
        const i = this.options.getSpannedRowCtrls(e);
        i && this.comp.setSpannedRowCtrls(i, !1);
      }
    });
  }
  listenOnDomOrder() {
    if (ew.indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const t = () => {
      const s = this.gos.get("ensureDomOrder"), i = xe(this.gos, "print");
      this.comp.setDomOrder(s || i);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const { dragSvc: e } = this.beans;
    if (!e)
      return;
    const t = (s) => {
      e.dragging && s.cancelable && s.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", t, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", t));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(e = !1) {
    const t = this.getCenterWidth(), s = this.getCenterViewportScrollLeft();
    this.beans.colViewport.setScrollPosition(t, s, e);
  }
  hasHorizontalScrollGap() {
    return this.eContainer.clientWidth - this.eViewport.clientWidth < 0;
  }
  hasVerticalScrollGap() {
    return this.eContainer.clientHeight - this.eViewport.clientHeight < 0;
  }
  getCenterWidth() {
    return io(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return cn(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = fs(this.beans, this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportInTheDOMTree() {
    return $c(this.eViewport);
  }
  getViewportScrollLeft() {
    return cn(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || hm(this.eViewport);
  }
  setHorizontalScroll(e) {
    this.comp.setHorizontalScroll(e);
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(e) {
    un(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(e = !1) {
    const t = this.options.getRowCtrls(this.beans.rowRenderer);
    if (!this.visible || t.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const s = xe(this.gos, "print"), o = this.gos.get("embedFullWidthRows") || s, n = t.filter((r) => {
      const a = r.isFullWidth();
      return this.options.fullWidth ? !o && a : o || !a;
    });
    this.comp.setRowCtrls({ rowCtrls: n, useFlushSync: e });
  }
}, gh = "ag-force-vertical-scroll", iw = "ag-selectable", ow = "ag-column-moving", nw = class extends S {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.colModel = e.colModel, this.scrollVisibleSvc = e.scrollVisibleSvc, this.pinnedRowModel = e.pinnedRowModel, this.filterManager = e.filterManager, this.rowGroupColsSvc = e.rowGroupColsSvc;
  }
  setComp(e, t, s, i, o, n, r) {
    var a, l;
    this.comp = e, this.eGridBody = t, this.eBodyViewport = s, this.eTop = i, this.eBottom = o, this.eStickyTop = n, this.eStickyBottom = r, this.eCenterColsViewport = s.querySelector(`.${ch("center")}`), this.eFullWidthContainer = s.querySelector(`.${Zo("fullWidth")}`), this.eStickyTopFullWidthContainer = n.querySelector(
      `.${Zo("stickyTopFullWidth")}`
    ), this.eStickyBottomFullWidthContainer = r.querySelector(
      `.${Zo("stickyBottomFullWidth")}`
    ), this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener(
      "enableCellTextSelection",
      (d) => this.setCellTextSelection(d.currentValue)
    ), this.createManagedBean(new qa(this.comp)), this.scrollFeature = this.createManagedBean(new Lv(s)), (a = this.beans.rowDragSvc) == null || a.setupRowDrag(s, this), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([i, s, o, n, r]), this.setGridRootRole(), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), this.updateScrollingClasses(), (l = this.filterManager) == null || l.setupAdvFilterHeaderComp(i), this.ctrlsSvc.register("gridBodyCtrl", this);
  }
  addEventListeners() {
    const e = this.setFloatingHeights.bind(this), t = this.setGridRootRole.bind(this), s = this.toggleRowResizeStyles.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      scrollGapChanged: this.updateScrollingClasses.bind(this),
      pinnedRowDataChanged: e,
      pinnedHeightChanged: e,
      pinnedRowsChanged: e,
      headerHeightChanged: this.setStickyTopOffsetTop.bind(this),
      columnRowGroupChanged: t,
      columnPivotChanged: t,
      rowResizeStarted: s,
      rowResizeEnded: s
    }), this.addManagedPropertyListener("treeData", t);
  }
  toggleRowResizeStyles(e) {
    const t = e.type === "rowResizeStarted";
    this.eBodyViewport.classList.toggle("ag-prevent-animation", t);
  }
  onGridColumnsChanged() {
    const e = this.beans.colModel.getCols();
    this.comp.setColumnCount(e.length);
  }
  onScrollVisibilityChanged() {
    const { scrollVisibleSvc: e } = this, t = e.verticalScrollShowing;
    this.setVerticalScrollPaddingVisible(t), this.setStickyWidth(t), this.setStickyBottomOffsetBottom();
    const s = t && e.getScrollbarWidth() || 0, i = Wc() ? 16 : 0, o = `calc(100% + ${s + i}px)`;
    Ct(this.beans, () => this.comp.setBodyViewportWidth(o)), this.updateScrollingClasses();
  }
  setGridRootRole() {
    const { rowGroupColsSvc: e, colModel: t } = this;
    let s = this.gos.get("treeData");
    if (!s) {
      const i = t.isPivotMode();
      s = (e ? e.columns.length : 0) >= (i ? 2 : 1);
    }
    this.comp.setGridRootRole(s ? "treegrid" : "grid");
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedElementListeners(t, {
        focusin: (s) => {
          const { target: i } = s, o = Is(i, "ag-root", t);
          t.classList.toggle("ag-has-focus", !o);
        },
        focusout: (s) => {
          const { target: i, relatedTarget: o } = s, n = t.contains(o), r = Is(
            o,
            "ag-root",
            t
          );
          Is(i, "ag-root", t) || (!n || r) && t.classList.remove("ag-has-focus");
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(ow, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(iw, e);
  }
  updateScrollingClasses() {
    const {
      eGridBody: { classList: e },
      scrollVisibleSvc: t
    } = this;
    e.toggle("ag-body-vertical-content-no-gap", !t.verticalScrollGap), e.toggle("ag-body-horizontal-content-no-gap", !t.horizontalScrollGap);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (e) => {
        if (e.target instanceof HTMLImageElement)
          return e.preventDefault(), !1;
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    var e;
    (e = this.beans.editSvc) == null || e.addStopEditingWhenGridLosesFocus([
      this.eBodyViewport,
      this.eBottom,
      this.eTop,
      this.eStickyTop,
      this.eStickyBottom
    ]);
  }
  updateRowCount() {
    var o, n;
    const e = (((o = this.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : o.getRowCount()) ?? 0) + (((n = this.filterManager) == null ? void 0 : n.getHeaderRowCount()) ?? 0), { rowModel: t } = this.beans, s = t.isLastRowIndexKnown() ? t.getRowCount() : -1, i = s === -1 ? -1 : e + s;
    this.comp.setRowCount(i);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? gh : null, s = xe(this.gos, "normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || s && gm(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    const { rowContainerHeight: e, environment: t } = this.beans;
    let s = t.sizesMeasured;
    const i = () => {
      const o = s && ci(this.gos) && !e.stretching, n = o ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(n, o);
    };
    i(), this.addManagedEventListeners({ heightScaleChanged: i }), this.addManagedPropertyListener("animateRows", i), this.addManagedEventListeners({
      gridStylesChanged: () => {
        !s && t.sizesMeasured && (s = !0, i());
      }
    });
  }
  addBodyViewportListener() {
    const {
      eBodyViewport: e,
      eStickyTop: t,
      eStickyBottom: s,
      eTop: i,
      eBottom: o,
      beans: { popupSvc: n, touchSvc: r }
    } = this, a = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(e, { contextmenu: a }), r == null || r.mockBodyContextMenu(this, a), this.addManagedElementListeners(e, {
      wheel: this.onBodyViewportWheel.bind(this, n)
    });
    const l = this.onStickyWheel.bind(this);
    for (const c of [t, s, i, o])
      this.addManagedElementListeners(c, { wheel: l });
    const d = this.onHorizontalWheel.bind(this);
    for (const c of ["left", "right", "topLeft", "topRight", "bottomLeft", "bottomRight"])
      this.addManagedElementListeners(this.ctrlsSvc.get(c).eContainer, {
        wheel: d
      });
    this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    this.addManagedElementListeners(this.eFullWidthContainer, {
      wheel: (e) => this.onFullWidthContainerWheel(e)
    });
  }
  onFullWidthContainerWheel(e) {
    const { deltaX: t, deltaY: s, shiftKey: i } = e;
    (i || Math.abs(t) > Math.abs(s)) && uo(this.gos, e) && this.scrollGridBodyToMatchEvent(e);
  }
  onStickyWheel(e) {
    const { deltaY: t } = e;
    e.preventDefault(), this.scrollVertically(t);
  }
  onHorizontalWheel(e) {
    const { deltaX: t, deltaY: s, shiftKey: i } = e;
    (i || Math.abs(t) > Math.abs(s)) && this.scrollGridBodyToMatchEvent(e);
  }
  scrollGridBodyToMatchEvent(e) {
    const { deltaX: t, deltaY: s } = e;
    e.preventDefault(), this.eCenterColsViewport.scrollBy({ left: t || s });
  }
  onBodyViewportContextMenu(e, t, s) {
    var o;
    if (!e && !s)
      return;
    this.gos.get("preventDefaultOnContextMenu") && (e || s).preventDefault();
    const { target: i } = e || t;
    (i === this.eBodyViewport || i === this.ctrlsSvc.get("center").eViewport) && ((o = this.beans.contextMenuSvc) == null || o.showContextMenu({
      mouseEvent: e,
      touchEvent: s,
      value: null,
      anchorToElement: this.eGridBody,
      source: "ui"
    }));
  }
  onBodyViewportWheel(e, t) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && e != null && e.hasAnchoredPopup() && t.preventDefault();
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.scrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  setFloatingHeights() {
    const {
      pinnedRowModel: e,
      beans: { environment: t }
    } = this, s = e == null ? void 0 : e.getPinnedTopTotalHeight(), i = e == null ? void 0 : e.getPinnedBottomTotalHeight(), o = t.getPinnedRowBorderWidth(), n = t.getRowBorderWidth(), r = o - n, a = s ? r + s : 0, l = i ? r + i : 0;
    this.comp.setTopHeight(a), this.comp.setBottomHeight(l), this.comp.setTopInvisible(a <= 0), this.comp.setBottomInvisible(l <= 0), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  setStickyWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.scrollVisibleSvc.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  setStickyTopOffsetTop() {
    var o, n;
    const t = this.ctrlsSvc.get("gridHeaderCtrl").headerHeight + (((o = this.filterManager) == null ? void 0 : o.getHeaderHeight()) ?? 0), s = ((n = this.pinnedRowModel) == null ? void 0 : n.getPinnedTopTotalHeight()) ?? 0;
    let i = 0;
    t > 0 && (i += t), s > 0 && (i += s), i > 0 && (i += 1), this.comp.setStickyTopTop(`${i}px`);
  }
  setStickyBottomOffsetBottom() {
    const { pinnedRowModel: e, scrollVisibleSvc: t, comp: s } = this, i = (e == null ? void 0 : e.getPinnedBottomTotalHeight()) ?? 0, n = t.horizontalScrollShowing && t.getScrollbarWidth() || 0, r = i + n;
    s.setStickyBottomBottom(`${r}px`);
  }
}, ph = class extends L {
  constructor(e, t) {
    super(), this.direction = t, this.eViewport = x, this.eContainer = x, this.hideTimeout = 0, this.setTemplate(e);
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    }), this.onScrollVisibilityChanged(), this.toggleCss("ag-apple-scrollbar", Vc() || As());
  }
  destroy() {
    super.destroy(), window.clearTimeout(this.hideTimeout);
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = Wc(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = this.getGui(), t = () => this.toggleCss("ag-scrollbar-active", !0), s = () => this.toggleCss("ag-scrollbar-active", !1);
    this.addManagedListeners(e, {
      mouseenter: t,
      mousedown: t,
      touchstart: t,
      mouseleave: s,
      touchend: s
    });
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), Ct(this.beans, () => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (e) => {
        e.direction === this.direction && (this.hideTimeout && (window.clearTimeout(this.hideTimeout), this.hideTimeout = 0), this.toggleCss("ag-scrollbar-scrolling", !0));
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.toggleCss("ag-scrollbar-scrolling", !1), this.hideTimeout = 0;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.eViewport;
    Zc(
      () => He(t),
      () => this.setScrollPosition(e),
      100
    );
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
}, rw = {
  tag: "div",
  cls: "ag-body-horizontal-scroll",
  attrs: { "aria-hidden": "true" },
  children: [
    { tag: "div", ref: "eLeftSpacer", cls: "ag-horizontal-left-spacer" },
    {
      tag: "div",
      ref: "eViewport",
      cls: "ag-body-horizontal-scroll-viewport",
      children: [{ tag: "div", ref: "eContainer", cls: "ag-body-horizontal-scroll-container" }]
    },
    { tag: "div", ref: "eRightSpacer", cls: "ag-horizontal-right-spacer" }
  ]
}, aw = class extends ph {
  constructor() {
    super(rw, "horizontal"), this.eLeftSpacer = x, this.eRightSpacer = x, this.setScrollVisibleDebounce = 0;
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.scrollVisibleSvc = e.scrollVisibleSvc;
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e,
      pinnedRowDataChanged: this.refreshCompBottom.bind(this)
    }), this.addManagedPropertyListener("domLayout", e), this.beans.ctrlsSvc.register("fakeHScrollComp", this), this.createManagedBean(new Ya((t) => this.eContainer.style.width = `${t}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  destroy() {
    window.clearTimeout(this.setScrollVisibleDebounce), super.destroy();
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  refreshCompBottom() {
    var t;
    if (!this.invisibleScrollbar)
      return;
    const e = ((t = this.beans.pinnedRowModel) == null ? void 0 : t.getPinnedBottomTotalHeight()) ?? 0;
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleSvc.verticalScrollShowing;
    let t = this.visibleCols.getDisplayedColumnsRightWidth();
    const s = !this.enableRtl && e, i = this.scrollVisibleSvc.getScrollbarWidth();
    s && (t += i), Et(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= i);
    let o = this.visibleCols.getColsLeftWidth();
    this.enableRtl && e && (o += i), Et(this.eLeftSpacer, o), this.eLeftSpacer.classList.toggle("ag-scroller-corner", o <= i);
  }
  setScrollVisible() {
    const e = this.scrollVisibleSvc.horizontalScrollShowing, t = this.invisibleScrollbar, s = this.gos.get("suppressHorizontalScroll"), i = e && this.scrollVisibleSvc.getScrollbarWidth() || 0, n = s ? 0 : i === 0 && t ? 16 : i, r = () => {
      this.setScrollVisibleDebounce = 0, this.toggleCss("ag-scrollbar-invisible", t), $i(this.getGui(), n), $i(this.eViewport, n), $i(this.eContainer, n), n || this.eContainer.style.setProperty("min-height", "1px"), this.setVisible(e, { skipAriaHidden: !0 });
    };
    window.clearTimeout(this.setScrollVisibleDebounce), e ? this.setScrollVisibleDebounce = window.setTimeout(r, 100) : r();
  }
  getScrollPosition() {
    return cn(this.eViewport, this.enableRtl);
  }
  setScrollPosition(e) {
    He(this.eViewport) || this.attemptSettingScrollPosition(e), un(this.eViewport, e, this.enableRtl);
  }
}, lw = {
  selector: "AG-FAKE-HORIZONTAL-SCROLL",
  component: aw
}, dw = {
  tag: "div",
  cls: "ag-body-vertical-scroll",
  attrs: { "aria-hidden": "true" },
  children: [
    {
      tag: "div",
      ref: "eViewport",
      cls: "ag-body-vertical-scroll-viewport",
      children: [{ tag: "div", ref: "eContainer", cls: "ag-body-vertical-scroll-container" }]
    }
  ]
}, cw = class extends ph {
  constructor() {
    super(dw, "vertical");
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new dh(this.eContainer));
    const { ctrlsSvc: e } = this.beans;
    e.register("fakeVScrollComp", this), this.addManagedEventListeners({
      rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this, e)
    });
  }
  setScrollVisible() {
    const { scrollVisibleSvc: e } = this.beans, t = e.verticalScrollShowing, s = this.invisibleScrollbar, i = t && e.getScrollbarWidth() || 0, o = i === 0 && s ? 16 : i;
    this.toggleCss("ag-scrollbar-invisible", s), Et(this.getGui(), o), Et(this.eViewport, o), Et(this.eContainer, o), this.setDisplayed(t, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged(e) {
    const s = e.getGridBodyCtrl().eBodyViewport, i = this.getScrollPosition(), o = s.scrollTop;
    i != o && this.setScrollPosition(o, !0);
  }
  getScrollPosition() {
    return this.eViewport.scrollTop;
  }
  setScrollPosition(e, t) {
    !t && !He(this.eViewport) && this.attemptSettingScrollPosition(e), this.eViewport.scrollTop = e;
  }
}, uw = {
  selector: "AG-FAKE-VERTICAL-SCROLL",
  component: cw
};
function hw(e) {
  return e.cols ? e.cols.treeDepth + 1 : -1;
}
function Mt(e) {
  var t;
  return ((t = e.ctrlsSvc.getHeaderRowContainerCtrl()) == null ? void 0 : t.getRowCount()) ?? 0;
}
function Za(e) {
  const t = [], s = e.ctrlsSvc.getHeaderRowContainerCtrls();
  for (const i of s) {
    if (!i)
      continue;
    const o = i.getGroupRowCount() || 0;
    for (let n = 0; n < o; n++) {
      const r = i.getGroupRowCtrlAtIndex(n), a = t[n];
      if (r) {
        const l = gw(e, r);
        (a == null || l > a) && (t[n] = l);
      }
    }
  }
  return t;
}
function gw(e, t) {
  let i = e.colModel.isPivotMode() ? fw(e) : mh(e);
  const o = t.getHeaderCellCtrls();
  for (const n of o) {
    const { column: r } = n, a = r.getAutoHeaderHeight();
    a != null && a > i && r.isAutoHeaderHeight() && (i = a);
  }
  return i;
}
function Qa(e) {
  let s = e.colModel.isPivotMode() ? pw(e) : jn(e);
  return e.colModel.forAllCols((i) => {
    const o = i.getAutoHeaderHeight();
    o != null && o > s && i.isAutoHeaderHeight() && (s = o);
  }), s;
}
function jn(e) {
  return e.gos.get("headerHeight") ?? e.environment.getDefaultHeaderHeight();
}
function fh(e) {
  return e.gos.get("floatingFiltersHeight") ?? jn(e);
}
function mh(e) {
  return e.gos.get("groupHeaderHeight") ?? jn(e);
}
function pw(e) {
  return e.gos.get("pivotHeaderHeight") ?? jn(e);
}
function fw(e) {
  return e.gos.get("pivotGroupHeaderHeight") ?? mh(e);
}
var mw = class extends S {
  setComp(e, t, s) {
    this.comp = e, this.eGui = t;
    const { beans: i } = this, { headerNavigation: o, touchSvc: n, ctrlsSvc: r } = i;
    o && this.createManagedBean(
      new ms(s, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this, i),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this, i)
    }), this.onPivotModeChanged(i), this.setupHeaderHeight();
    const a = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: a }), n == null || n.mockHeaderContextMenu(this, a), r.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      e
    ), this.addManagedEventListeners({
      displayedColumnsChanged: e,
      columnHeaderHeightChanged: e,
      // add this to the animation frame to avoid a feedback loop
      columnGroupHeaderHeightChanged: () => Ct(this.beans, () => e()),
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    });
  }
  setHeaderHeight() {
    var n;
    const { beans: e } = this;
    let t = 0;
    const s = Za(e).reduce((r, a) => r + a, 0), i = Qa(e);
    if ((n = e.filterManager) != null && n.hasFloatingFilters() && (t += fh(e)), t += s, t += i, this.headerHeight === t)
      return;
    this.headerHeight = t;
    const o = `${t + 1}px`;
    this.comp.setHeightAndMinHeight(o), this.eventSvc.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged(e) {
    const t = e.colModel.isPivotMode();
    this.comp.toggleCss("ag-pivot-on", t), this.comp.toggleCss("ag-pivot-off", !t);
  }
  onDisplayedColumnsChanged(e) {
    const s = e.visibleCols.allCols.some((i) => i.isSpanHeaderHeight());
    this.comp.toggleCss("ag-header-allow-overflow", s);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), s = e.shiftKey, i = s !== t ? "LEFT" : "RIGHT", { beans: o } = this, { headerNavigation: n, focusSvc: r } = o;
    (n.navigateHorizontally(i, !0, e) || !s && r.focusOverlay(!1) || Tt(o, s, !0)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    const { headerNavigation: s } = this.beans;
    switch (e.key) {
      case y.LEFT:
        t = "LEFT";
      case y.RIGHT: {
        T(t) || (t = "RIGHT"), s.navigateHorizontally(t, !1, e) && e.preventDefault();
        break;
      }
      case y.UP:
        t = "UP";
      case y.DOWN: {
        T(t) || (t = "DOWN"), s.navigateVertically(t, null, e) && e.preventDefault();
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e, { eGui: s, beans: i } = this;
    !t && s.contains(te(i)) || s.contains(t) || (i.focusSvc.focusedHeader = null);
  }
  onHeaderContextMenu(e, t, s) {
    var r;
    const { menuSvc: i, ctrlsSvc: o } = this.beans;
    if (!e && !s || !(i != null && i.isHeaderContextMenuEnabled()))
      return;
    const { target: n } = e ?? t;
    (n === this.eGui || n === ((r = o.getHeaderRowContainerCtrl()) == null ? void 0 : r.eViewport)) && i.showHeaderContextMenu(void 0, e, s);
  }
}, Xa = class extends L {
  constructor(e, t) {
    super(e), this.ctrl = t;
  }
  getCtrl() {
    return this.ctrl;
  }
}, Cw = {
  tag: "div",
  cls: "ag-header-cell",
  role: "columnheader",
  children: [
    { tag: "div", ref: "eResize", cls: "ag-header-cell-resize", role: "presentation" },
    { tag: "div", ref: "eHeaderCompWrapper", cls: "ag-header-cell-comp-wrapper", role: "presentation" }
  ]
}, vw = class extends Xa {
  constructor(e) {
    super(Cw, e), this.eResize = x, this.eHeaderCompWrapper = x, this.headerCompVersion = 0;
  }
  postConstruct() {
    const e = this.getGui();
    ((o, n) => {
      n != null && n != "" ? e.setAttribute(o, n) : e.removeAttribute(o);
    })("col-id", this.ctrl.column.getColId());
    const s = {
      setWidth: (o) => e.style.width = o,
      toggleCss: (o, n) => this.toggleCss(o, n),
      setUserStyles: (o) => bo(e, o),
      setAriaSort: (o) => o ? im(e, o) : om(e),
      setUserCompDetails: (o) => this.setUserCompDetails(o),
      getUserCompInstance: () => this.headerComp
    };
    this.ctrl.setComp(s, this.getGui(), this.eResize, this.eHeaderCompWrapper, void 0);
    const i = this.ctrl.getSelectAllGui();
    i && this.eResize.insertAdjacentElement("afterend", i);
  }
  destroy() {
    this.destroyHeaderComp(), super.destroy();
  }
  destroyHeaderComp() {
    this.headerComp && (this.eHeaderCompWrapper.removeChild(this.headerCompGui), this.headerComp = this.destroyBean(this.headerComp), this.headerCompGui = void 0);
  }
  setUserCompDetails(e) {
    this.headerCompVersion++;
    const t = this.headerCompVersion;
    e.newAgStackInstance().then((s) => this.afterCompCreated(t, s));
  }
  afterCompCreated(e, t) {
    if (e != this.headerCompVersion || !this.isAlive()) {
      this.destroyBean(t);
      return;
    }
    this.destroyHeaderComp(), this.headerComp = t, this.headerCompGui = t.getGui(), this.eHeaderCompWrapper.appendChild(this.headerCompGui), this.ctrl.setDragSource(this.getGui());
  }
}, ww = {
  tag: "div",
  cls: "ag-header-group-cell",
  role: "columnheader",
  children: [
    { tag: "div", ref: "eHeaderCompWrapper", cls: "ag-header-cell-comp-wrapper", role: "presentation" },
    { tag: "div", ref: "eResize", cls: "ag-header-cell-resize", role: "presentation" }
  ]
}, bw = class extends Xa {
  constructor(e) {
    super(ww, e), this.eResize = x, this.eHeaderCompWrapper = x;
  }
  postConstruct() {
    const e = this.getGui(), t = (i, o) => o != null ? e.setAttribute(i, o) : e.removeAttribute(i);
    e.setAttribute("col-id", this.ctrl.column.getUniqueId());
    const s = {
      toggleCss: (i, o) => this.toggleCss(i, o),
      setUserStyles: (i) => bo(e, i),
      setHeaderWrapperHidden: (i) => {
        i ? this.eHeaderCompWrapper.style.setProperty("display", "none") : this.eHeaderCompWrapper.style.removeProperty("display");
      },
      setHeaderWrapperMaxHeight: (i) => {
        i != null ? this.eHeaderCompWrapper.style.setProperty("max-height", `${i}px`) : this.eHeaderCompWrapper.style.removeProperty("max-height"), this.eHeaderCompWrapper.classList.toggle("ag-header-cell-comp-wrapper-limited-height", i != null);
      },
      setResizableDisplayed: (i) => G(this.eResize, i),
      setWidth: (i) => e.style.width = i,
      setAriaExpanded: (i) => t("aria-expanded", i),
      setUserCompDetails: (i) => this.setUserCompDetails(i),
      getUserCompInstance: () => this.headerGroupComp
    };
    this.ctrl.setComp(s, e, this.eResize, this.eHeaderCompWrapper, void 0);
  }
  setUserCompDetails(e) {
    e.newAgStackInstance().then((t) => this.afterHeaderCompCreated(t));
  }
  afterHeaderCompCreated(e) {
    const t = () => this.destroyBean(e);
    if (!this.isAlive()) {
      t();
      return;
    }
    const s = this.getGui(), i = e.getGui();
    this.eHeaderCompWrapper.appendChild(i), this.addDestroyFunc(t), this.headerGroupComp = e, this.ctrl.setDragSource(s);
  }
  addOrRemoveHeaderWrapperStyle(e, t) {
    const { eHeaderCompWrapper: s } = this;
    t ? s.style.setProperty(e, t) : s.style.removeProperty(e);
  }
}, yw = {
  tag: "div",
  cls: "ag-header-cell ag-floating-filter",
  role: "gridcell",
  children: [
    { tag: "div", ref: "eFloatingFilterBody", role: "presentation" },
    {
      tag: "div",
      ref: "eButtonWrapper",
      cls: "ag-floating-filter-button ag-hidden",
      role: "presentation",
      children: [
        {
          tag: "button",
          ref: "eButtonShowMainFilter",
          cls: "ag-button ag-floating-filter-button-button",
          attrs: { type: "button", tabindex: "-1" }
        }
      ]
    }
  ]
}, Sw = class extends Xa {
  constructor(e) {
    super(yw, e), this.eFloatingFilterBody = x, this.eButtonWrapper = x, this.eButtonShowMainFilter = x;
  }
  postConstruct() {
    const e = this.getGui(), t = {
      toggleCss: (s, i) => this.toggleCss(s, i),
      setUserStyles: (s) => bo(e, s),
      addOrRemoveBodyCssClass: (s, i) => this.eFloatingFilterBody.classList.toggle(s, i),
      setButtonWrapperDisplayed: (s) => G(this.eButtonWrapper, s),
      setCompDetails: (s) => this.setCompDetails(s),
      getFloatingFilterComp: () => this.compPromise,
      setWidth: (s) => e.style.width = s,
      setMenuIcon: (s) => this.eButtonShowMainFilter.appendChild(s)
    };
    this.ctrl.setComp(t, e, this.eButtonShowMainFilter, this.eFloatingFilterBody, void 0);
  }
  setCompDetails(e) {
    if (!e) {
      this.destroyFloatingFilterComp(), this.compPromise = null;
      return;
    }
    this.compPromise = e.newAgStackInstance(), this.compPromise.then((t) => this.afterCompCreated(t));
  }
  destroy() {
    this.destroyFloatingFilterComp(), super.destroy();
  }
  destroyFloatingFilterComp() {
    this.floatingFilterComp && (this.eFloatingFilterBody.removeChild(this.floatingFilterComp.getGui()), this.floatingFilterComp = this.destroyBean(this.floatingFilterComp));
  }
  afterCompCreated(e) {
    if (e) {
      if (!this.isAlive()) {
        this.destroyBean(e);
        return;
      }
      this.destroyFloatingFilterComp(), this.floatingFilterComp = e, this.eFloatingFilterBody.appendChild(e.getGui()), e.afterGuiAttached && e.afterGuiAttached();
    }
  }
}, xw = class extends L {
  constructor(e) {
    super({ tag: "div", cls: e.headerRowClass, role: "row" }), this.ctrl = e, this.headerComps = {};
  }
  postConstruct() {
    Oc(this.getGui(), this.ctrl.getAriaRowIndex());
    const e = {
      setHeight: (t) => this.getGui().style.height = t,
      setTop: (t) => this.getGui().style.top = t,
      setHeaderCtrls: (t, s) => this.setHeaderCtrls(t, s),
      setWidth: (t) => this.getGui().style.width = t
    };
    this.ctrl.setComp(e, void 0);
  }
  destroy() {
    this.setHeaderCtrls([], !1), super.destroy();
  }
  setHeaderCtrls(e, t) {
    if (!this.isAlive())
      return;
    const s = this.headerComps;
    if (this.headerComps = {}, e.forEach((i) => {
      const o = i.instanceId;
      let n = s[o];
      delete s[o], n == null && (n = this.createHeaderComp(i), this.getGui().appendChild(n.getGui())), this.headerComps[o] = n;
    }), Object.values(s).forEach((i) => {
      this.getGui().removeChild(i.getGui()), this.destroyBean(i);
    }), t) {
      const i = Object.values(this.headerComps);
      i.sort(
        (n, r) => {
          const a = n.getCtrl().column.getLeft(), l = r.getCtrl().column.getLeft();
          return a - l;
        }
      );
      const o = i.map((n) => n.getGui());
      qc(this.getGui(), o);
    }
  }
  createHeaderComp(e) {
    let t;
    switch (this.ctrl.type) {
      case "group":
        t = new bw(e);
        break;
      case "filter":
        t = new Sw(e);
        break;
      default:
        t = new vw(e);
        break;
    }
    return this.createBean(t), t.setParentComponent(this), t;
  }
}, Ja = class extends S {
  constructor(e, t, s, i) {
    super(), this.columnOrGroup = e, this.eCell = t, this.colsSpanning = i, this.columnOrGroup = e, this.ariaEl = t.querySelector("[role=columnheader]") || t, this.beans = s;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    const { beans: e, colsSpanning: t } = this;
    return e.gos.get("enableRtl") && t ? Z(t) : this.columnOrGroup;
  }
  postConstruct() {
    const e = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: e }), this.setLeftFirstTime(), this.addManagedEventListeners({ displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  setLeftFirstTime() {
    const { gos: e, colAnimation: t } = this.beans, s = e.get("suppressColumnMoveAnimation"), i = T(this.columnOrGroup.getOldLeft());
    (t == null ? void 0 : t.isActive()) && i && !s ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = this.modifyLeftForPrintLayout(e, e.getOldLeft()), s = this.modifyLeftForPrintLayout(e, e.getLeft());
    this.setLeft(t), this.actualLeft = s, this.beans.colAnimation.executeNextVMTurn(() => {
      this.actualLeft === s && this.setLeft(s);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    const { gos: s, visibleCols: i } = this.beans;
    if (!xe(s, "print") || e.getPinned() === "left")
      return t;
    const n = i.getColsLeftWidth();
    if (e.getPinned() === "right") {
      const r = i.bodyWidth;
      return n + r + t;
    }
    return n + t;
  }
  setLeft(e) {
    if (T(e) && (this.eCell.style.left = `${e}px`), ue(this.columnOrGroup)) {
      const t = this.columnOrGroup.getLeafColumns();
      if (!t.length)
        return;
      t.length > 1 && sm(this.ariaEl, t.length);
    }
  }
}, Rw = 0, Ch = "headerCtrl", el = class extends S {
  constructor(e, t) {
    super(), this.column = e, this.rowCtrl = t, this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.instanceId = e.getUniqueId() + "-" + Rw++;
  }
  postConstruct() {
    const e = this.refreshTabIndex.bind(this);
    this.addManagedPropertyListeners(["suppressHeaderFocus"], e), this.addManagedEventListeners({
      overlayExclusiveChanged: e
    });
  }
  shouldStopEventPropagation(e) {
    const { headerRowIndex: t, column: s } = this.beans.focusSvc.focusedHeader, i = s.getDefinition(), o = i && i.suppressHeaderKeyboardEvent;
    if (!T(o))
      return !1;
    const n = N(this.gos, {
      colDef: i,
      column: s,
      headerRowIndex: t,
      event: e
    });
    return !!o(n);
  }
  getWrapperHasFocus() {
    return te(this.beans) === this.eGui;
  }
  setGui(e, t) {
    this.eGui = e, this.addDomData(t), t.addManagedListeners(this.beans.eventSvc, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), t.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    }), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  refreshHeaderStyles() {
    const e = this.column.getDefinition();
    if (!e)
      return;
    const { headerStyle: t } = e;
    let s;
    if (typeof t == "function") {
      const i = this.getHeaderClassParams();
      s = t(i);
    } else
      s = t;
    s && this.comp.setUserStyles(s);
  }
  onGuiFocus() {
    this.eventSvc.dispatchEvent({
      type: "headerFocused",
      column: this.column
    });
  }
  setupAutoHeight(e) {
    const { wrapperElement: t, checkMeasuringCallback: s, compBean: i } = e, { beans: o } = this, n = (u) => {
      if (!this.isAlive() || !i.isAlive())
        return;
      const { paddingTop: h, paddingBottom: g, borderBottomWidth: p, borderTopWidth: f } = Ei(this.eGui), m = h + g + p + f, w = t.offsetHeight + m;
      if (u < 5) {
        const C = pe(o), v = !C || !C.contains(t), F = w == 0;
        if (v || F) {
          Wr(() => n(u + 1), "raf", o);
          return;
        }
      }
      this.setColHeaderHeight(this.column, w);
    };
    let r = !1, a;
    const l = () => {
      const u = this.column.isAutoHeaderHeight();
      u && !r && d(), !u && r && c();
    }, d = () => {
      r = !0, n(0), this.comp.toggleCss("ag-header-cell-auto-height", !0), a = fs(this.beans, t, () => n(0));
    }, c = () => {
      r = !1, a && a(), this.comp.toggleCss("ag-header-cell-auto-height", !1), a = void 0;
    };
    l(), i.addDestroyFunc(() => c()), i.addManagedListeners(this.column, { widthChanged: () => r && n(0) }), i.addManagedEventListeners({
      sortChanged: () => {
        r && window.setTimeout(() => n(0));
      }
    }), s && s(l);
  }
  onDisplayedColumnsChanged() {
    const { comp: e, column: t, beans: s, eGui: i } = this;
    !e || !t || !i || (Uu(e, t, s.visibleCols), Bc(i, s.visibleCols.getAriaColIndex(t)));
  }
  addResizeAndMoveKeyboardListeners(e) {
    e.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    const e = ks(this.beans);
    this.eGui && ai(this.eGui, "tabindex", e ? null : "-1");
  }
  onGuiKeyDown(e) {
    var n;
    const t = te(this.beans), s = e.key === y.LEFT || e.key === y.RIGHT;
    if (this.isResizing && (e.preventDefault(), e.stopImmediatePropagation()), // if elements within the header are focused, we don't process the event
    t !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
    !e.shiftKey && !e.altKey || ((this.isResizing || s) && (e.preventDefault(), e.stopImmediatePropagation()), !s))
      return;
    const o = e.key === y.LEFT !== this.gos.get("enableRtl") ? "left" : "right";
    if (e.altKey) {
      this.isResizing = !0, this.resizeMultiplier += 1;
      const r = this.getViewportAdjustedResizeDiff(e);
      this.resizeHeader(r, e.shiftKey), (n = this.resizeFeature) == null || n.toggleColumnResizing(!0);
    } else
      this.moveHeader(o);
  }
  moveHeader(e) {
    var t;
    (t = this.beans.colMoves) == null || t.moveHeader(e, this.eGui, this.column, this.rowCtrl.pinned, this);
  }
  getViewportAdjustedResizeDiff(e) {
    const t = this.getResizeDiff(e), { pinnedCols: s } = this.beans;
    return s ? s.getHeaderResizeDiff(t, this.column) : t;
  }
  getResizeDiff(e) {
    const { gos: t, column: s } = this;
    let i = e.key === y.LEFT !== t.get("enableRtl");
    const o = s.getPinned(), n = t.get("enableRtl");
    return o && n !== (o === "right") && (i = !i), (i ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = window.setTimeout(() => {
      var e;
      (e = this.resizeFeature) == null || e.toggleColumnResizing(!1);
    }, 150));
  }
  handleKeyDown(e) {
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case y.PAGE_DOWN:
      case y.PAGE_UP:
      case y.PAGE_HOME:
      case y.PAGE_END:
        t && e.preventDefault();
    }
  }
  addDomData(e) {
    const t = Ch, { eGui: s, gos: i } = this;
    bi(i, s, t, this), e.addDestroyFunc(() => bi(i, s, t, null));
  }
  focus(e) {
    const { eGui: t } = this;
    return t ? (this.lastFocusEvent = e || null, t.focus(), !0) : !1;
  }
  focusThis() {
    this.beans.focusSvc.focusedHeader = { headerRowIndex: this.rowCtrl.rowIndex, column: this.column };
  }
  removeDragSource() {
    var e;
    this.dragSource && ((e = this.beans.dragAndDrop) == null || e.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(e, t, s) {
    const i = e ?? t, { menuSvc: o, gos: n } = this.beans;
    n.get("preventDefaultOnContextMenu") && i.preventDefault(), o != null && o.isHeaderContextMenuEnabled(s) && o.showHeaderContextMenu(s, e, t), this.dispatchColumnMouseEvent("columnHeaderContextMenu", s);
  }
  dispatchColumnMouseEvent(e, t) {
    this.eventSvc.dispatchEvent({
      type: e,
      column: t
    });
  }
  setColHeaderHeight(e, t) {
    if (!e.setAutoHeaderHeight(t))
      return;
    const { eventSvc: s } = this;
    e.isColumn ? s.dispatchEvent({
      type: "columnHeaderHeightChanged",
      column: e,
      columns: [e],
      source: "autosizeColumnHeaderHeight"
    }) : s.dispatchEvent({
      type: "columnGroupHeaderHeightChanged",
      columnGroup: e,
      source: "autosizeColumnGroupHeaderHeight"
    });
  }
  clearComponent() {
    this.removeDragSource(), this.resizeFeature = null, this.comp = null, this.eGui = null;
  }
  destroy() {
    super.destroy(), this.column = null, this.lastFocusEvent = null, this.rowCtrl = null;
  }
}, Fw = class extends el {
  constructor() {
    super(...arguments), this.refreshFunctions = {}, this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map();
  }
  setComp(e, t, s, i, o) {
    this.comp = e;
    const { rowCtrl: n, column: r, beans: a } = this, { colResize: l, context: d, colHover: c, rangeSvc: u } = a, h = So(this, d, o);
    this.setGui(t, h), this.updateState(), this.setupWidth(h), this.setupMovingCss(h), this.setupMenuClass(h), this.setupSortableClass(h), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight({
      wrapperElement: i,
      checkMeasuringCallback: (p) => this.setRefreshFunction("measuring", p),
      compBean: h
    }), this.addColumnHoverListener(h), this.setupFilterClass(h), this.setupStylesFromColDef(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(h), this.setupSelectAll(h), this.setupUserComp(), this.refreshAria(), l ? this.resizeFeature = h.createManagedBean(
      l.createResizeFeature(n.pinned, r, s, e, this)
    ) : G(s, !1), c == null || c.createHoverFeature(h, [r], t), u == null || u.createRangeHighlightFeature(h, r, e), h.createManagedBean(new Ja(r, t, a)), h.createManagedBean(
      new ms(t, {
        shouldStopEventPropagation: (p) => this.shouldStopEventPropagation(p),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addResizeAndMoveKeyboardListeners(h), h.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader", "enableAdvancedFilter"],
      () => this.refresh()
    ), h.addManagedListeners(r, { colDefChanged: () => this.refresh() }), h.addManagedListeners(r, { headerHighlightChanged: this.onHeaderHighlightChanged.bind(this) });
    const g = () => this.checkDisplayName();
    h.addManagedEventListeners({
      columnValueChanged: g,
      columnRowGroupChanged: g,
      columnPivotChanged: g,
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    }), h.addDestroyFunc(() => {
      this.refreshFunctions = {}, this.selectAllFeature = null, this.dragSourceElement = void 0, this.userCompDetails = null, this.userHeaderClasses.clear(), this.ariaDescriptionProperties.clear(), this.clearComponent();
    });
  }
  resizeHeader(e, t) {
    var s;
    (s = this.beans.colResize) == null || s.resizeHeader(this.column, e, t);
  }
  getHeaderClassParams() {
    const { column: e, beans: t } = this, s = e.colDef;
    return N(t.gos, {
      colDef: s,
      column: e,
      floatingFilter: !1
    });
  }
  setupUserComp() {
    const e = this.lookupUserCompDetails();
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails() {
    const e = this.createParams(), t = this.column.getColDef();
    return DC(this.beans.userCompFactory, t, e);
  }
  createParams() {
    const { menuSvc: e, sortSvc: t, colFilter: s, gos: i } = this.beans;
    return N(i, {
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && !!(e != null && e.isHeaderFilterButtonEnabled(this.column)),
      enableFilterIcon: !!s && (!this.openFilterEnabled || fe(this.gos)),
      showColumnMenu: (n, r) => {
        e == null || e.showColumnMenu({
          column: this.column,
          buttonElement: n,
          positionBy: "button",
          onClosedCallback: r
        });
      },
      showColumnMenuAfterMouseClick: (n, r) => {
        e == null || e.showColumnMenu({
          column: this.column,
          mouseEvent: n,
          positionBy: "mouse",
          onClosedCallback: r
        });
      },
      showFilter: (n) => {
        e == null || e.showFilterMenu({
          column: this.column,
          buttonElement: n,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (n) => {
        t == null || t.progressSort(this.column, !!n, "uiColumnSorted");
      },
      setSort: (n, r) => {
        t == null || t.setSortForColumn(this.column, n, !!r, "uiColumnSorted");
      },
      eGridHeader: this.eGui,
      setTooltip: (n, r) => {
        i.assertModuleRegistered("Tooltip", 3), this.setupTooltip(n, r);
      }
    });
  }
  setupSelectAll(e) {
    const { selectionSvc: t } = this.beans;
    t && (this.selectAllFeature = e.createManagedBean(t.createSelectAllFeature(this.column)), this.selectAllFeature.setComp(this));
  }
  getSelectAllGui() {
    var e;
    return (e = this.selectAllFeature) == null ? void 0 : e.getCheckboxGui();
  }
  handleKeyDown(e) {
    var t;
    super.handleKeyDown(e), e.key === y.SPACE && ((t = this.selectAllFeature) == null || t.onSpaceKeyDown(e)), e.key === y.ENTER && this.onEnterKeyDown(e), e.key === y.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1);
  }
  onEnterKeyDown(e) {
    var t;
    e.ctrlKey || e.metaKey ? this.showMenuOnKeyPress(e, !0) : this.sortable && ((t = this.beans.sortSvc) == null || t.progressSort(this.column, e.shiftKey, "uiColumnSorted"));
  }
  showMenuOnKeyPress(e, t) {
    const s = this.comp.getUserCompInstance();
    Xl(s) && s.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    this.eGui.contains(e.relatedTarget) || (this.focusThis(), this.announceAriaDescription()), Wn() && this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.eGui.contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip(e, t) {
    var s;
    this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.setupHeaderTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    );
  }
  setupStylesFromColDef() {
    this.setRefreshFunction("headerStyles", this.refreshHeaderStyles.bind(this)), this.refreshHeaderStyles();
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), s = Wu(t, this.gos, this.column, null), i = this.userHeaderClasses;
      this.userHeaderClasses = new Set(s), s.forEach((o) => {
        i.has(o) ? i.delete(o) : this.comp.toggleCss(o, !0);
      }), i.forEach((o) => this.comp.toggleCss(o, !1));
    };
    this.setRefreshFunction("headerClasses", e), e();
  }
  setDragSource(e) {
    var t;
    this.dragSourceElement = e, this.removeDragSource(), !(!e || !this.draggable) && (this.dragSource = ((t = this.beans.colMoves) == null ? void 0 : t.setDragSourceForHeader(e, this.column, this.displayName)) ?? null);
  }
  updateState() {
    const { menuSvc: e } = this.beans;
    this.menuEnabled = !!(e != null && e.isColumnMenuInHeaderEnabled(this.column)), this.openFilterEnabled = !!(e != null && e.isFilterMenuInHeaderEnabled(this.column)), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  setRefreshFunction(e, t) {
    this.refreshFunctions[e] = t;
  }
  refresh() {
    this.updateState(), this.refreshHeaderComp(), this.refreshAria(), Object.values(this.refreshFunctions).forEach((e) => e());
  }
  refreshHeaderComp() {
    const e = this.lookupUserCompDetails();
    if (!e)
      return;
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == e.componentClass ? this.attemptHeaderCompRefresh(e.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.colNames.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName() {
    this.displayName !== this.calculateDisplayName() && this.refresh();
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  setupWidth(e) {
    const t = () => {
      const s = this.column.getActualWidth();
      this.comp.setWidth(`${s}px`);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupMovingCss(e) {
    const t = () => {
      this.comp.toggleCss("ag-header-cell-moving", this.column.isMoving());
    };
    e.addManagedListeners(this.column, { movingChanged: t }), t();
  }
  setupMenuClass(e) {
    const t = () => {
      var s;
      (s = this.comp) == null || s.toggleCss("ag-column-menu-visible", this.column.isMenuVisible());
    };
    e.addManagedListeners(this.column, { menuVisibleChanged: t }), t();
  }
  setupSortableClass(e) {
    const t = () => {
      this.comp.toggleCss("ag-header-cell-sortable", !!this.sortable);
    };
    t(), this.setRefreshFunction("updateSortable", t), e.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass(e) {
    const t = () => {
      const s = this.column.isFilterActive();
      this.comp.toggleCss("ag-header-cell-filtered", s), this.refreshAria();
    };
    e.addManagedListeners(this.column, { filterActiveChanged: t }), t();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.toggleCss("ag-header-cell-wrap-text", t);
    };
    e(), this.setRefreshFunction("wrapText", e);
  }
  onHeaderHighlightChanged() {
    const e = this.column.getHighlighted(), t = e === 0, s = e === 1;
    this.comp.toggleCss("ag-header-highlight-before", t), this.comp.toggleCss("ag-header-highlight-after", s);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: s, beans: i } = this, o = Za(this.beans), n = o.reduce((c, u) => c += u, 0) === 0;
    if (s.toggleCss("ag-header-parent-hidden", n), !t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), s.toggleCss("ag-header-span-height", !1), s.toggleCss("ag-header-span-total", !1);
      return;
    }
    const { numberOfParents: r, isSpanningTotal: a } = this.column.getColumnGroupPaddingInfo();
    s.toggleCss("ag-header-span-height", r > 0);
    const l = Qa(i);
    if (r === 0) {
      s.toggleCss("ag-header-span-total", !1), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${l}px`);
      return;
    }
    s.toggleCss("ag-header-span-total", a);
    let d = 0;
    for (let c = 0; c < r; c++)
      d += o[o.length - 1 - c];
    e.style.setProperty("top", `${-d}px`), e.style.setProperty("height", `${l + d}px`);
  }
  refreshAriaSort() {
    var e;
    if (this.sortable) {
      const t = this.getLocaleTextFunc(), s = ((e = this.beans.sortSvc) == null ? void 0 : e.getDisplaySortForColumn(this.column)) || null;
      this.comp.setAriaSort(jf(s)), this.setAriaDescriptionProperty("sort", t("ariaSortableColumn", "Press ENTER to sort"));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !fe(this.gos)) {
      const e = this.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        e("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else
      this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    var t;
    if (!this.eGui.contains(te(this.beans)))
      return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((s, i) => s === "filter" ? -1 : i.charCodeAt(0) - s.charCodeAt(0)).map((s) => this.ariaDescriptionProperties.get(s)).join(". ");
    (t = this.beans.ariaAnnounce) == null || t.announceValue(e, "columnHeader");
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener(e) {
    var t;
    (t = this.beans.colHover) == null || t.addHeaderColumnHoverListener(e, this.comp, this.column);
  }
  addActiveHeaderMouseListeners(e) {
    const t = (o) => this.handleMouseOverChange(o.type === "mouseenter"), s = () => {
      this.setActiveHeader(!0), this.dispatchColumnMouseEvent("columnHeaderClicked", this.column);
    }, i = (o) => this.handleContextMenuMouseEvent(o, void 0, this.column);
    e.addManagedListeners(this.eGui, {
      mouseenter: t,
      mouseleave: t,
      click: s,
      contextmenu: i
    });
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e), this.eventSvc.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    });
  }
  setActiveHeader(e) {
    this.comp.toggleCss("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return Xl(t) ? t.getAnchorElementForMenu(e) : this.eGui;
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), super.destroy();
  }
};
function Xl(e) {
  return typeof (e == null ? void 0 : e.getAnchorElementForMenu) == "function" && typeof e.onMenuKeyboardShortcut == "function";
}
var Pw = 0, fr = class extends S {
  constructor(e, t, s) {
    super(), this.rowIndex = e, this.pinned = t, this.type = s, this.instanceId = Pw++, this.allCtrls = [];
    const i = s == "group" ? "ag-header-row-column-group" : s == "filter" ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.headerRowClass = `ag-header-row ${i}`;
  }
  postConstruct() {
    this.isPrintLayout = xe(this.gos, "print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    return this.comp ? this.allCtrls.every((e) => e.eGui != null) : !1;
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(e, t, s = !0) {
    this.comp = e, t = So(this, this.beans.context, t), s && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners(t);
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners(e) {
    const t = this.onRowHeightChanged.bind(this), s = this.onDisplayedColumnsChanged.bind(this);
    e.addManagedEventListeners({
      columnResized: this.setWidth.bind(this),
      displayedColumnsChanged: s,
      virtualColumnsChanged: (i) => this.onVirtualColumnsChanged(i.afterScroll),
      columnGroupHeaderHeightChanged: t,
      columnHeaderHeightChanged: t,
      gridStylesChanged: t,
      advancedFilterEnabledChanged: t
    }), e.addManagedPropertyListener("domLayout", s), e.addManagedPropertyListener("ensureDomOrder", (i) => this.isEnsureDomOrder = i.currentValue), e.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      t
    );
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = xe(this.gos, "print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { visibleCols: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    const { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    const { filterManager: e } = this.beans, t = [], s = Za(this.beans), i = Qa(this.beans);
    t.push(...s), t.push(i), e != null && e.hasFloatingFilters() && t.push(fh(this.beans));
    let o = 0;
    for (let r = 0; r < this.rowIndex; r++)
      o += t[r];
    const n = t[this.rowIndex];
    return { topOffset: o, rowHeight: n };
  }
  onVirtualColumnsChanged(e = !1) {
    const t = this.getUpdatedHeaderCtrls(), s = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, s, e);
  }
  /**
   * Recycles the header cell ctrls and creates new ones for the columns in the viewport
   * @returns The updated header cell ctrls
   */
  getUpdatedHeaderCtrls() {
    const e = this.ctrlsById;
    this.ctrlsById = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const i of t)
      this.recycleAndCreateHeaderCtrls(i, this.ctrlsById, e);
    const s = (i) => {
      const { focusSvc: o, visibleCols: n } = this.beans;
      return o.isHeaderWrapperFocused(i) ? n.isVisible(i.column) : !1;
    };
    if (e)
      for (const [i, o] of e)
        s(o) ? this.ctrlsById.set(i, o) : this.destroyBean(o);
    return this.allCtrls = Array.from(this.ctrlsById.values()), this.allCtrls;
  }
  /** Get the current header cell ctrls */
  getHeaderCellCtrls() {
    return this.allCtrls;
  }
  recycleAndCreateHeaderCtrls(e, t, s) {
    if (e.isEmptyGroup())
      return;
    const i = e.getUniqueId();
    let o;
    if (s && (o = s.get(i), s.delete(i)), o && o.column != e && (this.destroyBean(o), o = void 0), o == null)
      switch (this.type) {
        case "filter": {
          o = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerFilterCellCtrl",
              !0,
              e,
              this
            )
          );
          break;
        }
        case "group":
          o = this.createBean(
            this.beans.registry.createDynamicBean(
              "headerGroupCellCtrl",
              !0,
              e,
              this
            )
          );
          break;
        default:
          o = this.createBean(new Fw(e, this));
          break;
      }
    t.set(i, o);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null)
      return [];
    let e = [];
    const t = this.getActualDepth(), { colViewport: s } = this.beans;
    return ["left", null, "right"].forEach((i) => {
      const o = s.getHeadersToRender(i, t);
      e = e.concat(o);
    }), e;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.colViewport.getHeadersToRender(this.pinned, this.getActualDepth());
  }
  focusHeader(e, t) {
    const s = this.allCtrls.find((o) => o.column == e);
    return s ? s.focus(t) : !1;
  }
  destroy() {
    this.allCtrls = this.destroyBeans(this.allCtrls), this.ctrlsById = void 0, super.destroy();
  }
}, Dw = class extends S {
  constructor(e) {
    super(), this.pinned = e, this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [];
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t;
    const { pinnedCols: s, ctrlsSvc: i, colModel: o, colMoves: n, filterManager: r } = this.beans;
    this.setupCenterWidth(), s == null || s.setupHeaderPinnedWidth(this), this.setupDragAndDrop(n, this.eViewport);
    const a = this.onDisplayedColumnsChanged.bind(this, r);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      displayedColumnsChanged: a,
      advancedFilterEnabledChanged: a
    });
    const l = `${typeof this.pinned == "string" ? this.pinned : "center"}Header`;
    i.register(l, this), o.ready && this.refresh();
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  refresh(e = !1) {
    const { focusSvc: t, colModel: s, filterManager: i } = this.beans;
    let o = 0;
    const n = t.getFocusHeaderToUseAfterRefresh(), r = () => {
      const c = hw(s) - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let u = 0; u < c; u++) {
        const h = this.createBean(new fr(o++, this.pinned, "group"));
        this.groupsRowCtrls.push(h);
      }
    }, a = () => {
      const c = o++, u = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.rowIndex !== c);
      (u || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), u && (this.columnsRowCtrl = this.createBean(new fr(c, this.pinned, "column")));
    }, l = () => {
      this.includeFloatingFilter = !!(i != null && i.hasFloatingFilters()) && !this.hidden;
      const c = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        c();
        return;
      }
      const u = o++;
      if (this.filtersRowCtrl) {
        const h = this.filtersRowCtrl.rowIndex !== u;
        (!e || h) && c();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(new fr(u, this.pinned, "filter")));
    };
    r(), a(), l();
    const d = this.getAllCtrls();
    this.comp.setCtrls(d), this.restoreFocusOnHeader(t, n);
  }
  getHeaderCtrlForColumn(e) {
    const t = (s) => s == null ? void 0 : s.getHeaderCellCtrls().find((i) => i.column === e);
    if (wt(e))
      return t(this.columnsRowCtrl);
    if (this.groupsRowCtrls.length !== 0)
      for (let s = 0; s < this.groupsRowCtrls.length; s++) {
        const i = t(this.groupsRowCtrls[s]);
        if (i)
          return i;
      }
  }
  getHtmlElementForColumnHeader(e) {
    var t;
    return ((t = this.getHeaderCtrlForColumn(e)) == null ? void 0 : t.eGui) ?? null;
  }
  getRowType(e) {
    var t;
    return (t = this.getAllCtrls()[e]) == null ? void 0 : t.type;
  }
  focusHeader(e, t, s) {
    const o = this.getAllCtrls()[e];
    return o ? o.focusHeader(t, s) : !1;
  }
  getGroupRowCount() {
    return this.groupsRowCtrls.length;
  }
  getGroupRowCtrlAtIndex(e) {
    return this.groupsRowCtrls[e];
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.eViewport, { scroll: e });
  }
  destroy() {
    this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl), this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl), this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls), super.destroy();
  }
  setupDragAndDrop(e, t) {
    const s = e == null ? void 0 : e.createBodyDropTarget(this.pinned, t);
    s && this.createManagedBean(s);
  }
  restoreFocusOnHeader(e, t) {
    if (!t)
      return;
    const { column: s } = t;
    s.getPinned() == this.pinned && e.focusHeaderPosition({ headerPosition: t });
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(!0);
  }
  onDisplayedColumnsChanged(e) {
    const t = !!(e != null && e.hasFloatingFilters()) && !this.hidden;
    this.includeFloatingFilter !== t && this.refresh(!0);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new Ya((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
}, Mw = class extends S {
  constructor() {
    super(...arguments), this.beanName = "menuSvc";
  }
  postConstruct() {
    const { enterpriseMenuFactory: e, filterMenuFactory: t } = this.beans;
    this.activeMenuFactory = e ?? t;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    const { enterpriseMenuFactory: t, filterMenuFactory: s } = this.beans, i = t && fe(this.gos) ? t : s;
    this.showColumnMenuCommon(i, e, e.containerType, !0);
  }
  showHeaderContextMenu(e, t, s) {
    var i;
    (i = this.activeMenuFactory) == null || i.showMenuAfterContextMenuEvent(e, t, s);
  }
  hidePopupMenu() {
    var e, t;
    (e = this.beans.contextMenuSvc) == null || e.hideActiveMenu(), (t = this.activeMenuFactory) == null || t.hideActiveMenu();
  }
  isColumnMenuInHeaderEnabled(e) {
    var s;
    const { suppressHeaderMenuButton: t } = e.getColDef();
    return !t && !!((s = this.activeMenuFactory) != null && s.isMenuEnabled(e)) && (fe(this.gos) || !!this.beans.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    var t;
    return !e.getColDef().suppressHeaderFilterButton && !!((t = this.beans.filterManager) != null && t.isFilterAllowed(e));
  }
  isHeaderContextMenuEnabled(e) {
    const t = e && wt(e) ? e.getColDef() : e == null ? void 0 : e.getColGroupDef();
    return !(t != null && t.suppressHeaderContextMenu) && this.gos.get("columnMenu") === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(As() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !fe(this.gos) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    var t;
    return !!((t = this.beans.filterManager) != null && t.isFilterAllowed(e)) && !fe(this.gos) && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFloatingFilterButtonEnabled(e) {
    return !e.getColDef().suppressFloatingFilterButton;
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos, t = e.get("suppressMenuHide");
    return fe(e) ? e.exists("suppressMenuHide") ? t : !1 : t;
  }
  showColumnMenuCommon(e, t, s, i) {
    const { positionBy: o, onClosedCallback: n } = t, r = t.column;
    if (o === "button") {
      const { buttonElement: a } = t;
      e == null || e.showMenuAfterButtonClick(r, a, s, n, i);
    } else if (o === "mouse") {
      const { mouseEvent: a } = t;
      e == null || e.showMenuAfterMouseEvent(r, a, s, n, i);
    } else if (r) {
      const a = this.beans, l = a.ctrlsSvc;
      l.getScrollFeature().ensureColumnVisible(r, "auto"), Ct(a, () => {
        var c;
        const d = (c = l.getHeaderRowContainerCtrl(r.getPinned())) == null ? void 0 : c.getHeaderCtrlForColumn(r);
        d && (e == null || e.showMenuAfterButtonClick(
          r,
          d.getAnchorElementForMenu(i),
          s,
          n,
          i
        ));
      });
    }
  }
};
function Dn(e, t, s) {
  e.menuVisible !== t && (e.menuVisible = t, e.dispatchColEvent("menuVisibleChanged", s));
}
var vh = class extends L {
  constructor() {
    super();
  }
}, Ew = {
  tag: "span",
  cls: "ag-overlay-loading-center",
  attrs: { "aria-live": "polite", "aria-atomic": "true" }
}, Aw = class extends vh {
  init() {
    var t;
    const e = ls((t = this.gos.get("overlayLoadingTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(e ?? Ew), !e) {
      const s = this.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = s("loadingOoo", "Loading...");
      });
    }
  }
}, Iw = { tag: "span", cls: "ag-overlay-no-rows-center" }, Tw = class extends vh {
  init() {
    var t;
    const e = ls((t = this.gos.get("overlayNoRowsTemplate")) == null ? void 0 : t.trim());
    if (this.setTemplate(e ?? Iw), !e) {
      const s = this.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = s("noRowsToShow", "No Rows To Show");
      });
    }
  }
};
function ho(e, t, s) {
  const i = k(e, t, s);
  if (i) {
    const { className: n } = i;
    if (typeof n == "string" && n.indexOf("ag-icon") > -1 || typeof n == "object" && n["ag-icon"])
      return i;
  }
  const o = _({ tag: "span" });
  return o.appendChild(i), o;
}
function k(e, t, s) {
  var n;
  let i = null;
  e === "smallDown" ? P(262) : e === "smallLeft" ? P(263) : e === "smallRight" && P(264);
  const o = s && s.getColDef().icons;
  if (o && (i = o[e]), t.gos && !i) {
    const r = t.gos.get("icons");
    r && (i = r[e]);
  }
  if (i) {
    let r;
    if (typeof i == "function")
      r = i();
    else if (typeof i == "string")
      r = i;
    else {
      P(38, { iconName: e });
      return;
    }
    if (typeof r == "string")
      return Aa(r);
    if (On(r))
      return r;
    P(133, { iconName: e });
    return;
  } else {
    const r = t.registry.getIcon(e);
    return r || (n = t.validation) == null || n.validateIcon(e), _({
      tag: "span",
      cls: `ag-icon ag-icon-${r ?? e}`,
      role: "presentation",
      attrs: { unselectable: "on" }
    });
  }
}
var Lw = (
  /*css*/
  ".ag-dnd-ghost{align-items:center;background-color:var(--ag-drag-and-drop-image-background-color);border:var(--ag-drag-and-drop-image-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-drag-and-drop-image-shadow);color:var(--ag-text-color);cursor:move;display:flex;font-weight:500;gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;padding-left:var(--ag-cell-horizontal-padding);padding-right:var(--ag-cell-horizontal-padding);text-overflow:ellipsis;transform:translateY(calc(var(--ag-spacing)*2));white-space:nowrap}"
), kw = {
  tag: "div",
  children: [
    {
      tag: "div",
      ref: "eGhost",
      cls: "ag-dnd-ghost ag-unselectable",
      children: [
        { tag: "span", ref: "eIcon", cls: "ag-dnd-ghost-icon ag-shake-left-to-right" },
        { tag: "div", ref: "eLabel", cls: "ag-dnd-ghost-label" }
      ]
    }
  ]
}, Gw = class extends L {
  constructor() {
    super(), this.dragSource = null, this.eIcon = x, this.eLabel = x, this.eGhost = x, this.registerCSS(Lw);
  }
  postConstruct() {
    const e = (t) => ho(t, this.beans, null);
    this.dropIconMap = {
      pinned: e("columnMovePin"),
      hide: e("columnMoveHide"),
      move: e("columnMoveMove"),
      left: e("columnMoveLeft"),
      right: e("columnMoveRight"),
      group: e("columnMoveGroup"),
      aggregate: e("columnMoveValue"),
      pivot: e("columnMovePivot"),
      notAllowed: e("dropNotAllowed")
    };
  }
  init(e) {
    this.dragSource = e.dragSource, this.setTemplate(kw), this.beans.environment.applyThemeClasses(this.eGhost);
  }
  destroy() {
    this.dragSource = null, super.destroy();
  }
  setIcon(e, t) {
    const { eIcon: s, dragSource: i, dropIconMap: o, gos: n } = this;
    de(s);
    let r = null;
    e || (e = i != null && i.getDefaultIconName ? i.getDefaultIconName() : "notAllowed"), r = o[e], s.classList.toggle("ag-shake-left-to-right", t), !(r === o.hide && n.get("suppressDragLeaveHidesColumns")) && r && s.appendChild(r);
  }
  setLabel(e) {
    this.eLabel.textContent = e;
  }
}, Ow = (
  /*css*/
  ".ag-label{white-space:nowrap}:where(.ag-ltr) .ag-label{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-label-align-right) .ag-label{order:1}:where(.ag-ltr) :where(.ag-label-align-right) .ag-label{margin-left:var(--ag-spacing)}:where(.ag-rtl) :where(.ag-label-align-right) .ag-label{margin-right:var(--ag-spacing)}.ag-label-align-right>*{flex:none}.ag-label-align-top{align-items:flex-start;flex-direction:column;>*{align-self:stretch}}.ag-label-ellipsis{flex:1;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-label-align-top) .ag-label{margin-bottom:calc(var(--ag-spacing)*.5)}"
), Bw = class extends L {
  constructor(e, t, s) {
    super(t, s), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {}, this.registerCSS(Ow);
  }
  postConstruct() {
    this.addCss("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: s, labelAlignment: i, disabled: o } = this.config;
    o != null && this.setDisabled(o), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), s != null && this.setLabelWidth(s), this.setLabelAlignment(i || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    const { label: e, eLabel: t } = this;
    de(t), typeof e == "string" ? t.innerText = e + this.labelSeparator : e && t.appendChild(e), e === "" ? (G(t, !1), Ne(t, "presentation")) : (G(t, !0), Ne(t, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    const e = this.eLabel;
    return e.id = e.id || `ag-${this.getCompId()}-label`, e.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const s = this.getGui().classList;
    return s.toggle("ag-label-align-left", e === "left"), s.toggle("ag-label-align-right", e === "right"), s.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (hn(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return so(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}, wh = class extends Bw {
  constructor(e, t, s, i) {
    super(e, t, s), this.className = i;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: s } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), s != null && this.onValueChange(s), this.className && this.addCss(this.className), this.refreshAriaLabelledBy();
  }
  setLabel(e) {
    return super.setLabel(e), this.refreshAriaLabelledBy(), this;
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId(), s = this.getLabel();
    s == null || s == "" || Kf(e) !== null ? to(e, "") : to(e, t ?? "");
  }
  setAriaLabel(e) {
    return Ee(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListeners(this, { fieldValueChanged: () => e(this.getValue()) }), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return Et(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
};
function Nw(e) {
  return {
    tag: "div",
    role: "presentation",
    children: [
      { tag: "div", ref: "eLabel", cls: "ag-input-field-label" },
      {
        tag: "div",
        ref: "eWrapper",
        cls: "ag-wrapper ag-input-wrapper",
        role: "presentation",
        children: [{ tag: e, ref: "eInput", cls: "ag-input-field-input" }]
      }
    ]
  };
}
var ii = class extends wh {
  constructor(e, t, s = "text", i = "input") {
    super(e, (e == null ? void 0 : e.template) ?? Nw(i), [], t), this.inputType = s, this.displayFieldTag = i, this.eLabel = x, this.eWrapper = x, this.eInput = x;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType();
    const { eLabel: e, eWrapper: t, eInput: s, className: i } = this;
    e.classList.add(`${i}-label`), t.classList.add(`${i}-input-wrapper`), s.classList.add(`${i}-input`), this.addCss("ag-input-field"), s.id = s.id || `ag-${this.getCompId()}-input`;
    const { inputName: o, inputWidth: n } = this.config;
    o != null && this.setInputName(o), n != null && this.setInputWidth(n), this.addInputListeners(), this.activateTabIndex([s]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return hn(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return ai(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return Ee(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return so(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === !0)
      ai(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      ai(this.eInput, "autocomplete", t);
    }
    return this;
  }
}, $n = class extends ii {
  constructor(e, t = "ag-checkbox", s = "checkbox") {
    super(e, t, s), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) }), this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    if (this.isSelected() === e)
      return;
    this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0;
    const s = this.eInput;
    s.checked = e, s.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue);
  }
  dispatchChange(e, t, s) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected: e, previousValue: t, event: s });
    const i = this.getInputElement();
    this.eventSvc.dispatchEvent({
      type: "checkboxChanged",
      id: i.id,
      name: i.name,
      selected: e,
      previousValue: t
    });
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), s = this.selected = e.target.checked;
    this.refreshSelectedClass(s), this.dispatchChange(s, t, e);
  }
  refreshSelectedClass(e) {
    const t = this.eWrapper.classList;
    t.toggle("ag-checked", e === !0), t.toggle("ag-indeterminate", e == null);
  }
}, Ii = {
  selector: "AG-CHECKBOX",
  component: $n
}, Hw = (
  /*css*/
  ".ag-checkbox-cell{height:100%}"
), Vw = {
  tag: "div",
  cls: "ag-cell-wrapper ag-checkbox-cell",
  role: "presentation",
  children: [
    {
      tag: "ag-checkbox",
      ref: "eCheckbox",
      role: "presentation"
    }
  ]
}, _w = class extends L {
  constructor() {
    super(Vw, [Ii]), this.eCheckbox = x, this.registerCSS(Hw);
  }
  init(e) {
    this.refresh(e);
    const { eCheckbox: t, beans: s } = this, i = t.getInputElement();
    i.setAttribute("tabindex", "-1"), Gc(i, "polite"), this.addManagedListeners(i, {
      click: (o) => {
        if (vt(o), t.isDisabled())
          return;
        const n = t.getValue();
        this.onCheckboxChanged(n);
      },
      dblclick: (o) => {
        vt(o);
      }
    }), this.addManagedElementListeners(e.eGridCell, {
      keydown: (o) => {
        if (o.key === y.SPACE && !t.isDisabled()) {
          e.eGridCell === te(s) && t.toggle();
          const n = t.getValue();
          this.onCheckboxChanged(n), o.preventDefault();
        }
      }
    });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), !0;
  }
  updateCheckbox(e) {
    let t, s = !0;
    const { value: i, column: o, node: n } = e;
    if (n.group && o)
      if (typeof i == "boolean")
        t = i;
      else {
        const u = o.getColId();
        u.startsWith(Ri) ? t = i == null || i === "" ? void 0 : i === "true" : n.aggData && n.aggData[u] !== void 0 ? t = i ?? void 0 : s = !1;
      }
    else
      t = i ?? void 0;
    const { eCheckbox: r } = this;
    if (!s) {
      r.setDisplayed(!1);
      return;
    }
    r.setValue(t);
    const a = e.disabled ?? !(o != null && o.isCellEditable(n));
    r.setDisabled(a);
    const l = this.getLocaleTextFunc(), d = Hc(l, t), c = a ? d : `${l("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${d})`;
    r.setInputAriaLabel(c);
  }
  onCheckboxChanged(e) {
    const { eventSvc: t, params: s } = this, { column: i, node: o, value: n } = s, r = {
      column: i,
      colDef: i.getColDef(),
      data: o.data,
      node: o,
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      value: n
    };
    t.dispatchEvent({
      type: "cellEditingStarted",
      ...r
    });
    const a = o.setDataValue(i, e, "edit");
    t.dispatchEvent({
      type: "cellEditingStopped",
      ...r,
      oldValue: n,
      newValue: e,
      valueChanged: a
    }), a || this.updateCheckbox(s);
  }
}, Ww = "ROOT_NODE_ID", zw = class extends S {
  constructor() {
    super(...arguments), this.nextId = 0, this.allNodesMap = {}, this.rootNode = null;
  }
  get treeData() {
    return !1;
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  extractRowData() {
    var e, t;
    return (t = (e = this.rootNode) == null ? void 0 : e.allLeafChildren) == null ? void 0 : t.map((s) => s.data);
  }
  activate(e) {
    this.rootNode = e, e.group = !0, e.level = -1, e.id = Ww, e.allLeafChildren = [], e.childrenAfterGroup = [], e.childrenAfterSort = [], e.childrenAfterAggFilter = [], e.childrenAfterFilter = [], this.updateRootSiblingArrays(e);
  }
  deactivate() {
    this.rootNode && (this.allNodesMap = {}, this.rootNode = null);
  }
  destroy() {
    super.destroy(), this.allNodesMap = {}, this.rootNode = null;
  }
  setNewRowData(e) {
    const t = this.rootNode;
    t && (this.dispatchRowDataUpdateStartedEvent(e), t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.allNodesMap = {}, this.nextId = 0, this.loadNewRowData(e), this.updateRootSiblingArrays(t));
  }
  updateRootSiblingArrays(e) {
    const t = e.sibling;
    t && (t.childrenAfterFilter = e.childrenAfterFilter, t.childrenAfterGroup = e.childrenAfterGroup, t.childrenAfterAggFilter = e.childrenAfterAggFilter, t.childrenAfterSort = e.childrenAfterSort, t.childrenMapped = e.childrenMapped, t.allLeafChildren = e.allLeafChildren);
  }
  loadNewRowData(e) {
    this.rootNode.allLeafChildren = (e == null ? void 0 : e.map((t, s) => this.createRowNode(t, s))) ?? [];
  }
  setImmutableRowData(e, t) {
    var p;
    const s = ro(this.gos), i = !this.gos.get("suppressMaintainUnsortedOrder"), o = e.changedRowNodes, n = /* @__PURE__ */ new Set(), r = this.rootNode, a = r.allLeafChildren, l = a.length;
    let d = !1, c = !1, u = !1, h = !1;
    for (let f = 0, m = -1, b = t.length; f < b; f++) {
      const w = t[f];
      let C = this.getRowNode(
        s({ data: w, level: 0 })
      );
      if (!C)
        d = !0, C = this.createRowNode(w, -1), o.add(C);
      else {
        if (i) {
          const v = C.sourceRowIndex;
          h || (h = v <= m || // A node was moved up, so order changed
          d), m = v;
        }
        C.data !== w && (u = !0, C.updateData(w), o.update(C));
      }
      n.add(C);
    }
    const g = [];
    for (let f = 0; f < l; f++) {
      const m = a[f];
      n.has(m) || (c = !0, m.isSelected() && g.push(m), m.pinnedSibling && ((p = this.beans.pinnedRowModel) == null || p.pinRow(m.pinnedSibling, null)), this.rowNodeDeleted(m), o.remove(m));
    }
    if (d || c || h) {
      const f = new Array(n.size);
      let m = 0;
      if (!i)
        for (let w = 0; w < l; ++w) {
          const C = a[w];
          n.delete(C) && (C.sourceRowIndex = m, f[m++] = C);
        }
      for (const w of n)
        w.sourceRowIndex = m, f[m++] = w;
      r.allLeafChildren = f;
      const b = r.sibling;
      b && (b.allLeafChildren = f), e.rowNodesOrderChanged || (e.rowNodesOrderChanged = h);
    }
    (d || c || h || u) && (this.deselectNodes(g), e.rowDataUpdated = !0);
  }
  /** Called when a node needs to be deleted */
  rowNodeDeleted(e) {
    e.clearRowTopAndRowIndex();
    const t = e.id, s = this.allNodesMap;
    s[t] === e && delete s[t];
  }
  updateRowData(e, t) {
    this.dispatchRowDataUpdateStartedEvent(e.add);
    const s = {
      changedRowNodes: t,
      rowNodeTransaction: { remove: [], update: [], add: [] },
      rowsInserted: !1
    }, i = [], o = ro(this.gos);
    return this.executeRemove(o, e, s, i), this.executeUpdate(o, e, s, i), this.executeAdd(e, s), this.deselectNodes(i), s;
  }
  executeAdd(e, t) {
    const s = e.add;
    if (!(s != null && s.length))
      return;
    let i = this.rootNode.allLeafChildren, o = i.length;
    if (typeof e.addIndex == "number" && (o = this.sanitizeAddIndex(e.addIndex), o > 0 && this.gos.get("treeData") && this.gos.get("getDataPath")))
      for (let u = 0; u < i.length; u++) {
        const h = i[u];
        if ((h == null ? void 0 : h.rowIndex) == o - 1) {
          o = u + 1;
          break;
        }
      }
    const n = s.length, r = t.changedRowNodes, a = new Array(n);
    for (let c = 0; c < n; c++) {
      const u = this.createRowNode(s[c], o + c);
      r.add(u), a[c] = u;
    }
    const l = this.rootNode;
    if (o < i.length) {
      const c = i.slice(0, o), u = i.slice(o, i.length), h = c.length + a.length;
      for (let g = 0, p = u.length; g < p; ++g)
        u[g].sourceRowIndex = h + g;
      i = [...c, ...a, ...u], t.rowsInserted = !0;
    } else
      i = i.concat(a);
    l.allLeafChildren = i;
    const d = l.sibling;
    d && (d.allLeafChildren = i), t.rowNodeTransaction.add = a;
  }
  executeRemove(e, t, { changedRowNodes: s, rowNodeTransaction: i }, o) {
    var d, c;
    const { remove: n } = t;
    if (!(n != null && n.length))
      return;
    const r = {};
    n.forEach((u) => {
      var g;
      const h = this.lookupRowNode(e, u);
      h && (h.isSelected() && o.push(h), h.pinnedSibling && ((g = this.beans.pinnedRowModel) == null || g.pinRow(h.pinnedSibling, null)), h.clearRowTopAndRowIndex(), r[h.id] = !0, delete this.allNodesMap[h.id], i.remove.push(h), s.remove(h));
    });
    const a = this.rootNode;
    a.allLeafChildren = ((d = a.allLeafChildren) == null ? void 0 : d.filter((u) => !r[u.id])) ?? null, (c = a.allLeafChildren) == null || c.forEach((u, h) => {
      u.sourceRowIndex = h;
    });
    const l = a.sibling;
    l && (l.allLeafChildren = a.allLeafChildren);
  }
  executeUpdate(e, t, { changedRowNodes: s, rowNodeTransaction: i }, o) {
    const { update: n } = t;
    n != null && n.length && n.forEach((r) => {
      const a = this.lookupRowNode(e, r);
      a && (a.updateData(r), !a.selectable && a.isSelected() && o.push(a), i.update.push(a), s.update(a));
    });
  }
  dispatchRowDataUpdateStartedEvent(e) {
    this.eventSvc.dispatchEvent({
      type: "rowDataUpdateStarted",
      firstRowData: e != null && e.length ? e[0] : null
    });
  }
  deselectNodes(e) {
    var o;
    const t = "rowDataChanged", s = this.beans.selectionSvc, i = e.length > 0;
    i && (s == null || s.setNodesSelected({
      newValue: !1,
      nodes: e,
      suppressFinishActions: !0,
      source: t
    })), (o = s == null ? void 0 : s.updateGroupsFromChildrenSelections) == null || o.call(s, t), i && this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source: t,
      selectedNodes: (s == null ? void 0 : s.getSelectedNodes()) ?? null,
      serverSideState: null
    });
  }
  sanitizeAddIndex(e) {
    var s;
    const t = ((s = this.rootNode.allLeafChildren) == null ? void 0 : s.length) ?? 0;
    return e < 0 || e >= t || Number.isNaN(e) ? t : Math.ceil(e);
  }
  createRowNode(e, t) {
    const s = new Us(this.beans);
    return s.parent = this.rootNode, s.level = 0, s.group = !1, s.expanded = !1, s.sourceRowIndex = t, s.setDataAndId(e, String(this.nextId)), this.allNodesMap[s.id] && P(2, { nodeId: s.id }), this.allNodesMap[s.id] = s, this.nextId++, s;
  }
  lookupRowNode(e, t) {
    var i, o;
    let s;
    if (e) {
      const n = e({ data: t, level: 0 });
      if (s = this.allNodesMap[n], !s)
        return K(4, { id: n }), null;
    } else if (s = (o = (i = this.rootNode) == null ? void 0 : i.allLeafChildren) == null ? void 0 : o.find((n) => n.data === t), !s)
      return K(5, { data: t }), null;
    return s || null;
  }
}, Ft = /* @__PURE__ */ ((e) => (e.Applied = "Applied", e.StoreNotFound = "StoreNotFound", e.StoreLoading = "StoreLoading", e.StoreWaitingToLoad = "StoreWaitingToLoad", e.StoreLoadingFailed = "StoreLoadingFailed", e.StoreWrongType = "StoreWrongType", e.Cancelled = "Cancelled", e.StoreNotStarted = "StoreNotStarted", e))(Ft || {}), Uw = {
  tag: "div",
  cls: "ag-selection-checkbox",
  role: "presentation",
  children: [
    {
      tag: "ag-checkbox",
      ref: "eCheckbox",
      role: "presentation"
    }
  ]
}, jw = class extends L {
  constructor() {
    super(Uw, [Ii]), this.eCheckbox = x;
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.getLocaleTextFunc(), { rowNode: t, eCheckbox: s } = this, i = t.isSelected(), o = Hc(e, i), [n, r] = t.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], a = e(n, r);
    s.setValue(i, !0), s.setInputAriaLabel(`${a} (${o})`);
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListeners(this.eCheckbox.getInputElement(), {
      // we don't want double click on this icon to open a group
      dblclick: vt,
      click: (i) => {
        var o;
        vt(i), (o = this.beans.selectionSvc) == null || o.handleSelectionEvent(i, this.rowNode, "checkboxSelected");
      }
    }), this.addManagedListeners(this.rowNode, {
      rowSelected: this.onSelectionChanged.bind(this),
      dataChanged: this.onDataChanged.bind(this),
      selectableChanged: this.onSelectableChanged.bind(this)
    }), this.addManagedPropertyListener("rowSelection", ({ currentValue: i, previousValue: o }) => {
      const n = typeof i == "object" ? lr(i) : void 0, r = typeof o == "object" ? lr(o) : void 0;
      n !== r && this.onSelectableChanged();
    }), Kr(this.gos) || typeof this.getIsVisible() == "function") {
      const i = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: i }), this.addManagedListeners(this.rowNode, {
        dataChanged: i,
        cellChanged: i
      }), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  showOrHideSelect() {
    const { column: e, rowNode: t, overrides: s, gos: i } = this;
    let o = t.selectable;
    const n = this.getIsVisible();
    if (o)
      if (typeof n == "function") {
        const l = s == null ? void 0 : s.callbackParams;
        if (!e)
          o = n({ ...l, node: t, data: t.data });
        else {
          const d = e.createColumnFunctionCallbackParams(t);
          o = n({ ...l, ...d });
        }
      } else
        o = n ?? !1;
    const r = i.get("rowSelection");
    if (r && typeof r != "string" ? !lr(r) : e == null ? void 0 : e.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!o), this.setVisible(!0), this.setDisplayed(!0);
      return;
    }
    if (s != null && s.removeHidden) {
      this.setDisplayed(o);
      return;
    }
    this.setVisible(o);
  }
  getIsVisible() {
    var s, i;
    const e = this.overrides;
    if (e)
      return e.isVisible;
    const t = this.gos.get("rowSelection");
    return t && typeof t != "string" ? Ts(t) : (i = (s = this.column) == null ? void 0 : s.getColDef()) == null ? void 0 : i.checkboxSelection;
  }
}, $w = class {
  constructor(e, t) {
    this.rowModel = e, this.pinnedRowModel = t, this.selectAll = !1, this.rootId = null, this.endId = null, this.cachedRange = [];
  }
  reset() {
    this.rootId = null, this.endId = null, this.cachedRange.length = 0;
  }
  setRoot(e) {
    this.rootId = e.id, this.endId = null, this.cachedRange.length = 0;
  }
  setEndRange(e) {
    this.endId = e.id, this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const e = this.getRoot(), t = this.getEnd();
      if (e == null || t == null)
        return this.cachedRange;
      this.cachedRange = this.getNodesInRange(e, t) ?? [];
    }
    return this.cachedRange;
  }
  isInRange(e) {
    return this.rootId === null ? !1 : this.getRange().some((t) => t.id === e.id);
  }
  getRoot(e) {
    if (this.rootId)
      return this.getRowNode(this.rootId);
    if (e)
      return this.setRoot(e), e;
  }
  getEnd() {
    if (this.endId)
      return this.getRowNode(this.endId);
  }
  getRowNode(e) {
    let t;
    const { rowModel: s, pinnedRowModel: i } = this;
    return t ?? (t = s.getRowNode(e)), i != null && i.isManual() && (t ?? (t = i.getPinnedRowById(e, "top")), t ?? (t = i.getPinnedRowById(e, "bottom"))), t;
  }
  /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  truncate(e) {
    const t = this.getRange();
    if (t.length === 0)
      return { keep: [], discard: [] };
    const s = t[0].id === this.rootId, i = t.findIndex((o) => o.id === e.id);
    if (i > -1) {
      const o = t.slice(0, i), n = t.slice(i + 1);
      return this.setEndRange(e), s ? { keep: o, discard: n } : { keep: n, discard: o };
    } else
      return { keep: t, discard: [] };
  }
  /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  extend(e, t = !1) {
    const s = this.getRoot();
    if (s == null) {
      const o = this.getRange().slice();
      return t && e.depthFirstSearch((n) => !n.group && o.push(n)), o.push(e), this.setRoot(e), { keep: o, discard: [] };
    }
    const i = this.getNodesInRange(s, e);
    if (!i)
      return this.setRoot(e), { keep: [e], discard: [] };
    if (i.find((o) => o.id === this.endId))
      return this.setEndRange(e), { keep: this.getRange(), discard: [] };
    {
      const o = this.getRange().slice();
      return this.setEndRange(e), { keep: this.getRange(), discard: o };
    }
  }
  getNodesInRange(e, t) {
    const { pinnedRowModel: s, rowModel: i } = this;
    if (!(s != null && s.isManual()))
      return i.getNodesInRangeForSelection(e, t);
    if (e.rowPinned === "top" && !t.rowPinned)
      return Ze(s, "top", e, void 0).concat(i.getNodesInRangeForSelection(i.getRow(0), t) ?? []);
    if (e.rowPinned === "bottom" && !t.rowPinned) {
      const o = Ze(s, "bottom", void 0, e), n = i.getRowCount(), r = i.getRow(n - 1);
      return (i.getNodesInRangeForSelection(t, r) ?? []).concat(o);
    }
    if (!e.rowPinned && !t.rowPinned)
      return i.getNodesInRangeForSelection(e, t);
    if (e.rowPinned === "top" && t.rowPinned === "top")
      return Ze(s, "top", e, t);
    if (e.rowPinned === "bottom" && t.rowPinned === "top") {
      const o = Ze(s, "top", t, void 0), n = Ze(s, "bottom", void 0, e), r = i.getRow(0), a = i.getRow(i.getRowCount() - 1);
      return o.concat(i.getNodesInRangeForSelection(r, a) ?? []).concat(n);
    }
    if (!e.rowPinned && t.rowPinned === "top")
      return Ze(s, "top", t, void 0).concat(i.getNodesInRangeForSelection(i.getRow(0), e) ?? []);
    if (e.rowPinned === "top" && t.rowPinned === "bottom") {
      const o = Ze(s, "top", e, void 0), n = Ze(s, "bottom", void 0, t), r = i.getRow(0), a = i.getRow(i.getRowCount() - 1);
      return o.concat(i.getNodesInRangeForSelection(r, a) ?? []).concat(n);
    }
    if (e.rowPinned === "bottom" && t.rowPinned === "bottom")
      return Ze(s, "bottom", e, t);
    if (!e.rowPinned && t.rowPinned === "bottom") {
      const o = Ze(s, "bottom", void 0, t), n = i.getRow(i.getRowCount());
      return (i.getNodesInRangeForSelection(e, n) ?? []).concat(o);
    }
    return null;
  }
}, Kw = class extends S {
  constructor(e) {
    super(), this.column = e, this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(te(this.beans)) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e;
    const t = this.createManagedBean(new $n());
    this.cbSelectAll = t, t.addCss("ag-header-select-all"), Ne(t.getGui(), "presentation"), this.showOrHideSelectAll();
    const s = this.updateStateOfCheckbox.bind(this);
    this.addManagedEventListeners({
      newColumnsLoaded: () => this.showOrHideSelectAll(),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      selectionChanged: s,
      paginationChanged: s,
      modelUpdated: s
    }), this.addManagedPropertyListener("rowSelection", ({ currentValue: i, previousValue: o }) => {
      const n = (r) => typeof r == "string" || !r || r.mode === "singleRow" ? void 0 : r.selectAll;
      n(i) !== n(o) && this.showOrHideSelectAll(), this.updateStateOfCheckbox();
    }), this.addManagedListeners(t, { fieldValueChanged: this.onCbSelectAll.bind(this) }), t.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onDisplayedColumnsChanged(e) {
    this.isAlive() && this.showOrHideSelectAll(e.source === "uiColumnMoved");
  }
  showOrHideSelectAll(e = !1) {
    const t = this.isCheckboxSelection();
    this.cbSelectAllVisible = t, this.cbSelectAll.setDisplayed(t), t && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel(e);
  }
  updateStateOfCheckbox() {
    if (!this.cbSelectAllVisible || this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.getSelectAllMode(), t = this.beans.selectionSvc, s = this.cbSelectAll, i = t.getSelectAllState(e);
    s.setValue(i);
    const o = t.hasNodesToSelect(e);
    s.setDisabled(!o), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel(e = !1) {
    const t = this.getLocaleTextFunc(), { headerCellCtrl: s, cbSelectAll: i, cbSelectAllVisible: o } = this, r = i.getValue() ? t("ariaChecked", "checked") : t("ariaUnchecked", "unchecked"), a = t("ariaRowSelectAll", "Press Space to toggle all rows selection");
    s.setAriaDescriptionProperty(
      "selectAll",
      o ? `${a} (${r})` : null
    ), i.setInputAriaLabel(t("ariaHeaderSelection", "Column with Header Selection")), e || s.announceAriaDescription();
  }
  checkSelectionType(e) {
    return Hs(this.gos) ? !0 : (P(128, { feature: e }), !1);
  }
  checkRightRowModelType(e) {
    const { gos: t, rowModel: s } = this.beans;
    return Ke(t) || nt(t) ? !0 : (P(129, { feature: e, rowModel: s.getType() }), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue(), t = this.getSelectAllMode();
    let s = "uiSelectAll";
    t === "currentPage" ? s = "uiSelectAllCurrentPage" : t === "filtered" && (s = "uiSelectAllFiltered");
    const i = { source: s, selectAll: t }, o = this.beans.selectionSvc;
    e ? o.selectAllRowNodes(i) : o.deselectAllRowNodes(i);
  }
  /**
   * Checkbox is enabled when either the `headerCheckbox` option is enabled in the new selection API
   * or `headerCheckboxSelection` is enabled in the legacy API.
   */
  isCheckboxSelection() {
    var d;
    const { column: e, gos: t, beans: s } = this, i = t.get("rowSelection"), o = e.getColDef(), { headerCheckboxSelection: n } = o;
    let r = !1;
    const a = typeof i == "object";
    if (a) {
      const c = yo(e), u = Na(e);
      (ao(i) === "autoGroupColumn" && u || c && ((d = s.selectionColSvc) != null && d.isSelectionColumnEnabled())) && (r = jo(i));
    } else
      typeof n == "function" ? r = n(N(t, { column: e, colDef: o })) : r = !!n;
    const l = a ? "headerCheckbox" : "headerCheckboxSelection";
    return r && this.checkRightRowModelType(l) && this.checkSelectionType(l);
  }
  getSelectAllMode() {
    const e = du(this.gos, !1);
    if (e)
      return e;
    const { headerCheckboxSelectionCurrentPageOnly: t, headerCheckboxSelectionFilteredOnly: s } = this.column.getColDef();
    return t ? "currentPage" : s ? "filtered" : "all";
  }
}, qw = class extends S {
  postConstruct() {
    const { gos: e, beans: t } = this;
    this.selectionCtx = new $w(t.rowModel, t.pinnedRowModel), this.addManagedPropertyListeners(["isRowSelectable", "rowSelection"], () => {
      const s = Kr(e);
      s !== this.isRowSelectable && (this.isRowSelectable = s, this.updateSelectable());
    }), this.isRowSelectable = Kr(e);
  }
  destroy() {
    super.destroy(), this.selectionCtx.reset();
  }
  createCheckboxSelectionComponent() {
    return new jw();
  }
  createSelectAllFeature(e) {
    return new Kw(e);
  }
  isMultiSelect() {
    return Hs(this.gos);
  }
  onRowCtrlSelected(e, t, s) {
    const i = !!e.rowNode.isSelected();
    e.forEachGui(s, (o) => {
      o.rowComp.toggleCss("ag-row-selected", i);
      const n = o.element;
      Hr(n, i), n.contains(te(this.beans)) && t(o);
    });
  }
  announceAriaRowSelection(e) {
    var o;
    if (this.isRowSelectionBlocked(e))
      return;
    const t = e.isSelected();
    if (!e.selectable)
      return;
    const i = this.getLocaleTextFunc()(
      t ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${t ? "deselect" : "select"} this row`
    );
    (o = this.beans.ariaAnnounce) == null || o.announceValue(i, "rowSelection");
  }
  isRowSelectionBlocked(e) {
    return !e.selectable || e.rowPinned && !za(e) || !Dt(this.gos);
  }
  updateRowSelectable(e, t) {
    var i;
    const s = ((i = this.isRowSelectable) == null ? void 0 : i.call(this, e)) ?? !0;
    return this.setRowSelectable(e, s, t), s;
  }
  setRowSelectable(e, t, s) {
    if (e.selectable !== t) {
      if (e.selectable = t, e.dispatchRowEvent("selectableChanged"), s)
        return;
      if (lo(this.gos)) {
        const o = this.calculateSelectedFromChildren(e);
        this.setNodesSelected({ nodes: [e], newValue: o ?? !1, source: "selectableChanged" });
        return;
      }
      e.isSelected() && !e.selectable && this.setNodesSelected({ nodes: [e], newValue: !1, source: "selectableChanged" });
    }
  }
  calculateSelectedFromChildren(e) {
    var i;
    let t = !1, s = !1;
    if (!((i = e.childrenAfterGroup) != null && i.length))
      return e.selectable ? e.__selected : null;
    for (let o = 0; o < e.childrenAfterGroup.length; o++) {
      const n = e.childrenAfterGroup[o];
      let r = n.isSelected();
      if (!n.selectable) {
        const a = this.calculateSelectedFromChildren(n);
        if (a === null)
          continue;
        r = a;
      }
      switch (r) {
        case !0:
          t = !0;
          break;
        case !1:
          s = !0;
          break;
        default:
          return;
      }
    }
    if (!(t && s))
      return t ? !0 : s ? !1 : e.selectable ? e.__selected : null;
  }
  selectRowNode(e, t, s, i = "api") {
    const o = !e.selectable && t, n = e.__selected === t;
    if (o || n)
      return !1;
    e.__selected = t, e.dispatchRowEvent("rowSelected");
    const r = e.sibling;
    r && r.footer && r.__localEventService && r.dispatchRowEvent("rowSelected");
    const a = e.pinnedSibling;
    return a && a.rowPinned && a.__localEventService && a.dispatchRowEvent("rowSelected"), this.eventSvc.dispatchEvent({
      ...sh(e, this.gos, "rowSelected"),
      event: s || null,
      source: i
    }), !0;
  }
  isCellCheckboxSelection(e, t) {
    const s = this.gos.get("rowSelection");
    if (s && typeof s != "string") {
      const i = yo(e) && Ts(s);
      return e.isColumnFunc(t, i);
    } else
      return e.isColumnFunc(t, e.colDef.checkboxSelection);
  }
  inferNodeSelections(e, t, s, i) {
    const { gos: o, selectionCtx: n } = this, r = e.isSelected(), a = lo(o), l = Im(o), d = Tm(o), c = this.isMultiSelect(), u = i === "rowClicked";
    if (u && !(l || d))
      return null;
    if (t && s && c) {
      const h = n.getRoot();
      if (h)
        if (h.isSelected()) {
          const g = n.isInRange(e) ? n.truncate(e) : n.extend(e, a);
          return {
            deselect: g.discard,
            select: g.keep,
            reset: !1
          };
        } else {
          const g = n.extend(e, a);
          return {
            select: [],
            deselect: g.keep,
            reset: !1
          };
        }
      else return null;
    } else if (t && c) {
      const h = n.selectAll ? this.beans.rowModel.getRow(0) : void 0, g = n.getRoot(h), p = n.isInRange(e) ? n.truncate(e) : n.extend(e, a);
      return {
        select: p.keep,
        deselect: p.discard,
        reset: n.selectAll || !!(g && !g.isSelected())
      };
    } else if (s) {
      if (u) {
        const h = !r;
        return h && !l || !h && !d ? null : (n.setRoot(e), {
          node: e,
          newValue: h,
          clearSelection: !1
        });
      }
      return n.setRoot(e), {
        node: e,
        newValue: !r,
        clearSelection: !c
      };
    } else {
      n.setRoot(e);
      const h = Lm(o), g = lu(o) === "filteredDescendants", p = u && (!h || !l);
      if (g && r === void 0 && Ke(o))
        return {
          node: e,
          newValue: !1,
          clearSelection: !c || p
        };
      if (u) {
        const f = r ? !h : l;
        return f === r && !p || f && !l || !f && !d ? null : {
          node: e,
          newValue: f,
          clearSelection: !c || p,
          keepDescendants: e.group && a
        };
      }
      return {
        node: e,
        newValue: !r,
        clearSelection: !c || p
      };
    }
  }
}, Yw = class extends $n {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    const t = this.eInput;
    e.selected && e.name && t.name && t.name === e.name && e.id && t.id !== e.id && this.setValue(!1, !0);
  }
}, Zw = (
  /*css*/
  '.ag-toggle-button{flex:none;min-width:unset;width:unset}.ag-toggle-button-input-wrapper{background-color:var(--ag-toggle-button-off-background-color);border-radius:calc(var(--ag-toggle-button-height)*.5);flex:none;height:var(--ag-toggle-button-height);max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);position:relative;transition:background-color .1s;:where(.ag-toggle-button-input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-toggle-button-height);margin:0;max-width:var(--ag-toggle-button-width);min-width:var(--ag-toggle-button-width);opacity:0}&:before{background-color:var(--ag-toggle-button-switch-background-color);border-radius:100%;content:"";display:block;height:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2);left:var(--ag-toggle-button-switch-inset);pointer-events:none;position:absolute;top:var(--ag-toggle-button-switch-inset);transition:left .1s;width:calc(var(--ag-toggle-button-height) - var(--ag-toggle-button-switch-inset)*2)}&.ag-checked{background-color:var(--ag-toggle-button-on-background-color);&:before{left:calc(100% - var(--ag-toggle-button-height) + var(--ag-toggle-button-switch-inset))}}&:focus-within{box-shadow:var(--ag-focus-shadow)}&.ag-disabled{opacity:.5}}'
), bh = class extends $n {
  constructor(e) {
    super(e, "ag-toggle-button"), this.registerCSS(Zw);
  }
  setValue(e, t) {
    return super.setValue(e, t), this.toggleCss("ag-selected", this.getValue()), this;
  }
}, Qw = {
  selector: "AG-TOGGLE-BUTTON",
  component: bh
}, tl = class extends ii {
  constructor(e, t = "ag-text-field", s = "text") {
    super(e, t, s);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    const s = this.eInput;
    return s.value !== e && (s.value = T(e) ? e : ""), super.setValue(e, t);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (s) => {
      lh(s) && s.key && !e.test(s.key) && s.preventDefault();
    };
    this.addManagedListeners(this.eInput, {
      keydown: t,
      paste: (s) => {
        var o;
        const i = (o = s.clipboardData) == null ? void 0 : o.getData("text");
        i && i.split("").some((n) => !e.test(n)) && s.preventDefault();
      }
    });
  }
}, yh = {
  selector: "AG-INPUT-TEXT-FIELD",
  component: tl
};
function Jl(e, t) {
  return e.toString().padStart(t, "0");
}
function ed(e, t = !0, s = "-") {
  if (!e)
    return null;
  let i = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((o) => Jl(o, 2)).join(s);
  return t && (i += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map((o) => Jl(o, 2)).join(":")), i;
}
function td(e) {
  if (!e)
    return null;
  const [t, s] = e.split(" ");
  if (!t)
    return null;
  const i = t.split("-").map((u) => parseInt(u, 10));
  if (i.filter((u) => !isNaN(u)).length !== 3)
    return null;
  const [o, n, r] = i, a = new Date(o, n - 1, r);
  if (a.getFullYear() !== o || a.getMonth() !== n - 1 || a.getDate() !== r)
    return null;
  if (!s || s === "00:00:00")
    return a;
  const [l, d, c] = s.split(":").map((u) => parseInt(u, 10));
  return l >= 0 && l < 24 && a.setHours(l), d >= 0 && d < 60 && a.setMinutes(d), c >= 0 && c < 60 && a.setSeconds(c), a;
}
function Xw(e) {
  return e.get("tooltipShowMode") === "whenTruncated";
}
function sl(e, t) {
  return Xw(e) ? Sh(t) : void 0;
}
function Sh(e) {
  return () => {
    const t = e();
    return t ? t.scrollWidth > t.clientWidth : !0;
  };
}
var Jw = class extends L {
  constructor(e = "default", t = !1) {
    super({ tag: "div", cls: `ag-list ag-${e}-list` }), this.cssIdentifier = e, this.unFocusable = t, this.activeClass = "ag-active-item", this.options = [], this.itemEls = [];
  }
  postConstruct() {
    const e = this.getGui();
    this.addManagedElementListeners(e, { mouseleave: () => this.clearHighlighted() }), !this.unFocusable && this.addManagedElementListeners(e, { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case y.ENTER:
        if (!this.highlightedEl)
          this.setValue(this.getValue());
        else {
          const s = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(s);
        }
        break;
      case y.DOWN:
      case y.UP:
        e.preventDefault(), this.navigate(t);
        break;
      case y.PAGE_DOWN:
      case y.PAGE_UP:
      case y.PAGE_HOME:
      case y.PAGE_END:
        e.preventDefault(), this.navigateToPage(t);
        break;
    }
  }
  navigate(e) {
    const t = e === y.DOWN;
    let s;
    const { itemEls: i, highlightedEl: o } = this;
    if (!o)
      s = i[t ? 0 : i.length - 1];
    else {
      let r = i.indexOf(o) + (t ? 1 : -1);
      r = Math.min(Math.max(r, 0), i.length - 1), s = i[r];
    }
    this.highlightItem(s);
  }
  navigateToPage(e) {
    const { itemEls: t, highlightedEl: s } = this;
    if (!s || t.length === 0)
      return;
    const i = t.indexOf(s), o = this.options.length - 1, n = t[0].clientHeight, r = Math.floor(this.getGui().clientHeight / n);
    let a = -1;
    e === y.PAGE_HOME ? a = 0 : e === y.PAGE_END ? a = o : e === y.PAGE_DOWN ? a = Math.min(i + r, o) : e === y.PAGE_UP && (a = Math.max(i - r, 0)), a !== -1 && this.highlightItem(t[a]);
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: s } = e, i = s ?? t;
    return this.options.push({ value: t, text: i }), this.renderOption(t, i), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(!0), this.itemEls.forEach((e) => {
      De(e);
    }), this.itemEls = [], this.refreshAriaRole();
  }
  refreshAriaRole() {
    const e = this.getGui();
    Ne(e, this.options.length === 0 ? "presentation" : "listbox");
  }
  updateIndices() {
    const e = this.getGui().querySelectorAll(".ag-list-item");
    this.refreshAriaRole(), e.forEach((t, s) => {
      Da(t, s + 1), Pa(t, e.length);
    });
  }
  renderOption(e, t) {
    const s = _({
      tag: "div",
      cls: `ag-list-item ag-${this.cssIdentifier}-list-item`,
      attrs: { role: "option" }
    }), i = _({
      tag: "span",
      children: t
    });
    s.appendChild(i), this.unFocusable || (s.tabIndex = -1), this.itemEls.push(s), this.addManagedListeners(s, {
      mouseover: () => this.highlightItem(s),
      mousedown: (o) => {
        o.preventDefault(), o.stopPropagation(), this.setValue(e);
      }
    }), this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        getTooltipValue: () => t,
        getGui: () => s,
        getLocation: () => "UNKNOWN",
        // only show tooltips for items where the text cannot be fully displayed
        shouldDisplayTooltip: () => i.scrollWidth > i.clientWidth
      })
    ), this.getGui().appendChild(s);
  }
  setValue(e, t) {
    if (this.value === e)
      return this.fireItemSelected(), this;
    if (e == null)
      return this.reset(t), this;
    const s = this.options.findIndex((i) => i.value === e);
    if (s !== -1) {
      const i = this.options[s];
      this.value = i.value, this.displayValue = i.text, this.highlightItem(this.itemEls[s]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.itemEls[e]);
  }
  reset(e) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent();
  }
  highlightItem(e) {
    if (!He(e))
      return;
    this.clearHighlighted(), this.highlightedEl = e, e.classList.add(this.activeClass), Hr(e, !0);
    const t = this.getGui(), { scrollTop: s, clientHeight: i } = t, { offsetTop: o, offsetHeight: n } = e;
    (o + n > s + i || o < s) && e.scrollIntoView({ block: "nearest" }), this.unFocusable || e.focus();
  }
  clearHighlighted() {
    const e = this.highlightedEl;
    !e || !He(e) || (e.classList.remove(this.activeClass), Hr(e, !1), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
}, eb = (
  /*css*/
  ".ag-picker-field-display{flex:1 1 auto}.ag-picker-field{align-items:center;display:flex}.ag-picker-field-icon{border:0;cursor:pointer;display:flex;margin:0;padding:0}.ag-picker-field-wrapper{background-color:var(--ag-picker-button-background-color);border:var(--ag-picker-button-border);border-radius:5px;min-height:max(var(--ag-list-item-height),calc(var(--ag-spacing)*4));overflow:hidden;&:disabled{opacity:.5}&.ag-picker-has-focus,&:focus-within{background-color:var(--ag-picker-button-focus-background-color);border:var(--ag-picker-button-focus-border);box-shadow:var(--ag-focus-shadow)}}"
), tb = {
  tag: "div",
  cls: "ag-picker-field",
  role: "presentation",
  children: [
    { tag: "div", ref: "eLabel" },
    {
      tag: "div",
      ref: "eWrapper",
      cls: "ag-wrapper ag-picker-field-wrapper ag-picker-collapsed",
      children: [
        { tag: "div", ref: "eDisplayField", cls: "ag-picker-field-display" },
        { tag: "div", ref: "eIcon", cls: "ag-picker-field-icon", attrs: { "aria-hidden": "true" } }
      ]
    }
  ]
}, sb = class extends wh {
  constructor(e) {
    if (super(e, (e == null ? void 0 : e.template) || tb, (e == null ? void 0 : e.agComponents) || [], e == null ? void 0 : e.className), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.eLabel = x, this.eWrapper = x, this.eDisplayField = x, this.eIcon = x, this.registerCSS(eb), this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e)
      return;
    const { pickerGap: t, maxPickerHeight: s, variableWidth: i, minPickerWidth: o, maxPickerWidth: n } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!i, s != null && this.setPickerMaxHeight(s), o != null && this.setPickerMinWidth(o), n != null && this.setPickerMaxWidth(n);
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedElementListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) }), this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon: s, inputWidth: i } = this.config;
    if (s) {
      const o = k(s, this.beans);
      o && this.eIcon.appendChild(o);
    }
    i != null && this.setInputWidth(i);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), ot(e, !1), this.ariaRole && Ne(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t)
        return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = !1;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case y.UP:
      case y.DOWN:
      case y.ENTER:
      case y.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case y.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0);
  }
  renderAndPositionPicker() {
    const e = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({
      bodyScroll: () => {
        this.hidePicker();
      }
    }));
    const t = this.getLocaleTextFunc(), {
      config: { pickerAriaLabelKey: s, pickerAriaLabelValue: i, modalPicker: o = !0 },
      maxPickerHeight: n,
      minPickerWidth: r,
      maxPickerWidth: a,
      variableWidth: l,
      beans: d,
      eWrapper: c
    } = this, u = {
      modal: o,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: () => {
        const f = yi(d);
        this.beforeHidePicker(), f && this.isAlive() && this.getFocusableElement().focus();
      },
      ariaLabel: t(s, i),
      anchorToElement: c
    };
    e.style.position = "absolute";
    const h = d.popupSvc, g = h.addPopup(u);
    l ? (r && (e.style.minWidth = r), e.style.width = Ia(dn(c)), a && (e.style.maxWidth = a)) : hn(e, a ?? dn(c));
    const p = n ?? `${Gn(h.getPopupParent())}px`;
    return e.style.setProperty("max-height", p), this.alignPickerToComponent(), g.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent)
      return;
    const {
      pickerGap: e,
      config: { pickerType: t },
      beans: { popupSvc: s, gos: i },
      eWrapper: o,
      pickerComponent: n
    } = this, r = i.get("enableRtl") ? "right" : "left";
    s.positionPopupByComponent({
      type: t,
      eventSource: o,
      ePopup: n.getGui(),
      position: "under",
      alignSide: r,
      keepWithinBounds: !0,
      nudgeY: e
    });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive())
      return;
    const t = this.getAriaElement();
    ot(t, e);
    const s = this.eWrapper.classList;
    s.toggle("ag-picker-expanded", e), s.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(!0);
  }
  onPickerFocusOut(e) {
    var t;
    (t = this.pickerComponent) != null && t.getGui().contains(e.relatedTarget) || this.togglePickerHasFocus(!1);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    var e;
    (e = this.hideCurrentPicker) == null || e.call(this);
  }
  setInputWidth(e) {
    return hn(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
}, ib = (
  /*css*/
  ".ag-select{align-items:center;display:flex;&.ag-disabled{opacity:.5}}:where(.ag-select){.ag-picker-field-wrapper{cursor:default}&.ag-disabled .ag-picker-field-wrapper:focus{box-shadow:none}&:not(.ag-cell-editor,.ag-label-align-top){min-height:var(--ag-list-item-height)}.ag-picker-field-display{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-picker-field-icon{align-items:center;display:flex}}:where(.ag-ltr) :where(.ag-select){.ag-picker-field-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding)/2);padding-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-select){.ag-picker-field-wrapper{padding-left:var(--ag-spacing);padding-right:calc(var(--ag-cell-horizontal-padding)/2)}}"
), ob = class extends sb {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "selectOpen",
      ariaRole: "combobox",
      ...e
    }), this.registerCSS(ib);
  }
  postConstruct() {
    this.tooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        shouldDisplayTooltip: Sh(() => this.eDisplayField),
        getGui: () => this.getGui()
      })
    ), super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: e, value: t, placeholder: s } = this.config;
    e != null && this.addOptions(e), t != null && this.setValue(t, !0), s && t == null && (this.eDisplayField.textContent = s), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    const e = this.createBean(new Jw("select", !0));
    this.listComponent = e, e.setParentComponent(this);
    const t = e.getAriaElement(), s = `ag-select-list-${e.getCompId()}`;
    t.setAttribute("id", s), Nc(this.getAriaElement(), t), e.addManagedElementListeners(e.getGui(), {
      mousedown: (i) => {
        i == null || i.preventDefault();
      }
    }), e.addManagedListeners(e, {
      selectedItem: () => {
        this.hidePicker(), this.dispatchLocalEvent({ type: "selectedItem" });
      },
      fieldValueChanged: () => {
        this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker());
      }
    });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(e) {
    var s;
    const { key: t } = e;
    switch (t === y.TAB && this.hidePicker(), t) {
      case y.ENTER:
      case y.UP:
      case y.DOWN:
      case y.PAGE_UP:
      case y.PAGE_DOWN:
      case y.PAGE_HOME:
      case y.PAGE_END:
        e.preventDefault(), this.isPickerDisplayed ? (s = this.listComponent) == null || s.handleKeyDown(e) : super.onKeyDown(e);
        break;
      case y.ESCAPE:
        super.onKeyDown(e);
        break;
      case y.SPACE:
        this.isPickerDisplayed ? e.preventDefault() : super.onKeyDown(e);
        break;
    }
  }
  showPicker() {
    const e = this.listComponent;
    e && (super.showPicker(), e.refreshHighlighted());
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  clearOptions() {
    var e;
    return (e = this.listComponent) == null || e.clearOptions(), this.setValue(void 0, !0), this;
  }
  setValue(e, t, s) {
    const {
      listComponent: i,
      config: { placeholder: o },
      eDisplayField: n,
      tooltipFeature: r
    } = this;
    if (this.value === e || !i)
      return this;
    if (s || i.setValue(e, !0), i.getValue() === this.getValue())
      return this;
    let l = i.getDisplayValue();
    return l == null && o && (l = o), n.textContent = l, r == null || r.setTooltipAndRefresh(l ?? null), super.setValue(e, t);
  }
  destroy() {
    this.listComponent = this.destroyBean(this.listComponent), super.destroy();
  }
}, Qo = {
  TAB_GUARD: "ag-tab-guard",
  TAB_GUARD_TOP: "ag-tab-guard-top",
  TAB_GUARD_BOTTOM: "ag-tab-guard-bottom"
}, nb = class extends S {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1, this.allowFocus = !1;
    const {
      comp: t,
      eTopGuard: s,
      eBottomGuard: i,
      focusTrapActive: o,
      forceFocusOutWhenTabGuardsAreEmpty: n,
      isFocusableContainer: r,
      focusInnerElement: a,
      onFocusIn: l,
      onFocusOut: d,
      shouldStopEventPropagation: c,
      onTabKeyDown: u,
      handleKeyDown: h,
      isEmpty: g,
      eFocusableElement: p
    } = e;
    this.comp = t, this.eTopGuard = s, this.eBottomGuard = i, this.providedFocusInnerElement = a, this.eFocusableElement = p, this.focusTrapActive = !!o, this.forceFocusOutWhenTabGuardsAreEmpty = !!n, this.isFocusableContainer = !!r, this.providedFocusIn = l, this.providedFocusOut = d, this.providedShouldStopEventPropagation = c, this.providedOnTabKeyDown = u, this.providedHandleKeyDown = h, this.providedIsEmpty = g;
  }
  postConstruct() {
    this.createManagedBean(
      new ms(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    ), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(
      (e) => this.addManagedElementListeners(e, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    if (this.forcingFocusOut)
      return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget) && !this.allowFocus) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && (this.providedIsEmpty ? this.providedIsEmpty() : cs(this.eFocusableElement, ".ag-tab-guard").length === 0)) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget))
      return;
    const t = e.target === this.eBottomGuard;
    !(this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t)) && this.forceFocusOutWhenTabGuardsAreEmpty && this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
  }
  findNextElementOutsideAndFocus(e) {
    var l;
    const t = pe(this.beans), s = cs(t.body, null, !0), i = s.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (i === -1)
      return;
    let o, n;
    e ? (o = 0, n = i) : (o = i + 1, n = s.length);
    const r = s.slice(o, n), a = this.gos.get("tabIndex");
    r.sort((d, c) => {
      const u = parseInt(d.getAttribute("tabindex") || "0"), h = parseInt(c.getAttribute("tabindex") || "0");
      return h === a ? 1 : u === a ? -1 : u === 0 ? 1 : h === 0 ? -1 : u - h;
    }), (l = r[e ? r.length - 1 : 0]) == null || l.focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || this.forcingFocusOut || (this.providedFocusIn && this.providedFocusIn(e), this.isFocusableContainer || this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const s = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), s && (s.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = cs(this.eFocusableElement);
    return this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length ? (t[e ? t.length - 1 : 0].focus({ preventScroll: !0 }), !0) : !1;
  }
  getNextFocusableElement(e) {
    return Be(this.beans, this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    if (this.forcingFocusOut)
      return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = !1, this.activateTabGuards();
    });
  }
  isTabGuard(e, t) {
    return e === this.eTopGuard && !t || e === this.eBottomGuard && (t ?? !0);
  }
  setAllowFocus(e) {
    this.allowFocus = e;
  }
}, xh = class extends S {
  constructor(e) {
    super(), this.comp = e;
  }
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard: t, eBottomGuard: s, eFocusableElement: i } = this, o = [t, s], n = {
      setTabIndex: (m) => {
        o.forEach(
          (b) => m != null ? b.setAttribute("tabindex", m) : b.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(t, s);
    const {
      focusTrapActive: r = !1,
      onFocusIn: a,
      onFocusOut: l,
      focusInnerElement: d,
      handleKeyDown: c,
      onTabKeyDown: u,
      shouldStopEventPropagation: h,
      isEmpty: g,
      forceFocusOutWhenTabGuardsAreEmpty: p,
      isFocusableContainer: f
    } = e;
    this.tabGuardCtrl = this.createManagedBean(
      new nb({
        comp: n,
        focusTrapActive: r,
        eTopGuard: t,
        eBottomGuard: s,
        eFocusableElement: i,
        onFocusIn: a,
        onFocusOut: l,
        focusInnerElement: d,
        handleKeyDown: c,
        onTabKeyDown: u,
        shouldStopEventPropagation: h,
        isEmpty: g,
        forceFocusOutWhenTabGuardsAreEmpty: p,
        isFocusableContainer: f
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(e) {
    const t = pe(this.beans).createElement("div"), s = e === "top" ? Qo.TAB_GUARD_TOP : Qo.TAB_GUARD_BOTTOM;
    return t.classList.add(Qo.TAB_GUARD, s), Ne(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    const s = this.eFocusableElement;
    s.insertAdjacentElement("afterbegin", e), s.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    de(this.comp.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t, s) {
    On(t) || (t = t.getGui());
    const { eBottomGuard: i } = this;
    i ? i.insertAdjacentElement("beforebegin", t) : e(t, s);
  }
  destroy() {
    const { eTopGuard: e, eBottomGuard: t } = this;
    De(e), De(t), super.destroy();
  }
}, Ti = class extends L {
  initialiseTabGuard(e) {
    this.tabGuardFeature = this.createManagedBean(new xh(this)), this.tabGuardFeature.initialiseTabGuard(e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardFeature.forceFocusOutOfContainer(e);
  }
  appendChild(e, t) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), e, t);
  }
}, Xt = class {
  constructor(e, t = !1) {
    this.DOUBLE_TAP_MILLIS = 500, this.destroyFuncs = [], this.touching = !1, this.localEventService = new hs(), this.preventMouseClick = t;
    const s = this.onTouchStart.bind(this), i = this.onTouchMove.bind(this), o = this.onTouchEnd.bind(this);
    e.addEventListener("touchstart", s, { passive: !0 }), e.addEventListener("touchmove", i, { passive: !0 }), e.addEventListener("touchend", o, { passive: !1 }), this.destroyFuncs.push(() => {
      e.removeEventListener("touchstart", s, { passive: !0 }), e.removeEventListener("touchmove", i, { passive: !0 }), e.removeEventListener("touchend", o, { passive: !1 });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching)
      return;
    this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
    const t = this.touchStart;
    window.setTimeout(() => {
      const s = this.touchStart === t;
      if (this.touching && s && !this.moved) {
        this.moved = !0;
        const i = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent: e
        };
        this.localEventService.dispatchEvent(i);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching)
      return;
    const t = this.getActiveTouch(e.touches);
    if (!t)
      return;
    !Ju(t, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = {
          type: "tap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const e = Date.now();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
        const s = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(s), this.lastTapTime = null;
      } else
        this.lastTapTime = e;
    else
      this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
}, rb = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.batchFrameworkComps = !1, this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t(), this.baseDocLink = `${Qc}/${this.frameworkName}-data-grid`, wm(this.baseDocLink);
  }
  setInterval(e, t) {
    return new q((s) => {
      s(window.setInterval(e, t));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(e, t, s, i) {
    let o = {};
    if (typeof i == "object" ? o = i : typeof i == "boolean" && (o = { capture: i }), o.passive == null) {
      const n = mu(t);
      n != null && (o.passive = n);
    }
    e.addEventListener(t, s, o);
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
  getDocLink(e) {
    return `${this.baseDocLink}${e ? `/${e}` : ""}`;
  }
};
function ab(e) {
  return {
    beanName: "gridApi",
    bean: e.getBean("apiFunctionSvc").api
  };
}
var lb = [
  // Validate license first
  "licenseManager",
  // core beans only
  "environment",
  "eventSvc",
  "gos",
  "paginationAutoPageSizeSvc",
  "apiFunctionSvc",
  "gridApi",
  "registry",
  "agCompUtils",
  "userCompFactory",
  "rowContainerHeight",
  "horizontalResizeSvc",
  "localeSvc",
  "pinnedRowModel",
  "dragSvc",
  "colGroupSvc",
  "visibleCols",
  "popupSvc",
  "selectionSvc",
  "colFilter",
  "quickFilter",
  "filterManager",
  "colModel",
  "headerNavigation",
  "pageBounds",
  "pagination",
  "pageBoundsListener",
  "rowSpanSvc",
  "stickyRowSvc",
  "rowRenderer",
  "expressionSvc",
  "alignedGridsSvc",
  "navigation",
  "valueCache",
  "valueSvc",
  "autoWidthCalc",
  "filterMenuFactory",
  "dragAndDrop",
  "focusSvc",
  "cellNavigation",
  "cellStyles",
  "scrollVisibleSvc",
  "sortSvc",
  "colHover",
  "colAnimation",
  "autoColSvc",
  "selectionColSvc",
  "changeDetectionSvc",
  "animationFrameSvc",
  "undoRedo",
  "colDefFactory",
  "rowStyleSvc",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsSvc",
  "pinnedCols",
  "dataTypeSvc",
  "syncSvc",
  "overlays",
  "stateSvc",
  "expansionSvc",
  "apiEventSvc",
  "ariaAnnounce",
  "menuSvc",
  "colMoves",
  "colAutosize",
  "colFlex",
  "colResize",
  "pivotColsSvc",
  "valueColsSvc",
  "rowGroupColsSvc",
  "funcColsSvc",
  "colNames",
  "colViewport",
  "pivotResultCols",
  "showRowGroupCols",
  "validation"
  // Have validations run last
], sd = Object.fromEntries(
  lb.map((e, t) => [e, t])
);
function db(e, t) {
  const s = (e.beanName ? sd[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER, i = (t.beanName ? sd[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return s - i;
}
function cb(e, t) {
  return (e == null ? void 0 : e.beanName) === "gridDestroySvc" ? -1 : (t == null ? void 0 : t.beanName) === "gridDestroySvc" ? 1 : 0;
}
var ub = { tag: "div", cls: "ag-pinned-left-header", role: "rowgroup" }, hb = { tag: "div", cls: "ag-pinned-right-header", role: "rowgroup" }, gb = {
  tag: "div",
  cls: "ag-header-viewport",
  role: "presentation",
  attrs: { tabindex: "-1" },
  children: [{ tag: "div", ref: "eCenterContainer", cls: "ag-header-container", role: "rowgroup" }]
}, mr = class extends L {
  constructor(e) {
    super(), this.eCenterContainer = x, this.headerRowComps = {}, this.rowCompsList = [], this.pinned = e;
  }
  postConstruct() {
    this.selectAndSetTemplate();
    const e = {
      setDisplayed: (s) => this.setDisplayed(s),
      setCtrls: (s) => this.setCtrls(s),
      // only gets called for center section
      setCenterWidth: (s) => this.eCenterContainer.style.width = s,
      setViewportScrollLeft: (s) => this.getGui().scrollLeft = s,
      // only gets called for pinned sections
      setPinnedContainerWidth: (s) => {
        const i = this.getGui();
        i.style.width = s, i.style.maxWidth = s, i.style.minWidth = s;
      }
    };
    this.createManagedBean(new Dw(this.pinned)).setComp(e, this.getGui());
  }
  selectAndSetTemplate() {
    const e = this.pinned == "left", t = this.pinned == "right", s = e ? ub : t ? hb : gb;
    this.setTemplate(s), this.eRowContainer = this.eCenterContainer !== x ? this.eCenterContainer : this.getGui();
  }
  destroy() {
    this.setCtrls([]), super.destroy();
  }
  destroyRowComp(e) {
    this.destroyBean(e), this.eRowContainer.removeChild(e.getGui());
  }
  setCtrls(e) {
    const t = this.headerRowComps;
    this.headerRowComps = {}, this.rowCompsList = [];
    let s;
    const i = (o) => {
      const n = o.getGui();
      n.parentElement != this.eRowContainer && this.eRowContainer.appendChild(n), s && Kc(this.eRowContainer, n, s), s = n;
    };
    e.forEach((o) => {
      const n = o.instanceId, r = t[n];
      delete t[n];
      const a = r || this.createBean(new xw(o));
      this.headerRowComps[n] = a, this.rowCompsList.push(a), i(a);
    }), Object.values(t).forEach((o) => this.destroyRowComp(o));
  }
}, pb = { tag: "div", cls: "ag-header", role: "presentation" }, fb = class extends L {
  constructor() {
    super(pb);
  }
  postConstruct() {
    const e = {
      toggleCss: (i, o) => this.toggleCss(i, o),
      setHeightAndMinHeight: (i) => {
        this.getGui().style.height = i, this.getGui().style.minHeight = i;
      }
    };
    this.createManagedBean(new mw()).setComp(e, this.getGui(), this.getFocusableElement());
    const s = (i) => {
      this.createManagedBean(i), this.appendChild(i);
    };
    s(new mr("left")), s(new mr(null)), s(new mr("right"));
  }
}, mb = {
  selector: "AG-HEADER-ROOT",
  component: fb
}, Cb = class extends L {
  constructor(e, t, s, i, o) {
    super(), this.cellCtrl = t, this.rendererVersion = 0, this.editorVersion = 0, this.beans = e, this.column = t.column, this.rowNode = t.rowNode, this.eRow = i;
    const n = _({
      tag: "div",
      role: t.getCellAriaRole(),
      attrs: {
        "comp-id": `${this.getCompId()}`,
        "col-id": t.column.colIdSanitised
      }
    });
    this.eCell = n;
    let r;
    t.isCellSpanning() ? (r = _({
      tag: "div",
      cls: "ag-spanned-cell-wrapper",
      role: "presentation"
    }), r.appendChild(n), this.setTemplateFromElement(r)) : this.setTemplateFromElement(n), this.cellCssManager = new Gu(() => n), this.forceWrapper = t.isForceWrapper(), this.refreshWrapper(!1);
    const a = {
      toggleCss: (l, d) => this.cellCssManager.toggleCss(l, d),
      setUserStyles: (l) => bo(n, l),
      getFocusableElement: () => n,
      setIncludeSelection: (l) => this.includeSelection = l,
      setIncludeRowDrag: (l) => this.includeRowDrag = l,
      setIncludeDndSource: (l) => this.includeDndSource = l,
      setRenderDetails: (l, d, c) => this.setRenderDetails(l, d, c),
      setEditDetails: (l, d, c) => this.setEditDetails(l, d, c),
      getCellEditor: () => this.cellEditor || null,
      getCellRenderer: () => this.cellRenderer || null,
      getParentOfValue: () => this.getParentOfValue()
    };
    t.setComp(a, n, r, this.eCellWrapper, s, o, void 0);
  }
  getParentOfValue() {
    return this.eCellValue ?? this.eCellWrapper ?? this.eCell;
  }
  setRenderDetails(e, t, s) {
    if (this.cellEditor && !this.cellEditorPopupWrapper)
      return;
    this.firstRender = this.firstRender == null;
    const o = this.refreshWrapper(!1);
    this.refreshEditStyles(!1), e ? !(s || o) && this.refreshCellRenderer(e) || (this.destroyRenderer(), this.createCellRendererInstance(e)) : (this.destroyRenderer(), this.insertValueWithoutCellRenderer(t));
  }
  setEditDetails(e, t, s) {
    e ? this.createCellEditorInstance(e, t, s) : this.destroyEditor();
  }
  removeControls() {
    const e = this.beans.context;
    this.checkboxSelectionComp = e.destroyBean(this.checkboxSelectionComp), this.dndSourceComp = e.destroyBean(this.dndSourceComp), this.rowDraggingComp = e.destroyBean(this.rowDraggingComp);
  }
  // returns true if wrapper was changed
  refreshWrapper(e) {
    const t = this.includeRowDrag || this.includeDndSource || this.includeSelection, s = t || this.forceWrapper, i = s && this.eCellWrapper == null;
    i && (this.eCellWrapper = _({ tag: "div", cls: "ag-cell-wrapper", role: "presentation" }), this.eCell.appendChild(this.eCellWrapper));
    const o = !s && this.eCellWrapper != null;
    o && (De(this.eCellWrapper), this.eCellWrapper = void 0), this.cellCssManager.toggleCss("ag-cell-value", !s);
    const n = !e && s, r = n && this.eCellValue == null;
    r && (this.eCellValue = _({ tag: "span", cls: "ag-cell-value", role: "presentation" }), this.eCellWrapper.appendChild(this.eCellValue));
    const a = !n && this.eCellValue != null;
    a && (De(this.eCellValue), this.eCellValue = void 0);
    const l = i || o || r || a;
    return l && this.removeControls(), !e && t && this.addControls(), l;
  }
  addControls() {
    const { cellCtrl: e, eCellWrapper: t, eCellValue: s, includeRowDrag: i, includeDndSource: o, includeSelection: n } = this, r = (a) => {
      a && t.insertBefore(a.getGui(), s);
    };
    i && this.rowDraggingComp == null && (this.rowDraggingComp = e.createRowDragComp(), r(this.rowDraggingComp)), o && this.dndSourceComp == null && (this.dndSourceComp = e.createDndSource(), r(this.dndSourceComp)), n && this.checkboxSelectionComp == null && (this.checkboxSelectionComp = e.createSelectionCheckbox(), r(this.checkboxSelectionComp));
  }
  createCellEditorInstance(e, t, s) {
    const i = this.editorVersion, o = e.newAgStackInstance(), { params: n } = e;
    o.then((a) => this.afterCellEditorCreated(i, a, n, t, s)), ie(this.cellEditor) && n.cellStartedEdit && this.cellCtrl.focusCell(!0);
  }
  insertValueWithoutCellRenderer(e) {
    const t = this.getParentOfValue();
    de(t);
    const s = _n(e);
    s != null && (t.textContent = s);
  }
  destroyRenderer() {
    const { context: e } = this.beans;
    this.cellRenderer = e.destroyBean(this.cellRenderer), De(this.cellRendererGui), this.cellRendererGui = null, this.rendererVersion++;
  }
  destroyEditor() {
    var s, i;
    const { context: e } = this.beans;
    (((s = this.cellEditorPopupWrapper) == null ? void 0 : s.getGui().contains(te(this.beans))) || this.cellCtrl.hasBrowserFocus()) && this.eCell.focus({ preventScroll: !0 }), (i = this.hideEditorPopup) == null || i.call(this), this.hideEditorPopup = void 0, this.cellEditor = e.destroyBean(this.cellEditor), this.cellEditorPopupWrapper = e.destroyBean(this.cellEditorPopupWrapper), De(this.cellEditorGui), this.cellEditorGui = null, this.editorVersion++;
  }
  refreshCellRenderer(e) {
    var s;
    if (((s = this.cellRenderer) == null ? void 0 : s.refresh) == null || this.cellRendererClass !== e.componentClass)
      return !1;
    const t = this.cellRenderer.refresh(e.params);
    return t === !0 || t === void 0;
  }
  createCellRendererInstance(e) {
    const t = this.rendererVersion, { componentClass: s } = e, i = () => {
      if (this.rendererVersion !== t || !this.isAlive())
        return;
      const r = e.newAgStackInstance(), a = this.afterCellRendererCreated.bind(this, t, s);
      r == null || r.then(a);
    }, { animationFrameSvc: o } = this.beans;
    o != null && o.active && this.firstRender ? o.createTask(
      i,
      this.rowNode.rowIndex,
      "p2",
      e.componentFromFramework
    ) : i();
  }
  afterCellRendererCreated(e, t, s) {
    if (!this.isAlive() || e !== this.rendererVersion) {
      this.beans.context.destroyBean(s);
      return;
    }
    this.cellRenderer = s, this.cellRendererClass = t;
    const o = s.getGui();
    if (this.cellRendererGui = o, o != null) {
      const n = this.getParentOfValue();
      de(n), n.appendChild(o);
    }
  }
  afterCellEditorCreated(e, t, s, i, o) {
    var d;
    const n = e !== this.editorVersion, { context: r } = this.beans;
    if (n) {
      r.destroyBean(t);
      return;
    }
    if (t.isCancelBeforeStart && t.isCancelBeforeStart()) {
      r.destroyBean(t), this.cellCtrl.stopEditing(!0);
      return;
    }
    if (!t.getGui) {
      P(97, { colId: this.column.getId() }), r.destroyBean(t);
      return;
    }
    this.cellEditor = t, this.cellEditorGui = t.getGui();
    const l = i || t.isPopup !== void 0 && t.isPopup();
    l ? this.addPopupCellEditor(s, o) : this.addInCellEditor(), this.refreshEditStyles(!0, l), (d = t.afterGuiAttached) == null || d.call(t), this.cellCtrl.cellEditorAttached();
  }
  refreshEditStyles(e, t) {
    const { cellCssManager: s } = this;
    s.toggleCss("ag-cell-inline-editing", e && !t), s.toggleCss("ag-cell-popup-editing", e && !!t), s.toggleCss("ag-cell-not-inline-editing", !e || !!t), this.cellCtrl.setInlineEditingCss();
  }
  addInCellEditor() {
    const { eCell: e } = this;
    e.contains(te(this.beans)) && e.focus(), this.destroyRenderer(), this.refreshWrapper(!0), de(this.getParentOfValue()), this.cellEditorGui && this.getParentOfValue().appendChild(this.cellEditorGui);
  }
  addPopupCellEditor(e, t) {
    var m;
    const { gos: s, context: i, editSvc: o, popupSvc: n, localeSvc: r } = this.beans;
    s.get("editType") === "fullRow" && P(98);
    const a = this.cellEditor;
    this.cellEditorPopupWrapper = i.createBean(o.createPopupEditorWrapper(e));
    const l = this.cellEditorPopupWrapper.getGui();
    this.cellEditorGui && l.appendChild(this.cellEditorGui);
    const d = s.get("stopEditingWhenCellsLoseFocus"), c = t ?? ((m = a.getPopupPosition) == null ? void 0 : m.call(a)) ?? "over", u = s.get("enableRtl"), h = {
      ePopup: l,
      column: this.column,
      rowNode: this.rowNode,
      type: "popupCellEditor",
      eventSource: this.eCell,
      position: c,
      alignSide: u ? "right" : "left",
      keepWithinBounds: !0
    }, g = n.positionPopupByComponent.bind(n, h), p = Tc(r), f = n.addPopup({
      modal: d,
      eChild: l,
      closeOnEsc: !0,
      closedCallback: () => {
        this.cellCtrl.onPopupEditorClosed();
      },
      anchorToElement: this.eCell,
      positionCallback: g,
      ariaLabel: p("ariaLabelCellEditor", "Cell Editor")
    });
    f && (this.hideEditorPopup = f.hideFunc);
  }
  detach() {
    this.eRow.removeChild(this.getGui());
  }
  // if the row is also getting destroyed, then we don't need to remove from dom,
  // as the row will also get removed, so no need to take out the cells from the row
  // if the row is going (removing is an expensive operation, so only need to remove
  // the top part)
  //
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroy() {
    this.cellCtrl.stopEditing(), this.destroyRenderer(), this.destroyEditor(), this.removeControls(), super.destroy();
  }
}, vb = class extends L {
  constructor(e, t, s) {
    super(), this.cellComps = /* @__PURE__ */ new Map(), this.beans = t, this.rowCtrl = e;
    const i = _({ tag: "div", role: "row", attrs: { "comp-id": `${this.getCompId()}` } });
    this.setInitialStyle(i, s), this.setTemplateFromElement(i);
    const o = i.style;
    this.domOrder = this.rowCtrl.getDomOrder();
    const n = {
      setDomOrder: (r) => this.domOrder = r,
      setCellCtrls: (r) => this.setCellCtrls(r),
      showFullWidth: (r) => this.showFullWidth(r),
      getFullWidthCellRenderer: () => this.fullWidthCellRenderer,
      toggleCss: (r, a) => this.toggleCss(r, a),
      setUserStyles: (r) => bo(i, r),
      setTop: (r) => o.top = r,
      setTransform: (r) => o.transform = r,
      setRowIndex: (r) => i.setAttribute("row-index", r),
      setRowId: (r) => i.setAttribute("row-id", r),
      setRowBusinessKey: (r) => i.setAttribute("row-business-key", r),
      refreshFullWidth: (r) => {
        var a, l;
        return ((l = (a = this.fullWidthCellRenderer) == null ? void 0 : a.refresh) == null ? void 0 : l.call(a, r())) ?? !1;
      }
    };
    e.setComp(n, this.getGui(), s, void 0), this.addDestroyFunc(() => {
      e.unsetComp(s);
    });
  }
  setInitialStyle(e, t) {
    const s = this.rowCtrl.getInitialTransform(t);
    if (s)
      e.style.setProperty("transform", s);
    else {
      const i = this.rowCtrl.getInitialRowTop(t);
      i && e.style.setProperty("top", i);
    }
  }
  showFullWidth(e) {
    const t = (i) => {
      if (this.isAlive()) {
        const o = i.getGui();
        this.getGui().appendChild(o), this.rowCtrl.setupDetailRowAutoHeight(o), this.setFullWidthRowComp(i);
      } else
        this.beans.context.destroyBean(i);
    };
    e.newAgStackInstance().then(t);
  }
  setCellCtrls(e) {
    const t = new Map(this.cellComps);
    for (const s of e) {
      const i = s.instanceId;
      this.cellComps.has(i) ? t.delete(i) : this.newCellComp(s);
    }
    this.destroyCells(t), this.ensureDomOrder(e);
  }
  ensureDomOrder(e) {
    if (!this.domOrder)
      return;
    const t = [];
    for (const s of e) {
      const i = this.cellComps.get(s.instanceId);
      i && t.push(i.getGui());
    }
    qc(this.getGui(), t);
  }
  newCellComp(e) {
    const t = new Cb(
      this.beans,
      e,
      this.rowCtrl.printLayout,
      this.getGui(),
      this.rowCtrl.editing
    );
    this.cellComps.set(e.instanceId, t), this.getGui().appendChild(t.getGui());
  }
  destroy() {
    super.destroy(), this.destroyCells(this.cellComps);
  }
  setFullWidthRowComp(e) {
    this.fullWidthCellRenderer = e, this.addDestroyFunc(() => {
      this.fullWidthCellRenderer = this.beans.context.destroyBean(this.fullWidthCellRenderer);
    });
  }
  destroyCells(e) {
    for (const t of e.values()) {
      if (!t)
        return;
      const s = t.cellCtrl.instanceId;
      if (this.cellComps.get(s) !== t)
        return;
      t.detach(), t.destroy(), this.cellComps.delete(s);
    }
  }
};
function wb(e, t, s) {
  const i = !!s.gos.get("enableCellSpan") && !!t.getSpannedRowCtrls, o = {
    tag: "div",
    ref: "eContainer",
    cls: Zo(e),
    role: "rowgroup"
  };
  if (t.type === "center" || i) {
    const n = {
      tag: "div",
      ref: "eSpannedContainer",
      cls: `ag-spanning-container ${$v(e)}`,
      role: "rowgroup"
    };
    return {
      tag: "div",
      ref: "eViewport",
      cls: `ag-viewport ${ch(e)}`,
      role: "presentation",
      children: [o, i ? n : null]
    };
  }
  return o;
}
var bb = class extends L {
  constructor(e) {
    super(), this.eViewport = x, this.eContainer = x, this.eSpannedContainer = x, this.rowCompsNoSpan = {}, this.rowCompsWithSpan = {}, this.name = e == null ? void 0 : e.name, this.options = xo(this.name);
  }
  postConstruct() {
    this.setTemplate(wb(this.name, this.options, this.beans));
    const e = {
      setHorizontalScroll: (s) => this.eViewport.scrollLeft = s,
      setViewportHeight: (s) => this.eViewport.style.height = s,
      setRowCtrls: ({ rowCtrls: s }) => this.setRowCtrls(s),
      setSpannedRowCtrls: (s) => this.setRowCtrls(s, !0),
      setDomOrder: (s) => {
        this.domOrder = s;
      },
      setContainerWidth: (s) => {
        this.eContainer.style.width = s, this.eSpannedContainer && (this.eSpannedContainer.style.width = s);
      },
      setOffsetTop: (s) => {
        const i = `translateY(${s})`;
        this.eContainer.style.transform = i, this.eSpannedContainer && (this.eSpannedContainer.style.transform = i);
      }
    };
    this.createManagedBean(new sw(this.name)).setComp(e, this.eContainer, this.eSpannedContainer, this.eViewport);
  }
  destroy() {
    this.setRowCtrls([]), this.setRowCtrls([], !0), super.destroy(), this.lastPlacedElement = null;
  }
  setRowCtrls(e, t) {
    const { beans: s, options: i } = this, o = t ? this.eSpannedContainer : this.eContainer, n = t ? { ...this.rowCompsWithSpan } : { ...this.rowCompsNoSpan }, r = {};
    t ? this.rowCompsWithSpan = r : this.rowCompsNoSpan = r, this.lastPlacedElement = null;
    const a = [];
    for (const l of e) {
      const d = l.instanceId, c = n[d];
      let u;
      if (c)
        u = c, delete n[d];
      else {
        if (!l.rowNode.displayed)
          continue;
        u = new vb(l, s, i.type);
      }
      r[d] = u, a.push([u, !c]);
    }
    this.removeOldRows(Object.values(n), o), this.addRowNodes(a, o);
  }
  addRowNodes(e, t) {
    const { domOrder: s } = this;
    for (const [i, o] of e) {
      const n = i.getGui();
      s ? this.ensureDomOrder(n, t) : o && t.appendChild(n);
    }
  }
  removeOldRows(e, t) {
    for (const s of e)
      t.removeChild(s.getGui()), s.destroy();
  }
  ensureDomOrder(e, t) {
    Kc(t, e, this.lastPlacedElement), this.lastPlacedElement = e;
  }
}, yb = {
  selector: "AG-ROW-CONTAINER",
  component: bb
};
function Hi(e, t) {
  return t.map((s) => {
    const i = `e${s[0].toUpperCase() + s.substring(1)}RowContainer`;
    return e[i] = { name: s }, {
      tag: "ag-row-container",
      ref: i,
      attrs: { name: s }
    };
  });
}
function Sb(e) {
  const t = {}, s = {
    tag: "div",
    ref: "eGridRoot",
    cls: "ag-root ag-unselectable",
    children: [
      { tag: "ag-header-root" },
      {
        tag: "div",
        ref: "eTop",
        cls: "ag-floating-top",
        role: "presentation",
        children: Hi(t, ["topLeft", "topCenter", "topRight", "topFullWidth"])
      },
      {
        tag: "div",
        ref: "eBody",
        cls: "ag-body",
        role: "presentation",
        children: [
          {
            tag: "div",
            ref: "eBodyViewport",
            cls: "ag-body-viewport",
            role: "presentation",
            children: Hi(t, ["left", "center", "right", "fullWidth"])
          },
          { tag: "ag-fake-vertical-scroll" }
        ]
      },
      {
        tag: "div",
        ref: "eStickyTop",
        cls: "ag-sticky-top",
        role: "presentation",
        children: Hi(t, [
          "stickyTopLeft",
          "stickyTopCenter",
          "stickyTopRight",
          "stickyTopFullWidth"
        ])
      },
      {
        tag: "div",
        ref: "eStickyBottom",
        cls: "ag-sticky-bottom",
        role: "presentation",
        children: Hi(t, [
          "stickyBottomLeft",
          "stickyBottomCenter",
          "stickyBottomRight",
          "stickyBottomFullWidth"
        ])
      },
      {
        tag: "div",
        ref: "eBottom",
        cls: "ag-floating-bottom",
        role: "presentation",
        children: Hi(t, [
          "bottomLeft",
          "bottomCenter",
          "bottomRight",
          "bottomFullWidth"
        ])
      },
      { tag: "ag-fake-horizontal-scroll" },
      e ? { tag: "ag-overlay-wrapper" } : null
    ]
  };
  return { paramsMap: t, elementParams: s };
}
var xb = class extends L {
  constructor() {
    super(...arguments), this.eGridRoot = x, this.eBodyViewport = x, this.eStickyTop = x, this.eStickyBottom = x, this.eTop = x, this.eBottom = x, this.eBody = x;
  }
  postConstruct() {
    const { overlays: e, rangeSvc: t } = this.beans, s = e == null ? void 0 : e.getOverlayWrapperSelector(), { paramsMap: i, elementParams: o } = Sb(!!s);
    this.setTemplate(
      o,
      [
        ...s ? [s] : [],
        lw,
        uw,
        mb,
        yb
      ],
      i
    );
    const n = (a, l) => {
      const d = `${a}px`;
      l.style.minHeight = d, l.style.height = d;
    }, r = {
      setRowAnimationCssOnBodyViewport: (a, l) => this.setRowAnimationCssOnBodyViewport(a, l),
      setColumnCount: (a) => tm(this.getGui(), a),
      setRowCount: (a) => em(this.getGui(), a),
      setTopHeight: (a) => n(a, this.eTop),
      setBottomHeight: (a) => n(a, this.eBottom),
      setTopInvisible: (a) => this.eTop.classList.toggle("ag-invisible", a),
      setBottomInvisible: (a) => this.eBottom.classList.toggle("ag-invisible", a),
      setStickyTopHeight: (a) => this.eStickyTop.style.height = a,
      setStickyTopTop: (a) => this.eStickyTop.style.top = a,
      setStickyTopWidth: (a) => this.eStickyTop.style.width = a,
      setStickyBottomHeight: (a) => {
        this.eStickyBottom.style.height = a, this.eStickyBottom.classList.toggle("ag-invisible", a === "0px");
      },
      setStickyBottomBottom: (a) => this.eStickyBottom.style.bottom = a,
      setStickyBottomWidth: (a) => this.eStickyBottom.style.width = a,
      setColumnMovingCss: (a, l) => this.toggleCss(a, l),
      updateLayoutClasses: (a, l) => {
        const d = [this.eBodyViewport.classList, this.eBody.classList];
        for (const c of d)
          c.toggle(lt.AUTO_HEIGHT, l.autoHeight), c.toggle(lt.NORMAL, l.normal), c.toggle(lt.PRINT, l.print);
        this.toggleCss(lt.AUTO_HEIGHT, l.autoHeight), this.toggleCss(lt.NORMAL, l.normal), this.toggleCss(lt.PRINT, l.print);
      },
      setAlwaysVerticalScrollClass: (a, l) => this.eBodyViewport.classList.toggle(gh, l),
      registerBodyViewportResizeListener: (a) => {
        const l = fs(this.beans, this.eBodyViewport, a);
        this.addDestroyFunc(() => l());
      },
      setPinnedTopBottomOverflowY: (a) => this.eTop.style.overflowY = this.eBottom.style.overflowY = a,
      setCellSelectableCss: (a, l) => {
        [this.eTop, this.eBodyViewport, this.eBottom].forEach(
          (d) => d.classList.toggle(a, l)
        );
      },
      setBodyViewportWidth: (a) => this.eBodyViewport.style.width = a,
      setGridRootRole: (a) => Ne(this.eGridRoot, a)
    };
    this.ctrl = this.createManagedBean(new nw()), this.ctrl.setComp(
      r,
      this.getGui(),
      this.eBodyViewport,
      this.eTop,
      this.eBottom,
      this.eStickyTop,
      this.eStickyBottom
    ), (t && xi(this.gos) || Hs(this.gos)) && Jf(this.getGui(), !0);
  }
  setRowAnimationCssOnBodyViewport(e, t) {
    const s = this.eBodyViewport.classList;
    s.toggle("ag-row-animation", t), s.toggle("ag-row-no-animation", !t);
  }
}, Rb = {
  selector: "AG-GRID-BODY",
  component: xb
}, Fb = class extends S {
  constructor() {
    super(...arguments), this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  setComp(e, t, s) {
    this.view = e, this.eGridHostDiv = t, this.eGui = s, this.eGui.setAttribute("grid-id", this.beans.context.getGridId());
    const { dragAndDrop: i, ctrlsSvc: o } = this.beans;
    i == null || i.registerGridDropTarget(() => this.eGui, this), qu(this.gos, t), this.createManagedBean(new qa(this.view)), this.view.setRtlClass(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr");
    const n = fs(this.beans, this.eGridHostDiv, this.onGridSizeChanged.bind(this));
    this.addDestroyFunc(() => n()), o.register("gridCtrl", this);
  }
  isDetailGrid() {
    var t;
    const e = Ua(this.getGui());
    return ((t = e == null ? void 0 : e.getAttribute("row-id")) == null ? void 0 : t.startsWith("detail")) || !1;
  }
  getOptionalSelectors() {
    var t, s, i, o;
    const e = this.beans;
    return {
      paginationSelector: (t = e.pagination) == null ? void 0 : t.getPaginationSelector(),
      gridHeaderDropZonesSelector: e.registry.getSelector("AG-GRID-HEADER-DROP-ZONES"),
      sideBarSelector: (s = e.sideBar) == null ? void 0 : s.getSelector(),
      statusBarSelector: (i = e.registry) == null ? void 0 : i.getSelector("AG-STATUS-BAR"),
      watermarkSelector: (o = e.licenseManager) == null ? void 0 : o.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    this.eventSvc.dispatchEvent({
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    });
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.getFocusableContainers(), { indexWithFocus: s, nextIndex: i } = this.getNextFocusableIndex(t, e);
    if (i < 0 || i >= t.length)
      return !1;
    if (i === 0) {
      if (s > 0) {
        const { visibleCols: o, focusSvc: n } = this.beans, r = o.allCols, a = Z(r);
        if (n.focusGridView({ column: a, backwards: !0 }))
          return !0;
      }
      return !1;
    }
    return this.focusContainer(t[i], e);
  }
  focusInnerElement(e) {
    const t = this.gos.getCallback("focusGridInnerElement");
    if (t && t({ fromBottom: !!e }))
      return !0;
    const s = this.getFocusableContainers(), { focusSvc: i, visibleCols: o } = this.beans, n = o.allCols;
    if (e) {
      if (s.length > 1)
        return this.focusContainer(Z(s), e);
      const r = Z(n);
      if (i.focusGridView({ column: r, backwards: e }))
        return !0;
    }
    if (this.gos.get("headerHeight") === 0 || ks(this.beans)) {
      if (i.focusGridView({ column: n[0], backwards: e }))
        return !0;
      for (let r = 1; r < s.length; r++)
        if (Ve(s[r].getGui(), e))
          return !0;
      return !1;
    }
    return i.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
  addFocusableContainer(e) {
    this.additionalFocusableContainers.add(e);
  }
  removeFocusableContainer(e) {
    this.additionalFocusableContainers.delete(e);
  }
  allowFocusForNextCoreContainer(e) {
    var n;
    const t = this.view.getFocusableContainers(), { nextIndex: s, indexWithFocus: i } = this.getNextFocusableIndex(t, e);
    if (i === -1 || s < 0 || s >= t.length)
      return;
    const o = t[s];
    (n = o.setAllowFocus) == null || n.call(o, !0), setTimeout(() => {
      var r;
      (r = o.setAllowFocus) == null || r.call(o, !1);
    });
  }
  isFocusable() {
    var t, s;
    const e = this.beans;
    return !ja(e) || !ks(e) || !!((s = (t = e.sideBar) == null ? void 0 : t.comp) != null && s.isDisplayed());
  }
  getNextFocusableIndex(e, t) {
    const s = te(this.beans), i = e.findIndex((n) => n.getGui().contains(s)), o = i + (t ? -1 : 1);
    return {
      indexWithFocus: i,
      nextIndex: o
    };
  }
  focusContainer(e, t) {
    var i, o;
    (i = e.setAllowFocus) == null || i.call(e, !0);
    const s = Ve(e.getGui(), t, !1, !0);
    return (o = e.setAllowFocus) == null || o.call(e, !1), s;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers];
  }
  destroy() {
    this.additionalFocusableContainers.clear(), super.destroy();
  }
}, Pb = class extends Ti {
  constructor(e) {
    super(), this.gridBody = x, this.sideBar = x, this.pagination = x, this.rootWrapperBody = x, this.eGridDiv = e;
  }
  postConstruct() {
    const e = {
      destroyGridUi: () => this.destroyBean(this),
      setRtlClass: (n) => this.addCss(n),
      forceFocusOutOfContainer: this.forceFocusOutOfContainer.bind(this),
      updateLayoutClasses: this.updateLayoutClasses.bind(this),
      getFocusableContainers: this.getFocusableContainers.bind(this),
      setUserSelect: (n) => {
        this.getGui().style.userSelect = n ?? "", this.getGui().style.webkitUserSelect = n ?? "";
      },
      setCursor: (n) => {
        this.getGui().style.cursor = n ?? "";
      }
    }, t = this.createManagedBean(new Fb()), s = t.getOptionalSelectors(), i = this.createTemplate(s), o = [Rb, ...Object.values(s).filter((n) => !!n)];
    this.setTemplate(i, o), t.setComp(e, this.eGridDiv, this.getGui()), this.insertGridIntoDom(), this.initialiseTabGuard({
      // we want to override the default behaviour to do nothing for onTabKeyDown
      onTabKeyDown: () => {
      },
      focusInnerElement: (n) => t.focusInnerElement(n),
      forceFocusOutWhenTabGuardsAreEmpty: !0,
      isEmpty: () => !t.isFocusable()
    });
  }
  insertGridIntoDom() {
    const e = this.getGui();
    this.eGridDiv.appendChild(e), this.addDestroyFunc(() => {
      this.eGridDiv.removeChild(e), oo(this.gos, "Grid removed from DOM");
    });
  }
  updateLayoutClasses(e, t) {
    const s = this.rootWrapperBody.classList, { AUTO_HEIGHT: i, NORMAL: o, PRINT: n } = lt, { autoHeight: r, normal: a, print: l } = t;
    s.toggle(i, r), s.toggle(o, a), s.toggle(n, l), this.toggleCss(i, r), this.toggleCss(o, a), this.toggleCss(n, l);
  }
  createTemplate(e) {
    const t = e.gridHeaderDropZonesSelector ? { tag: "ag-grid-header-drop-zones" } : null, s = e.sideBarSelector ? {
      tag: "ag-side-bar",
      ref: "sideBar"
    } : null, i = e.statusBarSelector ? { tag: "ag-status-bar" } : null, o = e.watermarkSelector ? { tag: "ag-watermark" } : null, n = e.paginationSelector ? { tag: "ag-pagination", ref: "pagination" } : null;
    return {
      tag: "div",
      cls: "ag-root-wrapper",
      role: "presentation",
      children: [
        t,
        {
          tag: "div",
          ref: "rootWrapperBody",
          cls: "ag-root-wrapper-body",
          role: "presentation",
          children: [{ tag: "ag-grid-body", ref: "gridBody" }, s]
        },
        i,
        n,
        o
      ]
    };
  }
  getFocusableElement() {
    return this.rootWrapperBody;
  }
  forceFocusOutOfContainer(e = !1) {
    var t;
    if (!e && ((t = this.pagination) != null && t.isDisplayed())) {
      this.pagination.forceFocusOutOfContainer(e);
      return;
    }
    super.forceFocusOutOfContainer(e);
  }
  getFocusableContainers() {
    const e = [this.gridBody];
    return [this.sideBar, this.pagination].forEach((t) => {
      t && e.push(t);
    }), e.filter((t) => He(t.getGui()));
  }
}, H = (e, t) => {
  for (const s of Object.keys(t))
    t[s] = e;
  return t;
}, id = {
  dispatchEvent: "CommunityCore",
  // this is always registered
  ...H("CommunityCore", {
    destroy: 0,
    getGridId: 0,
    getGridOption: 0,
    isDestroyed: 0,
    setGridOption: 0,
    updateGridOptions: 0,
    isModuleRegistered: 0
  }),
  ...H("GridState", {
    getState: 0
  }),
  ...H("SharedRowSelection", {
    setNodesSelected: 0,
    selectAll: 0,
    deselectAll: 0,
    selectAllFiltered: 0,
    deselectAllFiltered: 0,
    selectAllOnCurrentPage: 0,
    deselectAllOnCurrentPage: 0,
    getSelectedNodes: 0,
    getSelectedRows: 0
  }),
  ...H("RowApi", {
    redrawRows: 0,
    setRowNodeExpanded: 0,
    getRowNode: 0,
    addRenderedRowListener: 0,
    getRenderedNodes: 0,
    forEachNode: 0,
    getFirstDisplayedRowIndex: 0,
    getLastDisplayedRowIndex: 0,
    getDisplayedRowAtIndex: 0,
    getDisplayedRowCount: 0
  }),
  ...H("ScrollApi", {
    getVerticalPixelRange: 0,
    getHorizontalPixelRange: 0,
    ensureColumnVisible: 0,
    ensureIndexVisible: 0,
    ensureNodeVisible: 0
  }),
  ...H("KeyboardNavigation", {
    getFocusedCell: 0,
    clearFocusedCell: 0,
    setFocusedCell: 0,
    tabToNextCell: 0,
    tabToPreviousCell: 0,
    setFocusedHeader: 0
  }),
  ...H("EventApi", {
    addEventListener: 0,
    addGlobalListener: 0,
    removeEventListener: 0,
    removeGlobalListener: 0
  }),
  ...H("ValueCache", {
    expireValueCache: 0
  }),
  ...H("CellApi", {
    getCellValue: 0
  }),
  ...H("SharedMenu", {
    showColumnMenu: 0,
    hidePopupMenu: 0
  }),
  ...H("Sort", {
    onSortChanged: 0
  }),
  ...H("PinnedRow", {
    getPinnedTopRowCount: 0,
    getPinnedBottomRowCount: 0,
    getPinnedTopRow: 0,
    getPinnedBottomRow: 0,
    forEachPinnedRow: 0
  }),
  ...H("Overlay", {
    showLoadingOverlay: 0,
    showNoRowsOverlay: 0,
    hideOverlay: 0
  }),
  ...H("RenderApi", {
    setGridAriaProperty: 0,
    refreshCells: 0,
    refreshHeader: 0,
    isAnimationFrameQueueEmpty: 0,
    flushAllAnimationFrames: 0,
    getSizesForCurrentTheme: 0,
    getCellRendererInstances: 0
  }),
  ...H("HighlightChanges", {
    flashCells: 0
  }),
  ...H("RowDrag", {
    addRowDropZone: 0,
    removeRowDropZone: 0,
    getRowDropZoneParams: 0
  }),
  ...H("ColumnApi", {
    getColumnDefs: 0,
    getColumnDef: 0,
    getDisplayNameForColumn: 0,
    getColumn: 0,
    getColumns: 0,
    applyColumnState: 0,
    getColumnState: 0,
    resetColumnState: 0,
    isPinning: 0,
    isPinningLeft: 0,
    isPinningRight: 0,
    getDisplayedColAfter: 0,
    getDisplayedColBefore: 0,
    setColumnsVisible: 0,
    setColumnsPinned: 0,
    getAllGridColumns: 0,
    getDisplayedLeftColumns: 0,
    getDisplayedCenterColumns: 0,
    getDisplayedRightColumns: 0,
    getAllDisplayedColumns: 0,
    getAllDisplayedVirtualColumns: 0
  }),
  ...H("ColumnAutoSize", {
    sizeColumnsToFit: 0,
    autoSizeColumns: 0,
    autoSizeAllColumns: 0
  }),
  ...H("ColumnGroup", {
    setColumnGroupOpened: 0,
    getColumnGroup: 0,
    getProvidedColumnGroup: 0,
    getDisplayNameForColumnGroup: 0,
    getColumnGroupState: 0,
    setColumnGroupState: 0,
    resetColumnGroupState: 0,
    getLeftDisplayedColumnGroups: 0,
    getCenterDisplayedColumnGroups: 0,
    getRightDisplayedColumnGroups: 0,
    getAllDisplayedColumnGroups: 0
  }),
  ...H("ColumnMove", {
    moveColumnByIndex: 0,
    moveColumns: 0
  }),
  ...H("ColumnResize", {
    setColumnWidths: 0
  }),
  ...H("ColumnHover", {
    isColumnHovered: 0
  }),
  ...H("EditCore", {
    getCellEditorInstances: 0,
    getEditingCells: 0,
    stopEditing: 0,
    startEditingCell: 0
  }),
  ...H("UndoRedoEdit", {
    undoCellEditing: 0,
    redoCellEditing: 0,
    getCurrentUndoSize: 0,
    getCurrentRedoSize: 0
  }),
  ...H("FilterCore", {
    isAnyFilterPresent: 0,
    onFilterChanged: 0
  }),
  ...H("ColumnFilter", {
    isColumnFilterPresent: 0,
    getColumnFilterInstance: 0,
    destroyFilter: 0,
    setFilterModel: 0,
    getFilterModel: 0,
    getColumnFilterModel: 0,
    setColumnFilterModel: 0,
    showColumnFilter: 0
  }),
  ...H("QuickFilter", {
    isQuickFilterPresent: 0,
    getQuickFilter: 0,
    resetQuickFilter: 0
  }),
  ...H("Find", {
    findGetActiveMatch: 0,
    findGetTotalMatches: 0,
    findGoTo: 0,
    findNext: 0,
    findPrevious: 0,
    findGetNumMatches: 0,
    findGetParts: 0,
    findClearActive: 0,
    findRefresh: 0
  }),
  ...H("Pagination", {
    paginationIsLastPageFound: 0,
    paginationGetPageSize: 0,
    paginationGetCurrentPage: 0,
    paginationGetTotalPages: 0,
    paginationGetRowCount: 0,
    paginationGoToNextPage: 0,
    paginationGoToPreviousPage: 0,
    paginationGoToFirstPage: 0,
    paginationGoToLastPage: 0,
    paginationGoToPage: 0
  }),
  ...H("CsrmSsrmSharedApi", {
    expandAll: 0,
    collapseAll: 0,
    onRowHeightChanged: 0
  }),
  ...H("SsrmInfiniteSharedApi", {
    setRowCount: 0,
    getCacheBlockState: 0,
    isLastRowIndexKnown: 0
  }),
  ...H("ClientSideRowModelApi", {
    onGroupExpandedOrCollapsed: 0,
    refreshClientSideRowModel: 0,
    isRowDataEmpty: 0,
    forEachLeafNode: 0,
    forEachNodeAfterFilter: 0,
    forEachNodeAfterFilterAndSort: 0,
    resetRowHeights: 0,
    applyTransaction: 0,
    applyTransactionAsync: 0,
    flushAsyncTransactions: 0,
    getBestCostNodeSelection: 0
  }),
  ...H("CsvExport", {
    getDataAsCsv: 0,
    exportDataAsCsv: 0
  }),
  ...H("InfiniteRowModel", {
    refreshInfiniteCache: 0,
    purgeInfiniteCache: 0,
    getInfiniteRowCount: 0
  }),
  ...H("AdvancedFilter", {
    getAdvancedFilterModel: 0,
    setAdvancedFilterModel: 0,
    showAdvancedFilterBuilder: 0,
    hideAdvancedFilterBuilder: 0
  }),
  ...H("IntegratedCharts", {
    getChartModels: 0,
    getChartRef: 0,
    getChartImageDataURL: 0,
    downloadChart: 0,
    openChartToolPanel: 0,
    closeChartToolPanel: 0,
    createRangeChart: 0,
    createPivotChart: 0,
    createCrossFilterChart: 0,
    updateChart: 0,
    restoreChart: 0
  }),
  ...H("Clipboard", {
    copyToClipboard: 0,
    cutToClipboard: 0,
    copySelectedRowsToClipboard: 0,
    copySelectedRangeToClipboard: 0,
    copySelectedRangeDown: 0,
    pasteFromClipboard: 0
  }),
  ...H("ExcelExport", {
    getDataAsExcel: 0,
    exportDataAsExcel: 0,
    getSheetDataForExcel: 0,
    getMultipleSheetsAsExcel: 0,
    exportMultipleSheetsAsExcel: 0
  }),
  ...H("SharedMasterDetail", {
    addDetailGridInfo: 0,
    removeDetailGridInfo: 0,
    getDetailGridInfo: 0,
    forEachDetailGridInfo: 0
  }),
  ...H("ContextMenu", {
    showContextMenu: 0
  }),
  ...H("ColumnMenu", {
    showColumnChooser: 0,
    hideColumnChooser: 0
  }),
  ...H("CellSelection", {
    getCellRanges: 0,
    addCellRange: 0,
    clearRangeSelection: 0,
    clearCellSelection: 0
  }),
  ...H("SharedRowGrouping", {
    setRowGroupColumns: 0,
    removeRowGroupColumns: 0,
    addRowGroupColumns: 0,
    getRowGroupColumns: 0,
    moveRowGroupColumn: 0
  }),
  ...H("SharedAggregation", {
    addAggFuncs: 0,
    clearAggFuncs: 0,
    setColumnAggFunc: 0
  }),
  ...H("SharedPivot", {
    isPivotMode: 0,
    getPivotResultColumn: 0,
    setValueColumns: 0,
    getValueColumns: 0,
    removeValueColumns: 0,
    addValueColumns: 0,
    setPivotColumns: 0,
    removePivotColumns: 0,
    addPivotColumns: 0,
    getPivotColumns: 0,
    setPivotResultColumns: 0,
    getPivotResultColumns: 0
  }),
  ...H("ServerSideRowModelApi", {
    getServerSideSelectionState: 0,
    setServerSideSelectionState: 0,
    applyServerSideTransaction: 0,
    applyServerSideTransactionAsync: 0,
    applyServerSideRowData: 0,
    retryServerSideLoads: 0,
    flushServerSideAsyncTransactions: 0,
    refreshServerSide: 0,
    getServerSideGroupLevelState: 0
  }),
  ...H("SideBar", {
    isSideBarVisible: 0,
    setSideBarVisible: 0,
    setSideBarPosition: 0,
    openToolPanel: 0,
    closeToolPanel: 0,
    getOpenedToolPanel: 0,
    refreshToolPanel: 0,
    isToolPanelShowing: 0,
    getToolPanelInstance: 0,
    getSideBar: 0
  }),
  ...H("StatusBar", {
    getStatusPanel: 0
  })
}, Cr = {
  isDestroyed: () => !0,
  destroy() {
  },
  preConstruct() {
  },
  postConstruct() {
  },
  preWireBeans() {
  },
  wireBeans() {
  }
}, Db = (e, t) => e.eventSvc.dispatchEvent(t), Rh = class {
};
Reflect.defineProperty(Rh, "name", { value: "GridApi" });
var Mb = class extends S {
  constructor() {
    super(), this.beanName = "apiFunctionSvc", this.api = new Rh(), this.fns = {
      ...Cr,
      // dispatchEvent is used by frameworks, also used by aligned grids to identify a grid api instance
      dispatchEvent: Db
    }, this.preDestroyLink = "";
    const { api: e } = this;
    for (const t of Object.keys(id))
      e[t] = this.makeApi(t)[t];
  }
  postConstruct() {
    this.preDestroyLink = this.beans.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  addFunction(e, t) {
    var o;
    const { fns: s, beans: i } = this;
    s !== Cr && (s[e] = ((o = i == null ? void 0 : i.validation) == null ? void 0 : o.validateApiFunction(e, t)) ?? t);
  }
  makeApi(e) {
    return {
      [e]: (...t) => {
        const {
          beans: s,
          fns: { [e]: i }
        } = this;
        return i ? i(s, ...t) : this.apiNotFound(e);
      }
    };
  }
  apiNotFound(e) {
    const { beans: t, gos: s, preDestroyLink: i } = this;
    if (!t)
      P(26, { fnName: e, preDestroyLink: i });
    else {
      const o = id[e];
      s.assertModuleRegistered(o, `api.${e}`) && P(27, { fnName: e, module: o });
    }
  }
  destroy() {
    super.destroy(), this.fns = Cr, this.beans = null;
  }
};
function Eb(e) {
  return e.context.getGridId();
}
function Ab(e) {
  e.gridDestroySvc.destroy();
}
function Ib(e) {
  return e.gridDestroySvc.destroyCalled;
}
function Tb(e, t) {
  return e.gos.get(t);
}
function Lb(e, t, s) {
  Fh(e, { [t]: s });
}
function Fh(e, t) {
  e.gos.updateGridOptions({ options: t });
}
function kb(e, t) {
  const s = t.replace(/Module$/, "");
  return e.gos.isModuleRegistered(s);
}
var Gb = class extends S {
  constructor() {
    super(...arguments), this.beanName = "horizontalResizeSvc";
  }
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      onDragCancel: this.onDragStop.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    }, { dragSvc: s } = this.beans;
    return s.addDragSource(t), () => s.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const s = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(s);
  }
  setResizeIcons() {
    const e = this.beans.ctrlsSvc.get("gridCtrl");
    e.setResizeCursor(!0), e.disableUserSelect(!0);
  }
  onDragStop(e) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.beans.ctrlsSvc.get("gridCtrl");
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
}, Ph = {
  moduleName: "Drag",
  version: Q,
  beans: [Fv]
}, il = {
  moduleName: "SharedDragAndDrop",
  version: Q,
  beans: [wv],
  dependsOn: [Ph],
  userComponents: {
    agDragAndDropImage: Gw
  },
  icons: {
    // shown on drag and drop image component icon while dragging column to the side of the grid to pin
    columnMovePin: "pin",
    // shown on drag and drop image component icon while dragging over part of the page that is not a drop zone
    columnMoveHide: "eye-slash",
    // shown on drag and drop image component icon while dragging columns to reorder
    columnMoveMove: "arrows",
    // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
    columnMoveLeft: "left",
    // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
    columnMoveRight: "right",
    // shown on drag and drop image component icon while dragging over Row Groups drop zone
    columnMoveGroup: "group",
    // shown on drag and drop image component icon while dragging over Values drop zone
    columnMoveValue: "aggregation",
    // shown on drag and drop image component icon while dragging over pivot drop zone
    columnMovePivot: "pivot",
    // shown on drag and drop image component icon while dragging over drop zone that doesn't support it, e.g.
    // string column over aggregation drop zone
    dropNotAllowed: "not-allowed",
    // drag handle used to pick up draggable rows
    rowDrag: "grip"
  }
}, Dh = {
  moduleName: "HorizontalResize",
  version: Q,
  beans: [Gb],
  dependsOn: [Ph]
}, Ob = (
  /*css*/
  ":where(.ag-ltr) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:left .2s}.ag-header-group-cell{transition:left .2s,width .2s}}:where(.ag-rtl) :where(.ag-column-moving){.ag-cell,.ag-header-cell,.ag-spanned-cell-wrapper{transition:right .2s}.ag-header-group-cell{transition:right .2s,width .2s}}"
), Bb = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colAnimation", this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.activeNext = !1, this.suppressAnimation = !1, this.animationThreadCount = 0;
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    if (this.active)
      return;
    const { gos: e } = this;
    e.get("suppressColumnMoveAnimation") || e.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0, this.activeNext = !0);
  }
  finish() {
    this.active && this.flush(
      () => this.activeNext = !1,
      () => this.active = !1
    );
  }
  executeNextVMTurn(e) {
    this.activeNext ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount, { gridBodyCtrl: t } = this;
    t.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && t.setColumnMovingCss(!1);
    });
  }
  flush(e, t) {
    const { executeNextFuncs: s, executeLaterFuncs: i } = this;
    if (s.length === 0 && i.length === 0) {
      e(), t();
      return;
    }
    const o = (n) => {
      for (; n.length; ) {
        const r = n.pop();
        r && r();
      }
    };
    this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        e(), o(s);
      }, 0), window.setTimeout(() => {
        t(), o(i);
      }, 200);
    });
  }
};
function Nb(e, t, s) {
  var i;
  (i = e.colMoves) == null || i.moveColumnByIndex(t, s, "api");
}
function Hb(e, t, s) {
  var i;
  (i = e.colMoves) == null || i.moveColumns(t, s, "api");
}
var Vb = class extends S {
  constructor(e) {
    super(), this.pinned = e, this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [];
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((s) => {
      s.isPrimary() && (s.isAnyFunctionActive() || (s.isAllowValue() ? this.columnsToAggregate.push(s) : s.isAllowRowGroup() ? this.columnsToGroup.push(s) : s.isAllowPivot() && this.columnsToPivot.push(s)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? "pinned" : "move" : null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(e) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(e) {
    const { valueColsSvc: t, rowGroupColsSvc: s, pivotColsSvc: i } = this.beans;
    this.columnsToAggregate.length > 0 && (t == null || t.addColumns(this.columnsToAggregate, "toolPanelDragAndDrop")), this.columnsToGroup.length > 0 && (s == null || s.addColumns(this.columnsToGroup, "toolPanelDragAndDrop")), this.columnsToPivot.length > 0 && (i == null || i.addColumns(this.columnsToPivot, "toolPanelDragAndDrop"));
  }
  onDragCancel() {
    this.clearColumnsList();
  }
};
function _b(e, t) {
  !t || t.length <= 1 || t.filter((i) => e.indexOf(i) < 0).length > 0 || t.sort((i, o) => {
    const n = e.indexOf(i), r = e.indexOf(o);
    return n - r;
  });
}
function Mh(e) {
  const { isFromHeader: t, fromLeft: s, xPosition: i, fromEnter: o, fakeEvent: n, pinned: r, gos: a, colModel: l, colMoves: d, visibleCols: c } = e;
  let { allMovingColumns: u } = e;
  if (t) {
    const F = [];
    u.forEach((R) => {
      var I;
      let D = null, M = R.getParent();
      for (; M != null && M.getDisplayedLeafColumns().length === 1; )
        D = M, M = M.getParent();
      D != null ? (!!((I = D.getColGroupDef()) != null && I.marryChildren) ? (
        // when marry children is true, we also have to move hidden
        // columns within the group, so grab them from the `providedColumnGroup`
        D.getProvidedColumnGroup().getLeafColumns()
      ) : D.getLeafColumns()).forEach((E) => {
        F.includes(E) || F.push(E);
      }) : F.includes(R) || F.push(R);
    }), u = F;
  }
  const h = u.slice();
  _b(l.getCols(), h);
  const g = jb({
    movingCols: h,
    draggingRight: s,
    xPosition: i,
    pinned: r,
    gos: a,
    colModel: l,
    visibleCols: c
  }), p = Wb(h, l);
  if (g.length === 0)
    return;
  const f = g[0];
  let m = p !== null && !o;
  if (t && (m = p !== null), m && !n && (!s && f >= p || s && f <= p))
    return;
  const b = c.allCols, w = [];
  let C = null;
  for (let F = 0; F < g.length; F++) {
    const R = g[F], D = d.getProposedColumnOrder(h, R);
    if (!d.doesOrderPassRules(D))
      continue;
    const M = D.filter((J) => b.includes(J));
    if (C === null)
      C = M;
    else if (!pt(M, C))
      break;
    const I = zb(D);
    w.push({ move: R, fragCount: I });
  }
  if (w.length === 0)
    return;
  w.sort((F, R) => F.fragCount - R.fragCount);
  const v = w[0].move;
  if (!(v > l.getCols().length - u.length))
    return { columns: u, toIndex: v };
}
function Eh(e) {
  const { columns: t, toIndex: s } = Mh(e) || {}, { finished: i, colMoves: o } = e;
  return !t || s == null ? null : (o.moveColumns(t, s, "uiColumnMoved", i), i ? null : { columns: t, toIndex: s });
}
function Wb(e, t) {
  const s = t.getCols(), i = e.map((l) => s.indexOf(l)).sort((l, d) => l - d), o = i[0];
  return Z(i) - o !== i.length - 1 ? null : o;
}
function zb(e) {
  function t(i) {
    const o = [];
    let n = i.getOriginalParent();
    for (; n != null; )
      o.push(n), n = n.getOriginalParent();
    return o;
  }
  let s = 0;
  for (let i = 0; i < e.length - 1; i++) {
    let o = t(e[i]), n = t(e[i + 1]);
    [o, n] = o.length > n.length ? [o, n] : [n, o], o.forEach((r) => {
      n.indexOf(r) === -1 && s++;
    });
  }
  return s;
}
function Ub(e, t) {
  switch (t) {
    case "left":
      return e.leftCols;
    case "right":
      return e.rightCols;
    default:
      return e.centerCols;
  }
}
function jb(e) {
  const { movingCols: t, draggingRight: s, xPosition: i, pinned: o, gos: n, colModel: r, visibleCols: a } = e;
  if (n.get("suppressMovableColumns") || t.some((C) => C.getColDef().suppressMovable))
    return [];
  const d = Ub(a, o), c = r.getCols(), u = d.filter((C) => t.includes(C)), h = d.filter((C) => !t.includes(C)), g = c.filter((C) => !t.includes(C));
  let p = 0, f = i;
  if (s) {
    let C = 0;
    u.forEach((v) => C += v.getActualWidth()), f -= C;
  }
  if (f > 0) {
    for (let C = 0; C < h.length; C++) {
      const v = h[C];
      if (f -= v.getActualWidth(), f < 0)
        break;
      p++;
    }
    s && p++;
  }
  let m;
  if (p > 0) {
    const C = h[p - 1];
    m = g.indexOf(C) + 1;
  } else
    m = g.indexOf(h[0]), m === -1 && (m = 0);
  const b = [m], w = (C, v) => C - v;
  if (s) {
    let C = m + 1;
    const v = c.length - 1;
    for (; C <= v; )
      b.push(C), C++;
    b.sort(w);
  } else {
    let C = m;
    const v = c.length - 1;
    let F = c[C];
    for (; C <= v && d.indexOf(F) < 0; )
      C++, b.push(C), F = c[C];
    C = m - 1;
    const R = 0;
    for (; C >= R; )
      b.push(C), C--;
    b.sort(w).reverse();
  }
  return b;
}
function ta(e) {
  var d;
  const { pinned: t, fromKeyboard: s, gos: i, ctrlsSvc: o, useHeaderRow: n, skipScrollPadding: r } = e;
  let a = (d = o.getHeaderRowContainerCtrl(t)) == null ? void 0 : d.eViewport, { x: l } = e;
  return a ? (s && (l -= a.getBoundingClientRect().left), i.get("enableRtl") && (n && (a = a.querySelector(".ag-header-row")), l = a.clientWidth - l), t == null && !r && (l += o.get("center").getCenterViewportScrollLeft()), l) : 0;
}
function vr(e, t) {
  for (const s of e)
    s.moving = t, s.dispatchColEvent("movingChanged", "uiColumnMoved");
}
var od = 7, sa = 100, No = sa / 2, $b = 5, Kb = 100, qb = class extends S {
  constructor(e) {
    super(), this.pinned = e, this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.isCenterContainer = !T(e);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    const { pinned: e, lastDraggingEvent: t } = this, { dragItem: s } = t || {}, i = (s == null ? void 0 : s.columns) ?? [];
    for (const o of i) {
      const n = o.getPinned();
      if (o.getColDef().lockPinned) {
        if (n == e)
          return "move";
        continue;
      }
      const r = s == null ? void 0 : s.containerType;
      if (r === e || !e)
        return "move";
      if (e && (!n || r !== e))
        return "pinned";
    }
    return "notAllowed";
  }
  onDragEnter(e) {
    const t = e.dragItem, s = t.columns;
    if (e.dragSource.type === 0)
      this.setColumnsVisible(s, !0, "uiColumnDragged");
    else {
      const o = t.visibleState, n = (s || []).filter((r) => o[r.getId()]);
      this.setColumnsVisible(n, !0, "uiColumnDragged");
    }
    this.gos.get("suppressMoveWhenColumnDragging") || this.attemptToPinColumns(s, this.pinned), this.onDragging(e, !0, !0);
  }
  onDragging(e = this.lastDraggingEvent, t = !1, s = !1, i = !1) {
    const { gos: o, ctrlsSvc: n } = this.beans, r = o.get("suppressMoveWhenColumnDragging");
    if (i && !r) {
      this.finishColumnMoving();
      return;
    }
    if (this.lastDraggingEvent = e, !e || !i && ie(e.hDirection))
      return;
    const a = ta({
      x: e.x,
      pinned: this.pinned,
      gos: o,
      ctrlsSvc: n
    });
    t || this.checkCenterForScrolling(a), r ? this.handleColumnDragWhileSuppressingMovement(e, t, s, a, i) : this.handleColumnDragWhileAllowingMovement(e, t, s, a, i);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.clearHighlighted(), this.updateDragItemContainerType(), this.lastMovedInfo = null;
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  onDragCancel() {
    this.clearHighlighted(), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, s) {
    if (!e)
      return;
    const i = e.filter((o) => !o.getColDef().lockVisible);
    this.beans.colModel.setColsVisible(i, t, s);
  }
  finishColumnMoving() {
    this.clearHighlighted();
    const e = this.lastMovedInfo;
    if (!e)
      return;
    const { columns: t, toIndex: s } = e;
    this.beans.colMoves.moveColumns(t, s, "uiColumnMoved", !0);
  }
  updateDragItemContainerType() {
    const { lastDraggingEvent: e } = this;
    if (this.gos.get("suppressMoveWhenColumnDragging") || !e)
      return;
    const t = e.dragItem;
    t && (t.containerType = this.pinned);
  }
  handleColumnDragWhileSuppressingMovement(e, t, s, i, o) {
    const n = this.getAllMovingColumns(e, !0);
    if (o) {
      const r = this.isAttemptingToPin(n);
      r && this.attemptToPinColumns(n, void 0, !0);
      const { fromLeft: a, xPosition: l } = this.getNormalisedXPositionInfo(n, r) || {};
      if (a == null || l == null) {
        this.finishColumnMoving();
        return;
      }
      this.moveColumnsAfterHighlight({
        allMovingColumns: n,
        xPosition: l,
        fromEnter: t,
        fakeEvent: s,
        fromLeft: a
      });
    } else {
      if (!this.beans.dragAndDrop.isDropZoneWithinThisGrid(e))
        return;
      this.highlightHoveredColumn(n, i);
    }
  }
  handleColumnDragWhileAllowingMovement(e, t, s, i, o) {
    const n = this.getAllMovingColumns(e), r = this.normaliseDirection(e.hDirection) === "right", a = e.dragSource.type === 1, l = this.getMoveColumnParams({
      allMovingColumns: n,
      isFromHeader: a,
      xPosition: i,
      fromLeft: r,
      fromEnter: t,
      fakeEvent: s
    }), d = Eh({ ...l, finished: o });
    d && (this.lastMovedInfo = d);
  }
  getAllMovingColumns(e, t = !1) {
    const s = e.dragSource.getDragItem();
    let i = null;
    t ? (i = s.columnsInSplit, i || (i = s.columns)) : i = s.columns;
    const o = (n) => n.getColDef().lockPinned ? n.getPinned() == this.pinned : !0;
    return i ? i.filter(o) : [];
  }
  getMoveColumnParams(e) {
    const { allMovingColumns: t, isFromHeader: s, xPosition: i, fromLeft: o, fromEnter: n, fakeEvent: r } = e, { gos: a, colModel: l, colMoves: d, visibleCols: c } = this.beans;
    return {
      allMovingColumns: t,
      isFromHeader: s,
      fromLeft: o,
      xPosition: i,
      pinned: this.pinned,
      fromEnter: n,
      fakeEvent: r,
      gos: a,
      colModel: l,
      colMoves: d,
      visibleCols: c
    };
  }
  highlightHoveredColumn(e, t) {
    var c;
    const { gos: s, colModel: i } = this.beans, o = s.get("enableRtl"), n = i.getCols().filter((u) => u.isVisible() && u.getPinned() === this.pinned);
    let r = null, a = null, l = null;
    for (const u of n) {
      if (a = u.getActualWidth(), r = this.getNormalisedColumnLeft(u, 0, o), r != null) {
        const h = r + a;
        if (r <= t && h >= t) {
          l = u;
          break;
        }
      }
      r = null, a = null;
    }
    if (l)
      e.indexOf(l) !== -1 && (l = null);
    else {
      for (let u = n.length - 1; u >= 0; u--) {
        const h = n[u], g = n[u].getParent();
        if (!g) {
          l = h;
          break;
        }
        const p = g == null ? void 0 : g.getDisplayedLeafColumns();
        if (p.length) {
          l = Z(p);
          break;
        }
      }
      if (!l)
        return;
      r = this.getNormalisedColumnLeft(l, 0, o), a = l.getActualWidth();
    }
    if (((c = this.lastHighlightedColumn) == null ? void 0 : c.column) !== l && this.clearHighlighted(), l == null || r == null || a == null)
      return;
    let d;
    t - r < a / 2 !== o ? d = 0 : d = 1, nd(l, d), this.lastHighlightedColumn = { column: l, position: d };
  }
  getNormalisedXPositionInfo(e, t) {
    const { gos: s, visibleCols: i } = this.beans, o = s.get("enableRtl"), { firstMovingCol: n, column: r, position: a } = this.getColumnMoveAndTargetInfo(
      e,
      t,
      o
    );
    if (!n || !r || a == null)
      return;
    const l = i.allCols, d = l.indexOf(n), c = l.indexOf(r), u = a === 0 !== o, h = d < c || d === c && !u;
    let g = 0;
    if (u ? h && (g -= 1) : h || (g += 1), c + g === d)
      return;
    const p = l[c + g];
    if (!p)
      return;
    const f = this.getNormalisedColumnLeft(p, 20, o);
    return { fromLeft: h, xPosition: f };
  }
  getColumnMoveAndTargetInfo(e, t, s) {
    const i = this.lastHighlightedColumn || {}, { firstMovingCol: o, lastMovingCol: n } = Yb(e);
    if (!o || !n || i.column || !t)
      return {
        firstMovingCol: o,
        ...i
      };
    const a = this.getPinDirection() === "left";
    return {
      firstMovingCol: o,
      position: a ? 1 : 0,
      column: a !== s ? o : n
    };
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl"))
      switch (e) {
        case "left":
          return "right";
        case "right":
          return "left";
      }
    return e;
  }
  getNormalisedColumnLeft(e, t, s) {
    const { gos: i, ctrlsSvc: o } = this.beans, n = e.getLeft();
    if (n == null)
      return null;
    const r = e.getActualWidth();
    return ta({
      x: s ? n + r - t : n + t,
      pinned: e.getPinned(),
      useHeaderRow: s,
      skipScrollPadding: !0,
      gos: i,
      ctrlsSvc: o
    });
  }
  isAttemptingToPin(e) {
    const t = this.needToMoveLeft || this.needToMoveRight, s = this.failedMoveAttempts > od;
    return t && s || e.some((i) => i.getPinned() !== this.pinned);
  }
  moveColumnsAfterHighlight(e) {
    const { allMovingColumns: t, xPosition: s, fromEnter: i, fakeEvent: o, fromLeft: n } = e, r = this.getMoveColumnParams({
      allMovingColumns: t,
      isFromHeader: !0,
      xPosition: s,
      fromLeft: n,
      fromEnter: i,
      fakeEvent: o
    }), { columns: a, toIndex: l } = Mh(r) || {};
    a && l != null && (this.lastMovedInfo = {
      columns: a,
      toIndex: l
    }), this.finishColumnMoving();
  }
  clearHighlighted() {
    const { lastHighlightedColumn: e } = this;
    e && (nd(e.column, null), this.lastHighlightedColumn = null);
  }
  checkCenterForScrolling(e) {
    if (!this.isCenterContainer)
      return;
    const t = this.beans.ctrlsSvc.get("center"), s = t.getCenterViewportScrollLeft(), i = s + t.getCenterWidth();
    let o, n;
    this.gos.get("enableRtl") ? (o = e < s + No, n = e > i - No) : (n = e < s + No, o = e > i - No), this.needToMoveRight = o, this.needToMoveLeft = n, n || o ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
  }
  ensureIntervalStarted() {
    var e;
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), Kb), (e = this.beans.dragAndDrop.getDragAndDropImageComponent()) == null || e.setIcon(this.needToMoveLeft ? "left" : "right", !0));
  }
  ensureIntervalCleared() {
    var e;
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.failedMoveAttempts = 0, (e = this.beans.dragAndDrop.getDragAndDropImageComponent()) == null || e.setIcon(this.getIconName(), !1));
  }
  moveInterval() {
    var i, o;
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * $b, e > sa && (e = sa);
    let t = null;
    const s = this.gridBodyCon.scrollFeature;
    if (this.needToMoveLeft ? t = s.scrollHorizontally(-e) : this.needToMoveRight && (t = s.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      this.failedMoveAttempts++;
      const { pinnedCols: n, dragAndDrop: r, gos: a } = this.beans;
      if (this.failedMoveAttempts <= od + 1 || !n)
        return;
      if ((i = r.getDragAndDropImageComponent()) == null || i.setIcon("pinned", !1), !a.get("suppressMoveWhenColumnDragging")) {
        const l = (o = this.lastDraggingEvent) == null ? void 0 : o.dragItem.columns;
        this.attemptToPinColumns(l, void 0, !0);
      }
    }
  }
  getPinDirection() {
    if (this.needToMoveLeft || this.pinned === "left")
      return "left";
    if (this.needToMoveRight || this.pinned === "right")
      return "right";
  }
  attemptToPinColumns(e, t, s = !1) {
    const i = (e || []).filter((r) => !r.getColDef().lockPinned);
    if (!i.length)
      return 0;
    s && (t = this.getPinDirection());
    const { pinnedCols: o, dragAndDrop: n } = this.beans;
    return o == null || o.setColsPinned(i, t, "uiColumnDragged"), s && n.nudge(), i.length;
  }
  destroy() {
    super.destroy(), this.lastDraggingEvent = null, this.clearHighlighted(), this.lastMovedInfo = null;
  }
};
function nd(e, t) {
  e.highlighted !== t && (e.highlighted = t, e.dispatchColEvent("headerHighlightChanged", "uiColumnMoved"));
}
function Yb(e) {
  const t = e.length;
  let s, i;
  for (let o = 0; o < t; o++) {
    if (!s) {
      const n = e[o];
      n.getLeft() != null && (s = n);
    }
    if (!i) {
      const n = e[t - 1 - o];
      n.getLeft() != null && (i = n);
    }
    if (s && i)
      break;
  }
  return { firstMovingCol: s, lastMovingCol: i };
}
var Zb = class extends S {
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    const { ctrlsSvc: e, dragAndDrop: t } = this.beans, s = this.pinned;
    e.whenReady(this, (i) => {
      let o;
      const n = i.gridBodyCtrl.eBodyViewport;
      switch (s) {
        case "left":
          o = [
            [n, i.left.eContainer],
            [i.bottomLeft.eContainer],
            [i.topLeft.eContainer]
          ];
          break;
        case "right":
          o = [
            [n, i.right.eContainer],
            [i.bottomRight.eContainer],
            [i.topRight.eContainer]
          ];
          break;
        default:
          o = [
            [n, i.center.eViewport],
            [i.bottomCenter.eViewport],
            [i.topCenter.eViewport]
          ];
          break;
      }
      this.eSecondaryContainers = o;
    }), this.moveColumnFeature = this.createManagedBean(new qb(s)), this.bodyDropPivotTarget = this.createManagedBean(new Vb(s)), t.addDropTarget(this), this.addDestroyFunc(() => t.removeDropTarget(this));
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.beans.colModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
  onDragCancel() {
    this.currentDropListener.onDragCancel();
  }
}, Qb = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colMoves";
  }
  moveColumnByIndex(e, t, s) {
    const i = this.beans.colModel.getCols();
    if (!i)
      return;
    const o = i[e];
    this.moveColumns([o], t, s);
  }
  moveColumns(e, t, s, i = !0) {
    const { colModel: o, colAnimation: n, visibleCols: r, eventSvc: a } = this.beans, l = o.getCols();
    if (!l)
      return;
    if (t > l.length - e.length) {
      P(30, { toIndex: t });
      return;
    }
    n == null || n.start();
    const d = o.getColsForKeys(e);
    this.doesMovePassRules(d, t) && (Ul(o.getCols(), d, t), r.refresh(s), a.dispatchEvent({
      type: "columnMoved",
      columns: d,
      column: d.length === 1 ? d[0] : null,
      toIndex: t,
      finished: i,
      source: s
    })), n == null || n.finish();
  }
  doesMovePassRules(e, t) {
    const s = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(s);
  }
  doesOrderPassRules(e) {
    const { colModel: t, gos: s } = this.beans;
    return !(!Eu(e, t.getColTree()) || !((o) => {
      const n = (d) => d ? d === "left" || d === !0 ? -1 : 1 : 0, r = s.get("enableRtl");
      let a = r ? 1 : -1, l = !0;
      return o.forEach((d) => {
        const c = n(d.getColDef().lockPosition);
        r ? c > a && (l = !1) : c < a && (l = !1), a = c;
      }), l;
    })(e));
  }
  getProposedColumnOrder(e, t) {
    const i = this.beans.colModel.getCols().slice();
    return Ul(i, e, t), i;
  }
  createBodyDropTarget(e, t) {
    return new Zb(e, t);
  }
  moveHeader(e, t, s, i, o) {
    const { ctrlsSvc: n, gos: r, colModel: a, visibleCols: l, focusSvc: d } = this.beans, c = t.getBoundingClientRect(), u = c.left, h = ue(s), g = h ? c.width : s.getActualWidth(), p = e === "left" !== r.get("enableRtl"), f = ta({
      x: p ? u - 20 : u + g + 20,
      pinned: i,
      fromKeyboard: !0,
      gos: r,
      ctrlsSvc: n
    }), m = d.focusedHeader;
    Eh({
      allMovingColumns: h ? s.getLeafColumns() : [s],
      isFromHeader: !0,
      fromLeft: e === "right",
      xPosition: f,
      pinned: i,
      fromEnter: !1,
      fakeEvent: !1,
      gos: r,
      colModel: a,
      colMoves: this,
      visibleCols: l,
      finished: !0
    });
    let b;
    if (h) {
      const w = s.getDisplayedLeafColumns();
      b = p ? w[0] : Z(w);
    } else
      b = s;
    if (n.getScrollFeature().ensureColumnVisible(b, "auto"), (!o.isAlive() || r.get("ensureDomOrder")) && m) {
      let w;
      if (h) {
        const C = s.getGroupId(), v = s.getLeafColumns();
        if (!v.length)
          return;
        const F = v[0].getParent();
        if (!F)
          return;
        w = Xb(F, C);
      } else
        w = s;
      w && d.focusHeaderPosition({
        headerPosition: {
          ...m,
          column: w
        }
      });
    }
  }
  setDragSourceForHeader(e, t, s) {
    const { gos: i, colModel: o, dragAndDrop: n, visibleCols: r } = this.beans;
    let a = !i.get("suppressDragLeaveHidesColumns");
    const l = ue(t), d = l ? t.getProvidedColumnGroup().getLeafColumns() : [t], u = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => a ? "hide" : "notAllowed",
      getDragItem: l ? () => ey(t, r.allCols) : () => Jb(t),
      dragItemName: s,
      onDragStarted: () => {
        a = !i.get("suppressDragLeaveHidesColumns"), vr(d, !0);
      },
      onDragStopped: () => vr(d, !1),
      onDragCancelled: () => vr(d, !1),
      onGridEnter: (h) => {
        if (a) {
          const { columns: g = [], visibleState: p } = h ?? {}, f = l ? (b) => !p || p[b.getColId()] : () => !0, m = g.filter(
            (b) => !b.getColDef().lockVisible && f(b)
          );
          o.setColsVisible(m, !0, "uiColumnMoved");
        }
      },
      onGridExit: (h) => {
        var g;
        if (a) {
          const p = ((g = h == null ? void 0 : h.columns) == null ? void 0 : g.filter((f) => !f.getColDef().lockVisible)) || [];
          o.setColsVisible(p, !1, "uiColumnMoved");
        }
      }
    };
    return n.addDragSource(u, !0), u;
  }
};
function Xb(e, t) {
  for (; e; ) {
    if (e.getGroupId() === t)
      return e;
    e = e.getParent();
  }
}
function Jb(e) {
  const t = {};
  return t[e.getId()] = e.isVisible(), {
    columns: [e],
    visibleState: t,
    containerType: e.pinned
  };
}
function ey(e, t) {
  var a;
  const s = e.getProvidedColumnGroup().getLeafColumns(), i = {};
  s.forEach((l) => i[l.getId()] = l.isVisible());
  const o = [];
  t.forEach((l) => {
    s.indexOf(l) >= 0 && (o.push(l), Ae(s, l));
  }), s.forEach((l) => o.push(l));
  const n = [], r = e.getLeafColumns();
  for (const l of o)
    r.indexOf(l) !== -1 && n.push(l);
  return {
    columns: o,
    columnsInSplit: n,
    visibleState: i,
    containerType: (a = n[0]) == null ? void 0 : a.pinned
  };
}
var ol = {
  moduleName: "ColumnMove",
  version: Q,
  beans: [Qb, Bb],
  apiFunctions: {
    moveColumnByIndex: Nb,
    moveColumns: Hb
  },
  dependsOn: [il],
  css: [Ob]
}, ty = class extends S {
  constructor() {
    super(...arguments), this.beanName = "autoWidthCalc";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const s = this.getHeaderCellForColumn(e);
    if (!s)
      return -1;
    const i = this.beans.rowRenderer.getAllCellsNotSpanningForColumn(e);
    return t || i.push(s), this.getPreferredWidthForElements(i);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.getPreferredWidthForElements([t]) : -1;
  }
  getPreferredWidthForElements(e, t) {
    const s = document.createElement("form");
    s.style.position = "fixed";
    const i = this.centerRowContainerCtrl.eContainer;
    e.forEach((n) => this.cloneItemIntoDummy(n, s)), i.appendChild(s);
    const o = s.offsetWidth;
    return i.removeChild(s), t = t ?? this.gos.get("autoSizePadding"), o + t;
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.beans.ctrlsSvc.getHeaderRowContainerCtrls().forEach((s) => {
      const i = s.getHtmlElementForColumnHeader(e);
      i != null && (t = i);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const s = e.cloneNode(!0);
    s.style.width = "", s.style.position = "static", s.style.left = "";
    const i = document.createElement("div"), o = i.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((a) => s.classList.contains(a)) ? (o.add("ag-header", "ag-header-row"), i.style.position = "static") : o.add("ag-row");
    let r = e.parentElement;
    for (; r; ) {
      if (["ag-header-row", "ag-row"].some((l) => r.classList.contains(l))) {
        for (let l = 0; l < r.classList.length; l++) {
          const d = r.classList[l];
          d != "ag-row-position-absolute" && o.add(d);
        }
        break;
      }
      r = r.parentElement;
    }
    i.appendChild(s), t.appendChild(i);
  }
}, sy = {
  moduleName: "AutoWidth",
  version: Q,
  beans: [ty]
};
function iy(e, t, s = !0, i = "api") {
  var o;
  (o = e.colResize) == null || o.setColumnWidths(t, !1, s, i);
}
var oy = class extends S {
  constructor(e, t, s, i) {
    super(), this.comp = e, this.eResize = t, this.pinned = s, this.columnGroup = i;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const { horizontalResizeSvc: e, gos: t, colAutosize: s } = this.beans, i = e.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    this.addDestroyFunc(i), !t.get("suppressAutoSize") && s && this.addDestroyFunc(
      s.addColumnGroupResize(
        this.eResize,
        this.columnGroup,
        () => this.resizeLeafColumnsToFit("uiColumnResized")
      )
    );
  }
  onResizeStart(e) {
    const {
      columnsToResize: t,
      resizeStartWidth: s,
      resizeRatios: i,
      groupAfterColumns: o,
      groupAfterStartWidth: n,
      groupAfterRatios: r
    } = this.getInitialValues(e);
    this.resizeCols = t, this.resizeStartWidth = s, this.resizeRatios = i, this.resizeTakeFromCols = o, this.resizeTakeFromStartWidth = n, this.resizeTakeFromRatios = r, this.toggleColumnResizing(!0);
  }
  onResizing(e, t, s = "uiColumnResized") {
    const i = this.normaliseDragChange(t), o = this.resizeStartWidth + i;
    this.resizeColumnsFromLocalValues(o, s, e);
  }
  getInitialValues(e) {
    var l;
    const t = (d) => d.reduce((c, u) => c + u.getActualWidth(), 0), s = (d, c) => d.map((u) => u.getActualWidth() / c), i = this.getColumnsToResize(), o = t(i), n = s(i, o), r = {
      columnsToResize: i,
      resizeStartWidth: o,
      resizeRatios: n
    };
    let a = null;
    if (e && (a = ((l = this.beans.colGroupSvc) == null ? void 0 : l.getGroupAtDirection(this.columnGroup, "After")) ?? null), a) {
      const d = a.getDisplayedLeafColumns(), c = r.groupAfterColumns = d.filter(
        (h) => h.isResizable()
      ), u = r.groupAfterStartWidth = t(c);
      r.groupAfterRatios = s(c, u);
    } else
      r.groupAfterColumns = void 0, r.groupAfterStartWidth = void 0, r.groupAfterRatios = void 0;
    return r;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.beans.autoWidthCalc.getPreferredWidthForColumnGroup(this.columnGroup), s = this.getInitialValues();
    t > s.resizeStartWidth && this.resizeColumns(s, t, e, !0);
  }
  resizeColumnsFromLocalValues(e, t, s = !0) {
    if (!this.resizeCols || !this.resizeRatios)
      return;
    const i = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols,
      groupAfterStartWidth: this.resizeTakeFromStartWidth,
      groupAfterRatios: this.resizeTakeFromRatios
    };
    this.resizeColumns(i, e, t, s);
  }
  resizeColumns(e, t, s, i = !0) {
    var u;
    const {
      columnsToResize: o,
      resizeStartWidth: n,
      resizeRatios: r,
      groupAfterColumns: a,
      groupAfterStartWidth: l,
      groupAfterRatios: d
    } = e, c = [];
    if (c.push({
      columns: o,
      ratios: r,
      width: t
    }), a) {
      const h = t - n;
      c.push({
        columns: a,
        ratios: d,
        width: l - h
      });
    }
    (u = this.beans.colResize) == null || u.resizeColumnSets({
      resizeSets: c,
      finished: i,
      source: s
    }), i && this.toggleColumnResizing(!1);
  }
  toggleColumnResizing(e) {
    this.comp.toggleCss("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
}, ny = class extends S {
  constructor(e, t, s, i, o) {
    super(), this.pinned = e, this.column = t, this.eResize = s, this.comp = i, this.ctrl = o;
  }
  postConstruct() {
    const e = [];
    let t, s;
    const i = () => {
      if (G(this.eResize, t), !t)
        return;
      const { horizontalResizeSvc: r, colAutosize: a } = this.beans, l = r.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      e.push(l), s && a && e.push(a.addColumnAutosize(this.eResize, this.column));
    }, o = () => {
      e.forEach((r) => r()), e.length = 0;
    }, n = () => {
      const r = this.column.isResizable(), a = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (r !== t || a !== s) && (t = r, s = a, o(), i());
    };
    n(), this.addDestroyFunc(o), this.ctrl.setRefreshFunction("resize", n);
  }
  onResizing(e, t) {
    const { column: s, lastResizeAmount: i, resizeStartWidth: o, beans: n } = this, r = this.normaliseResizeAmount(t), a = o + r, l = [{ key: s, newWidth: a }], { pinnedCols: d, ctrlsSvc: c, colResize: u } = n;
    if (this.column.getPinned()) {
      const h = (d == null ? void 0 : d.leftWidth) ?? 0, g = (d == null ? void 0 : d.rightWidth) ?? 0, p = io(c.getGridBodyCtrl().eBodyViewport) - 50;
      if (h + g + (r - i) > p)
        return;
    }
    this.lastResizeAmount = r, u == null || u.setColumnWidths(l, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0);
  }
  toggleColumnResizing(e) {
    this.comp.toggleCss("ag-column-resizing", e);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const s = this.pinned !== "left", i = this.pinned === "right";
    return this.gos.get("enableRtl") ? s && (t *= -1) : i && (t *= -1), t;
  }
}, ry = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colResize";
  }
  setColumnWidths(e, t, s, i) {
    const o = [], { colModel: n, gos: r, visibleCols: a } = this.beans;
    e.forEach((l) => {
      const d = n.getColDefCol(l.key) || n.getCol(l.key);
      if (!d)
        return;
      if (o.push({
        width: l.newWidth,
        ratios: [1],
        columns: [d]
      }), r.get("colResizeDefault") === "shift" && (t = !t), t) {
        const u = a.getColAfter(d);
        if (!u)
          return;
        const h = d.getActualWidth() - l.newWidth, g = u.getActualWidth() + h;
        o.push({
          width: g,
          ratios: [1],
          columns: [u]
        });
      }
    }), o.length !== 0 && this.resizeColumnSets({
      resizeSets: o,
      finished: s,
      source: i
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: s, source: i } = e;
    if (!(!t || t.every((c) => ay(c)))) {
      if (s) {
        const c = t && t.length > 0 ? t[0].columns : null;
        mn(this.eventSvc, c, s, i);
      }
      return;
    }
    const n = [], r = [];
    t.forEach((c) => {
      const { width: u, columns: h, ratios: g } = c, p = {}, f = {};
      h.forEach((w) => r.push(w));
      let m = !0, b = 0;
      for (; m; ) {
        if (b++, b > 1e3) {
          K(31);
          break;
        }
        m = !1;
        const w = [];
        let C = 0, v = u;
        h.forEach((R, D) => {
          if (f[R.getId()])
            v -= p[R.getId()];
          else {
            w.push(R);
            const I = g[D];
            C += I;
          }
        });
        const F = 1 / C;
        w.forEach((R, D) => {
          const M = D === w.length - 1;
          let I;
          M ? I = v : (I = Math.round(g[D] * u * F), v -= I);
          const J = R.getMinWidth(), W = R.getMaxWidth();
          I < J ? (I = J, f[R.getId()] = !0, m = !0) : W > 0 && I > W && (I = W, f[R.getId()] = !0, m = !0), p[R.getId()] = I;
        });
      }
      h.forEach((w) => {
        const C = p[w.getId()];
        w.getActualWidth() !== C && (w.setActualWidth(C, i), n.push(w));
      });
    });
    const a = n.length > 0;
    let l = [];
    if (a) {
      const { colFlex: c, visibleCols: u, colViewport: h } = this.beans;
      l = (c == null ? void 0 : c.refreshFlexedColumns({
        resizingCols: r,
        skipSetLeft: !0
      })) ?? [], u.setLeftValues(i), u.updateBodyWidths(), h.checkViewportColumns();
    }
    const d = r.concat(l);
    (a || s) && mn(this.eventSvc, d, s, i, l);
  }
  resizeHeader(e, t, s) {
    if (!e.isResizable())
      return;
    const i = e.getActualWidth(), o = e.getMinWidth(), n = e.getMaxWidth(), r = Math.min(Math.max(i + t, o), n);
    this.setColumnWidths([{ key: e, newWidth: r }], s, !0, "uiColumnResized");
  }
  createResizeFeature(e, t, s, i, o) {
    return new ny(e, t, s, i, o);
  }
  createGroupResizeFeature(e, t, s, i) {
    return new oy(e, t, s, i);
  }
};
function ay(e) {
  const { columns: t, width: s } = e;
  let i = 0, o = 0, n = !0;
  t.forEach((l) => {
    const d = l.getMinWidth();
    i += d || 0;
    const c = l.getMaxWidth();
    c > 0 ? o += c : n = !1;
  });
  const r = s >= i, a = !n || s <= o;
  return r && a;
}
var ly = {
  moduleName: "ColumnResize",
  version: Q,
  beans: [ry],
  apiFunctions: {
    setColumnWidths: iy
  },
  dependsOn: [Dh, sy]
}, dy = class extends S {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    }), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.__addEventListener("widthChanged", e), t.__addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.__removeEventListener("widthChanged", e), t.__removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.toggleCss("ag-hidden", e === 0);
  }
}, cy = class extends el {
  constructor() {
    super(...arguments), this.onSuppressColMoveChange = () => {
      !this.isAlive() || this.isSuppressMoving() ? this.removeDragSource() : this.dragSource || this.setDragSource(this.eGui);
    };
  }
  setComp(e, t, s, i, o) {
    const { column: n, beans: r } = this, { context: a, colNames: l, colHover: d, rangeSvc: c, colResize: u } = r;
    this.comp = e, o = So(this, a, o), this.setGui(t, o), this.displayName = l.getDisplayNameForColumnGroup(n, "header"), this.refreshHeaderStyles(), this.addClasses(), this.setupMovingCss(o), this.setupExpandable(o), this.setupTooltip(), this.setupAutoHeight({
      wrapperElement: i,
      compBean: o
    }), this.setupUserComp(), this.addHeaderMouseListeners(o), this.addManagedPropertyListener("groupHeaderHeight", this.refreshMaxHeaderHeight.bind(this)), this.refreshMaxHeaderHeight();
    const h = this.rowCtrl.pinned, g = n.getProvidedColumnGroup().getLeafColumns();
    d == null || d.createHoverFeature(o, g, t), c == null || c.createRangeHighlightFeature(o, n, e), o.createManagedBean(new Ja(n, t, r)), o.createManagedBean(new dy(e, n)), u ? this.resizeFeature = o.createManagedBean(
      u.createGroupResizeFeature(e, s, h, n)
    ) : e.setResizableDisplayed(!1), o.createManagedBean(
      new ms(t, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    ), this.addHighlightListeners(o, g), o.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners(o), o.addDestroyFunc(() => this.clearComponent());
  }
  getHeaderClassParams() {
    const { column: e, beans: t } = this, s = e.getDefinition();
    return N(t.gos, {
      colDef: s,
      columnGroup: e,
      floatingFilter: !1
    });
  }
  refreshMaxHeaderHeight() {
    const { gos: e, comp: t } = this, s = e.get("groupHeaderHeight");
    s != null ? s === 0 ? t.setHeaderWrapperHidden(!0) : t.setHeaderWrapperMaxHeight(s) : (t.setHeaderWrapperHidden(!1), t.setHeaderWrapperMaxHeight(null));
  }
  addHighlightListeners(e, t) {
    if (this.beans.gos.get("suppressMoveWhenColumnDragging"))
      for (const s of t)
        e.addManagedListeners(s, {
          headerHighlightChanged: this.onLeafColumnHighlightChanged.bind(this, s)
        });
  }
  onLeafColumnHighlightChanged(e) {
    const t = this.column.getDisplayedLeafColumns(), s = t[0] === e, i = Z(t) === e;
    if (!s && !i)
      return;
    const o = e.getHighlighted(), n = !!this.rowCtrl.getHeaderCellCtrls().find((l) => l.column.isMoving());
    let r = !1, a = !1;
    if (n) {
      const l = this.beans.gos.get("enableRtl"), d = o === 1, c = o === 0;
      s && (l ? a = d : r = c), i && (l ? r = c : a = d);
    }
    this.comp.toggleCss("ag-header-highlight-before", r), this.comp.toggleCss("ag-header-highlight-after", a);
  }
  resizeHeader(e, t) {
    const { resizeFeature: s } = this;
    if (!s)
      return;
    const i = s.getInitialValues(t);
    s.resizeColumns(i, i.resizeStartWidth + e, "uiColumnResized", !0);
  }
  resizeLeafColumnsToFit(e) {
    var t;
    (t = this.resizeFeature) == null || t.resizeLeafColumnsToFit(e);
  }
  setupUserComp() {
    const { colGroupSvc: e, userCompFactory: t, gos: s, enterpriseMenuFactory: i } = this.beans, o = this.column, n = o.getProvidedColumnGroup(), r = N(s, {
      displayName: this.displayName,
      columnGroup: o,
      setExpanded: (l) => {
        e.setColumnGroupOpened(n, l, "gridInitializing");
      },
      setTooltip: (l, d) => {
        s.assertModuleRegistered("Tooltip", 3), this.setupTooltip(l, d);
      },
      showColumnMenu: (l, d) => i == null ? void 0 : i.showMenuAfterButtonClick(
        n,
        l,
        "columnMenu",
        d
      ),
      showColumnMenuAfterMouseClick: (l, d) => i == null ? void 0 : i.showMenuAfterMouseEvent(
        n,
        l,
        "columnMenu",
        d
      ),
      eGridHeader: this.eGui
    }), a = EC(t, r);
    a && this.comp.setUserCompDetails(a);
  }
  addHeaderMouseListeners(e) {
    const t = (o) => this.handleMouseOverChange(o.type === "mouseenter"), s = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup()), i = (o) => this.handleContextMenuMouseEvent(o, void 0, this.column.getProvidedColumnGroup());
    e.addManagedListeners(this.eGui, {
      mouseenter: t,
      mouseleave: t,
      click: s,
      contextmenu: i
    });
  }
  handleMouseOverChange(e) {
    this.eventSvc.dispatchEvent({
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    });
  }
  setupTooltip(e, t) {
    var s;
    this.tooltipFeature = (s = this.beans.tooltipSvc) == null ? void 0 : s.setupHeaderGroupTooltip(
      this.tooltipFeature,
      this,
      e,
      t
    );
  }
  setupExpandable(e) {
    const t = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const s = this.refreshExpanded.bind(this);
    e.addManagedListeners(t, {
      expandedChanged: s,
      expandableChanged: s
    });
  }
  refreshExpanded() {
    const { column: e } = this;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0), this.refreshHeaderStyles();
  }
  addClasses() {
    const { column: e } = this, t = e.getColGroupDef(), s = Wu(t, this.gos, null, e);
    e.isPadding() ? (s.push("ag-header-group-cell-no-group"), e.getLeafColumns().every((o) => o.isSpanHeaderHeight()) && s.push("ag-header-span-height")) : (s.push("ag-header-group-cell-with-group"), t != null && t.wrapHeaderText && s.push("ag-header-cell-wrap-text")), s.forEach((i) => this.comp.toggleCss(i, !0));
  }
  setupMovingCss(e) {
    const { column: t } = this, i = t.getProvidedColumnGroup().getLeafColumns(), o = () => this.comp.toggleCss("ag-header-cell-moving", t.isMoving());
    i.forEach((n) => {
      e.addManagedListeners(n, { movingChanged: o });
    }), o();
  }
  onFocusIn(e) {
    this.eGui.contains(e.relatedTarget) || this.focusThis();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === y.ENTER) {
      const s = this.column, i = !s.isExpanded();
      this.beans.colGroupSvc.setColumnGroupOpened(
        s.getProvidedColumnGroup(),
        i,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    var t;
    !this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), e && (this.dragSource = ((t = this.beans.colMoves) == null ? void 0 : t.setDragSourceForHeader(e, this.column, this.displayName)) ?? null));
  }
  isSuppressMoving() {
    return this.gos.get("suppressMovableColumns") || this.column.getLeafColumns().some((e) => e.getColDef().suppressMovable || e.getColDef().lockPosition);
  }
  destroy() {
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), super.destroy();
  }
};
function uy(e, t, s) {
  var i;
  (i = e.colGroupSvc) == null || i.setColumnGroupOpened(t, s, "api");
}
function hy(e, t, s) {
  var i;
  return ((i = e.colGroupSvc) == null ? void 0 : i.getColumnGroup(t, s)) ?? null;
}
function gy(e, t) {
  var s;
  return ((s = e.colGroupSvc) == null ? void 0 : s.getProvidedColGroup(t)) ?? null;
}
function py(e, t, s) {
  return e.colNames.getDisplayNameForColumnGroup(t, s) || "";
}
function fy(e) {
  var t;
  return ((t = e.colGroupSvc) == null ? void 0 : t.getColumnGroupState()) ?? [];
}
function my(e, t) {
  var s;
  (s = e.colGroupSvc) == null || s.setColumnGroupState(t, "api");
}
function Cy(e) {
  var t;
  (t = e.colGroupSvc) == null || t.resetColumnGroupState("api");
}
function vy(e) {
  return e.visibleCols.treeLeft;
}
function wy(e) {
  return e.visibleCols.treeCenter;
}
function by(e) {
  return e.visibleCols.treeRight;
}
function yy(e) {
  return e.visibleCols.getAllTrees();
}
function Sy(e, t) {
  for (let s = 0; s < t.length; s++) {
    const i = e.indexOf(t[s]);
    i >= 0 && (e[i] = e[e.length - 1], e.pop());
  }
}
var xy = class extends S {
  constructor() {
    super(...arguments), this.beanName = "visibleCols", this.colsAndGroupsMap = {}, this.leftCols = [], this.rightCols = [], this.centerCols = [], this.allCols = [], this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.isBodyWidthDirty = !0;
  }
  refresh(e, t = !1) {
    const { colFlex: s, colModel: i, colGroupSvc: o, colViewport: n, selectionColSvc: r } = this.beans;
    t || this.buildTrees(i, o), o == null || o.updateOpenClosedVisibility(), this.leftCols = wr(this.treeLeft), this.centerCols = wr(this.treeCenter), this.rightCols = wr(this.treeRight), r == null || r.refreshVisibility(this.leftCols, this.centerCols, this.rightCols), this.joinColsAriaOrder(i), this.joinCols(), this.setLeftValues(e), this.autoHeightCols = this.allCols.filter((a) => a.isAutoHeight()), s == null || s.refreshFlexedColumns(), this.updateBodyWidths(), n.checkViewportColumns(!1), this.setFirstRightAndLastLeftPinned(i, this.leftCols, this.rightCols, e), this.eventSvc.dispatchEvent({
      type: "displayedColumnsChanged",
      source: e
    });
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const e = ti(this.centerCols), t = ti(this.leftCols), s = ti(this.rightCols);
    this.isBodyWidthDirty = this.bodyWidth !== e, (this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== s) && (this.bodyWidth = e, this.leftWidth = t, this.rightWidth = s, this.eventSvc.dispatchEvent({
      type: "columnContainerWidthChanged"
    }), this.eventSvc.dispatchEvent({
      type: "displayedColumnsWidthChanged"
    }));
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(e, t, s, i) {
    let o, n;
    this.gos.get("enableRtl") ? (o = t ? t[0] : null, n = s ? Z(s) : null) : (o = t ? Z(t) : null, n = s ? s[0] : null), e.getCols().forEach((r) => {
      r.setLastLeftPinned(r === o, i), r.setFirstRightPinned(r === n, i);
    });
  }
  buildTrees(e, t) {
    const s = e.getColsToShow(), i = s.filter((l) => l.getPinned() == "left"), o = s.filter((l) => l.getPinned() == "right"), n = s.filter((l) => l.getPinned() != "left" && l.getPinned() != "right"), r = new rC(), a = (l) => t ? t.createColumnGroups(l) : l.columns;
    this.treeLeft = a({
      columns: i,
      idCreator: r,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    }), this.treeRight = a({
      columns: o,
      idCreator: r,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    }), this.treeCenter = a({
      columns: n,
      idCreator: r,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    }), this.updateColsAndGroupsMap();
  }
  clear() {
    this.leftCols = [], this.rightCols = [], this.centerCols = [], this.allCols = [], this.ariaOrderColumns = [];
  }
  joinColsAriaOrder(e) {
    const t = e.getCols(), s = [], i = [], o = [];
    for (const n of t) {
      const r = n.getPinned();
      r ? r === !0 || r === "left" ? s.push(n) : o.push(n) : i.push(n);
    }
    this.ariaOrderColumns = s.concat(i).concat(o);
  }
  getAriaColIndex(e) {
    let t;
    return ue(e) ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
      e.forEach((t) => {
        ue(t) && t.checkLeft();
      });
    });
  }
  setLeftValuesOfCols(e) {
    const { colModel: t } = this.beans;
    if (!t.getColDefCols())
      return;
    const i = t.getCols().slice(0), o = this.gos.get("enableRtl");
    [this.leftCols, this.rightCols, this.centerCols].forEach((n) => {
      if (o) {
        let r = ti(n);
        n.forEach((a) => {
          r -= a.getActualWidth(), a.setLeft(r, e);
        });
      } else {
        let r = 0;
        n.forEach((a) => {
          a.setLeft(r, e), r += a.getActualWidth();
        });
      }
      Sy(i, n);
    }), i.forEach((n) => {
      n.setLeft(null, e);
    });
  }
  joinCols() {
    this.gos.get("enableRtl") ? this.allCols = this.rightCols.concat(this.centerCols).concat(this.leftCols) : this.allCols = this.leftCols.concat(this.centerCols).concat(this.rightCols);
  }
  getAllTrees() {
    return this.treeLeft && this.treeRight && this.treeCenter ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight) : null;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(e) {
    return this.allCols.indexOf(e) >= 0;
  }
  getLeftColsForRow(e) {
    const {
      leftCols: t,
      beans: { colModel: s }
    } = this;
    return s.colSpanActive ? this.getColsForRow(e, t) : t;
  }
  getRightColsForRow(e) {
    const {
      rightCols: t,
      beans: { colModel: s }
    } = this;
    return s.colSpanActive ? this.getColsForRow(e, t) : t;
  }
  getColsForRow(e, t, s, i) {
    const o = [];
    let n = null;
    for (let r = 0; r < t.length; r++) {
      const a = t[r], l = t.length - r, d = Math.min(a.getColSpan(e), l), c = [a];
      if (d > 1) {
        const h = d - 1;
        for (let g = 1; g <= h; g++)
          c.push(t[r + g]);
        r += h;
      }
      let u;
      s ? (u = !1, c.forEach((h) => {
        s(h) && (u = !0);
      })) : u = !0, u && (o.length === 0 && n && (i && i(a)) && o.push(n), o.push(a)), n = a;
    }
    return o;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  getColBefore(e) {
    const t = this.allCols, s = t.indexOf(e);
    return s > 0 ? t[s - 1] : null;
  }
  isPinningLeft() {
    return this.leftCols.length > 0;
  }
  isPinningRight() {
    return this.rightCols.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const e = (t) => {
      this.colsAndGroupsMap[t.getUniqueId()] = t;
    };
    Gs(this.treeCenter, !1, e), Gs(this.treeLeft, !1, e), Gs(this.treeRight, !1, e);
  }
  isVisible(e) {
    return this.colsAndGroupsMap[e.getUniqueId()] === e;
  }
  getFirstColumn() {
    const e = this.gos.get("enableRtl"), t = ["leftCols", "centerCols", "rightCols"];
    e && t.reverse();
    for (let s = 0; s < t.length; s++) {
      const i = this[t[s]];
      if (i.length)
        return e ? Z(i) : i[0];
    }
    return null;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(e) {
    const t = this.allCols, s = t.indexOf(e);
    return s < t.length - 1 ? t[s + 1] : null;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return ti(this.leftCols);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return ti(this.rightCols);
  }
  isColAtEdge(e, t) {
    const s = this.allCols;
    if (!s.length)
      return !1;
    const i = t === "first";
    let o;
    if (ue(e)) {
      const n = e.getDisplayedLeafColumns();
      if (!n.length)
        return !1;
      o = i ? n[0] : Z(n);
    } else
      o = e;
    return (i ? s[0] : Z(s)) === o;
  }
};
function Gs(e, t, s) {
  if (e)
    for (let i = 0; i < e.length; i++) {
      const o = e[i];
      if (ue(o)) {
        const n = t ? o.getDisplayedChildren() : o.getChildren();
        Gs(n, t, s);
      }
      s(o);
    }
}
function wr(e) {
  const t = [];
  return Gs(e, !0, (s) => {
    wt(s) && t.push(s);
  }), t;
}
var Ry = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colGroupSvc";
  }
  getColumnGroupState() {
    const e = [], t = this.beans.colModel.getColTree();
    return At(null, t, (s) => {
      ae(s) && e.push({
        groupId: s.getGroupId(),
        open: s.isExpanded()
      });
    }), e;
  }
  resetColumnGroupState(e) {
    const t = this.beans.colModel.getColDefColTree();
    if (!t)
      return;
    const s = [];
    At(null, t, (i) => {
      if (ae(i)) {
        const o = i.getColGroupDef(), n = {
          groupId: i.getGroupId(),
          open: o ? o.openByDefault : void 0
        };
        s.push(n);
      }
    }), this.setColumnGroupState(s, e);
  }
  setColumnGroupState(e, t) {
    const { colModel: s, colAnimation: i, visibleCols: o, eventSvc: n } = this.beans;
    if (!s.getColTree().length)
      return;
    i == null || i.start();
    const a = [];
    e.forEach((l) => {
      const d = l.groupId, c = l.open, u = this.getProvidedColGroup(d);
      u && u.isExpanded() !== c && (u.setExpanded(c), a.push(u));
    }), o.refresh(t, !0), a.length && n.dispatchEvent({
      type: "columnGroupOpened",
      columnGroup: a.length === 1 ? a[0] : void 0,
      columnGroups: a
    }), i == null || i.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, s) {
    let i;
    ae(e) ? i = e.getId() : i = e || "", this.setColumnGroupState([{ groupId: i, open: t }], s);
  }
  getProvidedColGroup(e) {
    let t = null;
    return At(null, this.beans.colModel.getColTree(), (s) => {
      ae(s) && s.getId() === e && (t = s);
    }), t;
  }
  getGroupAtDirection(e, t) {
    const s = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), i = e.getDisplayedLeafColumns(), o = t === "After" ? Z(i) : i[0], n = `getCol${t}`;
    for (; ; ) {
      const r = this.beans.visibleCols[n](o);
      if (!r)
        return null;
      const a = this.getColGroupAtLevel(r, s);
      if (a !== e)
        return a;
    }
  }
  getColGroupAtLevel(e, t) {
    let s = e.getParent(), i, o;
    for (; i = s.getProvidedColumnGroup().getLevel(), o = s.getPaddingLevel(), !(i + o <= t); )
      s = s.getParent();
    return s;
  }
  updateOpenClosedVisibility() {
    const e = this.beans.visibleCols.getAllTrees();
    Gs(e, !1, (t) => {
      ue(t) && t.calculateDisplayedColumns();
    });
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if (ue(e))
      return e;
    const s = this.beans.visibleCols.getAllTrees(), i = typeof t == "number";
    let o = null;
    return Gs(s, !1, (n) => {
      if (ue(n)) {
        const r = n;
        let a;
        i ? a = e === r.getGroupId() && t === r.getPartId() : a = e === r.getGroupId(), a && (o = r);
      }
    }), o;
  }
  createColumnGroups(e) {
    const { columns: t, idCreator: s, pinned: i, oldDisplayedGroups: o, isStandaloneStructure: n } = e, r = this.mapOldGroupsById(o), a = [];
    let l = t;
    for (; l.length; ) {
      const d = l;
      l = [];
      let c = 0;
      const u = (h) => {
        const g = c;
        c = h;
        const p = d[g], m = (ue(p) ? p.getProvidedColumnGroup() : p).getOriginalParent();
        if (m == null) {
          for (let w = g; w < h; w++)
            a.push(d[w]);
          return;
        }
        const b = this.createColumnGroup(
          m,
          s,
          r,
          i,
          n
        );
        for (let w = g; w < h; w++)
          b.addChild(d[w]);
        l.push(b);
      };
      for (let h = 1; h < d.length; h++) {
        const g = d[h], f = (ue(g) ? g.getProvidedColumnGroup() : g).getOriginalParent(), m = d[c], w = (ue(m) ? m.getProvidedColumnGroup() : m).getOriginalParent();
        f !== w && u(h);
      }
      c < d.length && u(d.length);
    }
    return n || this.setupParentsIntoCols(a, null), a;
  }
  createProvidedColumnGroup(e, t, s, i, o, n, r) {
    const a = o.getUniqueKey(t.groupId || null, null), l = Yr(this.beans, t, a), d = new ui(l, a, !1, s);
    this.createBean(d);
    const c = this.findExistingGroup(t, n);
    c && n.splice(c.idx, 1);
    const u = c == null ? void 0 : c.group;
    u && d.setExpanded(u.isExpanded());
    const h = Ru(
      this.beans,
      l.children,
      s + 1,
      e,
      i,
      o,
      n,
      r
    );
    return d.setChildren(h), d;
  }
  balanceColumnTree(e, t, s, i) {
    const o = [];
    for (let n = 0; n < e.length; n++) {
      const r = e[n];
      if (ae(r)) {
        const a = r, l = this.balanceColumnTree(
          a.getChildren(),
          t + 1,
          s,
          i
        );
        a.setChildren(l), o.push(a);
      } else {
        let a, l;
        for (let d = s - 1; d >= t; d--) {
          const c = i.getUniqueKey(null, null), u = Yr(this.beans, null, c), h = new ui(u, c, !0, t);
          this.createBean(h), l && l.setChildren([h]), l = h, a || (a = l);
        }
        if (a && l)
          if (o.push(a), e.some((c) => ae(c))) {
            l.setChildren([r]);
            continue;
          } else {
            l.setChildren(e);
            break;
          }
        o.push(r);
      }
    }
    return o;
  }
  findDepth(e) {
    let t = 0, s = e;
    for (; s && s[0] && ae(s[0]); )
      t++, s = s[0].getChildren();
    return t;
  }
  findMaxDepth(e, t) {
    let s = t;
    for (let i = 0; i < e.length; i++) {
      const o = e[i];
      if (ae(o)) {
        const n = o, r = this.findMaxDepth(n.getChildren(), t + 1);
        s < r && (s = r);
      }
    }
    return s;
  }
  /**
   * Inserts dummy group columns in the hierarchy above auto-generated columns
   * in order to ensure auto-generated columns are leaf nodes (and therefore are
   * displayed correctly)
   */
  balanceTreeForAutoCols(e, t) {
    const s = [];
    return e.forEach((i) => {
      let o = i;
      for (let n = t - 1; n >= 0; n--) {
        const r = new ui(null, `FAKE_PATH_${i.getId()}}_${n}`, !0, n);
        this.createBean(r), r.setChildren([o]), o.originalParent = r, o = r;
      }
      t === 0 && (i.originalParent = null), s.push(o);
    }), s;
  }
  findExistingGroup(e, t) {
    if (e.groupId != null)
      for (let i = 0; i < t.length; i++) {
        const o = t[i];
        if (o.getColGroupDef() && o.getId() === e.groupId)
          return { idx: i, group: o };
      }
  }
  createColumnGroup(e, t, s, i, o) {
    const n = e.getGroupId(), r = t.getInstanceIdForKey(n), a = eh(n, r);
    let l = s[a];
    return l && l.getProvidedColumnGroup() !== e && (l = null), T(l) ? l.reset() : (l = new th(e, n, r, i), o || this.createBean(l)), l;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, s = (i) => {
      i.forEach((o) => {
        if (ue(o)) {
          const n = o;
          t[o.getUniqueId()] = n, s(n.getChildren());
        }
      });
    };
    return e && s(e), t;
  }
  setupParentsIntoCols(e, t) {
    e.forEach((s) => {
      if (s.parent = t, ue(s)) {
        const i = s;
        this.setupParentsIntoCols(i.getChildren(), i);
      }
    });
  }
}, Ah = {
  moduleName: "ColumnGroup",
  version: Q,
  dynamicBeans: { headerGroupCellCtrl: cy },
  beans: [Ry],
  apiFunctions: {
    getAllDisplayedColumnGroups: yy,
    getCenterDisplayedColumnGroups: wy,
    getColumnGroup: hy,
    getColumnGroupState: fy,
    getDisplayNameForColumnGroup: py,
    getLeftDisplayedColumnGroups: vy,
    getProvidedColumnGroup: gy,
    getRightDisplayedColumnGroups: by,
    resetColumnGroupState: Cy,
    setColumnGroupOpened: uy,
    setColumnGroupState: my
  }
}, Fy = {
  moduleName: "CheckboxCellRenderer",
  version: Q,
  userComponents: {
    agCheckboxCellRenderer: _w
  }
}, Py = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colFlex";
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ?? "flex";
    e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth);
    const s = this.flexViewportWidth;
    if (!s)
      return [];
    const { visibleCols: i } = this.beans, o = i.centerCols;
    let n = -1;
    if (e.resizingCols) {
      const p = new Set(e.resizingCols);
      for (let f = o.length - 1; f >= 0; f--)
        if (p.has(o[f])) {
          n = f;
          break;
        }
    }
    let r = !1;
    const a = o.map((p, f) => {
      const m = p.getFlex(), b = m != null && m > 0 && f > n;
      return r || (r = b), {
        col: p,
        isFlex: b,
        flex: Math.max(0, m ?? 0),
        initialSize: p.getActualWidth(),
        min: p.getMinWidth(),
        max: p.getMaxWidth(),
        targetSize: 0
      };
    });
    if (!r)
      return [];
    let l = a.length, d = a.reduce((p, f) => p + f.flex, 0), c = s;
    const u = (p, f) => {
      p.frozenSize = f, p.col.setActualWidth(f, t), c -= f, d -= p.flex, l -= 1;
    }, h = (p) => p.frozenSize != null;
    for (const p of a)
      p.isFlex || u(p, p.initialSize);
    for (; l > 0; ) {
      const p = Math.round(d < 1 ? c * d : c);
      let f, m = 0, b = 0;
      for (const v of a) {
        if (h(v))
          continue;
        f = v, b += p * (v.flex / d);
        const F = b - m, R = Math.round(F);
        v.targetSize = R, m += R;
      }
      f && (f.targetSize += p - m);
      let w = 0;
      for (const v of a) {
        if (h(v))
          continue;
        const F = v.targetSize, R = Math.min(Math.max(F, v.min), v.max);
        w += R - F, v.violationType = R === F ? void 0 : R < F ? "max" : "min", v.targetSize = R;
      }
      const C = w === 0 ? "all" : w > 0 ? "min" : "max";
      for (const v of a)
        h(v) || (C === "all" || v.violationType === C) && u(v, v.targetSize);
    }
    e.skipSetLeft || i.setLeftValues(t), e.updateBodyWidths && i.updateBodyWidths();
    const g = a.filter((p) => p.isFlex && !p.violationType).map((p) => p.col);
    if (e.fireResizedEvent) {
      const p = a.filter((m) => m.initialSize !== m.frozenSize).map((m) => m.col), f = a.filter((m) => m.flex).map((m) => m.col);
      mn(this.eventSvc, p, !0, t, f);
    }
    return g;
  }
  initCol(e) {
    const { flex: t, initialFlex: s } = e.colDef;
    t !== void 0 ? e.flex = t : s !== void 0 && (e.flex = s);
  }
  // this method should only be used by the colModel to
  // change flex when required by the applyColumnState method.
  setColFlex(e, t) {
    e.flex = t ?? null, e.dispatchStateUpdatedEvent("flex");
  }
}, Dy = class extends S {
  constructor() {
    super(...arguments), this.beanName = "dataTypeSvc", this.dataTypeDefinitions = {}, this.isPendingInference = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  wireBeans(e) {
    this.colModel = e.colModel;
  }
  postConstruct() {
    this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.colModel.recreateColumnDefs(e);
    });
  }
  processDataTypeDefinitions() {
    const e = this.getDefaultDataTypes(), t = {};
    this.dataTypeDefinitions = t;
    const s = {};
    this.formatValueFuncs = s;
    const i = (r) => (a) => {
      const { column: l, node: d, value: c } = a;
      let u = l.getColDef().valueFormatter;
      return u === r.groupSafeValueFormatter && (u = r.valueFormatter), this.beans.valueSvc.formatValue(l, d, c, u);
    };
    for (const r of Object.keys(e)) {
      const a = e[r], l = {
        ...a,
        groupSafeValueFormatter: ld(a, this.gos)
      };
      t[r] = l, s[r] = i(l);
    }
    const o = this.gos.get("dataTypeDefinitions") ?? {}, n = {};
    this.dataTypeMatchers = n;
    for (const r of Object.keys(o)) {
      const a = o[r], l = this.processDataTypeDefinition(
        a,
        o,
        [r],
        e
      );
      l && (t[r] = l, a.dataTypeMatcher && (n[r] = a.dataTypeMatcher), s[r] = i(l));
    }
    this.checkObjectValueHandlers(e), ["dateString", "text", "number", "boolean", "date"].forEach((r) => {
      const a = n[r];
      a && delete n[r], n[r] = a ?? e[r].dataTypeMatcher;
    });
  }
  processDataTypeDefinition(e, t, s, i) {
    let o;
    const n = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      let r = i[n];
      const a = t[n];
      if (r && a && (r = a), !ad(e, r, n))
        return;
      o = rd(r, e);
    } else {
      if (s.includes(n)) {
        P(44);
        return;
      }
      const r = t[n];
      if (!ad(e, r, n))
        return;
      const a = this.processDataTypeDefinition(
        r,
        t,
        [...s, n],
        i
      );
      if (!a)
        return;
      o = rd(a, e);
    }
    return {
      ...o,
      groupSafeValueFormatter: ld(o, this.gos)
    };
  }
  updateColDefAndGetColumnType(e, t, s) {
    let { cellDataType: i } = t;
    const { field: o } = t;
    if (i === void 0 && (i = e.cellDataType), (i == null || i === !0) && (i = this.canInferCellDataType(e, t) ? this.inferCellDataType(o, s) : !1), !i) {
      e.cellDataType = !1;
      return;
    }
    const n = this.dataTypeDefinitions[i];
    if (!n) {
      P(47, { cellDataType: i });
      return;
    }
    return e.cellDataType = i, n.groupSafeValueFormatter && (e.valueFormatter = n.groupSafeValueFormatter), n.valueParser && (e.valueParser = n.valueParser), n.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, i, n, s), n.columnTypes;
  }
  addColumnListeners(e) {
    if (!this.isPendingInference)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const s = (i) => {
      t.add(i.key);
    };
    e.__addEventListener("columnStateUpdated", s), this.columnStateUpdateListenerDestroyFuncs.push(
      () => e.__removeEventListener("columnStateUpdated", s)
    );
  }
  canInferCellDataType(e, t) {
    const { gos: s } = this;
    if (!Ke(s))
      return !1;
    const i = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (br(t, i))
      return !1;
    const o = t.type === null ? e.type : t.type;
    if (o) {
      const n = s.get("columnTypes") ?? {};
      if (fn(o).some((a) => {
        const l = n[a.trim()];
        return l && br(l, i);
      }))
        return !1;
    }
    return !br(e, i);
  }
  inferCellDataType(e, t) {
    if (!e)
      return;
    let s;
    const i = this.getInitialData();
    if (i) {
      const o = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      s = $o(i, e, o);
    } else
      this.initWaitForRowData(t);
    if (s != null)
      return Object.keys(this.dataTypeMatchers).find((o) => this.dataTypeMatchers[o](s)) ?? "object";
  }
  getInitialData() {
    var t;
    const e = this.gos.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const s = (t = this.beans.rowModel.rootNode) == null ? void 0 : t.allLeafChildren;
      if (s != null && s.length)
        return s[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isPendingInference)
      return;
    this.isPendingInference = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions, { colAutosize: s, eventSvc: i } = this.beans;
    t && s && (s.shouldQueueResizeOperations = !0);
    const [o] = this.addManagedEventListeners({
      rowDataUpdateStarted: (n) => {
        const { firstRowData: r } = n;
        r && (o == null || o(), this.isPendingInference = !1, this.processColumnsPendingInference(r, t), this.columnStateUpdatesPendingInference = {}, t && (s == null || s.processResizeOperations()), i.dispatchEvent({
          type: "dataTypesInferred"
        }));
      }
    });
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const s = [];
    this.destroyColumnStateUpdateListeners();
    const i = {}, o = {};
    for (const n of Object.keys(this.columnStateUpdatesPendingInference)) {
      const r = this.columnStateUpdatesPendingInference[n], a = this.colModel.getCol(n);
      if (!a)
        return;
      const l = a.getColDef();
      if (!this.resetColDefIntoCol(a, "cellDataTypeInferred"))
        return;
      const d = a.getColDef();
      if (t && d.type && d.type !== l.type) {
        const c = Ey(a, r);
        c.rowGroup && c.rowGroupIndex == null && (i[n] = c), c.pivot && c.pivotIndex == null && (o[n] = c), s.push(c);
      }
    }
    t && s.push(
      ...this.generateColumnStateForRowGroupAndPivotIndexes(
        i,
        o
      )
    ), s.length && Wt(this.beans, { state: s }, "cellDataTypeInferred"), this.initialData = null;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    const s = {}, { rowGroupColsSvc: i, pivotColsSvc: o } = this.beans;
    return i == null || i.restoreColumnOrder(s, e), o == null || o.restoreColumnOrder(s, t), Object.values(s);
  }
  resetColDefIntoCol(e, t) {
    const s = e.getUserProvidedColDef();
    if (!s)
      return !1;
    const i = Fi(this.beans, s, e.getColId());
    return e.setColDef(i, s, t), !0;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, s = e.object;
    this.hasObjectValueParser = t.valueParser !== s.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== s.valueFormatter;
  }
  getDateStringTypeDefinition(e) {
    const { dateString: t } = this.dataTypeDefinitions;
    return e ? this.getDataTypeDefinition(e) ?? t : t;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType)
      return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var t;
    return (t = this.getDataTypeDefinition(e)) == null ? void 0 : t.baseDataType;
  }
  checkType(e, t) {
    var i;
    if (t == null)
      return !0;
    const s = (i = this.getDataTypeDefinition(e)) == null ? void 0 : i.dataTypeMatcher;
    return s ? s(t) : !0;
  }
  validateColDef(e) {
    const t = (s) => P(48, { property: s });
    if (e.cellDataType === "object") {
      const { object: s } = this.dataTypeDefinitions;
      e.valueFormatter === s.groupSafeValueFormatter && !this.hasObjectValueFormatter && t("Formatter"), e.editable && e.valueParser === s.valueParser && !this.hasObjectValueParser && t("Parser");
    }
  }
  getFormatValue(e) {
    return this.formatValueFuncs[e];
  }
  isColPendingInference(e) {
    return this.isPendingInference && !!this.columnStateUpdatesPendingInference[e];
  }
  setColDefPropertiesForBaseDataType(e, t, s, i) {
    var n;
    const o = this.formatValueFuncs[t];
    switch (s.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor";
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.getFindText = () => null, e.suppressKeyboardEvent = (r) => !!r.colDef.editable && r.event.key === y.SPACE;
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = o;
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = o;
        break;
      }
      case "object": {
        e.cellEditorParams = {
          useFormatter: !0
        }, e.comparator = (r, a) => {
          const l = this.colModel.getColDefCol(i), d = l == null ? void 0 : l.getColDef();
          if (!l || !d)
            return 0;
          const c = r == null ? "" : o({ column: l, node: null, value: r }), u = a == null ? "" : o({ column: l, node: null, value: a });
          return c === u ? 0 : c > u ? 1 : -1;
        }, e.keyCreator = o;
        break;
      }
    }
    (n = this.beans.filterManager) == null || n.setColDefPropertiesForDataType(e, s, o);
  }
  getDefaultDataTypes() {
    const e = (s) => !!s.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (s) => {
          var i, o;
          return ((o = (i = s.newValue) == null ? void 0 : i.trim) == null ? void 0 : o.call(i)) === "" ? null : Number(s.newValue);
        },
        valueFormatter: (s) => s.value == null ? "" : typeof s.value != "number" || isNaN(s.value) ? t("invalidNumber", "Invalid Number") : String(s.value),
        dataTypeMatcher: (s) => typeof s == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (s) => s.newValue === "" ? null : zr(s.newValue),
        dataTypeMatcher: (s) => typeof s == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (s) => {
          var i, o;
          return s.newValue == null ? s.newValue : ((o = (i = s.newValue) == null ? void 0 : i.trim) == null ? void 0 : o.call(i)) === "" ? null : String(s.newValue).toLowerCase() === "true";
        },
        valueFormatter: (s) => s.value == null ? "" : String(s.value),
        dataTypeMatcher: (s) => typeof s == "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (s) => td(s.newValue == null ? null : String(s.newValue)),
        valueFormatter: (s) => s.value == null ? "" : !(s.value instanceof Date) || isNaN(s.value.getTime()) ? t("invalidDate", "Invalid Date") : ed(s.value, !1) ?? "",
        dataTypeMatcher: (s) => s instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (s) => td(s) ?? void 0,
        dateFormatter: (s) => ed(s ?? null, !1) ?? void 0,
        valueParser: (s) => e(String(s.newValue)) ? s.newValue : null,
        valueFormatter: (s) => e(String(s.value)) ? s.value : "",
        dataTypeMatcher: (s) => typeof s == "string" && e(s)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (s) => zr(s.value) ?? ""
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()), this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {}, this.dataTypeMatchers = {}, this.formatValueFuncs = {}, this.columnStateUpdatesPendingInference = {}, this.destroyColumnStateUpdateListeners(), super.destroy();
  }
};
function rd(e, t) {
  const s = {
    ...e,
    ...t
  };
  return e.columnTypes && t.columnTypes && t.appendColumnTypes && (s.columnTypes = [
    ...fn(e.columnTypes),
    ...fn(t.columnTypes)
  ]), s;
}
function ad(e, t, s) {
  return t ? t.baseDataType !== e.baseDataType ? (P(46), !1) : !0 : (P(45, { parentCellDataType: s }), !1);
}
function ld(e, t) {
  if (e.valueFormatter)
    return (s) => {
      var i, o;
      if ((i = s.node) != null && i.group) {
        const n = (s.colDef.pivotValueColumn ?? s.column).getAggFunc();
        if (n) {
          if (n === "first" || n === "last")
            return e.valueFormatter(s);
          if (e.baseDataType === "number" && n !== "count") {
            if (typeof s.value == "number")
              return e.valueFormatter(s);
            if (typeof s.value == "object") {
              if (!s.value)
                return;
              if ("toNumber" in s.value)
                return e.valueFormatter({
                  ...s,
                  value: s.value.toNumber()
                });
              if ("value" in s.value)
                return e.valueFormatter({
                  ...s,
                  value: s.value.value
                });
            }
          }
          return;
        }
        if (t.get("groupDisplayType") === "groupRows" && !t.get("treeData"))
          return;
      } else if (t.get("groupHideOpenParents") && s.column.isRowGroupActive() && typeof s.value == "string" && !((o = e.dataTypeMatcher) != null && o.call(e, s.value)))
        return;
      return e.valueFormatter(s);
    };
}
function My(e, t, s, i) {
  if (!t[s])
    return !1;
  const o = e[s];
  return o === null ? (t[s] = !1, !1) : i === void 0 ? !!o : o === i;
}
function br(e, t) {
  return [
    ["cellRenderer", "agSparklineCellRenderer"],
    ["valueGetter", void 0],
    ["valueParser", void 0],
    ["refData", void 0]
  ].some(
    ([s, i]) => My(e, t, s, i)
  );
}
function Ey(e, t) {
  const s = ku(e);
  return t.forEach((i) => {
    delete s[i], i === "rowGroup" ? delete s.rowGroupIndex : i === "pivot" && delete s.pivotIndex;
  }), s;
}
var Ay = {
  moduleName: "DataType",
  version: Q,
  beans: [Dy],
  dependsOn: [Fy]
}, Iy = {
  moduleName: "ColumnFlex",
  version: Q,
  beans: [Py]
};
function Ty(e) {
  if (!e || e == null)
    return null;
  const t = /([a-z])([A-Z])/g, s = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(s, "$1 $2$3").replace(/\./g, " ").split(" ").map((o) => o.substring(0, 1).toUpperCase() + (o.length > 1 ? o.substring(1, o.length) : "")).join(" ");
}
var Ly = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colNames";
  }
  getDisplayNameForColumn(e, t, s = !1) {
    if (!e)
      return null;
    const i = this.getHeaderName(e.getColDef(), e, null, null, t), { aggColNameSvc: o } = this.beans;
    return s && o ? o.getHeaderName(e, i) : i;
  }
  getDisplayNameForProvidedColumnGroup(e, t, s) {
    const i = t == null ? void 0 : t.getColGroupDef();
    return i ? this.getHeaderName(i, null, e, t, s) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, s, i, o) {
    var r;
    const n = e.headerValueGetter;
    if (n) {
      const a = N(this.gos, {
        colDef: e,
        column: t,
        columnGroup: s,
        providedColumnGroup: i,
        location: o
      });
      return typeof n == "function" ? n(a) : typeof n == "string" ? ((r = this.beans.expressionSvc) == null ? void 0 : r.evaluate(n, a)) ?? null : "";
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return Ty(e.field);
    }
    return "";
  }
}, ky = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colViewport", this.colsWithinViewport = [], this.headerColsWithinViewport = [], this.colsWithinViewportHash = "", this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
  }
  wireBeans(e) {
    this.visibleCols = e.visibleCols, this.colModel = e.colModel;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(e, t, s = !1) {
    const { visibleCols: i } = this, o = i.isBodyWidthDirty;
    if (!(e === this.scrollWidth && t === this.scrollPosition && !o)) {
      if (this.scrollWidth = e, this.scrollPosition = t, i.isBodyWidthDirty = !0, this.gos.get("enableRtl")) {
        const r = i.bodyWidth;
        this.viewportLeft = r - t - e, this.viewportRight = r - t;
      } else
        this.viewportLeft = t, this.viewportRight = e + t;
      this.colModel.ready && this.checkViewportColumns(s);
    }
  }
  getHeadersToRender(e, t) {
    let s;
    switch (e) {
      case "left":
        s = this.rowsOfHeadersToRenderLeft[t];
        break;
      case "right":
        s = this.rowsOfHeadersToRenderRight[t];
        break;
      default:
        s = this.rowsOfHeadersToRenderCenter[t];
        break;
    }
    return s || [];
  }
  extractViewportColumns() {
    const e = this.visibleCols.centerCols;
    this.isColumnVirtualisationSuppressed() ? (this.colsWithinViewport = e, this.headerColsWithinViewport = e) : (this.colsWithinViewport = e.filter(this.isColumnInRowViewport.bind(this)), this.headerColsWithinViewport = e.filter(this.isColumnInHeaderViewport.bind(this)));
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear(e) {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, e || (this.colsWithinViewportHash = "");
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() || Gy(e) ? !0 : this.isColumnInRowViewport(e);
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, s = t + e.getActualWidth(), i = this.viewportLeft - 200, o = this.viewportRight + 200, n = t < i && s < i, r = t > o && s > o;
    return !n && !r;
  }
  // used by Grid API only
  getViewportColumns() {
    const { leftCols: e, rightCols: t } = this.visibleCols;
    return this.colsWithinViewport.concat(e).concat(t);
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(e) {
    if (!this.colModel.colSpanActive)
      return this.colsWithinViewport;
    const t = (n) => {
      const r = n.getLeft();
      return T(r) && r > this.viewportLeft;
    }, s = this.isColumnVirtualisationSuppressed() ? void 0 : this.isColumnInRowViewport.bind(this), { visibleCols: i } = this, o = i.centerCols;
    return i.getColsForRow(e, o, s, t);
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(e = !1) {
    this.extractViewport() && this.eventSvc.dispatchEvent({
      type: "virtualColumnsChanged",
      afterScroll: e
    });
  }
  calculateHeaderRows() {
    this.clear(!0);
    const e = {}, { leftCols: t, rightCols: s, treeLeft: i, treeRight: o, treeCenter: n } = this.visibleCols;
    this.headerColsWithinViewport.concat(t).concat(s).forEach((l) => e[l.getId()] = !0);
    const a = (l, d, c) => {
      let u = !1;
      for (let h = 0; h < l.length; h++) {
        const g = l[h];
        let p = !1;
        if (wt(g))
          p = e[g.getId()] === !0;
        else {
          const m = g.getDisplayedChildren();
          m && (p = a(m, d, c + 1));
        }
        p && (u = !0, d[c] || (d[c] = []), d[c].push(g));
      }
      return u;
    };
    a(i, this.rowsOfHeadersToRenderLeft, 0), a(o, this.rowsOfHeadersToRenderRight, 0), a(n, this.rowsOfHeadersToRenderCenter, 0);
  }
  extractViewport() {
    const e = (i) => `${i.getId()}-${i.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.getViewportColumns().map(e).join("#"), s = this.colsWithinViewportHash !== t;
    return s && (this.colsWithinViewportHash = t, this.calculateHeaderRows()), s;
  }
};
function Gy(e) {
  for (; e; ) {
    if (e.isAutoHeaderHeight())
      return !0;
    e = e.getParent();
  }
  return !1;
}
var Oy = class extends S {
  constructor() {
    super(...arguments), this.beanName = "agCompUtils";
  }
  adaptFunction(e, t) {
    if (!e.cellRenderer)
      return null;
    class s {
      refresh() {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(o) {
        const n = t(o), r = typeof n;
        if (r === "string" || r === "number" || r === "boolean") {
          this.eGui = Aa("<span>" + n + "</span>");
          return;
        }
        if (n == null) {
          this.eGui = _({ tag: "span" });
          return;
        }
        this.eGui = n;
      }
    }
    return s;
  }
}, By = {
  moduleName: "CellRendererFunction",
  version: Q,
  beans: [Oy]
}, Ny = class extends S {
  constructor() {
    super(...arguments), this.beanName = "registry", this.agGridDefaults = {}, this.agGridDefaultParams = {}, this.jsComps = {}, this.dynamicBeans = {}, this.selectors = {}, this.icons = {};
  }
  postConstruct() {
    const e = this.gos.get("components");
    if (e != null)
      for (const t of Object.keys(e))
        this.jsComps[t] = e[t];
  }
  registerModule(e) {
    const { icons: t, userComponents: s, dynamicBeans: i, selectors: o } = e;
    if (s) {
      const n = (r, a, l) => {
        this.agGridDefaults[r] = a, l && (this.agGridDefaultParams[r] = l);
      };
      for (const r of Object.keys(s)) {
        const a = s[r];
        typeof a == "object" ? n(r, a.classImp, a.params) : n(r, a);
      }
    }
    if (i)
      for (const n of Object.keys(i))
        this.dynamicBeans[n] = i[n];
    if (o == null || o.forEach((n) => {
      this.selectors[n.selector] = n;
    }), t)
      for (const n of Object.keys(t))
        this.icons[n] = t[n];
  }
  getUserComponent(e, t) {
    var a;
    const s = (l, d, c) => ({
      componentFromFramework: d,
      component: l,
      params: c
    }), { frameworkOverrides: i } = this.beans, o = i.frameworkComponent(t, this.gos.get("components"));
    if (o != null)
      return s(o, !0);
    const n = this.jsComps[t];
    if (n) {
      const l = i.isFrameworkComponent(n);
      return s(n, l);
    }
    const r = this.agGridDefaults[t];
    return r ? s(r, !1, this.agGridDefaultParams[t]) : ((a = this.beans.validation) == null || a.missingUserComponent(e, t, this.agGridDefaults, this.jsComps), null);
  }
  createDynamicBean(e, t, ...s) {
    const i = this.dynamicBeans[e];
    if (i == null) {
      if (t)
        throw new Error(ds(256));
      return;
    }
    return new i(...s);
  }
  getSelector(e) {
    return this.selectors[e];
  }
  getIcon(e) {
    return this.icons[e];
  }
}, Hy = 23, Vy = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ctrlsSvc", this.params = {}, this.ready = !1, this.readyCallbacks = [];
  }
  postConstruct() {
    var e, t;
    this.addEventListener(
      "ready",
      () => {
        this.updateReady(), this.ready && (this.readyCallbacks.forEach((s) => s(this.params)), this.readyCallbacks.length = 0);
      },
      ((t = (e = this.beans.frameworkOverrides).runWhenReadyAsync) == null ? void 0 : t.call(e)) ?? !1
    );
  }
  updateReady() {
    const e = Object.values(this.params);
    this.ready = e.length === Hy && e.every((t) => (t == null ? void 0 : t.isAlive()) ?? !1);
  }
  whenReady(e, t) {
    this.ready ? t(this.params) : this.readyCallbacks.push(t), e.addDestroyFunc(() => {
      const s = this.readyCallbacks.indexOf(t);
      s >= 0 && this.readyCallbacks.splice(s, 1);
    });
  }
  register(e, t) {
    this.params[e] = t, this.updateReady(), this.ready && this.dispatchLocalEvent({ type: "ready" }), t.addDestroyFunc(() => {
      this.updateReady();
    });
  }
  get(e) {
    return this.params[e];
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader: e, centerHeader: t, rightHeader: s } = this.params;
    return [e, s, t];
  }
  getHeaderRowContainerCtrl(e) {
    const t = this.params;
    switch (e) {
      case "left":
        return t.leftHeader;
      case "right":
        return t.rightHeader;
      default:
        return t.centerHeader;
    }
  }
  getScrollFeature() {
    return this.getGridBodyCtrl().scrollFeature;
  }
}, _y = (
  /*css*/
  ':where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart),:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]){box-sizing:border-box;&:after,&:before{box-sizing:border-box}&:where(div,span,label):focus-visible{box-shadow:inset var(--ag-focus-shadow);outline:none}}:where(.ag-root-wrapper,.ag-popup,.ag-dnd-ghost,.ag-chart) :where([class^=ag-]) ::-ms-clear{display:none}.ag-aria-description-container{border:0;z-index:9999;clip:rect(1px,1px,1px,1px);height:1px;overflow:hidden;padding:0;position:absolute;white-space:nowrap;width:1px}.ag-hidden{display:none!important}.ag-invisible{visibility:hidden!important}.ag-unselectable{-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-selectable{-webkit-user-select:text;-moz-user-select:text;user-select:text}.ag-tab-guard{display:block;height:0;position:absolute;width:0}:where(.ag-virtual-list-viewport) .ag-tab-guard{position:sticky}.ag-tab-guard-top{top:1px}.ag-tab-guard-bottom{bottom:1px}.ag-shake-left-to-right{animation-direction:alternate;animation-duration:.2s;animation-iteration-count:infinite;animation-name:ag-shake-left-to-right}@keyframes ag-shake-left-to-right{0%{padding-left:6px;padding-right:2px}to{padding-left:2px;padding-right:6px}}.ag-body-horizontal-scroll-viewport,.ag-body-vertical-scroll-viewport,.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport,.ag-virtual-list-viewport{flex:1 1 auto;height:100%;min-width:0;overflow:hidden;position:relative}.ag-viewport{position:relative}.ag-spanning-container{position:absolute;top:0;z-index:1}.ag-body-viewport,.ag-center-cols-viewport,.ag-floating-bottom-viewport,.ag-floating-top-viewport,.ag-header-viewport,.ag-sticky-bottom-viewport,.ag-sticky-top-viewport{overflow-x:auto;-ms-overflow-style:none!important;scrollbar-width:none!important;&::-webkit-scrollbar{display:none!important}}.ag-body-viewport{display:flex;overflow-x:hidden;&:where(.ag-layout-normal){overflow-y:auto;-webkit-overflow-scrolling:touch}}.ag-floating-bottom-container,.ag-floating-top-container,.ag-sticky-bottom-container,.ag-sticky-top-container{min-height:1px}.ag-center-cols-viewport{min-height:100%;width:100%}.ag-body-horizontal-scroll-viewport{overflow-x:scroll}.ag-body-vertical-scroll-viewport{overflow-y:scroll}.ag-virtual-list-viewport{overflow:auto;width:100%}.ag-body-container,.ag-body-horizontal-scroll-container,.ag-body-vertical-scroll-container,.ag-center-cols-container,.ag-floating-bottom-container,.ag-floating-bottom-full-width-container,.ag-floating-top-container,.ag-full-width-container,.ag-header-container,.ag-pinned-left-cols-container,.ag-pinned-right-cols-container,.ag-sticky-bottom-container,.ag-sticky-top-container,.ag-virtual-list-container{position:relative}.ag-floating-bottom-container,.ag-floating-top-container,.ag-header-container,.ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top,.ag-sticky-bottom-container,.ag-sticky-top-container{height:100%;white-space:nowrap}.ag-center-cols-container,.ag-pinned-right-cols-container{display:block}.ag-body-horizontal-scroll-container{height:100%}.ag-body-vertical-scroll-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container,.ag-full-width-container,.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{pointer-events:none;position:absolute;top:0}:where(.ag-ltr) .ag-floating-bottom-full-width-container,:where(.ag-ltr) .ag-floating-top-full-width-container,:where(.ag-ltr) .ag-full-width-container,:where(.ag-ltr) .ag-sticky-bottom-full-width-container,:where(.ag-ltr) .ag-sticky-top-full-width-container{left:0}:where(.ag-rtl) .ag-floating-bottom-full-width-container,:where(.ag-rtl) .ag-floating-top-full-width-container,:where(.ag-rtl) .ag-full-width-container,:where(.ag-rtl) .ag-sticky-bottom-full-width-container,:where(.ag-rtl) .ag-sticky-top-full-width-container{right:0}.ag-full-width-container{width:100%}.ag-floating-bottom-full-width-container,.ag-floating-top-full-width-container{display:inline-block;height:100%;overflow:hidden;width:100%}.ag-virtual-list-container{overflow:hidden}.ag-body{display:flex;flex:1 1 auto;flex-direction:row!important;min-height:0;position:relative}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:flex;min-height:0;min-width:0;position:relative;&:where(.ag-scrollbar-invisible){bottom:0;position:absolute;&:where(.ag-apple-scrollbar){opacity:0;transition:opacity .4s;visibility:hidden;&:where(.ag-scrollbar-scrolling,.ag-scrollbar-active){opacity:1;visibility:visible}}}}.ag-body-horizontal-scroll{width:100%;&:where(.ag-scrollbar-invisible){left:0;right:0}}.ag-body-vertical-scroll{height:100%;&:where(.ag-scrollbar-invisible){top:0;z-index:10}}:where(.ag-ltr) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){right:0}}:where(.ag-rtl) .ag-body-vertical-scroll{&:where(.ag-scrollbar-invisible){left:0}}.ag-force-vertical-scroll{overflow-y:scroll!important}.ag-horizontal-left-spacer,.ag-horizontal-right-spacer{height:100%;min-width:0;overflow-x:scroll;&:where(.ag-scroller-corner){overflow-x:hidden}}:where(.ag-row-animation) .ag-row{transition:transform .4s,top .4s,opacity .2s;&:where(.ag-after-created){transition:transform .4s,top .4s,height .4s,opacity .2s}}:where(.ag-row-animation.ag-prevent-animation) .ag-row{transition:none!important;&:where(.ag-row.ag-after-created){transition:none!important}}:where(.ag-row-no-animation) .ag-row{transition:none}.ag-row-loading{align-items:center;display:flex}.ag-row-position-absolute{position:absolute}.ag-row-position-relative{position:relative}.ag-full-width-row{overflow:hidden;pointer-events:all}.ag-row-inline-editing{z-index:1}.ag-row-dragging{z-index:2}.ag-stub-cell{align-items:center;display:flex}.ag-cell{display:inline-block;height:100%;position:absolute;white-space:nowrap;&:focus-visible{box-shadow:none}}.ag-cell-value{flex:1 1 auto}.ag-cell-value,.ag-group-value{overflow:hidden;text-overflow:ellipsis}.ag-cell-wrap-text{white-space:normal;word-break:break-word}:where(.ag-cell) .ag-icon{display:inline-block;vertical-align:middle}.ag-floating-top{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-top:not(.ag-invisible)){border-bottom:var(--ag-pinned-row-border)}.ag-floating-bottom{display:flex;overflow:hidden;position:relative;white-space:nowrap;width:100%}:where(.ag-floating-bottom:not(.ag-invisible)){border-top:var(--ag-pinned-row-border)}.ag-sticky-bottom,.ag-sticky-top{background-color:var(--ag-background-color);display:flex;height:0;overflow:hidden;position:absolute;width:100%;z-index:1}.ag-opacity-zero{opacity:0!important}.ag-cell-label-container{align-items:center;display:flex;flex-direction:row-reverse;height:100%;justify-content:space-between;width:100%}:where(.ag-right-aligned-header){.ag-cell-label-container{flex-direction:row}.ag-header-cell-text{text-align:end}}.ag-column-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr){direction:ltr;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row}}:where(.ag-rtl){direction:rtl;text-align:right;.ag-body,.ag-body-horizontal-scroll,.ag-body-viewport,.ag-floating-bottom,.ag-floating-top,.ag-header,.ag-sticky-bottom,.ag-sticky-top{flex-direction:row-reverse}.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{display:block}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(180deg)}}:where(.ag-rtl){.ag-icon-contracted,.ag-icon-expanded,.ag-icon-tree-closed{transform:rotate(-180deg)}}.ag-measurement-container{height:0;overflow:hidden;visibility:hidden;width:0}.ag-measurement-element-border{display:inline-block;&:before{border-left:var(--ag-internal-measurement-border);content:"";display:block}}.ag-group{position:relative;width:100%}.ag-group-title-bar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-title{display:inline;min-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:where(.ag-group-title-bar) .ag-group-title{cursor:default}.ag-group-toolbar{align-items:center;display:flex;padding:var(--ag-spacing)}.ag-group-container{display:flex}.ag-disabled .ag-group-container{pointer-events:none}.ag-disabled-group-container,.ag-disabled-group-title-bar{opacity:.5}.ag-group-container-horizontal{flex-flow:row wrap}.ag-group-container-vertical{flex-direction:column}.ag-group-title-bar-icon{cursor:pointer;flex:none}:where(.ag-ltr) .ag-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-group-title-bar-icon{margin-left:var(--ag-spacing)}:where(.ag-group-item-alignment-stretch) .ag-group-item{align-items:stretch}:where(.ag-group-item-alignment-start) .ag-group-item{align-items:flex-start}:where(.ag-group-item-alignment-end) .ag-group-item{align-items:flex-end}.ag-popup-child{top:0;z-index:5;&:where(:not(.ag-tooltip-custom)){box-shadow:var(--ag-popup-shadow)}}.ag-popup-editor{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-large-text-input{display:block}:where(.ag-ltr) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-left:var(--ag-row-group-indent-size)}:where(.ag-rtl) .ag-row:not(.ag-row-level-0) .ag-pivot-leaf-group{margin-right:var(--ag-row-group-indent-size)}:where(.ag-ltr) .ag-row-group-leaf-indent{margin-left:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}:where(.ag-rtl) .ag-row-group-leaf-indent{margin-right:calc(var(--ag-cell-widget-spacing) + var(--ag-icon-size))}.ag-value-change-delta{padding:0 2px}.ag-value-change-delta-up{color:var(--ag-value-change-delta-up-color)}.ag-value-change-delta-down{color:var(--ag-value-change-delta-down-color)}.ag-value-change-value{background-color:transparent;border-radius:1px;padding-left:1px;padding-right:1px;transition:background-color 1s}.ag-value-change-value-highlight{background-color:var(--ag-value-change-value-highlight-background-color);transition:background-color .1s}.ag-cell-data-changed{background-color:var(--ag-value-change-value-highlight-background-color)!important}.ag-cell-data-changed-animation{background-color:transparent}.ag-cell-highlight{background-color:var(--ag-range-selection-highlight-color)!important}.ag-row,.ag-spanned-row{color:var(--ag-cell-text-color);font-family:var(--ag-cell-font-family);font-size:var(--ag-data-font-size);white-space:nowrap;--ag-internal-content-line-height:calc(min(var(--ag-row-height), var(--ag-line-height, 1000px)) - var(--ag-internal-row-border-width, 1px) - 2px)}.ag-row{background-color:var(--ag-background-color);border-bottom:var(--ag-row-border);height:var(--ag-row-height);width:100%}:where(.ag-body-vertical-content-no-gap>div>div>div,.ag-body-vertical-content-no-gap>div>div>div>div)>.ag-row-last{border-bottom-color:transparent}.ag-sticky-bottom{border-top:var(--ag-row-border);box-sizing:content-box!important}.ag-group-contracted,.ag-group-expanded{cursor:pointer}.ag-cell,.ag-full-width-row .ag-cell-wrapper.ag-row-group{border:1px solid transparent;line-height:var(--ag-internal-content-line-height);-webkit-font-smoothing:subpixel-antialiased}:where(.ag-ltr) .ag-cell{border-right:var(--ag-column-border)}:where(.ag-rtl) .ag-cell{border-left:var(--ag-column-border)}.ag-spanned-cell-wrapper{background-color:var(--ag-background-color);position:absolute}.ag-spanned-cell-wrapper>.ag-spanned-cell{display:block;position:relative}:where(.ag-ltr) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-right-color:transparent}:where(.ag-rtl) :where(.ag-body-horizontal-content-no-gap) .ag-column-last{border-left-color:transparent}.ag-cell-wrapper{align-items:center;display:flex;>:where(:not(.ag-cell-value,.ag-group-value)){align-items:center;display:flex;height:var(--ag-internal-content-line-height)}&:where(.ag-row-group){align-items:flex-start}:where(.ag-full-width-row) &:where(.ag-row-group){align-items:center;height:100%}}:where(.ag-ltr) .ag-cell-wrapper{padding-left:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-rtl) .ag-cell-wrapper{padding-right:calc(var(--ag-indentation-level)*var(--ag-row-group-indent-size))}:where(.ag-cell-wrap-text:not(.ag-cell-auto-height)) .ag-cell-wrapper{align-items:normal;height:100%;:where(.ag-cell-value){height:100%}}:where(.ag-ltr) .ag-row>.ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-row>.ag-cell-wrapper.ag-row-group{padding-right:calc(var(--ag-cell-horizontal-padding) + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-cell-focus:not(.ag-cell-range-selected):focus-within,.ag-cell-range-single-cell,.ag-cell-range-single-cell.ag-cell-range-handle,.ag-context-menu-open .ag-cell-focus:not(.ag-cell-range-selected),.ag-context-menu-open .ag-full-width-row.ag-row-focus .ag-cell-wrapper.ag-row-group,.ag-full-width-row.ag-row-focus:focus .ag-cell-wrapper.ag-row-group{border:1px solid;border-color:var(--ag-range-selection-border-color);border-style:var(--ag-range-selection-border-style);outline:initial}.ag-full-width-row.ag-row-focus:focus{box-shadow:none}:where(.ag-ltr) .ag-group-contracted,:where(.ag-ltr) .ag-group-expanded,:where(.ag-ltr) .ag-row-drag,:where(.ag-ltr) .ag-selection-checkbox{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-contracted,:where(.ag-rtl) .ag-group-expanded,:where(.ag-rtl) .ag-row-drag,:where(.ag-rtl) .ag-selection-checkbox{margin-left:var(--ag-cell-widget-spacing)}:where(.ag-ltr) .ag-group-child-count{margin-left:3px}:where(.ag-rtl) .ag-group-child-count{margin-right:3px}.ag-row-highlight-above:after,.ag-row-highlight-below:after{background-color:var(--ag-range-selection-border-color);content:"";height:1px;position:absolute;width:calc(100% - 1px)}:where(.ag-ltr) .ag-row-highlight-above:after,:where(.ag-ltr) .ag-row-highlight-below:after{left:1px}:where(.ag-rtl) .ag-row-highlight-above:after,:where(.ag-rtl) .ag-row-highlight-below:after{right:1px}.ag-row-highlight-above:after{top:0}.ag-row-highlight-below:after{bottom:0}.ag-row-odd{background-color:var(--ag-odd-row-background-color)}.ag-row-selected:before{background-color:var(--ag-selected-row-background-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-full-width-row.ag-row-group:before,.ag-row-hover:not(.ag-full-width-row):before{background-color:var(--ag-row-hover-color);content:"";display:block;inset:0;pointer-events:none;position:absolute}.ag-row-hover.ag-row-selected:before{background-color:var(--ag-row-hover-color);background-image:linear-gradient(var(--ag-selected-row-background-color),var(--ag-selected-row-background-color))}.ag-row.ag-full-width-row.ag-row-group>*{position:relative}.ag-column-hover{background-color:var(--ag-column-hover-color)}.ag-header-range-highlight{background-color:var(--ag-range-header-highlight-color)}.ag-right-aligned-cell{font-variant-numeric:tabular-nums}:where(.ag-ltr) .ag-right-aligned-cell{text-align:right}:where(.ag-rtl) .ag-right-aligned-cell{text-align:left}.ag-right-aligned-cell .ag-cell-value,.ag-right-aligned-cell .ag-group-value{margin-left:auto}:where(.ag-ltr) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-ltr) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level));padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}:where(.ag-rtl) .ag-cell:not(.ag-cell-inline-editing),:where(.ag-rtl) .ag-full-width-row .ag-cell-wrapper.ag-row-group{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px + var(--ag-row-group-indent-size)*var(--ag-indentation-level))}.ag-row>.ag-cell-wrapper{padding-left:calc(var(--ag-cell-horizontal-padding) - 1px);padding-right:calc(var(--ag-cell-horizontal-padding) - 1px)}.ag-row-dragging{cursor:move;opacity:.5}.ag-details-row{background-color:var(--ag-background-color);padding:calc(var(--ag-spacing)*3.75)}.ag-layout-auto-height,.ag-layout-print{.ag-center-cols-container,.ag-center-cols-viewport{min-height:150px}}.ag-overlay-loading-wrapper{background-color:var(--ag-modal-overlay-background-color)}.ag-skeleton-container{align-content:center;height:100%;width:100%}.ag-skeleton-effect{animation:ag-skeleton-loading 1.5s ease-in-out .5s infinite;background-color:var(--ag-row-loading-skeleton-effect-color);border-radius:.25rem;height:1em;width:100%}:where(.ag-ltr) .ag-right-aligned-cell .ag-skeleton-effect{margin-left:auto}:where(.ag-rtl) .ag-right-aligned-cell .ag-skeleton-effect{margin-right:auto}@keyframes ag-skeleton-loading{0%{opacity:1}50%{opacity:.4}to{opacity:1}}.ag-loading{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-loading{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-loading{padding-right:var(--ag-cell-horizontal-padding)}:where(.ag-ltr) .ag-loading-icon{padding-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-loading-icon{padding-left:var(--ag-cell-widget-spacing)}.ag-icon-loading{animation-duration:1s;animation-iteration-count:infinite;animation-name:spin;animation-timing-function:linear}@keyframes spin{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.ag-input-wrapper,.ag-picker-field-wrapper{align-items:center;display:flex;flex:1 1 auto;line-height:normal;position:relative}.ag-input-field{align-items:center;display:flex;flex-direction:row}.ag-input-field-input:where(:not([type=checkbox],[type=radio])){flex:1 1 auto;min-width:0;width:100%}.ag-header{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);color:var(--ag-header-text-color);display:flex;font-family:var(--ag-header-font-family);font-size:var(--ag-header-font-size);font-weight:var(--ag-header-font-weight);overflow:hidden;white-space:nowrap;width:100%}.ag-header-row{height:var(--ag-header-height);position:absolute}.ag-floating-filter-button-button,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,:where(.ag-header-cell-sortable) .ag-header-cell-label{cursor:pointer}:where(.ag-ltr) .ag-header-expand-icon{margin-left:4px}:where(.ag-rtl) .ag-header-expand-icon{margin-right:4px}.ag-header-row:where(:not(:first-child)){:where(.ag-header-cell:not(.ag-header-span-height.ag-header-span-total,.ag-header-parent-hidden),.ag-header-group-cell.ag-header-group-cell-with-group){border-top:var(--ag-header-row-border)}}.ag-header-row:where(:not(.ag-header-row-column-group)){overflow:hidden}:where(.ag-header.ag-header-allow-overflow) .ag-header-row{overflow:visible}.ag-header-cell{display:inline-flex;overflow:hidden}.ag-header-group-cell{contain:paint;display:flex}.ag-header-cell,.ag-header-group-cell{align-items:center;gap:var(--ag-cell-widget-spacing);height:100%;padding:0 var(--ag-cell-horizontal-padding);position:absolute}@property --ag-internal-moving-color{syntax:"<color>";inherits:false;initial-value:transparent}@property --ag-internal-hover-color{syntax:"<color>";inherits:false;initial-value:transparent}.ag-header-cell:where(:not(.ag-floating-filter)),.ag-header-group-cell{&:before{background-image:linear-gradient(var(--ag-internal-hover-color),var(--ag-internal-hover-color)),linear-gradient(var(--ag-internal-moving-color),var(--ag-internal-moving-color));content:"";inset:0;position:absolute;--ag-internal-moving-color:transparent;--ag-internal-hover-color:transparent;transition:--ag-internal-moving-color var(--ag-header-cell-background-transition-duration),--ag-internal-hover-color var(--ag-header-cell-background-transition-duration)}&:where(:hover):before{--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}&:where(.ag-header-cell-moving):before{--ag-internal-moving-color:var(--ag-header-cell-moving-background-color);--ag-internal-hover-color:var(--ag-header-cell-hover-background-color)}}:where(.ag-header-cell:not(.ag-floating-filter) *,.ag-header-group-cell *){position:relative;z-index:1}.ag-header-cell-menu-button:where(:not(.ag-header-menu-always-show)){opacity:0;transition:opacity .2s}.ag-header-cell-filter-button,:where(.ag-header-cell.ag-header-active) .ag-header-cell-menu-button{opacity:1}.ag-header-cell-label,.ag-header-group-cell-label{align-items:center;align-self:stretch;display:flex;flex:1 1 auto;overflow:hidden;padding:5px 0}:where(.ag-ltr) .ag-sort-indicator-icon{padding-left:var(--ag-spacing)}:where(.ag-rtl) .ag-sort-indicator-icon{padding-right:var(--ag-spacing)}.ag-header-cell-label{text-overflow:ellipsis}.ag-header-group-cell-label.ag-sticky-label{flex:none;max-width:100%;overflow:visible;position:sticky}:where(.ag-ltr) .ag-header-group-cell-label.ag-sticky-label{left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-header-group-cell-label.ag-sticky-label{right:var(--ag-cell-horizontal-padding)}.ag-header-cell-text,.ag-header-group-text{overflow:hidden;text-overflow:ellipsis}.ag-header-cell-text{word-break:break-word}.ag-header-cell-comp-wrapper{width:100%}:where(.ag-header-group-cell) .ag-header-cell-comp-wrapper{display:flex}:where(.ag-header-cell:not(.ag-header-cell-auto-height)) .ag-header-cell-comp-wrapper{align-items:center;display:flex;height:100%}.ag-header-cell-wrap-text .ag-header-cell-comp-wrapper{white-space:normal}.ag-header-cell-comp-wrapper-limited-height>*{overflow:hidden}:where(.ag-right-aligned-header) .ag-header-cell-label{flex-direction:row-reverse}:where(.ag-ltr) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell:not(.ag-right-aligned-header)){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-ltr) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-right:var(--ag-spacing)}}:where(.ag-rtl) :where(.ag-header-cell.ag-right-aligned-header){.ag-header-label-icon,.ag-header-menu-icon{margin-left:var(--ag-spacing)}}.ag-header-cell:after,.ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{content:"";height:var(--ag-header-column-border-height);position:absolute;top:calc(50% - var(--ag-header-column-border-height)*.5);z-index:1}:where(.ag-ltr) .ag-header-cell:after,:where(.ag-ltr) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-right:var(--ag-header-column-border);right:0}:where(.ag-rtl) .ag-header-cell:after,:where(.ag-rtl) .ag-header-group-cell:where(:not(.ag-header-span-height.ag-header-group-cell-no-group)):after{border-left:var(--ag-header-column-border);left:0}.ag-header-highlight-after:after,.ag-header-highlight-before:after{background-color:var(--ag-accent-color);content:"";height:100%;position:absolute;width:1px}:where(.ag-ltr) .ag-header-highlight-before:after{left:0}:where(.ag-rtl) .ag-header-highlight-before:after{right:0}:where(.ag-ltr) .ag-header-highlight-after:after{right:0;:where(.ag-pinned-left-header) &{right:1px}}:where(.ag-rtl) .ag-header-highlight-after:after{left:0;:where(.ag-pinned-left-header) &{left:1px}}.ag-header-cell-resize{align-items:center;cursor:ew-resize;display:flex;height:100%;position:absolute;top:0;width:8px;z-index:2;&:after{background-color:var(--ag-header-column-resize-handle-color);content:"";height:var(--ag-header-column-resize-handle-height);position:absolute;top:calc(50% - var(--ag-header-column-resize-handle-height)*.5);width:var(--ag-header-column-resize-handle-width);z-index:1}}:where(.ag-ltr) .ag-header-cell-resize{right:-3px;&:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-rtl) .ag-header-cell-resize{left:-3px;&:after{right:calc(50% - var(--ag-header-column-resize-handle-width))}}:where(.ag-header-cell.ag-header-span-height) .ag-header-cell-resize:after{height:calc(100% - var(--ag-spacing)*4);top:calc(var(--ag-spacing)*2)}.ag-header-group-cell-no-group:where(.ag-header-span-height){display:none}.ag-sort-indicator-container{display:flex;gap:var(--ag-spacing)}.ag-layout-print{&.ag-body{display:block;height:unset}&.ag-root-wrapper{display:inline-block}.ag-body-horizontal-scroll,.ag-body-vertical-scroll{display:none}&.ag-force-vertical-scroll{overflow-y:visible!important}}@media print{.ag-root-wrapper.ag-layout-print{display:table;.ag-body-horizontal-scroll-viewport,.ag-body-viewport,.ag-center-cols-container,.ag-center-cols-viewport,.ag-root,.ag-root-wrapper-body,.ag-virtual-list-viewport{display:block!important;height:auto!important;overflow:hidden!important}.ag-cell,.ag-row{-moz-column-break-inside:avoid;break-inside:avoid}}}ag-grid,ag-grid-angular{display:block}.ag-chart,.ag-dnd-ghost,.ag-popup,.ag-root-wrapper{cursor:default;line-height:normal;white-space:normal;-webkit-font-smoothing:antialiased;background-color:var(--ag-background-color);color:var(--ag-text-color);color-scheme:var(--ag-browser-color-scheme);font-family:var(--ag-font-family);font-size:var(--ag-font-size);--ag-indentation-level:0}.ag-root-wrapper{border:var(--ag-wrapper-border);border-radius:var(--ag-wrapper-border-radius);display:flex;flex-direction:column;overflow:hidden;position:relative;&.ag-layout-normal{height:100%}}.ag-root-wrapper-body{display:flex;flex-direction:row;&.ag-layout-normal{flex:1 1 auto;height:0;min-height:0}}.ag-root{display:flex;flex-direction:column;position:relative;&.ag-layout-auto-height,&.ag-layout-normal{flex:1 1 auto;overflow:hidden;width:0}&.ag-layout-normal{height:100%}}.ag-drag-handle{color:var(--ag-drag-handle-color);cursor:grab}.ag-list-item,.ag-virtual-list-item{height:var(--ag-list-item-height)}.ag-virtual-list-item{position:absolute;width:100%}.ag-select-list{background-color:var(--ag-picker-list-background-color);border:var(--ag-picker-list-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);overflow:hidden auto}.ag-list-item{align-items:center;display:flex;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;&.ag-active-item{background-color:var(--ag-row-hover-color)}}.ag-select-list-item{cursor:default;-webkit-user-select:none;-moz-user-select:none;user-select:none;:where(span){overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}:where(.ag-ltr) .ag-select-list-item{padding-left:calc(var(--ag-cell-horizontal-padding)/2)}:where(.ag-rtl) .ag-select-list-item{padding-right:calc(var(--ag-cell-horizontal-padding)/2)}.ag-list-item-hovered:after{background-color:var(--ag-accent-color);content:"";height:1px;left:0;position:absolute;right:0}.ag-item-highlight-top:after{top:0}.ag-item-highlight-bottom:after{bottom:0}:where(.ag-icon):before{align-items:center;background-color:currentcolor;color:inherit;content:"";display:flex;font-family:inherit;font-size:var(--ag-icon-size);font-style:normal;font-variant:normal;height:var(--ag-icon-size);justify-content:center;line-height:var(--ag-icon-size);-webkit-mask-size:contain;mask-size:contain;text-transform:none;width:var(--ag-icon-size)}.ag-icon{background-position:50%;background-repeat:no-repeat;background-size:contain;color:var(--ag-icon-color);display:block;height:var(--ag-icon-size);position:relative;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-icon-size)}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly,.ag-disabled,[disabled]{.ag-icon{opacity:.5}&.ag-icon-grip{opacity:.35}}.ag-column-select-column-readonly{&.ag-icon-grip,.ag-icon-grip{opacity:.35}}.ag-chart-menu-icon,.ag-chart-settings-next,.ag-chart-settings-prev,.ag-column-group-icons,.ag-column-select-header-icon,.ag-filter-toolpanel-expand,.ag-floating-filter-button-button,.ag-group-title-bar-icon,.ag-header-cell-filter-button,.ag-header-cell-menu-button,.ag-header-expand-icon,.ag-panel-title-bar-button,.ag-panel-title-bar-button-icon,.ag-set-filter-group-icons,:where(.ag-group-contracted) .ag-icon,:where(.ag-group-expanded) .ag-icon{background-color:var(--ag-icon-button-background-color);border-radius:var(--ag-icon-button-border-radius);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-background-color);color:var(--ag-icon-button-color);&:hover{background-color:var(--ag-icon-button-hover-background-color);box-shadow:0 0 0 var(--ag-icon-button-background-spread) var(--ag-icon-button-hover-background-color);color:var(--ag-icon-button-hover-color)}}.ag-filter-active{background-image:linear-gradient(var(--ag-icon-button-active-background-color),var(--ag-icon-button-active-background-color));border-radius:1px;outline:solid var(--ag-icon-button-background-spread) var(--ag-icon-button-active-background-color);position:relative;&:after{background-color:var(--ag-accent-color);border-radius:50%;content:"";height:6px;position:absolute;top:-1px;width:6px}:where(.ag-icon-filter){clip-path:path("M8,0C8,4.415 11.585,8 16,8L16,16L0,16L0,0L8,0Z");color:var(--ag-icon-button-active-color)}}:where(.ag-ltr) .ag-filter-active{&:after{right:-1px}}:where(.ag-rtl) .ag-filter-active{&:after{left:-1px}}.ag-menu{background-color:var(--ag-menu-background-color);border:var(--ag-menu-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-menu-shadow);color:var(--ag-menu-text-color);max-height:100%;overflow-y:auto}.ag-menu,.ag-resizer{position:absolute;-webkit-user-select:none;-moz-user-select:none;user-select:none}.ag-resizer{pointer-events:none;z-index:1}:where(.ag-resizer){&.ag-resizer-topLeft{cursor:nwse-resize;height:5px;left:0;top:0;width:5px}&.ag-resizer-top{cursor:ns-resize;height:5px;left:5px;right:5px;top:0}&.ag-resizer-topRight{cursor:nesw-resize;height:5px;right:0;top:0;width:5px}&.ag-resizer-right{bottom:5px;cursor:ew-resize;right:0;top:5px;width:5px}&.ag-resizer-bottomRight{bottom:0;cursor:nwse-resize;height:5px;right:0;width:5px}&.ag-resizer-bottom{bottom:0;cursor:ns-resize;height:5px;left:5px;right:5px}&.ag-resizer-bottomLeft{bottom:0;cursor:nesw-resize;height:5px;left:0;width:5px}&.ag-resizer-left{bottom:5px;cursor:ew-resize;left:0;top:5px;width:5px}}'
), Kd, qd, nl = typeof window != "object" || !((qd = (Kd = window == null ? void 0 : window.document) == null ? void 0 : Kd.fonts) != null && qd.forEach), Pi = (e, t, s, i, o, n) => {
  if (nl)
    return;
  i && (e = `@layer ${CSS.escape(i)} { ${e} }`);
  let r = gi.map.get(t);
  if (r || (r = [], gi.map.set(t, r)), r.find((c) => c.css === e))
    return;
  const a = document.createElement("style");
  n && a.setAttribute("nonce", n), a.dataset.agGlobalCss = s, a.textContent = e;
  const l = { css: e, el: a, priority: o };
  let d;
  for (const c of r) {
    if (c.priority > o)
      break;
    d = c;
  }
  if (d) {
    d.el.insertAdjacentElement("afterend", a);
    const c = r.indexOf(d);
    r.splice(c + 1, 0, l);
  } else
    t.insertBefore(a, t.querySelector(":not(title, meta)")), r.push(l);
}, Ih = (e, t, s) => {
  Pi(_y, e, "core", t, 0, s), Array.from(jC()).sort((i, o) => i.moduleName.localeCompare(o.moduleName)).forEach(
    (i) => {
      var o;
      return (o = i.css) == null ? void 0 : o.forEach(
        (n) => Pi(n, e, `module-${i.moduleName}`, t, 0, s)
      );
    }
  );
}, Wy = (e) => {
  gi.grids.add(e);
}, zy = (e) => {
  if (gi.grids.delete(e), gi.grids.size === 0) {
    gi.map = /* @__PURE__ */ new WeakMap();
    for (const t of document.head.querySelectorAll("style[data-ag-global-css]"))
      t.remove();
  }
}, dd, gi = (dd = typeof window == "object" ? window : {}).agStyleInjectionState ?? (dd.agStyleInjectionState = {
  map: /* @__PURE__ */ new WeakMap(),
  grids: /* @__PURE__ */ new Set()
}), Lt = (e) => new Th(e), Jt = "$default", Uy = 0, Th = class {
  constructor({ feature: e, params: t, modeParams: s = {}, css: i, cssImports: o }) {
    this.feature = e, this.css = i, this.cssImports = o, this.modeParams = {
      // NOTE: it's important that default is defined first, putting it
      // first in iteration order, because when merging params the default
      // params override any prior modal params, so modal params in this
      // part need to come after default params to prevent them from being
      // immediately overridden.
      [Jt]: {
        ...s[Jt] ?? {},
        ...t ?? {}
      },
      ...s
    };
  }
  use(e, t, s) {
    let i = this._inject;
    if (i == null) {
      let { css: o } = this;
      if (o) {
        const n = `ag-theme-${this.feature ?? "part"}-${++Uy}`;
        typeof o == "function" && (o = o()), o = `:where(.${n}) {
${o}
}
`;
        for (const r of this.cssImports ?? [])
          o = `@import url(${JSON.stringify(r)});
${o}`;
        i = { css: o, class: n };
      } else
        i = !1;
      this._inject = i;
    }
    return i && e && Pi(i.css, e, i.class, t, 1, s), i ? i.class : !1;
  }
}, jy = (e) => e.replace(/[A-Z]/g, (t) => `-${t}`).toLowerCase(), Lh = (e) => `--ag-${jy(e)}`, kt = (e) => `var(${Lh(e)})`, $y = (e, t, s) => Math.max(t, Math.min(s, e)), Ky = (e) => {
  const t = /* @__PURE__ */ new Map();
  return (s) => {
    const i = s;
    return t.has(i) || t.set(i, e(s)), t.get(i);
  };
}, Rt = (e) => ({ ref: "accentColor", mix: e }), Qe = (e) => ({ ref: "foregroundColor", mix: e }), ut = (e) => ({
  ref: "foregroundColor",
  mix: e,
  onto: "backgroundColor"
}), qy = (e) => ({
  ref: "foregroundColor",
  mix: e,
  onto: "headerBackgroundColor"
}), Ue = { ref: "backgroundColor" }, Vi = { ref: "foregroundColor" }, is = { ref: "accentColor" }, Mn = {
  backgroundColor: "#fff",
  foregroundColor: "#181d1f",
  borderColor: Qe(0.15),
  chromeBackgroundColor: ut(0.02),
  browserColorScheme: "light"
}, Yy = {
  ...Mn,
  textColor: Vi,
  accentColor: "#2196f3",
  invalidColor: "#e02525",
  wrapperBorder: !0,
  rowBorder: !0,
  headerRowBorder: !0,
  footerRowBorder: {
    ref: "rowBorder"
  },
  columnBorder: {
    style: "solid",
    width: 1,
    color: "transparent"
  },
  headerColumnBorder: !1,
  headerColumnBorderHeight: "100%",
  pinnedColumnBorder: !0,
  pinnedRowBorder: !0,
  sidePanelBorder: !0,
  sideBarPanelWidth: 250,
  sideBarBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  sideButtonBarBackgroundColor: {
    ref: "sideBarBackgroundColor"
  },
  sideButtonBarTopPadding: 0,
  sideButtonSelectedUnderlineWidth: 2,
  sideButtonSelectedUnderlineColor: "transparent",
  sideButtonSelectedUnderlineTransitionDuration: 0,
  sideButtonBackgroundColor: "transparent",
  sideButtonTextColor: { ref: "textColor" },
  sideButtonHoverBackgroundColor: { ref: "sideButtonBackgroundColor" },
  sideButtonHoverTextColor: { ref: "sideButtonTextColor" },
  sideButtonSelectedBackgroundColor: Ue,
  sideButtonSelectedTextColor: { ref: "sideButtonTextColor" },
  sideButtonBorder: "solid 1px transparent",
  sideButtonSelectedBorder: !0,
  sideButtonLeftPadding: { ref: "spacing" },
  sideButtonRightPadding: { ref: "spacing" },
  sideButtonVerticalPadding: { calc: "spacing * 3" },
  fontFamily: [
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu",
    "Cantarell",
    "Helvetica Neue",
    "sans-serif"
  ],
  headerBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  headerFontFamily: {
    ref: "fontFamily"
  },
  cellFontFamily: {
    ref: "fontFamily"
  },
  headerFontWeight: 500,
  headerFontSize: {
    ref: "fontSize"
  },
  dataFontSize: {
    ref: "fontSize"
  },
  headerTextColor: {
    ref: "textColor"
  },
  headerCellHoverBackgroundColor: "transparent",
  headerCellMovingBackgroundColor: { ref: "headerCellHoverBackgroundColor" },
  headerCellBackgroundTransitionDuration: "0.2s",
  cellTextColor: {
    ref: "textColor"
  },
  subtleTextColor: {
    ref: "textColor",
    mix: 0.5
  },
  rangeSelectionBorderStyle: "solid",
  rangeSelectionBorderColor: is,
  rangeSelectionBackgroundColor: Rt(0.2),
  rangeSelectionChartBackgroundColor: "#0058FF1A",
  rangeSelectionChartCategoryBackgroundColor: "#00FF841A",
  rangeSelectionHighlightColor: Rt(0.5),
  rangeHeaderHighlightColor: qy(0.08),
  rowNumbersSelectedColor: Rt(0.5),
  rowHoverColor: Rt(0.08),
  columnHoverColor: Rt(0.05),
  selectedRowBackgroundColor: Rt(0.12),
  modalOverlayBackgroundColor: {
    ref: "backgroundColor",
    mix: 0.66
  },
  oddRowBackgroundColor: Ue,
  borderRadius: 4,
  wrapperBorderRadius: 8,
  cellHorizontalPadding: {
    calc: "spacing * 2 * cellHorizontalPaddingScale"
  },
  cellWidgetSpacing: {
    calc: "spacing * 1.5"
  },
  cellHorizontalPaddingScale: 1,
  rowGroupIndentSize: {
    calc: "cellWidgetSpacing + iconSize"
  },
  valueChangeDeltaUpColor: "#43a047",
  valueChangeDeltaDownColor: "#e53935",
  valueChangeValueHighlightBackgroundColor: "#16a08580",
  spacing: 8,
  fontSize: 14,
  rowHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 3.25 * rowVerticalPaddingScale"
  },
  rowVerticalPaddingScale: 1,
  headerHeight: {
    calc: "max(iconSize, dataFontSize) + spacing * 4 * headerVerticalPaddingScale"
  },
  headerVerticalPaddingScale: 1,
  popupShadow: "0 0 16px #00000026",
  cardShadow: "0 1px 4px 1px #00000018",
  dropdownShadow: { ref: "cardShadow" },
  dragAndDropImageBackgroundColor: Ue,
  dragAndDropImageBorder: !0,
  dragAndDropImageShadow: {
    ref: "popupShadow"
  },
  dragHandleColor: Qe(0.7),
  focusShadow: {
    spread: 3,
    color: Rt(0.5)
  },
  headerColumnResizeHandleHeight: "30%",
  headerColumnResizeHandleWidth: 2,
  headerColumnResizeHandleColor: {
    ref: "borderColor"
  },
  widgetContainerHorizontalPadding: {
    calc: "spacing * 1.5"
  },
  widgetContainerVerticalPadding: {
    calc: "spacing * 1.5"
  },
  widgetHorizontalSpacing: {
    calc: "spacing * 1.5"
  },
  widgetVerticalSpacing: {
    ref: "spacing"
  },
  listItemHeight: {
    calc: "max(iconSize, dataFontSize) + widgetVerticalSpacing"
  },
  iconSize: 16,
  iconColor: "inherit",
  iconButtonColor: { ref: "iconColor" },
  iconButtonBackgroundColor: "transparent",
  iconButtonBackgroundSpread: 4,
  iconButtonBorderRadius: 1,
  iconButtonHoverColor: { ref: "iconButtonColor" },
  iconButtonHoverBackgroundColor: Qe(0.1),
  iconButtonActiveColor: is,
  iconButtonActiveBackgroundColor: Rt(0.28),
  iconButtonActiveIndicatorColor: is,
  toggleButtonWidth: 28,
  toggleButtonHeight: 18,
  toggleButtonOnBackgroundColor: is,
  toggleButtonOffBackgroundColor: ut(0.3),
  toggleButtonSwitchBackgroundColor: Ue,
  toggleButtonSwitchInset: 2,
  menuBorder: {
    color: Qe(0.2)
  },
  menuBackgroundColor: ut(0.03),
  menuTextColor: ut(0.95),
  menuShadow: {
    ref: "popupShadow"
  },
  menuSeparatorColor: {
    ref: "borderColor"
  },
  setFilterIndentSize: {
    ref: "iconSize"
  },
  chartMenuPanelWidth: 260,
  chartMenuLabelColor: Qe(0.8),
  dialogShadow: {
    ref: "popupShadow"
  },
  cellEditingBorder: {
    color: is
  },
  cellEditingShadow: { ref: "cardShadow" },
  dialogBorder: {
    color: Qe(0.2)
  },
  panelBackgroundColor: Ue,
  panelTitleBarBackgroundColor: {
    ref: "headerBackgroundColor"
  },
  panelTitleBarIconColor: {
    ref: "headerTextColor"
  },
  panelTitleBarTextColor: {
    ref: "headerTextColor"
  },
  panelTitleBarFontWeight: {
    ref: "headerFontWeight"
  },
  panelTitleBarBorder: !0,
  columnSelectIndentSize: {
    ref: "iconSize"
  },
  toolPanelSeparatorBorder: !0,
  tooltipBackgroundColor: {
    ref: "chromeBackgroundColor"
  },
  tooltipTextColor: {
    ref: "textColor"
  },
  tooltipBorder: !0,
  columnDropCellBackgroundColor: Qe(0.07),
  columnDropCellTextColor: {
    ref: "textColor"
  },
  columnDropCellDragHandleColor: {
    ref: "textColor"
  },
  columnDropCellBorder: {
    color: Qe(0.13)
  },
  selectCellBackgroundColor: Qe(0.07),
  selectCellBorder: {
    color: Qe(0.13)
  },
  advancedFilterBuilderButtonBarBorder: !0,
  advancedFilterBuilderIndentSize: {
    calc: "spacing * 2 + iconSize"
  },
  advancedFilterBuilderJoinPillColor: "#f08e8d",
  advancedFilterBuilderColumnPillColor: "#a6e194",
  advancedFilterBuilderOptionPillColor: "#f3c08b",
  advancedFilterBuilderValuePillColor: "#85c0e4",
  findMatchColor: Vi,
  findMatchBackgroundColor: "#ffff00",
  findActiveMatchColor: Vi,
  findActiveMatchBackgroundColor: "#ffa500",
  filterToolPanelGroupIndent: {
    ref: "spacing"
  },
  rowLoadingSkeletonEffectColor: Qe(0.15),
  statusBarLabelColor: Vi,
  statusBarLabelFontWeight: 500,
  statusBarValueColor: Vi,
  statusBarValueFontWeight: 500,
  pinnedSourceRowTextColor: {
    ref: "textColor"
  },
  pinnedSourceRowBackgroundColor: {
    ref: "backgroundColor"
  },
  pinnedSourceRowFontWeight: 600,
  pinnedRowFontWeight: 600,
  pinnedRowBackgroundColor: {
    ref: "backgroundColor"
  },
  pinnedRowTextColor: {
    ref: "textColor"
  }
}, Zy = (
  /*css*/
  ":where(.ag-button){background:none;border:none;color:inherit;cursor:pointer;font-family:inherit;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;margin:0;padding:0;text-indent:inherit;text-shadow:inherit;text-transform:inherit;word-spacing:inherit;&:disabled{cursor:default}&:focus-visible{box-shadow:var(--ag-focus-shadow);outline:none}}.ag-standard-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;background-color:var(--ag-button-background-color);border:var(--ag-button-border);border-radius:var(--ag-button-border-radius);color:var(--ag-button-text-color);cursor:pointer;font-weight:var(--ag-button-font-weight);padding:var(--ag-button-vertical-padding) var(--ag-button-horizontal-padding);&:hover{background-color:var(--ag-button-hover-background-color);border:var(--ag-button-hover-border);color:var(--ag-button-hover-text-color)}&:active{background-color:var(--ag-button-active-background-color);border:var(--ag-button-active-border);color:var(--ag-button-active-text-color)}&:disabled{background-color:var(--ag-button-disabled-background-color);border:var(--ag-button-disabled-border);color:var(--ag-button-disabled-text-color)}}"
), Qy = {
  buttonTextColor: "inherit",
  buttonFontWeight: "normal",
  buttonBackgroundColor: "transparent",
  buttonBorder: !1,
  buttonBorderRadius: { ref: "borderRadius" },
  buttonHorizontalPadding: { calc: "spacing * 2" },
  buttonVerticalPadding: { ref: "spacing" },
  buttonHoverTextColor: { ref: "buttonTextColor" },
  buttonHoverBackgroundColor: { ref: "buttonBackgroundColor" },
  buttonHoverBorder: { ref: "buttonBorder" },
  buttonActiveTextColor: { ref: "buttonHoverTextColor" },
  buttonActiveBackgroundColor: { ref: "buttonHoverBackgroundColor" },
  buttonActiveBorder: { ref: "buttonHoverBorder" },
  buttonDisabledTextColor: { ref: "inputDisabledTextColor" },
  buttonDisabledBackgroundColor: { ref: "inputDisabledBackgroundColor" },
  buttonDisabledBorder: { ref: "inputDisabledBorder" }
}, Xy = () => Lt({
  feature: "buttonStyle",
  params: {
    ...Qy,
    buttonBackgroundColor: Ue,
    buttonBorder: !0,
    buttonHoverBackgroundColor: { ref: "rowHoverColor" },
    buttonActiveBorder: { color: is }
  },
  css: Zy
}), Jy = /* @__PURE__ */ Xy(), eS = (
  /*css*/
  ".ag-column-drop-vertical-empty-message{align-items:center;border:1px dashed;border-color:var(--ag-border-color);display:flex;inset:0;justify-content:center;margin:calc(var(--ag-spacing)*1.5) calc(var(--ag-spacing)*2);overflow:hidden;padding:calc(var(--ag-spacing)*2);position:absolute}"
), tS = () => Lt({
  feature: "columnDropStyle",
  css: eS
}), kh = /* @__PURE__ */ tS(), sS = [
  "colorScheme",
  "color",
  "length",
  "scale",
  "borderStyle",
  "border",
  "shadow",
  "image",
  "fontFamily",
  "fontWeight",
  "duration"
], iS = Ky((e) => (e = e.toLowerCase(), sS.find((t) => e.endsWith(t.toLowerCase())) ?? "length")), Kn = (e) => typeof e == "object" && (e != null && e.ref) ? kt(e.ref) : typeof e == "string" ? e : typeof e == "number" ? String(e) : !1, rl = (e) => {
  if (typeof e == "string")
    return e;
  if (e && "ref" in e) {
    const t = kt(e.ref);
    return e.mix == null ? t : `color-mix(in srgb, ${e.onto ? kt(e.onto) : "transparent"}, ${t} ${$y(e.mix * 100, 0, 100)}%)`;
  }
  return !1;
}, oS = Kn, oi = (e) => typeof e == "string" ? e : typeof e == "number" ? `${e}px` : e && "calc" in e ? `calc(${e.calc.replace(/ ?[*/+] ?/g, " $& ").replace(/-?\b[a-z][a-z0-9]*\b(?![-(])/gi, (s) => s[0] === "-" ? s : ` ${kt(s)} `)})` : e && "ref" in e ? kt(e.ref) : !1, nS = Kn, rS = (e, t) => typeof e == "string" ? e : e === !0 ? "solid 1px var(--ag-border-color)" : e === !1 ? t === "columnBorder" ? "solid 1px transparent" : "none" : e && "ref" in e ? kt(e.ref) : Gh(e.style ?? "solid") + " " + oi(e.width ?? 1) + " " + rl(e.color ?? { ref: "borderColor" }), aS = (e) => typeof e == "string" ? e : e === !1 ? "none" : e && "ref" in e ? kt(e.ref) : [
  oi(e.offsetX ?? 0),
  oi(e.offsetY ?? 0),
  oi(e.radius ?? 0),
  oi(e.spread ?? 0),
  rl(e.color ?? { ref: "foregroundColor" })
].join(" "), Gh = Kn, Oh = (e) => typeof e == "string" ? e.includes(",") ? e : cd(e) : e && "googleFont" in e ? Oh(e.googleFont) : e && "ref" in e ? kt(e.ref) : Array.isArray(e) ? e.map((t) => (typeof t == "object" && "googleFont" in t && (t = t.googleFont), cd(t))).join(", ") : !1, cd = (e) => (
  // don't quote var() expressions or quote safe identifier names, so that
  // people can specify fonts like sans-serif which are keywords not strings,
  // or var(--my-var)
  /^[\w-]+$|\w\(/.test(e) ? e : JSON.stringify(e)
), lS = Kn, Bh = (e) => typeof e == "string" ? e : e && "url" in e ? `url(${JSON.stringify(e.url)})` : e && "svg" in e ? Bh({ url: `data:image/svg+xml,${encodeURIComponent(e.svg)}` }) : e && "ref" in e ? kt(e.ref) : !1, dS = (e, t) => typeof e == "string" ? e : typeof e == "number" ? (e >= 10 && K(104, { value: e, param: t }), `${e}s`) : e && "ref" in e ? kt(e.ref) : !1, cS = {
  color: rl,
  colorScheme: oS,
  length: oi,
  scale: nS,
  border: rS,
  borderStyle: Gh,
  shadow: aS,
  image: Bh,
  fontFamily: Oh,
  fontWeight: lS,
  duration: dS
}, uS = (e, t) => {
  const s = iS(e);
  return cS[s](t, e);
}, hS = () => new Nh().withPart(Jy).withPart(kh), Nh = class Hh {
  constructor(t = []) {
    this.parts = t;
  }
  withPart(t) {
    return typeof t == "function" && (t = t()), t instanceof Th ? new Hh([...this.parts, t]) : (zi(259, { part: t }, "Invalid part"), this);
  }
  withoutPart(t) {
    return this.withPart(Lt({ feature: t }));
  }
  withParams(t, s = Jt) {
    return this.withPart(
      Lt({
        modeParams: { [s]: t }
      })
    );
  }
  /**
   * Called by a grid instance when it starts using the theme. This installs
   * the theme's parts into document head, or the shadow DOM if the provided
   * container is within a shadow root.
   */
  _startUse({ styleContainer: t, cssLayer: s, nonce: i, loadThemeGoogleFonts: o }) {
    if (nl)
      return;
    pS(), Ih(t, s, i);
    const n = gS(this);
    if (n.length > 0)
      for (const r of n)
        o && mS(r, i);
    for (const r of this.parts)
      r.use(t, s, i);
  }
  /**
   * Return CSS that that applies the params of this theme to elements with
   * the provided class name
   */
  _getCssClass() {
    return this._cssClassCache ?? (this._cssClassCache = ud(this.parts).map((t) => t.use(void 0, void 0, void 0)).filter(Boolean).join(" "));
  }
  _getModeParams() {
    let t = this._paramsCache;
    if (!t) {
      const s = {
        // NOTE: defining the default mode here is important, it ensures
        // that the default mode is first in iteration order, which puts
        // it first in outputted CSS, allowing other modes to override it
        [Jt]: { ...Yy }
      };
      for (const i of ud(this.parts))
        for (const o of Object.keys(i.modeParams)) {
          const n = i.modeParams[o];
          if (n) {
            const r = s[o] ?? (s[o] = {}), a = /* @__PURE__ */ new Set();
            for (const l of Object.keys(n)) {
              const d = n[l];
              d !== void 0 && (r[l] = d, a.add(l));
            }
            if (o === Jt)
              for (const l of Object.keys(s)) {
                const d = s[l];
                if (l !== Jt)
                  for (const c of a)
                    delete d[c];
              }
          }
        }
      this._paramsCache = t = s;
    }
    return t;
  }
  /**
   * Return the CSS chunk that is inserted into the grid DOM, and will
   * therefore be removed automatically when the grid is destroyed or it
   * starts to use a new theme.
   *
   * @param className a unique class name on the grid wrapper used to scope the returned CSS to the grid instance
   */
  _getPerGridCss(t) {
    const s = "##SELECTOR##";
    let i = this._paramsCssCache;
    if (!i) {
      let o = "", n = "";
      const r = this._getModeParams();
      for (const l of Object.keys(r)) {
        const d = r[l];
        if (l !== Jt) {
          const u = `:where([data-ag-theme-mode="${typeof CSS == "object" ? CSS.escape(l) : l}"]) & {
`;
          o += u, n += u;
        }
        for (const c of Object.keys(d).sort()) {
          const u = d[c], h = uS(c, u);
          if (h === !1)
            K(107, { key: c, value: u });
          else {
            const g = Lh(c), p = g.replace("--ag-", "--ag-inherited-");
            o += `	${g}: var(${p}, ${h});
`, n += `	${p}: var(${g});
`;
          }
        }
        l !== Jt && (o += `}
`, n += `}
`);
      }
      let a = `${s} {
${o}}
`;
      a += `:has(> ${s}):not(${s}) {
${n}}
`, this._paramsCssCache = i = a;
    }
    return i.replaceAll(s, `:where(.${t})`);
  }
}, ud = (e) => {
  const t = /* @__PURE__ */ new Map();
  for (const i of e)
    t.set(i.feature, i);
  const s = [];
  for (const i of e)
    (!i.feature || t.get(i.feature) === i) && s.push(i);
  return s;
}, gS = (e) => {
  const t = /* @__PURE__ */ new Set(), s = (n) => {
    if (Array.isArray(n))
      n.forEach(s);
    else {
      const r = n == null ? void 0 : n.googleFont;
      typeof r == "string" && t.add(r);
    }
  };
  return Object.values(e._getModeParams()).flatMap((n) => Object.values(n)).forEach(s), Array.from(t).sort();
}, hd = !1, pS = () => {
  if (!hd) {
    hd = !0;
    for (const e of Array.from(document.head.querySelectorAll('style[data-ag-scope="legacy"]')))
      e.remove();
  }
}, fS = /* @__PURE__ */ new Set(), mS = async (e, t) => {
  fS.add(e);
  const s = `@import url('https://${CS}/css2?family=${encodeURIComponent(e)}:wght@100;200;300;400;500;600;700;800;900&display=swap');
`;
  Pi(s, document.head, `googleFont:${e}`, void 0, 0, t);
}, CS = "fonts.googleapis.com", vS = (
  /*css*/
  '.ag-checkbox-input-wrapper,.ag-radio-button-input-wrapper{background-color:var(--ag-checkbox-unchecked-background-color);border:solid var(--ag-checkbox-border-width) var(--ag-checkbox-unchecked-border-color);flex:none;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);:where(input){-webkit-appearance:none;-moz-appearance:none;appearance:none;cursor:pointer;display:block;height:var(--ag-icon-size);margin:0;opacity:0;width:var(--ag-icon-size)}&:after{content:"";display:block;inset:0;-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;pointer-events:none;position:absolute}&:where(.ag-checked){background-color:var(--ag-checkbox-checked-background-color);border-color:var(--ag-checkbox-checked-border-color);&:after{background-color:var(--ag-checkbox-checked-shape-color)}}&:where(:focus-within,:active){box-shadow:var(--ag-focus-shadow)}&:where(.ag-disabled){filter:grayscale();opacity:.5}}.ag-checkbox-input-wrapper{border-radius:var(--ag-checkbox-border-radius);&:where(.ag-checked):after{-webkit-mask-image:var(--ag-checkbox-checked-shape-image);mask-image:var(--ag-checkbox-checked-shape-image)}&:where(.ag-indeterminate){background-color:var(--ag-checkbox-indeterminate-background-color);border-color:var(--ag-checkbox-indeterminate-border-color);&:after{background-color:var(--ag-checkbox-indeterminate-shape-color);-webkit-mask-image:var(--ag-checkbox-indeterminate-shape-image);mask-image:var(--ag-checkbox-indeterminate-shape-image)}}}.ag-radio-button-input-wrapper{border-radius:100%;&:where(.ag-checked):after{-webkit-mask-image:var(--ag-radio-checked-shape-image);mask-image:var(--ag-radio-checked-shape-image)}}'
), wS = () => Lt({
  feature: "checkboxStyle",
  params: {
    checkboxBorderWidth: 1,
    checkboxBorderRadius: {
      ref: "borderRadius"
    },
    checkboxUncheckedBackgroundColor: Ue,
    checkboxUncheckedBorderColor: ut(0.3),
    checkboxCheckedBackgroundColor: is,
    checkboxCheckedBorderColor: { ref: "checkboxCheckedBackgroundColor" },
    checkboxCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="7" fill="none"><path stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.75" d="M1 3.5 3.5 6l5-5"/></svg>'
    },
    checkboxCheckedShapeColor: Ue,
    checkboxIndeterminateBackgroundColor: ut(0.3),
    checkboxIndeterminateBorderColor: { ref: "checkboxIndeterminateBackgroundColor" },
    checkboxIndeterminateShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="10" height="2" fill="none"><rect width="10" height="2" fill="#000" rx="1"/></svg>'
    },
    checkboxIndeterminateShapeColor: Ue,
    radioCheckedShapeImage: {
      svg: '<svg xmlns="http://www.w3.org/2000/svg" width="6" height="6" fill="none"><circle cx="3" cy="3" r="3" fill="#000"/></svg>'
    }
  },
  css: vS
}), bS = /* @__PURE__ */ wS(), Vh = () => ({
  ...Mn,
  backgroundColor: "hsl(217, 0%, 17%)",
  foregroundColor: "#FFF",
  chromeBackgroundColor: ut(0.05),
  rowHoverColor: Rt(0.15),
  selectedRowBackgroundColor: Rt(0.2),
  menuBackgroundColor: ut(0.1),
  browserColorScheme: "dark",
  popupShadow: "0 0px 20px #000A",
  cardShadow: "0 1px 4px 1px #000A",
  advancedFilterBuilderJoinPillColor: "#7a3a37",
  advancedFilterBuilderColumnPillColor: "#355f2d",
  advancedFilterBuilderOptionPillColor: "#5a3168",
  advancedFilterBuilderValuePillColor: "#374c86",
  findMatchColor: Ue,
  findActiveMatchColor: Ue,
  checkboxUncheckedBorderColor: ut(0.4),
  toggleButtonOffBackgroundColor: ut(0.4)
}), _h = () => ({
  ...Vh(),
  backgroundColor: "#1f2836"
}), yS = () => Lt({
  feature: "colorScheme",
  params: _h()
}), SS = /* @__PURE__ */ yS(), xS = () => Lt({
  feature: "colorScheme",
  params: Mn,
  modeParams: {
    light: Mn,
    dark: Vh(),
    "dark-blue": _h()
  }
}), RS = /* @__PURE__ */ xS(), Wh = {
  aggregation: '<path d="M18 7V4H6l6 8-6 8h12v-3"/>',
  arrows: '<polyline points="5 9 2 12 5 15"/><polyline points="9 5 12 2 15 5"/><polyline points="15 19 12 22 9 19"/><polyline points="19 9 22 12 19 15"/><line x1="2" x2="22" y1="12" y2="12"/><line x1="12" x2="12" y1="2" y2="22"/>',
  asc: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  cancel: '<path d="m18 6-12 12"/><path d="m6 6 12 12"/>',
  chart: '<line x1="18" x2="18" y1="20" y2="10"/><line x1="12" x2="12" y1="20" y2="4"/><line x1="6" x2="6" y1="20" y2="14"/>',
  "color-picker": '<path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/>',
  columns: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"/>',
  contracted: '<path d="m9 18 6-6-6-6"/>',
  copy: '<rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/>',
  cross: '<path d="M18 6 6 18"/><path d="m6 6 12 12"/>',
  csv: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  cut: '<circle cx="6" cy="6" r="3"/><path d="M8.12 8.12 12 12"/><path d="M20 4 8.12 15.88"/><circle cx="6" cy="18" r="3"/><path d="M14.8 14.8 20 20"/>',
  desc: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  down: '<path d="M12 5v14"/><path d="m19 12-7 7-7-7"/>',
  excel: '<path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14 2 14 8 20 8"/><path d="M8 13h2"/><path d="M8 17h2"/><path d="M14 13h2"/><path d="M14 17h2"/>',
  expanded: '<path d="m15 18-6-6 6-6"/>',
  "eye-slash": '<path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"/><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"/><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"/><line x1="2" x2="22" y1="2" y2="22"/>',
  eye: '<path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/><circle cx="12" cy="12" r="3"/>',
  filter: '<path d="M3 6h18"/><path d="M7 12h10"/><path d="M10 18h4"/>',
  first: '<path d="m17 18-6-6 6-6"/><path d="M7 6v12"/>',
  group: '<path d="M16 12H3"/><path d="M16 18H3"/><path d="M10 6H3"/><path d="M21 18V8a2 2 0 0 0-2-2h-5"/><path d="m16 8-2-2 2-2"/>',
  last: '<path d="m7 18 6-6-6-6"/><path d="M17 6v12"/>',
  left: '<path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>',
  linked: '<path d="M9 17H7A5 5 0 0 1 7 7h2"/><path d="M15 7h2a5 5 0 1 1 0 10h-2"/><line x1="8" x2="16" y1="12" y2="12"/>',
  loading: '<line x1="12" x2="12" y1="2" y2="6"/><line x1="12" x2="12" y1="18" y2="22"/><line x1="4.93" x2="7.76" y1="4.93" y2="7.76"/><line x1="16.24" x2="19.07" y1="16.24" y2="19.07"/><line x1="2" x2="6" y1="12" y2="12"/><line x1="18" x2="22" y1="12" y2="12"/><line x1="4.93" x2="7.76" y1="19.07" y2="16.24"/><line x1="16.24" x2="19.07" y1="7.76" y2="4.93"/>',
  maximize: '<polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" x2="14" y1="3" y2="10"/><line x1="3" x2="10" y1="21" y2="14"/>',
  menu: '<line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/>',
  "menu-alt": '<circle cx="12" cy="5" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="12" r="0.75" fill="#D9D9D9"/><circle cx="12" cy="19" r="0.75" fill="#D9D9D9"/>',
  minimize: '<polyline points="4 14 10 14 10 20"/><polyline points="20 10 14 10 14 4"/><line x1="14" x2="21" y1="10" y2="3"/><line x1="3" x2="10" y1="21" y2="14"/>',
  minus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/>',
  next: '<path d="m9 18 6-6-6-6"/>',
  none: '<path d="m7 15 5 5 5-5"/><path d="m7 9 5-5 5 5"/>',
  "not-allowed": '<circle cx="12" cy="12" r="10"/><path d="m4.9 4.9 14.2 14.2"/>',
  paste: '<path d="M15 2H9a1 1 0 0 0-1 1v2c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V3c0-.6-.4-1-1-1Z"/><path d="M8 4H6a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2M16 4h2a2 2 0 0 1 2 2v2M11 14h10"/><path d="m17 10 4 4-4 4"/>',
  pin: '<line x1="12" x2="12" y1="17" y2="22"/><path d="M5 17h14v-1.76a2 2 0 0 0-1.11-1.79l-1.78-.9A2 2 0 0 1 15 10.76V6h1a2 2 0 0 0 0-4H8a2 2 0 0 0 0 4h1v4.76a2 2 0 0 1-1.11 1.79l-1.78.9A2 2 0 0 0 5 15.24Z"/>',
  pivot: '<path d="M15 3v18"/><rect width="18" height="18" x="3" y="3" rx="2"/><path d="M21 9H3"/><path d="M21 15H3"/>',
  plus: '<circle cx="12" cy="12" r="10"/><path d="M8 12h8"/><path d="M12 8v8"/>',
  previous: '<path d="m15 18-6-6 6-6"/>',
  right: '<path d="M5 12h14"/><path d="m12 5 7 7-7 7"/>',
  save: '<path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/>',
  "small-left": '<path d="m15 18-6-6 6-6"/>',
  "small-right": '<path d="m9 18 6-6-6-6"/>',
  tick: '<path d="M20 6 9 17l-5-5"/>',
  "tree-closed": '<path d="m9 18 6-6-6-6"/>',
  "tree-indeterminate": '<path d="M5 12h14"/>',
  "tree-open": '<path d="m6 9 6 6 6-6"/>',
  unlinked: '<path d="M9 17H7A5 5 0 0 1 7 7"/><path d="M15 7h2a5 5 0 0 1 4 8"/><line x1="8" x2="12" y1="12" y2="12"/><line x1="2" x2="22" y1="2" y2="22"/>',
  up: '<path d="m5 12 7-7 7 7"/><path d="M12 19V5"/>',
  grip: '<circle cx="5" cy="8" r="0.5"/><circle cx="12" cy="8" r="0.5"/><circle cx="19" cy="8" r="0.5"/><circle cx="5" cy="16" r="0.5"/><circle cx="12" cy="16" r="0.5"/><circle cx="19" cy="16" r="0.5"/><g stroke="none" fill="currentColor"><circle cx="5" cy="8" r="1"/><circle cx="12" cy="8" r="1"/><circle cx="19" cy="8" r="1"/><circle cx="5" cy="16" r="1"/><circle cx="12" cy="16" r="1"/><circle cx="19" cy="16" r="1"/></g>',
  settings: '<path d="M20 7h-9"/><path d="M14 17H5"/><circle cx="17" cy="17" r="3"/><circle cx="7" cy="7" r="3"/>'
}, zh = {
  "column-arrow": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 32 32"><path fill-rule="evenodd" clip-rule="evenodd" d="M0 26C0 28.2092 1.79086 30 4 30H14C16.2091 30 18 28.2092 18 26V15H25.8786L24.4394 16.4393C23.8536 17.0251 23.8536 17.9749 24.4394 18.5607C25.0252 19.1464 25.9748 19.1464 26.5606 18.5607L30.5606 14.5607C31.1464 13.9749 31.1464 13.0251 30.5606 12.4393L26.5606 8.43934C25.9748 7.85356 25.0252 7.85356 24.4394 8.43934C23.8536 9.02512 23.8536 9.97488 24.4394 10.5607L25.8786 12H18V6C18 3.79086 16.2091 2 14 2H4C1.79086 2 0 3.79086 0 6V26ZM14 5H10.5V12H15V6C15 5.44772 14.5523 5 14 5ZM4 5H7.5V12H3V6C3 5.44772 3.44772 5 4 5ZM10.5 15H15V26C15 26.5522 14.5523 27 14 27H10.5V15ZM4 27H7.5V15H3V26C3 26.5522 3.44772 27 4 27Z" fill="currentColor"/></svg>',
  "small-down": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 10.667 16 21.334l8.667-10.667H7.334Z"/></svg>',
  "small-up": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="black" stroke="none" viewBox="0 0 32 32"><path d="M7.334 21.333 16 10.666l8.667 10.667H7.334Z"/></svg>',
  "pinned-top": '<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" viewBox="0 0 16 16"><path fill="currentColor" d="M12.53 3.72A.75.75 0 0 1 12 5H4a.75.75 0 0 1 0-1.5h8a.75.75 0 0 1 .53.22ZM3.269 10.744a.75.75 0 0 1 .2-.524l4-4a.75.75 0 0 1 1.06 0l4 4a.75.75 0 1 1-1.06 1.06L8.75 8.56V14a.75.75 0 0 1-1.5 0V8.56l-2.72 2.72a.75.75 0 0 1-1.26-.536Z"/></svg>',
  "pinned-bottom": '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M3.47 12.28A.75.75 0 0 1 4 11h8a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.53-.22ZM12.731 5.256a.75.75 0 0 1-.2.524l-4 4a.75.75 0 0 1-1.06 0l-4-4a.75.75 0 1 1 1.06-1.06l2.72 2.72V2a.75.75 0 0 1 1.5 0v5.44l2.72-2.72a.75.75 0 0 1 1.26.536Z"/></svg>',
  "un-pin": '<svg xmlns="http://www.w3.org/2000/svg" fill="none" class="ag-icon" viewBox="0 0 16 16"><path fill="currentColor" d="M8 11a.75.75 0 0 0-.75.75v3.333a.75.75 0 1 0 1.5 0V11.75A.75.75 0 0 0 8 11Z"/><path fill="currentColor" d="M13.11 1.436a.75.75 0 0 0-1.22-.872l-10 14a.75.75 0 1 0 1.22.872L5.207 12.5h7.376a.75.75 0 0 0 .75-.75v-1.174a2.08 2.08 0 0 0-1.153-1.863l-1.185-.599-.005-.002a.58.58 0 0 1-.323-.522V5.165a2.083 2.083 0 0 0 1.854-2.904l.589-.825Zm-3.943 5.52v.634a2.08 2.08 0 0 0 1.153 1.863l1.185.6.005.002a.58.58 0 0 1 .323.522V11H6.28l2.887-4.044ZM9.277 1H5.25a2.084 2.084 0 0 0-.083 4.165v1.676l1.5-2.132v-.292a.75.75 0 0 0-.75-.75H5.25a.584.584 0 0 1 0-1.167h2.972L9.277 1Z"/></svg>'
}, FS = (e = {}) => {
  let t = "";
  for (const s of [...Object.keys(Wh), ...Object.keys(zh)]) {
    const i = PS(s, e.strokeWidth);
    t += `.ag-icon-${s}::before { mask-image: url('data:image/svg+xml,${encodeURIComponent(i)}'); }
`;
  }
  return t;
}, PS = (e, t = 1.5) => {
  const s = zh[e];
  if (s)
    return s;
  const i = Wh[e];
  if (!i)
    throw new Error(`Missing icon data for ${e}`);
  return `<svg xmlns="http://www.w3.org/2000/svg" class="ag-icon" fill="none" stroke-linecap="round" stroke-linejoin="round" stroke="black" stroke-width="${t}" viewBox="0 0 24 24"><style>* { vector-effect: non-scaling-stroke; }</style>` + i + "</svg>";
}, DS = (e = {}) => Lt({
  feature: "iconSet",
  css: () => FS(e)
}), MS = /* @__PURE__ */ DS(), ES = (
  /*css*/
  ':where(.ag-input-field-input[type=number]:not(.ag-number-field-input-stepper)){-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;&::-webkit-inner-spin-button,&::-webkit-outer-spin-button{-webkit-appearance:none;appearance:none;margin:0}}.ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){background-color:var(--ag-input-background-color);border:var(--ag-input-border);border-radius:var(--ag-input-border-radius);color:var(--ag-input-text-color);font-family:inherit;font-size:inherit;line-height:inherit;margin:0;min-height:var(--ag-input-height);padding:0;&:where(:disabled){background-color:var(--ag-input-disabled-background-color);border:var(--ag-input-disabled-border);color:var(--ag-input-disabled-text-color)}&:where(:focus){background-color:var(--ag-input-focus-background-color);border:var(--ag-input-focus-border);box-shadow:var(--ag-input-focus-shadow);color:var(--ag-input-focus-text-color);outline:none}&:where(:invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&:where(.invalid){background-color:var(--ag-input-invalid-background-color);border:var(--ag-input-invalid-border);color:var(--ag-input-invalid-text-color)}&::-moz-placeholder{color:var(--ag-input-placeholder-text-color)}&::placeholder{color:var(--ag-input-placeholder-text-color)}}:where(.ag-ltr) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-left:var(--ag-input-padding-start)}:where(.ag-rtl) .ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){padding-right:var(--ag-input-padding-start)}:where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{background-color:currentcolor;color:var(--ag-input-icon-color);content:"";display:block;height:12px;-webkit-mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");mask-image:url("data:image/svg+xml;charset=utf-8;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMiIgaGVpZ2h0PSIxMiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS41Ij48cGF0aCBkPSJNNS4zIDlhMy43IDMuNyAwIDEgMCAwLTcuNSAzLjcgMy43IDAgMCAwIDAgNy41Wk0xMC41IDEwLjUgOC4zIDguMiIvPjwvc3ZnPg==");-webkit-mask-position:center;mask-position:center;-webkit-mask-repeat:no-repeat;mask-repeat:no-repeat;opacity:.5;position:absolute;width:12px}}:where(.ag-ltr) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{margin-left:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-left:calc(var(--ag-spacing)*1.5 + 12px)}}:where(.ag-rtl) :where(.ag-column-select-header-filter-wrapper,.ag-filter-toolpanel-search,.ag-mini-filter,.ag-filter-filter){.ag-input-wrapper:before{margin-right:var(--ag-spacing)}.ag-number-field-input,.ag-text-field-input{padding-right:calc(var(--ag-spacing)*1.5 + 12px)}}'
), AS = (
  /*css*/
  ".ag-input-field-input:where(input:not([type]),input[type=text],input[type=number],input[type=tel],input[type=date],input[type=datetime-local],textarea){&:focus{box-shadow:var(--ag-focus-shadow)}}"
), IS = {
  inputBackgroundColor: "transparent",
  inputBorder: !1,
  inputBorderRadius: 0,
  inputTextColor: {
    ref: "textColor"
  },
  inputPlaceholderTextColor: {
    ref: "inputTextColor",
    mix: 0.5
  },
  inputPaddingStart: 0,
  inputHeight: {
    calc: "max(iconSize, fontSize) + spacing * 2"
  },
  inputFocusBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputFocusBorder: {
    ref: "inputBorder"
  },
  inputFocusShadow: "none",
  inputFocusTextColor: {
    ref: "inputTextColor"
  },
  inputDisabledBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputDisabledBorder: {
    ref: "inputBorder"
  },
  inputDisabledTextColor: {
    ref: "inputTextColor"
  },
  inputInvalidBackgroundColor: {
    ref: "inputBackgroundColor"
  },
  inputInvalidBorder: {
    ref: "inputBorder"
  },
  inputInvalidTextColor: {
    ref: "inputTextColor"
  },
  inputIconColor: {
    ref: "inputTextColor"
  },
  pickerButtonBorder: !1,
  pickerButtonFocusBorder: { ref: "inputFocusBorder" },
  pickerButtonBackgroundColor: { ref: "backgroundColor" },
  pickerButtonFocusBackgroundColor: { ref: "backgroundColor" },
  pickerListBorder: !1,
  pickerListBackgroundColor: { ref: "backgroundColor" }
}, TS = () => Lt({
  feature: "inputStyle",
  params: {
    ...IS,
    inputBackgroundColor: Ue,
    inputBorder: !0,
    inputBorderRadius: {
      ref: "borderRadius"
    },
    inputPaddingStart: {
      ref: "spacing"
    },
    inputFocusBorder: {
      color: is
    },
    inputFocusShadow: {
      ref: "focusShadow"
    },
    inputDisabledBackgroundColor: ut(0.06),
    inputDisabledTextColor: {
      ref: "textColor",
      mix: 0.5
    },
    inputInvalidBorder: {
      color: { ref: "invalidColor" }
    },
    pickerButtonBorder: !0,
    pickerListBorder: !0
  },
  css: () => ES + AS
}), LS = /* @__PURE__ */ TS(), kS = (
  /*css*/
  '.ag-tabs-header{background-color:var(--ag-tab-bar-background-color);border-bottom:var(--ag-tab-bar-border);display:flex;flex:1;gap:var(--ag-tab-spacing);padding:var(--ag-tab-bar-top-padding) var(--ag-tab-bar-horizontal-padding) 0}.ag-tabs-header-wrapper{display:flex}.ag-tabs-close-button-wrapper{align-items:center;border:0;display:flex;padding:var(--ag-spacing)}:where(.ag-ltr) .ag-tabs-close-button-wrapper{border-right:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-tabs-close-button-wrapper{border-left:1px solid var(--ag-border-color)}.ag-tabs-close-button{background-color:unset;border:0;cursor:pointer;padding:0}.ag-tab{align-items:center;background-color:var(--ag-tab-background-color);border-left:var(--ag-tab-selected-border-width) solid transparent;border-right:var(--ag-tab-selected-border-width) solid transparent;color:var(--ag-tab-text-color);cursor:pointer;display:flex;flex:1;justify-content:center;padding:var(--ag-tab-top-padding) var(--ag-tab-horizontal-padding) var(--ag-tab-bottom-padding);position:relative;&:hover{background-color:var(--ag-tab-hover-background-color);color:var(--ag-tab-hover-text-color)}&.ag-tab-selected{background-color:var(--ag-tab-selected-background-color);color:var(--ag-tab-selected-text-color)}&:after{background-color:var(--ag-tab-selected-underline-color);bottom:0;content:"";display:block;height:var(--ag-tab-selected-underline-width);left:0;opacity:0;position:absolute;right:0;transition:opacity var(--ag-tab-selected-underline-transition-duration)}&.ag-tab-selected:after{opacity:1}}:where(.ag-ltr) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-left-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-right-color:var(--ag-tab-selected-border-color)}}}:where(.ag-rtl) .ag-tab{&.ag-tab-selected{&:where(:not(:first-of-type)){border-right-color:var(--ag-tab-selected-border-color)}&:where(:not(:last-of-type)){border-left-color:var(--ag-tab-selected-border-color)}}}'
), GS = {
  tabBarBackgroundColor: "transparent",
  tabBarHorizontalPadding: 0,
  tabBarTopPadding: 0,
  tabBackgroundColor: "transparent",
  tabTextColor: {
    ref: "textColor"
  },
  tabHorizontalPadding: {
    ref: "spacing"
  },
  tabTopPadding: {
    ref: "spacing"
  },
  tabBottomPadding: {
    ref: "spacing"
  },
  tabSpacing: "0",
  tabHoverBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabHoverTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBackgroundColor: {
    ref: "tabBackgroundColor"
  },
  tabSelectedTextColor: {
    ref: "tabTextColor"
  },
  tabSelectedBorderWidth: 1,
  tabSelectedBorderColor: "transparent",
  tabSelectedUnderlineColor: "transparent",
  tabSelectedUnderlineWidth: 0,
  tabSelectedUnderlineTransitionDuration: 0,
  tabBarBorder: !1
}, OS = () => Lt({
  feature: "tabStyle",
  params: {
    ...GS,
    tabBarBorder: !0,
    tabBarBackgroundColor: Qe(0.05),
    tabTextColor: {
      ref: "textColor",
      mix: 0.7
    },
    tabSelectedTextColor: {
      ref: "textColor"
    },
    tabHoverTextColor: {
      ref: "textColor"
    },
    tabSelectedBorderColor: {
      ref: "borderColor"
    },
    tabSelectedBackgroundColor: Ue
  },
  css: kS
}), BS = /* @__PURE__ */ OS(), NS = () => hS().withPart(bS).withPart(RS).withPart(MS).withPart(BS).withPart(LS).withPart(kh).withParams({
  fontFamily: [
    { googleFont: "IBM Plex Sans" },
    "-apple-system",
    "BlinkMacSystemFont",
    "Segoe UI",
    "Roboto",
    "Oxygen-Sans",
    "Ubuntu"
  ]
}), Uh = /* @__PURE__ */ NS(), HS = {
  cssName: "--ag-cell-horizontal-padding",
  changeKey: "cellHorizontalPaddingChanged",
  defaultValue: 16
}, VS = {
  cssName: "--ag-indentation-level",
  changeKey: "indentationLevelChanged",
  defaultValue: 0,
  noWarn: !0,
  cacheDefault: !0
}, _S = {
  cssName: "--ag-row-group-indent-size",
  changeKey: "rowGroupIndentSizeChanged",
  defaultValue: 0
}, gd = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
}, pd = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
}, fd = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
}, yr = {
  cssName: "--ag-row-border",
  changeKey: "rowBorderWidthChanged",
  defaultValue: 1,
  border: !0
}, md = {
  cssName: "--ag-pinned-row-border",
  changeKey: "pinnedRowBorderWidthChanged",
  defaultValue: 1,
  border: !0
}, WS = 0, zS = class extends S {
  constructor() {
    super(...arguments), this.beanName = "environment", this.sizeEls = /* @__PURE__ */ new Map(), this.lastKnownValues = /* @__PURE__ */ new Map(), this.sizesMeasured = !1, this.paramsClass = `ag-theme-params-${++WS}`, this.globalCSS = [];
  }
  wireBeans(e) {
    const { eGridDiv: t, gridOptions: s } = e;
    this.eGridDiv = t, this.eStyleContainer = s.themeStyleContainer ?? (t.getRootNode() === document ? document.head : t), this.cssLayer = s.themeCssLayer, this.styleNonce = s.styleNonce;
  }
  postConstruct() {
    this.addManagedPropertyListener("theme", () => this.handleThemeGridOptionChange()), this.handleThemeGridOptionChange(), this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.getSizeEl(gd), this.getSizeEl(pd), this.getSizeEl(fd), this.getSizeEl(yr), this.getSizeEl(md), this.refreshRowBorderWidthVariable(), this.addDestroyFunc(() => zy(this)), this.mutationObserver = new MutationObserver(() => {
      this.fireGridStylesChangedEvent("themeChanged");
    }), this.addDestroyFunc(() => this.mutationObserver.disconnect());
  }
  getPinnedRowBorderWidth() {
    return this.getCSSVariablePixelValue(md);
  }
  getRowBorderWidth() {
    return this.getCSSVariablePixelValue(yr);
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(gd);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(pd);
  }
  getDefaultCellHorizontalPadding() {
    return this.getCSSVariablePixelValue(HS);
  }
  getCellPaddingLeft() {
    const e = this.getDefaultCellHorizontalPadding(), t = this.getCSSVariablePixelValue(VS), s = this.getCSSVariablePixelValue(_S);
    return e - 1 + s * t;
  }
  getCellPadding() {
    const e = this.getDefaultCellHorizontalPadding() - 1;
    return this.getCellPaddingLeft() + e;
  }
  getDefaultColumnMinWidth() {
    return Math.min(36, this.getDefaultRowHeight());
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(fd);
  }
  applyThemeClasses(e) {
    const { gridTheme: t } = this;
    let s = "";
    if (t)
      s = `${this.paramsClass} ${t._getCssClass()}`;
    else {
      this.mutationObserver.disconnect();
      let i = this.eGridDiv;
      for (; i; ) {
        let o = !1;
        for (const n of Array.from(i.classList))
          n.startsWith("ag-theme-") && (o = !0, s = s ? `${s} ${n}` : n);
        o && this.mutationObserver.observe(i, {
          attributes: !0,
          attributeFilter: ["class"]
        }), i = i.parentElement;
      }
    }
    for (const i of Array.from(e.classList))
      i.startsWith("ag-theme-") && e.classList.remove(i);
    if (s) {
      const i = e.className;
      e.className = i + (i ? " " : "") + s;
    }
  }
  refreshRowHeightVariable() {
    const { eGridDiv: e } = this, t = e.style.getPropertyValue("--ag-line-height").trim(), s = this.gos.get("rowHeight");
    if (s == null || isNaN(s) || !isFinite(s))
      return t !== null && e.style.setProperty("--ag-line-height", null), -1;
    const i = `${s}px`;
    return t != i ? (e.style.setProperty("--ag-line-height", i), s) : t != "" ? parseFloat(t) : -1;
  }
  addGlobalCSS(e, t) {
    this.gridTheme ? Pi(e, this.eStyleContainer, t, this.cssLayer, 0, this.styleNonce) : this.globalCSS.push([e, t]);
  }
  getCSSVariablePixelValue(e) {
    const t = this.lastKnownValues.get(e);
    if (t != null)
      return t;
    const s = this.measureSizeEl(e);
    return s === "detached" || s === "no-styles" ? (e.cacheDefault && this.lastKnownValues.set(e, e.defaultValue), e.defaultValue) : (this.lastKnownValues.set(e, s), s);
  }
  measureSizeEl(e) {
    const t = this.getSizeEl(e);
    if (t.offsetParent == null)
      return "detached";
    const s = t.offsetWidth;
    return s === Sr ? "no-styles" : (this.sizesMeasured = !0, s);
  }
  getMeasurementContainer() {
    let e = this.eMeasurementContainer;
    return e || (e = this.eMeasurementContainer = _({ tag: "div", cls: "ag-measurement-container" }), this.eGridDiv.appendChild(e)), e;
  }
  getSizeEl(e) {
    let t = this.sizeEls.get(e);
    if (t)
      return t;
    const s = this.getMeasurementContainer();
    t = _({ tag: "div" });
    const { border: i, noWarn: o } = e;
    i ? (t.className = "ag-measurement-element-border", t.style.setProperty(
      "--ag-internal-measurement-border",
      `var(${e.cssName}, solid ${Sr}px)`
    )) : t.style.width = `var(${e.cssName}, ${Sr}px)`, s.appendChild(t), this.sizeEls.set(e, t);
    let n = this.measureSizeEl(e);
    n === "no-styles" && !o && P(9, { variable: e });
    const r = fs(this.beans, t, () => {
      const a = this.measureSizeEl(e);
      a === "detached" || a === "no-styles" || (this.lastKnownValues.set(e, a), a !== n && (n = a, this.fireGridStylesChangedEvent(e.changeKey)));
    });
    return this.addDestroyFunc(() => r()), t;
  }
  fireGridStylesChangedEvent(e) {
    e === "rowBorderWidthChanged" && this.refreshRowBorderWidthVariable(), this.eventSvc.dispatchEvent({
      type: "gridStylesChanged",
      [e]: !0
    });
  }
  refreshRowBorderWidthVariable() {
    const e = this.getCSSVariablePixelValue(yr);
    this.eGridDiv.style.setProperty("--ag-internal-row-border-width", `${e}px`);
  }
  handleThemeGridOptionChange() {
    const { gos: e, eGridDiv: t, globalCSS: s, gridTheme: i } = this, o = e.get("theme");
    let n;
    if (o === "legacy")
      n = void 0;
    else {
      const r = o ?? Uh;
      r instanceof Nh ? n = r : K(240, { theme: r });
    }
    if (n !== i) {
      if (n) {
        Wy(this), Ih(this.eStyleContainer, this.cssLayer, this.styleNonce);
        for (const [a, l] of s)
          Pi(a, this.eStyleContainer, l, this.cssLayer, 0, this.styleNonce);
        s.length = 0;
      }
      this.gridTheme = n, n == null || n._startUse({
        loadThemeGoogleFonts: e.get("loadThemeGoogleFonts"),
        styleContainer: this.eStyleContainer,
        cssLayer: this.cssLayer,
        nonce: this.styleNonce
      });
      let r = this.eParamsStyle;
      if (!r) {
        r = this.eParamsStyle = _({ tag: "style" });
        const a = this.gos.get("styleNonce");
        a && r.setAttribute("nonce", a), t.appendChild(r);
      }
      nl || (r.textContent = (n == null ? void 0 : n._getPerGridCss(this.paramsClass)) || ""), this.applyThemeClasses(t), this.fireGridStylesChangedEvent("themeChanged");
    }
    n && getComputedStyle(this.getMeasurementContainer()).getPropertyValue("--ag-legacy-styles-loaded") && K(o ? 106 : 239);
  }
}, Sr = 15538, US = class extends S {
  constructor() {
    super(...arguments), this.beanName = "eventSvc", this.globalSvc = new hs();
  }
  postConstruct() {
    const { globalListener: e, globalSyncListener: t } = this.beans;
    e && this.addGlobalListener(e, !0), t && this.addGlobalListener(t, !1);
  }
  addEventListener(e, t, s) {
    this.globalSvc.addEventListener(e, t, s);
  }
  removeEventListener(e, t, s) {
    this.globalSvc.removeEventListener(e, t, s);
  }
  addGlobalListener(e, t = !1) {
    this.globalSvc.addGlobalListener(e, t);
  }
  removeGlobalListener(e, t = !1) {
    this.globalSvc.removeGlobalListener(e, t);
  }
  /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */
  dispatchLocalEvent() {
  }
  dispatchEvent(e) {
    this.globalSvc.dispatchEvent(N(this.gos, e));
  }
  dispatchEventOnce(e) {
    this.globalSvc.dispatchEventOnce(N(this.gos, e));
  }
};
function jh(e) {
  return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1;
}
function ia(e, t) {
  let s;
  if (ue(e) && jh(e) && e.isPadding()) {
    const i = e;
    s = i.getLeafColumns()[0];
    let o = s;
    for (; o !== i; )
      t++, o = o.getParent();
  }
  return {
    column: s || e,
    headerRowIndex: t
  };
}
var jS = class extends S {
  constructor() {
    super(...arguments), this.beanName = "headerNavigation", this.currentHeaderRowWithoutSpan = -1;
  }
  postConstruct() {
    const e = this.beans;
    e.ctrlsSvc.whenReady(this, (s) => {
      this.gridBodyCon = s.gridBodyCtrl;
    });
    const t = pe(e);
    this.addManagedElementListeners(t, {
      mousedown: () => {
        this.currentHeaderRowWithoutSpan = -1;
      }
    });
  }
  getHeaderPositionForColumn(e, t) {
    let s;
    const { colModel: i, colGroupSvc: o, ctrlsSvc: n } = this.beans;
    if (typeof e == "string" ? (s = i.getCol(e), s || (s = (o == null ? void 0 : o.getColumnGroup(e)) ?? null)) : s = e, !s)
      return null;
    const r = n.getHeaderRowContainerCtrl(), a = r == null ? void 0 : r.getAllCtrls(), l = Z(a || []).type === "filter", d = Mt(this.beans) - 1;
    let c = -1, u = s;
    for (; u; )
      c++, u = u.getParent();
    let h = c;
    return t && l && h === d - 1 && h++, h === -1 ? null : {
      headerRowIndex: h,
      column: s
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t, s) {
    const i = this.beans.focusSvc;
    if (t || (t = i.focusedHeader), !t)
      return !1;
    const { headerRowIndex: o } = t, n = t.column, r = Mt(this.beans), a = e === "UP", l = this.getHeaderRowType(o);
    let {
      headerRowIndex: d,
      column: c,
      headerRowIndexWithoutSpan: u
    } = a ? $S(l, n, o) : KS(l, n, o), h = !1;
    return d < 0 && (d = 0, c = n, h = !0), d >= r ? (d = -1, this.currentHeaderRowWithoutSpan = -1) : u !== void 0 && (this.currentHeaderRowWithoutSpan = u), !h && !c ? !1 : i.focusHeaderPosition({
      headerPosition: { headerRowIndex: d, column: c },
      allowUserOverride: !0,
      event: s
    });
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, s) {
    const { focusSvc: i, gos: o } = this.beans, n = i.focusedHeader;
    let r, a;
    this.currentHeaderRowWithoutSpan !== -1 ? n.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = n.headerRowIndex, e === "LEFT" !== o.get("enableRtl") ? (a = "Before", r = this.findHeader(n, a)) : (a = "After", r = this.findHeader(n, a));
    const l = o.getCallback("tabToNextHeader");
    if (t && l) {
      const d = i.focusHeaderPositionFromUserFunc({
        userFunc: l,
        headerPosition: r,
        direction: a
      });
      if (d) {
        const { headerRowIndex: c } = i.focusedHeader || {};
        c != null && c != n.headerRowIndex && (this.currentHeaderRowWithoutSpan = c);
      }
      return d;
    }
    return r || !t ? i.focusHeaderPosition({
      headerPosition: r,
      direction: a,
      fromTab: t,
      allowUserOverride: !0,
      event: s
    }) : this.focusNextHeaderRow(n, a, s);
  }
  focusNextHeaderRow(e, t, s) {
    const i = e.headerRowIndex;
    let o = null, n;
    const r = this.beans;
    if (t === "Before" ? i > 0 && (n = i - 1, this.currentHeaderRowWithoutSpan -= 1, o = this.findColAtEdgeForHeaderRow(n, "end")) : (n = i + 1, this.currentHeaderRowWithoutSpan < Mt(r) ? this.currentHeaderRowWithoutSpan += 1 : this.currentHeaderRowWithoutSpan = -1, o = this.findColAtEdgeForHeaderRow(n, "start")), !o)
      return !1;
    const { column: a, headerRowIndex: l } = ia(
      o.column,
      o == null ? void 0 : o.headerRowIndex
    );
    return r.focusSvc.focusHeaderPosition({
      headerPosition: { column: a, headerRowIndex: l },
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: s
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let s;
    if (ue(e)) {
      const i = e.getDisplayedLeafColumns();
      s = t === "Before" ? Z(i) : i[0];
    } else
      s = e;
    this.gridBodyCon.scrollFeature.ensureColumnVisible(s);
  }
  findHeader(e, t) {
    let s, i;
    const { colGroupSvc: o, visibleCols: n } = this.beans;
    if (ue(e.column) ? s = (o == null ? void 0 : o.getGroupAtDirection(e.column, t)) ?? void 0 : (i = `getCol${t}`, s = n[i](e.column)), !s)
      return;
    const { headerRowIndex: r } = e;
    if (this.getHeaderRowType(r) !== "filter") {
      const d = [s];
      for (; s.getParent(); )
        s = s.getParent(), d.push(s);
      s = d[Math.max(0, d.length - 1 - r)];
    }
    const { column: a, headerRowIndex: l } = ia(s, r);
    return {
      column: a,
      headerRowIndex: l
    };
  }
  getHeaderRowType(e) {
    const t = this.beans.ctrlsSvc.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    const { visibleCols: s, ctrlsSvc: i, colGroupSvc: o } = this.beans, n = s.allCols, r = n[t === "start" ? 0 : n.length - 1];
    if (!r)
      return;
    const a = i.getHeaderRowContainerCtrl(r.getPinned()), l = a == null ? void 0 : a.getRowType(e);
    if (l == "group") {
      const d = o == null ? void 0 : o.getColGroupAtLevel(r, e);
      return {
        headerRowIndex: e,
        column: d
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: l == null ? -1 : e,
      column: r
    };
  }
};
function $S(e, t, s) {
  const i = e === "filter", o = e === "column";
  let n = i ? t : t.getParent(), r = s - 1, a = r;
  if (o && jh(t.getParent())) {
    for (; n && n.isPadding(); )
      n = n.getParent(), r--;
    a = r, r < 0 && (n = t, r = s, a = void 0);
  }
  return { column: n, headerRowIndex: r, headerRowIndexWithoutSpan: a };
}
function KS(e, t, s, i = "After") {
  let o = t, n = s + 1;
  const r = n;
  if (e === "group") {
    const a = t.getDisplayedLeafColumns(), l = i === "After" ? a[0] : Z(a), d = [];
    let c = l;
    for (; c.getParent() !== t; )
      c = c.getParent(), d.push(c);
    if (o = l, l.isSpanHeaderHeight())
      for (let u = d.length - 1; u >= 0; u--) {
        const h = d[u];
        if (!h.isPadding()) {
          o = h;
          break;
        }
        n++;
      }
    else
      o = Z(d), o || (o = l);
  }
  return { column: o, headerRowIndex: n, headerRowIndexWithoutSpan: r };
}
var qS = class extends S {
  constructor() {
    super(...arguments), this.beanName = "focusSvc", this.focusFallbackTimeout = null, this.needsFocusRestored = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.visibleCols = e.visibleCols, this.rowRenderer = e.rowRenderer, this.navigation = e.navigation, this.filterManager = e.filterManager, this.overlays = e.overlays;
  }
  postConstruct() {
    const e = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: e,
      columnRowGroupChanged: e
    }), this.addDestroyFunc(sv(this.beans));
  }
  attemptToRecoverFocus() {
    this.needsFocusRestored = !0, this.focusFallbackTimeout != null && clearTimeout(this.focusFallbackTimeout), this.focusFallbackTimeout = window.setTimeout(this.setFocusRecovered.bind(this), 100);
  }
  setFocusRecovered() {
    this.needsFocusRestored = !1, this.focusFallbackTimeout != null && (clearTimeout(this.focusFallbackTimeout), this.focusFallbackTimeout = null);
  }
  /**
   * Specifies whether to take focus, as grid either already has focus, or lost it due
   * to a destroyed cell
   * @returns true if the grid should re-take focus, otherwise false
   */
  shouldTakeFocus() {
    return this.gos.get("suppressFocusAfterRefresh") ? (this.setFocusRecovered(), !1) : this.needsFocusRestored ? (this.setFocusRecovered(), !0) : this.doesRowOrCellHaveBrowserFocus();
  }
  onColumnEverythingChanged() {
    if (!this.focusedCell)
      return;
    const e = this.focusedCell.column, t = this.colModel.getCol(e.getId());
    e !== t && this.clearFocusedCell();
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    const { gos: e, focusedCell: t } = this;
    return e.get("suppressFocusAfterRefresh") || e.get("suppressCellFocus") || !t || !this.doesRowOrCellHaveBrowserFocus() ? null : t;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeader || !this.isDomDataPresentInHierarchy(te(this.beans), Ch) ? null : this.focusedHeader;
  }
  /**
   * Check for both cells and rows, as a row might be destroyed and the dom data removed before the cell if the
   * row is animating out.
   */
  doesRowOrCellHaveBrowserFocus() {
    const e = te(this.beans);
    return this.isDomDataPresentInHierarchy(e, Sn) ? !0 : this.isDomDataPresentInHierarchy(e, Pn);
  }
  isDomDataPresentInHierarchy(e, t) {
    let s = e;
    for (; s; ) {
      if (su(this.gos, s, t))
        return !0;
      s = s.parentNode;
    }
    return !1;
  }
  getFocusedCell() {
    return this.focusedCell;
  }
  getFocusEventParams(e) {
    const { rowIndex: t, rowPinned: s, column: i } = e, o = {
      rowIndex: t,
      rowPinned: s,
      column: i,
      isFullWidthCell: !1
    }, n = this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: s });
    return n && (o.isFullWidthCell = n.isFullWidth()), o;
  }
  clearFocusedCell() {
    if (this.focusedCell == null)
      return;
    const e = this.getFocusEventParams(this.focusedCell);
    this.focusedCell = null, this.eventSvc.dispatchEvent({
      type: "cellFocusCleared",
      ...e
    });
  }
  setFocusedCell(e) {
    this.setFocusRecovered();
    const { column: t, rowIndex: s, rowPinned: i, forceBrowserFocus: o = !1, preventScrollOnBrowserFocus: n = !1 } = e, r = this.colModel.getCol(t);
    if (!r) {
      this.focusedCell = null;
      return;
    }
    this.focusedCell = {
      rowIndex: s,
      rowPinned: ls(i),
      column: r
    }, this.eventSvc.dispatchEvent({
      type: "cellFocused",
      ...this.getFocusEventParams(this.focusedCell),
      forceBrowserFocus: o,
      preventScrollOnBrowserFocus: n
    });
  }
  isCellFocused(e) {
    return this.focusedCell == null ? !1 : Yu(e, this.focusedCell);
  }
  isHeaderWrapperFocused(e) {
    if (this.focusedHeader == null)
      return !1;
    const {
      column: t,
      rowCtrl: { rowIndex: s, pinned: i }
    } = e, { column: o, headerRowIndex: n } = this.focusedHeader;
    return t === o && s === n && i == o.getPinned();
  }
  focusHeaderPosition(e) {
    var l;
    if (this.setFocusRecovered(), ks(this.beans))
      return !1;
    const { direction: t, fromTab: s, allowUserOverride: i, event: o, fromCell: n, rowWithoutSpanValue: r } = e;
    let { headerPosition: a } = e;
    if (n && ((l = this.filterManager) != null && l.isAdvFilterHeaderActive()))
      return this.focusAdvancedFilter(a);
    if (i) {
      const d = this.focusedHeader, c = Mt(this.beans);
      if (s) {
        const u = this.gos.getCallback("tabToNextHeader");
        u && (a = this.getHeaderPositionFromUserFunc({
          userFunc: u,
          direction: t,
          currentPosition: d,
          headerPosition: a,
          headerRowCount: c
        }));
      } else {
        const u = this.gos.getCallback("navigateToNextHeader");
        if (u && o) {
          const h = {
            key: o.key,
            previousHeaderPosition: d,
            nextHeaderPosition: a,
            headerRowCount: c,
            event: o
          };
          a = u(h);
        }
      }
    }
    return a ? this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: t,
      event: o,
      fromCell: n,
      rowWithoutSpanValue: r
    }) : !1;
  }
  focusHeaderPositionFromUserFunc(e) {
    if (ks(this.beans))
      return !1;
    const { userFunc: t, headerPosition: s, direction: i, event: o } = e, n = this.focusedHeader, r = Mt(this.beans), a = this.getHeaderPositionFromUserFunc({
      userFunc: t,
      direction: i,
      currentPosition: n,
      headerPosition: s,
      headerRowCount: r
    });
    return !!a && this.focusProvidedHeaderPosition({
      headerPosition: a,
      direction: i,
      event: o
    });
  }
  getHeaderPositionFromUserFunc(e) {
    const { userFunc: t, direction: s, currentPosition: i, headerPosition: o, headerRowCount: n } = e, a = t({
      backwards: s === "Before",
      previousHeaderPosition: i,
      nextHeaderPosition: o,
      headerRowCount: n
    });
    return a === !0 ? i : a === !1 ? null : a;
  }
  focusProvidedHeaderPosition(e) {
    const { headerPosition: t, direction: s, fromCell: i, rowWithoutSpanValue: o, event: n } = e, { column: r, headerRowIndex: a } = t, { filterManager: l, ctrlsSvc: d, headerNavigation: c } = this.beans;
    if (a === -1)
      return l != null && l.isAdvFilterHeaderActive() ? this.focusAdvancedFilter(t) : this.focusGridView({ column: r, event: n });
    c == null || c.scrollToColumn(r, s);
    const u = d.getHeaderRowContainerCtrl(r.getPinned()), h = (u == null ? void 0 : u.focusHeader(t.headerRowIndex, r, n)) || !1;
    return c && h && (o != null || i) && (c.currentHeaderRowWithoutSpan = o ?? -1), h;
  }
  focusFirstHeader() {
    var i;
    if ((i = this.overlays) != null && i.isExclusive() && this.focusOverlay())
      return !0;
    let e = this.visibleCols.allCols[0];
    if (!e)
      return !1;
    const { colGroupSvc: t } = this.beans;
    t && e.getParent() && (e = t.getColGroupAtLevel(e, 0));
    const s = ia(e, 0);
    return this.focusHeaderPosition({
      headerPosition: s,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(e) {
    var i;
    if ((i = this.overlays) != null && i.isExclusive() && this.focusOverlay(!0))
      return !0;
    const t = Mt(this.beans) - 1, s = Z(this.visibleCols.allCols);
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: t, column: s },
      rowWithoutSpanValue: -1,
      event: e
    });
  }
  focusPreviousFromFirstCell(e) {
    var t;
    return (t = this.filterManager) != null && t.isAdvFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(e);
  }
  isAnyCellFocused() {
    return !!this.focusedCell;
  }
  isRowFocused(e, t) {
    return this.focusedCell == null ? !1 : this.focusedCell.rowIndex === e && this.focusedCell.rowPinned === ls(t);
  }
  focusOverlay(e) {
    var s, i;
    const t = ((s = this.overlays) == null ? void 0 : s.isVisible()) && ((i = this.overlays.eWrapper) == null ? void 0 : i.getGui());
    return !!t && Ve(t, e);
  }
  focusGridView(e) {
    var n, r, a, l, d, c;
    const { backwards: t = !1, canFocusOverlay: s = !0, event: i } = e;
    if ((n = this.overlays) != null && n.isExclusive())
      return s && this.focusOverlay(t);
    if (ja(this.beans))
      return t && !ks(this.beans) ? this.focusLastHeader() : s && this.focusOverlay(t) ? !0 : t ? !1 : Tt(this.beans, t);
    const o = t ? xv(this.beans) : Sv(this.beans);
    if (o) {
      const u = e.column ?? ((r = this.focusedHeader) == null ? void 0 : r.column), { rowIndex: h, rowPinned: g } = o, p = zn(this.beans, o);
      if (!u || !p || h == null)
        return !1;
      if (u.isSuppressNavigable(p)) {
        const f = this.gos.get("enableRtl");
        let m;
        return !i || i.key === y.TAB ? m = f ? y.LEFT : y.RIGHT : m = i.key, (a = this.beans.navigation) == null || a.navigateToNextCell(
          null,
          m,
          { rowIndex: h, column: u, rowPinned: g || null },
          !0
        ), !0;
      }
      if ((l = this.navigation) == null || l.ensureCellVisible({ rowIndex: h, column: u, rowPinned: g }), t) {
        const f = this.rowRenderer.getRowByPosition(o);
        if (f != null && f.isFullWidth() && ((d = this.navigation) != null && d.tryToFocusFullWidthRow(o, t)))
          return !0;
      }
      return this.setFocusedCell({
        rowIndex: h,
        column: u,
        rowPinned: ls(g),
        forceBrowserFocus: !0
      }), (c = this.beans.rangeSvc) == null || c.setRangeToCell({ rowIndex: h, rowPinned: g, column: u }), !0;
    }
    return !!(s && this.focusOverlay(t) || t && this.focusLastHeader());
  }
  focusAdvancedFilter(e) {
    var t;
    return this.advFilterFocusColumn = e == null ? void 0 : e.column, ((t = this.beans.advancedFilter) == null ? void 0 : t.getCtrl().focusHeaderComp()) ?? !1;
  }
  focusNextFromAdvancedFilter(e, t) {
    var i;
    const s = (t ? void 0 : this.advFilterFocusColumn) ?? ((i = this.visibleCols.allCols) == null ? void 0 : i[0]);
    return e ? this.focusHeaderPosition({
      headerPosition: {
        column: s,
        headerRowIndex: Mt(this.beans) - 1
      }
    }) : this.focusGridView({ column: s });
  }
  clearAdvancedFilterColumn() {
    this.advFilterFocusColumn = void 0;
  }
}, YS = class extends S {
  constructor() {
    super(...arguments), this.beanName = "scrollVisibleSvc";
  }
  wireBeans(e) {
    this.ctrlsSvc = e.ctrlsSvc, this.colAnimation = e.colAnimation;
  }
  postConstruct() {
    this.getScrollbarWidth(), this.addManagedEventListeners({
      displayedColumnsChanged: this.updateScrollVisible.bind(this),
      displayedColumnsWidthChanged: this.updateScrollVisible.bind(this)
    });
  }
  updateScrollVisible() {
    const { colAnimation: e } = this;
    e != null && e.isActive() ? e.executeLaterVMTurn(() => {
      e.executeLaterVMTurn(() => this.updateScrollVisibleImpl());
    }) : this.updateScrollVisibleImpl();
  }
  updateScrollVisibleImpl() {
    var s;
    const e = this.ctrlsSvc.get("center");
    if (!e || (s = this.colAnimation) != null && s.isActive())
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.verticalScrollShowing
    };
    this.setScrollsVisible(t), this.updateScrollGap();
  }
  updateScrollGap() {
    const e = this.ctrlsSvc.get("center"), t = e.hasHorizontalScrollGap(), s = e.hasVerticalScrollGap();
    (this.horizontalScrollGap !== t || this.verticalScrollGap !== s) && (this.horizontalScrollGap = t, this.verticalScrollGap = s, this.eventSvc.dispatchEvent({
      type: "scrollGapChanged"
    }));
  }
  setScrollsVisible(e) {
    (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) && (this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing, this.eventSvc.dispatchEvent({
      type: "scrollVisibilityChanged"
    }));
  }
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const e = this.gos.get("scrollbarWidth"), s = typeof e == "number" && e >= 0 ? e : lm();
      s != null && (this.scrollbarWidth = s, this.eventSvc.dispatchEvent({
        type: "scrollbarWidthChanged"
      }));
    }
    return this.scrollbarWidth;
  }
}, ZS = class extends S {
  constructor() {
    super(...arguments), this.beanName = "gridDestroySvc", this.destroyCalled = !1;
  }
  destroy() {
    var i;
    if (this.destroyCalled)
      return;
    const { stateSvc: e, ctrlsSvc: t, context: s } = this.beans;
    this.eventSvc.dispatchEvent({
      type: "gridPreDestroyed",
      state: (e == null ? void 0 : e.getState()) ?? {}
    }), this.destroyCalled = !0, (i = t.get("gridCtrl")) == null || i.destroyGridUi(), s.destroy(), super.destroy();
  }
}, QS = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]), XS = {
  suppressContextMenu: !1,
  preventDefaultOnContextMenu: !1,
  allowContextMenuWithControlKey: !1,
  suppressMenuHide: !0,
  enableBrowserTooltips: !1,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: !1,
  tooltipShowMode: "standard",
  tooltipInteraction: !1,
  copyHeadersToClipboard: !1,
  copyGroupHeadersToClipboard: !1,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: !1,
  suppressCopySingleCellRanges: !1,
  suppressLastEmptyLineOnPaste: !1,
  suppressClipboardPaste: !1,
  suppressClipboardApi: !1,
  suppressCutToClipboard: !1,
  maintainColumnOrder: !1,
  enableStrictPivotColumnOrder: !1,
  suppressFieldDotNotation: !1,
  allowDragFromColumnsToolPanel: !1,
  suppressMovableColumns: !1,
  suppressColumnMoveAnimation: !1,
  suppressMoveWhenColumnDragging: !1,
  suppressDragLeaveHidesColumns: !1,
  suppressRowGroupHidesColumns: !1,
  suppressAutoSize: !1,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: !1,
  singleClickEdit: !1,
  suppressClickEdit: !1,
  readOnlyEdit: !1,
  stopEditingWhenCellsLoseFocus: !1,
  enterNavigatesVertically: !1,
  enterNavigatesVerticallyAfterEdit: !1,
  enableCellEditingOnBackspace: !1,
  undoRedoCellEditing: !1,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: !1,
  suppressExcelExport: !1,
  cacheQuickFilter: !1,
  includeHiddenColumnsInQuickFilter: !1,
  excludeChildrenWhenTreeDataFiltering: !1,
  enableAdvancedFilter: !1,
  includeHiddenColumnsInAdvancedFilter: !1,
  enableCharts: !1,
  masterDetail: !1,
  keepDetailRows: !1,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: !1,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: !1,
  valueCacheNeverExpires: !1,
  enableCellExpressions: !1,
  suppressTouch: !1,
  suppressFocusAfterRefresh: !1,
  suppressBrowserResizeObserver: !1,
  suppressPropertyNamesCheck: !1,
  suppressChangeDetection: !1,
  debug: !1,
  suppressLoadingOverlay: !1,
  suppressNoRowsOverlay: !1,
  pagination: !1,
  paginationPageSize: 100,
  paginationPageSizeSelector: !0,
  paginationAutoPageSize: !1,
  paginateChildRows: !1,
  suppressPaginationPanel: !1,
  pivotMode: !1,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: !1,
  suppressExpandablePivotGroups: !1,
  functionsReadOnly: !1,
  suppressAggFuncInHeader: !1,
  alwaysAggregateAtRootLevel: !1,
  aggregateOnlyChangedColumns: !1,
  suppressAggFilteredOnly: !1,
  removePivotHeaderRowWhenSingleValueColumn: !1,
  animateRows: !0,
  cellFlashDuration: 500,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: !1,
  domLayout: "normal",
  ensureDomOrder: !1,
  enableRtl: !1,
  suppressColumnVirtualisation: !1,
  suppressMaxRenderedRowRestriction: !1,
  suppressRowVirtualisation: !1,
  rowDragManaged: !1,
  suppressRowDrag: !1,
  suppressMoveWhenRowDragging: !1,
  rowDragEntireRow: !1,
  rowDragMultiRow: !1,
  embedFullWidthRows: !1,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: !1,
  groupSelectsChildren: !1,
  groupSuppressBlankHeader: !1,
  groupSelectsFiltered: !1,
  showOpenedGroup: !1,
  groupRemoveSingleChildren: !1,
  groupRemoveLowestSingleChildren: !1,
  groupHideOpenParents: !1,
  groupAllowUnbalanced: !1,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: !1,
  treeData: !1,
  rowGroupPanelSuppressSort: !1,
  suppressGroupRowsSticky: !1,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: !1,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: !1,
  serverSideSortAllLevels: !1,
  serverSideOnlyRefreshFilteredGroups: !1,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: !1,
  alwaysShowVerticalScroll: !1,
  debounceVerticalScrollbar: !1,
  suppressHorizontalScroll: !1,
  suppressScrollOnNewData: !1,
  suppressScrollWhenPopupsAreOpen: !1,
  suppressAnimationFrame: !1,
  suppressMiddleClickScrolls: !1,
  suppressPreventDefaultOnMouseWheel: !1,
  rowMultiSelectWithClick: !1,
  suppressRowDeselection: !1,
  suppressRowClickSelection: !1,
  suppressCellFocus: !1,
  suppressHeaderFocus: !1,
  suppressMultiRangeSelection: !1,
  enableCellTextSelection: !1,
  enableRangeSelection: !1,
  enableRangeHandle: !1,
  enableFillHandle: !1,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: !1,
  accentedSort: !1,
  unSortIcon: !1,
  suppressMultiSort: !1,
  alwaysMultiSort: !1,
  suppressMaintainUnsortedOrder: !1,
  suppressRowHoverHighlight: !1,
  suppressRowTransform: !1,
  columnHoverHighlight: !1,
  deltaSort: !1,
  enableGroupEdit: !1,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: !1,
  suppressServerSideFullWidthLoadingRow: !1,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: !0,
  suppressSetFilterByDefault: !1,
  rowNumbers: !1
}, _i = (e, t) => ({
  tag: "span",
  ref: `eSort${e}`,
  cls: `ag-sort-indicator-icon ag-sort-${t} ag-hidden`,
  attrs: { "aria-hidden": "true" }
}), JS = {
  tag: "span",
  cls: "ag-sort-indicator-container",
  children: [
    _i("Order", "order"),
    _i("Asc", "ascending-icon"),
    _i("Desc", "descending-icon"),
    _i("Mixed", "mixed-icon"),
    _i("None", "none-icon")
  ]
}, al = class extends L {
  constructor(e) {
    super(), this.eSortOrder = x, this.eSortAsc = x, this.eSortDesc = x, this.eSortMixed = x, this.eSortNone = x, e || this.setTemplate(JS);
  }
  attachCustomElements(e, t, s, i, o) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = s, this.eSortMixed = i, this.eSortNone = o;
  }
  setupSort(e, t = !1) {
    if (this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), !e.isSortable() && !e.getColDef().showRowGroup)
      return;
    this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e);
    const s = this.updateIcons.bind(this), i = this.onSortChanged.bind(this);
    this.addManagedPropertyListener("unSortIcon", s), this.addManagedEventListeners({
      newColumnsLoaded: s,
      // Watch global events, as row group columns can effect their display column.
      sortChanged: i,
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: i
    }), this.onSortChanged();
  }
  addInIcon(e, t, s) {
    if (t == null)
      return;
    const i = k(e, this.beans, s);
    i && t.appendChild(i);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const { eSortAsc: e, eSortDesc: t, eSortNone: s, column: i, gos: o, beans: n } = this, r = n.sortSvc.getDisplaySortForColumn(i);
    if (e && G(e, r === "asc", { skipAriaHidden: !0 }), t && G(t, r === "desc", { skipAriaHidden: !0 }), s) {
      const a = !i.getColDef().unSortIcon && !o.get("unSortIcon"), l = r == null;
      G(s, !a && l, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    const { eSortMixed: e, column: t, gos: s } = this;
    this.addInIcon("sortUnSort", e, t);
    const i = t.getColDef().showRowGroup;
    dt(s) && i && (this.addManagedEventListeners({
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.updateMultiSortIndicator.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
    }), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    const { eSortMixed: e, beans: t, column: s } = this;
    if (e) {
      const i = t.sortSvc.getDisplaySortForColumn(s) === "mixed";
      G(e, i, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    const {
      eSortOrder: e,
      column: t,
      beans: { sortSvc: s }
    } = this;
    if (!e)
      return;
    const i = s.getColumnsWithSortingOrdered(), o = s.getDisplaySortIndexForColumn(t) ?? -1, n = i.some(
      (a) => s.getDisplaySortIndexForColumn(a) ?? !1
    ), r = o >= 0 && n;
    G(e, r, { skipAriaHidden: !0 }), o >= 0 ? e.textContent = (o + 1).toString() : de(e);
  }
}, ex = {
  selector: "AG-SORT-INDICATOR",
  component: al
}, go = ["asc", "desc", null], tx = class extends S {
  constructor() {
    super(...arguments), this.beanName = "sortSvc";
  }
  progressSort(e, t, s) {
    const i = this.getNextSortDirection(e);
    this.setSortForColumn(e, i, t, s);
  }
  progressSortFromEvent(e, t) {
    const i = this.gos.get("multiSortKey") === "ctrl" ? t.ctrlKey || t.metaKey : t.shiftKey;
    this.progressSort(e, i, "uiColumnSorted");
  }
  setSortForColumn(e, t, s, i) {
    var c;
    t !== "asc" && t !== "desc" && (t = null);
    const { gos: o, showRowGroupCols: n } = this.beans, r = dt(o);
    let a = [e];
    if (r && e.getColDef().showRowGroup) {
      const u = (c = n == null ? void 0 : n.getSourceColumnsForGroupColumn) == null ? void 0 : c.call(n, e), h = u == null ? void 0 : u.filter((g) => g.isSortable());
      h && (a = [e, ...h]);
    }
    a.forEach((u) => this.setColSort(u, t, i));
    const l = (s || o.get("alwaysMultiSort")) && !o.get("suppressMultiSort"), d = [];
    if (!l) {
      const u = this.clearSortBarTheseColumns(a, i);
      d.push(...u);
    }
    this.updateSortIndex(e), d.push(...a), this.dispatchSortChangedEvents(i, d);
  }
  updateSortIndex(e) {
    const { gos: t, colModel: s, showRowGroupCols: i } = this.beans, o = dt(t), n = i == null ? void 0 : i.getShowRowGroupCol(e.getId()), r = o && n || e, a = this.getColumnsWithSortingOrdered();
    s.forAllCols((c) => this.setColSortIndex(c, null));
    const l = a.filter((c) => o && c.getColDef().showRowGroup ? !1 : c !== r);
    (r.getSort() ? [...l, r] : l).forEach((c, u) => this.setColSortIndex(c, u));
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    let e = !1;
    return this.beans.colModel.forAllCols((t) => {
      t.getSort() && (e = !0);
    }), e;
  }
  dispatchSortChangedEvents(e, t) {
    const s = {
      type: "sortChanged",
      source: e
    };
    t && (s.columns = t), this.eventSvc.dispatchEvent(s);
  }
  clearSortBarTheseColumns(e, t) {
    const s = [];
    return this.beans.colModel.forAllCols((i) => {
      e.includes(i) || (i.getSort() && s.push(i), this.setColSort(i, void 0, t));
    }), s;
  }
  getNextSortDirection(e) {
    const t = e.getColDef().sortingOrder ?? this.gos.get("sortingOrder") ?? go, s = t.indexOf(e.getSort()), i = s < 0, o = s == t.length - 1;
    return i || o ? t[0] : t[s + 1];
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    const { gos: e, colModel: t, showRowGroupCols: s, rowGroupColsSvc: i } = this.beans;
    let o = [];
    if (t.forAllCols((d) => {
      d.getSort() && o.push(d);
    }), t.isPivotMode()) {
      const d = dt(e);
      o = o.filter((c) => {
        const u = !!c.getAggFunc(), h = !c.isPrimary(), g = d ? s == null ? void 0 : s.getShowRowGroupCol(c.getId()) : c.getColDef().showRowGroup;
        return u || h || g;
      });
    }
    const n = (i == null ? void 0 : i.columns.filter((d) => !!d.getSort())) ?? [], r = {};
    o.forEach((d, c) => r[d.getId()] = c), o.sort((d, c) => {
      const u = d.getSortIndex(), h = c.getSortIndex();
      if (u != null && h != null)
        return u - h;
      if (u == null && h == null) {
        const g = r[d.getId()], p = r[c.getId()];
        return g > p ? 1 : -1;
      } else return h == null ? -1 : 1;
    });
    const a = dt(e) && !!n.length;
    a && (o = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        o.map((d) => (s == null ? void 0 : s.getShowRowGroupCol(d.getId())) ?? d)
      )
    ]);
    const l = /* @__PURE__ */ new Map();
    return o.forEach((d, c) => l.set(d, c)), a && n.forEach((d) => {
      const c = s.getShowRowGroupCol(d.getId());
      l.set(d, l.get(c));
    }), l;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([, e], [, t]) => e - t).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = dt(this.gos), s = !!e.getColDef().showRowGroup;
    return t && s;
  }
  getDisplaySortForColumn(e) {
    var r;
    const t = (r = this.beans.showRowGroupCols) == null ? void 0 : r.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const i = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, o = i[0].getSort();
    return i.every((a) => a.getSort() == o) ? o : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
  setupHeader(e, t, s) {
    let i = 0;
    e.addManagedListeners(t, {
      movingChanged: () => {
        i = Date.now();
      }
    }), s && e.addManagedElementListeners(s, {
      click: (n) => {
        const r = t.isMoving(), l = Date.now() - i < 50;
        r || l || this.progressSortFromEvent(t, n);
      }
    });
    const o = () => {
      var r;
      const n = t.getSort();
      if (e.toggleCss("ag-header-cell-sorted-asc", n === "asc"), e.toggleCss("ag-header-cell-sorted-desc", n === "desc"), e.toggleCss("ag-header-cell-sorted-none", !n), t.getColDef().showRowGroup) {
        const a = (r = this.beans.showRowGroupCols) == null ? void 0 : r.getSourceColumnsForGroupColumn(t), d = !(a == null ? void 0 : a.every(
          (c) => t.getSort() == c.getSort()
        ));
        e.toggleCss("ag-header-cell-sorted-mixed", d);
      }
    };
    e.addManagedEventListeners({
      sortChanged: o,
      columnRowGroupChanged: o
    });
  }
  initCol(e) {
    const { sort: t, initialSort: s, sortIndex: i, initialSortIndex: o } = e.colDef;
    t !== void 0 ? (t === "asc" || t === "desc") && (e.sort = t) : (s === "asc" || s === "desc") && (e.sort = s), i !== void 0 ? i !== null && (e.sortIndex = i) : o !== null && (e.sortIndex = o);
  }
  updateColSort(e, t, s) {
    t !== void 0 && (t === "desc" || t === "asc" ? this.setColSort(e, t, s) : this.setColSort(e, void 0, s));
  }
  setColSort(e, t, s) {
    e.sort !== t && (e.sort = t, e.dispatchColEvent("sortChanged", s)), e.dispatchStateUpdatedEvent("sort");
  }
  setColSortIndex(e, t) {
    e.sortIndex = t, e.dispatchStateUpdatedEvent("sortIndex");
  }
  createSortIndicator(e) {
    return new al(e);
  }
  getSortIndicatorSelector() {
    return ex;
  }
}, pi = {
  agSetColumnFilter: "SetFilter",
  agSetColumnFloatingFilter: "SetFilter",
  agMultiColumnFilter: "MultiFilter",
  agMultiColumnFloatingFilter: "MultiFilter",
  agGroupColumnFilter: "GroupFilter",
  agGroupColumnFloatingFilter: "GroupFilter",
  agGroupCellRenderer: "GroupCellRenderer",
  agGroupRowRenderer: "GroupCellRenderer",
  agRichSelect: "RichSelect",
  agRichSelectCellEditor: "RichSelect",
  agDetailCellRenderer: "SharedMasterDetail",
  agSparklineCellRenderer: "Sparklines",
  agDragAndDropImage: "SharedDragAndDrop",
  agColumnHeader: "ColumnHeaderComp",
  agColumnGroupHeader: "ColumnGroupHeaderComp",
  agSortIndicator: "Sort",
  agAnimateShowChangeCellRenderer: "HighlightChanges",
  agAnimateSlideCellRenderer: "HighlightChanges",
  agLoadingCellRenderer: "LoadingCellRenderer",
  agSkeletonCellRenderer: "SkeletonCellRenderer",
  agCheckboxCellRenderer: "CheckboxCellRenderer",
  agLoadingOverlay: "Overlay",
  agNoRowsOverlay: "Overlay",
  agTooltipComponent: "Tooltip",
  agReadOnlyFloatingFilter: "CustomFilter",
  agTextColumnFilter: "TextFilter",
  agNumberColumnFilter: "NumberFilter",
  agDateColumnFilter: "DateFilter",
  agDateInput: "DateFilter",
  agTextColumnFloatingFilter: "TextFilter",
  agNumberColumnFloatingFilter: "NumberFilter",
  agDateColumnFloatingFilter: "DateFilter",
  agCellEditor: "TextEditor",
  agSelectCellEditor: "SelectEditor",
  agTextCellEditor: "TextEditor",
  agNumberCellEditor: "NumberEditor",
  agDateCellEditor: "DateEditor",
  agDateStringCellEditor: "DateEditor",
  agCheckboxCellEditor: "CheckboxEditor",
  agLargeTextCellEditor: "LargeTextEditor",
  agMenuItem: "MenuItem",
  agColumnsToolPanel: "ColumnsToolPanel",
  agFiltersToolPanel: "FiltersToolPanel",
  agAggregationComponent: "StatusBar",
  agSelectedRowCountComponent: "StatusBar",
  agTotalRowCountComponent: "StatusBar",
  agFilteredRowCountComponent: "StatusBar",
  agTotalAndFilteredRowCountComponent: "StatusBar",
  agFindCellRenderer: "Find"
}, sx = () => ({
  checkboxSelection: { version: "32.2", message: "Use `rowSelection.checkboxes` in `GridOptions` instead." },
  headerCheckboxSelection: {
    version: "32.2",
    message: "Use `rowSelection.headerCheckbox = true` in `GridOptions` instead."
  },
  headerCheckboxSelectionFilteredOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "filtered"` in `GridOptions` instead.'
  },
  headerCheckboxSelectionCurrentPageOnly: {
    version: "32.2",
    message: 'Use `rowSelection.selectAll = "currentPage"` in `GridOptions` instead.'
  },
  showDisabledCheckboxes: {
    version: "32.2",
    message: "Use `rowSelection.hideDisabledCheckboxes = true` in `GridOptions` instead."
  }
}), ix = {
  aggFunc: "SharedAggregation",
  autoHeight: "RowAutoHeight",
  cellClass: "CellStyle",
  cellClassRules: "CellStyle",
  cellEditor: ({ cellEditor: e, editable: t }) => t ? typeof e == "string" ? pi[e] ?? "CustomEditor" : "CustomEditor" : null,
  cellRenderer: ({ cellRenderer: e }) => typeof e != "string" ? null : pi[e],
  cellStyle: "CellStyle",
  columnChooserParams: "ColumnMenu",
  contextMenuItems: "ContextMenu",
  dndSource: "DragAndDrop",
  dndSourceOnRowDrag: "DragAndDrop",
  editable: ({ editable: e, cellEditor: t }) => e && !t ? "TextEditor" : null,
  enableCellChangeFlash: "HighlightChanges",
  enablePivot: "SharedPivot",
  enableRowGroup: "SharedRowGrouping",
  enableValue: "SharedAggregation",
  filter: ({ filter: e }) => e && typeof e != "string" && typeof e != "boolean" ? "CustomFilter" : typeof e == "string" ? pi[e] ?? "ColumnFilter" : "ColumnFilter",
  floatingFilter: "ColumnFilter",
  getQuickFilterText: "QuickFilter",
  headerTooltip: "Tooltip",
  mainMenuItems: "ColumnMenu",
  menuTabs: (e) => {
    var s;
    const t = ["columnsMenuTab", "generalMenuTab"];
    return (s = e.menuTabs) != null && s.some((i) => t.includes(i)) ? "ColumnMenu" : null;
  },
  pivot: "SharedPivot",
  pivotIndex: "SharedPivot",
  rowDrag: "RowDrag",
  rowGroup: "SharedRowGrouping",
  rowGroupIndex: "SharedRowGrouping",
  tooltipField: "Tooltip",
  tooltipValueGetter: "Tooltip",
  spanRows: "CellSpan"
}, ox = () => ({
  autoHeight: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (t, { paginationAutoPageSize: s }) => s ? "colDef.autoHeight is not supported with paginationAutoPageSize." : null
  },
  cellRendererParams: {
    validate: (t) => (t.rowGroup != null || t.rowGroupIndex != null || t.cellRenderer === "agGroupCellRenderer") && "checkbox" in t.cellRendererParams ? 'Since v33.0, `cellRendererParams.checkbox` has been deprecated. Use `rowSelection.checkboxLocation = "autoGroupColumn"` instead.' : null
  },
  flex: {
    validate: (t, s) => s.autoSizeStrategy ? "colDef.flex is not supported with gridOptions.autoSizeStrategy" : null
  },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    validate: (t, { rowSelection: s }) => s === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    validate: (t, { rowSelection: s }) => s === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    validate: (t, { rowSelection: s }) => s === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerValueGetter: {
    validate: (t) => {
      const s = t.headerValueGetter;
      return typeof s == "function" || typeof s == "string" ? null : "headerValueGetter must be a function or a valid string expression";
    }
  },
  icons: {
    validate: ({ icons: t }) => {
      if (t) {
        if (t.smallDown)
          return ds(262);
        if (t.smallLeft)
          return ds(263);
        if (t.smallRight)
          return ds(264);
      }
      return null;
    }
  },
  sortingOrder: {
    validate: (t) => {
      const s = t.sortingOrder;
      if (Array.isArray(s) && s.length > 0) {
        const i = s.filter((o) => !go.includes(o));
        if (i.length > 0)
          return `sortingOrder must be an array with elements from [${go.map(gn).join()}], currently it includes [${i.map(gn).join()}]`;
      } else if (!Array.isArray(s) || s.length <= 0)
        return `sortingOrder must be an array with at least one element, currently it's ${s}`;
      return null;
    }
  },
  type: {
    validate: (t) => {
      const s = t.type;
      return s instanceof Array ? s.some((o) => typeof o != "string") ? "if colDef.type is supplied an array it should be of type 'string[]'" : null : typeof s == "string" ? null : "colDef.type should be of type 'string' | 'string[]'";
    }
  },
  rowSpan: {
    validate: (t, { suppressRowTransform: s }) => s ? null : "colDef.rowSpan requires suppressRowTransform to be enabled."
  },
  spanRows: {
    dependencies: {
      editable: { required: [!1, void 0] },
      rowDrag: { required: [!1, void 0] },
      colSpan: { required: [void 0] },
      rowSpan: { required: [void 0] }
    },
    validate: (t, {
      rowSelection: s,
      cellSelection: i,
      suppressRowTransform: o,
      enableCellSpan: n,
      rowDragEntireRow: r,
      enableCellTextSelection: a
    }) => typeof s == "object" && (s == null ? void 0 : s.mode) === "singleRow" && s != null && s.enableClickSelection ? "colDef.spanRows is not supported with rowSelection.clickSelection" : i ? "colDef.spanRows is not supported with cellSelection." : o ? "colDef.spanRows is not supported with suppressRowTransform." : n ? r ? "colDef.spanRows is not supported with rowDragEntireRow." : a ? "colDef.spanRows is not supported with enableCellTextSelection." : null : "colDef.spanRows requires enableCellSpan to be enabled."
  }
}), nx = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerStyle: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  spanRows: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0,
  context: void 0,
  dateComponent: void 0,
  dateComponentParams: void 0,
  getFindText: void 0
}, rx = () => Object.keys(nx), ax = () => ({
  objectName: "colDef",
  allProperties: rx(),
  docsUrl: "column-properties/",
  deprecations: sx(),
  validations: ox()
}), lx = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "pinnedRowsChanged",
  "rangeSelectionChanged",
  "cellSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "cellSelectionDeleteStart",
  "cellSelectionDeleteEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterOpened",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "dragCancelled",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd",
  "rowDragCancel",
  "findChanged",
  "rowResizeStarted",
  "rowResizeEnded"
], dx = [
  "scrollbarWidthChanged",
  "keyShortcutChangedCellStart",
  "keyShortcutChangedCellEnd",
  "pinnedHeightChanged",
  "cellFocusCleared",
  "fullWidthRowFocused",
  "checkboxChanged",
  "heightScaleChanged",
  "suppressMovableColumns",
  "suppressMenuHide",
  "suppressFieldDotNotation",
  "columnPanelItemDragStart",
  "columnPanelItemDragEnd",
  "bodyHeightChanged",
  "columnContainerWidthChanged",
  "displayedColumnsWidthChanged",
  "scrollVisibilityChanged",
  "scrollGapChanged",
  "columnHoverChanged",
  "flashCells",
  "paginationPixelOffsetChanged",
  "displayedRowsChanged",
  "leftPinnedWidthChanged",
  "rightPinnedWidthChanged",
  "rowContainerHeightChanged",
  "headerHeightChanged",
  "columnGroupHeaderHeightChanged",
  "columnHeaderHeightChanged",
  "gridStylesChanged",
  "storeUpdated",
  "filterDestroyed",
  "rowDataUpdateStarted",
  "rowCountReady",
  "advancedFilterEnabledChanged",
  "dataTypesInferred",
  "fieldValueChanged",
  "fieldPickerValueSelected",
  "richSelectListRowSelected",
  "sideBarUpdated",
  "alignedGridScroll",
  "alignedGridColumn",
  "gridOptionsChanged",
  "chartTitleEdit",
  "recalculateRowBounds",
  "stickyTopOffsetChanged",
  "overlayExclusiveChanged",
  "beforeRefreshModel",
  "rowNodeDataChanged"
], cx = () => [...lx, ...dx], ux = [
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "treeDataChildrenField",
  "treeDataParentIdField",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow",
  "themeCssLayer",
  "findSearchValue",
  "styleNonce"
], hx = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "dragAndDropImageComponentParams",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "themeStyleContainer",
  "statusBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy",
  "selectionColumnDef",
  "findOptions"
], gx = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
], $h = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
], px = ["theme", "rowSelection"], fx = [
  "cellSelection",
  "sideBar",
  "rowNumbers",
  "suppressGroupChangesColumnVisibility",
  "groupAggFiltering",
  "suppressStickyTotalRow",
  "groupHideParentOfSingleChild",
  "enableRowPinning"
], Kh = [
  "loadThemeGoogleFonts",
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMoveWhenColumnDragging",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "enableCellSpan",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading",
  "maintainColumnOrder",
  "enableStrictPivotColumnOrder",
  "suppressSetFilterByDefault"
], mx = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "dragAndDropImageComponent",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "loadingCellRendererSelector",
  "getRowId",
  "chartMenuItems",
  "groupTotalRow",
  "alwaysPassFilter",
  "isRowPinnable",
  "isRowPinned"
], Cx = () => [
  ...gx,
  ...hx,
  ...ux,
  ...$h,
  ...mx,
  ...Kh,
  ...fx,
  ...px
], vx = () => ({
  suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." },
  enableFillHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeHandle: { version: "32.2", message: "Use `cellSelection.handle` instead." },
  enableRangeSelection: { version: "32.2", message: "Use `cellSelection = true` instead." },
  suppressMultiRangeSelection: {
    version: "32.2",
    message: "Use `cellSelection.suppressMultiRanges` instead."
  },
  suppressClearOnFillReduction: {
    version: "32.2",
    message: "Use `cellSelection.handle.suppressClearOnFillReduction` instead."
  },
  fillHandleDirection: { version: "32.2", message: "Use `cellSelection.handle.direction` instead." },
  fillOperation: { version: "32.2", message: "Use `cellSelection.handle.setFillValue` instead." },
  suppressRowClickSelection: {
    version: "32.2",
    message: "Use `rowSelection.enableClickSelection` instead."
  },
  suppressRowDeselection: { version: "32.2", message: "Use `rowSelection.enableClickSelection` instead." },
  rowMultiSelectWithClick: {
    version: "32.2",
    message: "Use `rowSelection.enableSelectionWithoutKeys` instead."
  },
  groupSelectsChildren: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "descendants"` instead.'
  },
  groupSelectsFiltered: {
    version: "32.2",
    message: 'Use `rowSelection.groupSelects = "filteredDescendants"` instead.'
  },
  isRowSelectable: { version: "32.2", message: "Use `selectionOptions.isRowSelectable` instead." },
  suppressCopySingleCellRanges: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  suppressCopyRowsToClipboard: { version: "32.2", message: "Use `rowSelection.copySelectedRows` instead." },
  onRangeSelectionChanged: { version: "32.2", message: "Use `onCellSelectionChanged` instead." },
  onRangeDeleteStart: { version: "32.2", message: "Use `onCellSelectionDeleteStart` instead." },
  onRangeDeleteEnd: { version: "32.2", message: "Use `onCellSelectionDeleteEnd` instead." },
  suppressBrowserResizeObserver: {
    version: "32.2",
    message: "The grid always uses the browser's ResizeObserver, this grid option has no effect."
  },
  onColumnEverythingChanged: {
    version: "32.2",
    message: "Either use `onDisplayedColumnsChanged` which is fired at the same time, or use one of the more specific column events."
  },
  groupRemoveSingleChildren: {
    version: "33",
    message: "Use `groupHideParentOfSingleChild` instead."
  },
  groupRemoveLowestSingleChildren: {
    version: "33",
    message: 'Use `groupHideParentOfSingleChild: "leafGroupsOnly"` instead.'
  },
  suppressRowGroupHidesColumns: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressHideOnGroup"` instead.'
  },
  suppressMakeColumnVisibleAfterUnGroup: {
    version: "33",
    message: 'Use `suppressGroupChangesColumnVisibility: "suppressShowOnUngroup"` instead.'
  },
  unSortIcon: { version: "33", message: "Use `defaultColDef.unSortIcon` instead." },
  sortingOrder: { version: "33", message: "Use `defaultColDef.sortingOrder` instead." },
  suppressPropertyNamesCheck: {
    version: "33",
    message: "`gridOptions` and `columnDefs` both have a `context` property that should be used for arbitrary user data. This means that column definitions and gridOptions should only contain valid properties making this property redundant."
  }
});
function St(e, t, s) {
  return typeof t == "number" || t == null ? t == null || t >= s ? null : `${e}: value should be greater than or equal to ${s}` : `${e}: value should be a number`;
}
var wx = {
  alignedGrids: "AlignedGrids",
  allowContextMenuWithControlKey: "ContextMenu",
  autoSizeStrategy: "ColumnAutoSize",
  cellSelection: "CellSelection",
  columnHoverHighlight: "ColumnHover",
  datasource: "InfiniteRowModel",
  doesExternalFilterPass: "ExternalFilter",
  editType: "EditCore",
  enableAdvancedFilter: "AdvancedFilter",
  enableCellSpan: "CellSpan",
  enableCharts: "IntegratedCharts",
  enableRangeSelection: "CellSelection",
  enableRowPinning: "PinnedRow",
  findSearchValue: "Find",
  getContextMenuItems: "ContextMenu",
  getLocaleText: "Locale",
  getMainMenuItems: "ColumnMenu",
  getRowClass: "RowStyle",
  getRowStyle: "RowStyle",
  groupTotalRow: "SharedRowGrouping",
  grandTotalRow: "SharedRowGrouping",
  initialState: "GridState",
  isExternalFilterPresent: "ExternalFilter",
  isRowPinnable: "PinnedRow",
  localeText: "Locale",
  masterDetail: "SharedMasterDetail",
  pagination: "Pagination",
  pinnedBottomRowData: "PinnedRow",
  pinnedTopRowData: "PinnedRow",
  pivotMode: "SharedPivot",
  pivotPanelShow: "RowGroupingPanel",
  quickFilterText: "QuickFilter",
  rowClass: "RowStyle",
  rowClassRules: "RowStyle",
  rowData: "ClientSideRowModel",
  rowDragManaged: "RowDrag",
  rowGroupPanelShow: "RowGroupingPanel",
  rowNumbers: "RowNumbers",
  rowSelection: "SharedRowSelection",
  rowStyle: "RowStyle",
  serverSideDatasource: "ServerSideRowModel",
  sideBar: "SideBar",
  statusBar: "StatusBar",
  treeData: "SharedTreeData",
  undoRedoCellEditing: "UndoRedoEdit",
  valueCache: "ValueCache",
  viewportDatasource: "ViewportRowModel"
}, bx = () => {
  const e = {
    autoSizePadding: {
      validate({ autoSizePadding: s }) {
        return St("autoSizePadding", s, 0);
      }
    },
    cacheBlockSize: {
      supportedRowModels: ["serverSide", "infinite"],
      validate({ cacheBlockSize: s }) {
        return St("cacheBlockSize", s, 1);
      }
    },
    cacheOverflowSize: {
      validate({ cacheOverflowSize: s }) {
        return St("cacheOverflowSize", s, 1);
      }
    },
    datasource: {
      supportedRowModels: ["infinite"]
    },
    domLayout: {
      validate: (s) => {
        const i = s.domLayout, o = ["autoHeight", "normal", "print"];
        return i && !o.includes(i) ? `domLayout must be one of [${o.join()}], currently it's ${i}` : null;
      }
    },
    enableFillHandle: {
      dependencies: {
        enableRangeSelection: { required: [!0] }
      }
    },
    enableRangeHandle: {
      dependencies: {
        enableRangeSelection: { required: [!0] }
      }
    },
    enableRangeSelection: {
      dependencies: {
        rowDragEntireRow: { required: [!1, void 0] }
      }
    },
    enableRowPinning: {
      supportedRowModels: ["clientSide"],
      validate({ enableRowPinning: s, pinnedTopRowData: i, pinnedBottomRowData: o }) {
        return s && (i || o) ? "Manual row pinning cannot be used together with pinned row data. Either set `enableRowPinning` to `false`, or remove `pinnedTopRowData` and `pinnedBottomRowData`." : null;
      }
    },
    isRowPinnable: {
      supportedRowModels: ["clientSide"],
      validate({ isRowPinnable: s, pinnedTopRowData: i, pinnedBottomRowData: o }) {
        return s && (i || o) ? "Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinnable`, or remove `pinnedTopRowData` and `pinnedBottomRowData`." : null;
      }
    },
    isRowPinned: {
      supportedRowModels: ["clientSide"],
      validate({ isRowPinned: s, pinnedTopRowData: i, pinnedBottomRowData: o }) {
        return s && (i || o) ? "Manual row pinning cannot be used together with pinned row data. Either remove `isRowPinned`, or remove `pinnedTopRowData` and `pinnedBottomRowData`." : null;
      }
    },
    groupDefaultExpanded: {
      supportedRowModels: ["clientSide"]
    },
    groupHideOpenParents: {
      supportedRowModels: ["clientSide", "serverSide"],
      dependencies: {
        groupTotalRow: { required: [void 0, "bottom"] },
        treeData: {
          required: [void 0, !1],
          reason: "Tree Data has values at the group level so it doesn't make sense to hide them."
        }
      }
    },
    groupHideParentOfSingleChild: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] }
      }
    },
    groupRemoveLowestSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] },
        groupRemoveSingleChildren: { required: [void 0, !1] }
      }
    },
    groupRemoveSingleChildren: {
      dependencies: {
        groupHideOpenParents: { required: [void 0, !1] },
        groupRemoveLowestSingleChildren: { required: [void 0, !1] }
      }
    },
    groupSelectsChildren: {
      dependencies: {
        rowSelection: { required: ["multiple"] }
      }
    },
    icons: {
      validate: ({ icons: s }) => {
        if (s) {
          if (s.smallDown)
            return ds(262);
          if (s.smallLeft)
            return ds(263);
          if (s.smallRight)
            return ds(264);
        }
        return null;
      }
    },
    infiniteInitialRowCount: {
      validate({ infiniteInitialRowCount: s }) {
        return St("infiniteInitialRowCount", s, 1);
      }
    },
    initialGroupOrderComparator: {
      supportedRowModels: ["clientSide"]
    },
    keepDetailRowsCount: {
      validate({ keepDetailRowsCount: s }) {
        return St("keepDetailRowsCount", s, 1);
      }
    },
    paginationPageSize: {
      validate({ paginationPageSize: s }) {
        return St("paginationPageSize", s, 1);
      }
    },
    paginationPageSizeSelector: {
      validate: (s) => {
        const i = s.paginationPageSizeSelector;
        return typeof i == "boolean" || i == null || i.length ? null : `'paginationPageSizeSelector' cannot be an empty array.
                    If you want to hide the page size selector, set paginationPageSizeSelector to false.`;
      }
    },
    pivotMode: {
      dependencies: {
        treeData: {
          required: [!1, void 0],
          reason: "Pivot Mode is not supported with Tree Data."
        }
      }
    },
    quickFilterText: {
      supportedRowModels: ["clientSide"]
    },
    rowBuffer: {
      validate({ rowBuffer: s }) {
        return St("rowBuffer", s, 0);
      }
    },
    rowClass: {
      validate: (s) => typeof s.rowClass == "function" ? "rowClass should not be a function, please use getRowClass instead" : null
    },
    rowData: {
      supportedRowModels: ["clientSide"]
    },
    rowDragManaged: {
      supportedRowModels: ["clientSide"],
      dependencies: {
        treeData: {
          required: [!1, void 0]
        },
        pagination: {
          required: [!1, void 0]
        }
      }
    },
    rowSelection: {
      validate({ rowSelection: s }) {
        return s && typeof s == "string" ? 'As of version 32.2.1, using `rowSelection` with the values "single" or "multiple" has been deprecated. Use the object value instead.' : s && typeof s != "object" ? "Expected `RowSelectionOptions` object for the `rowSelection` property." : s && s.mode !== "multiRow" && s.mode !== "singleRow" ? `Selection mode "${s.mode}" is invalid. Use one of 'singleRow' or 'multiRow'.` : null;
      }
    },
    rowStyle: {
      validate: (s) => {
        const i = s.rowStyle;
        return i && typeof i == "function" ? "rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead" : null;
      }
    },
    serverSideDatasource: {
      supportedRowModels: ["serverSide"]
    },
    serverSideInitialRowCount: {
      supportedRowModels: ["serverSide"],
      validate({ serverSideInitialRowCount: s }) {
        return St("serverSideInitialRowCount", s, 1);
      }
    },
    serverSideOnlyRefreshFilteredGroups: {
      supportedRowModels: ["serverSide"]
    },
    serverSideSortAllLevels: {
      supportedRowModels: ["serverSide"]
    },
    sortingOrder: {
      validate: (s) => {
        const i = s.sortingOrder;
        if (Array.isArray(i) && i.length > 0) {
          const o = i.filter((n) => !go.includes(n));
          if (o.length > 0)
            return `sortingOrder must be an array with elements from [${go.map(gn).join()}], currently it includes [${o.map(gn).join()}]`;
        } else if (!Array.isArray(i) || i.length <= 0)
          return `sortingOrder must be an array with at least one element, currently it's ${i}`;
        return null;
      }
    },
    tooltipHideDelay: {
      validate: (s) => s.tooltipHideDelay && s.tooltipHideDelay < 0 ? "tooltipHideDelay should not be lower than 0" : null
    },
    tooltipShowDelay: {
      validate: (s) => s.tooltipShowDelay && s.tooltipShowDelay < 0 ? "tooltipShowDelay should not be lower than 0" : null
    },
    treeData: {
      supportedRowModels: ["clientSide", "serverSide"],
      validate: (s) => {
        const i = s.rowModelType ?? "clientSide";
        switch (i) {
          case "clientSide": {
            const { treeDataChildrenField: o, treeDataParentIdField: n, getDataPath: r, getRowId: a } = s;
            if (!o && !n && !r)
              return "treeData requires either 'treeDataChildrenField' or 'treeDataParentIdField' or 'getDataPath' in the clientSide row model.";
            if (o) {
              if (r)
                return "Cannot use both 'treeDataChildrenField' and 'getDataPath' at the same time.";
              if (n)
                return "Cannot use both 'treeDataChildrenField' and 'treeDataParentIdField' at the same time.";
            }
            if (n) {
              if (!a)
                return "getRowId callback not provided, tree data with parent id cannot be built.";
              if (r)
                return "Cannot use both 'treeDataParentIdField' and 'getDataPath' at the same time.";
            }
            return null;
          }
          case "serverSide": {
            const o = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${i} row model.`;
            return s.isServerSideGroup && s.getServerSideGroupKey ? null : o;
          }
        }
        return null;
      }
    },
    viewportDatasource: {
      supportedRowModels: ["viewport"]
    },
    viewportRowModelBufferSize: {
      validate({ viewportRowModelBufferSize: s }) {
        return St("viewportRowModelBufferSize", s, 0);
      }
    },
    viewportRowModelPageSize: {
      validate({ viewportRowModelPageSize: s }) {
        return St("viewportRowModelPageSize", s, 1);
      }
    },
    rowDragEntireRow: {
      dependencies: {
        cellSelection: { required: [void 0] }
      }
    },
    autoGroupColumnDef: {
      validate({ autoGroupColumnDef: s, showOpenedGroup: i }) {
        return s != null && s.field && i ? "autoGroupColumnDef.field and showOpenedGroup are not supported when used together." : s != null && s.valueGetter && i ? "autoGroupColumnDef.valueGetter and showOpenedGroup are not supported when used together." : null;
      }
    }
  }, t = {};
  return Kh.forEach((s) => {
    t[s] = { expectedType: "boolean" };
  }), $h.forEach((s) => {
    t[s] = { expectedType: "number" };
  }), me(t, e), t;
}, yx = () => ({
  objectName: "gridOptions",
  allProperties: [...Cx(), ...cx().map((e) => uu(e))],
  propertyExceptions: ["api"],
  docsUrl: "grid-options/",
  deprecations: vx(),
  validations: bx()
}), Sx = 0, xx = 0, Rx = class extends S {
  constructor() {
    super(...arguments), this.beanName = "gos", this.domDataKey = "__AG_" + Math.random().toString(), this.gridInstanceId = xx++, this.gridReadyFired = !1, this.queueEvents = [], this.propEventSvc = new hs(), this.globalEventHandlerFactory = (e) => (t, s) => {
      if (!this.isAlive())
        return;
      const i = QS.has(t);
      if (i && !e || !i && e)
        return;
      const o = (n, r) => {
        const a = this.gridOptions[uu(n)];
        typeof a == "function" && this.beans.frameworkOverrides.wrapOutgoing(() => a(r));
      };
      if (this.gridReadyFired)
        o(t, s);
      else if (t === "gridReady") {
        o(t, s), this.gridReadyFired = !0;
        for (const n of this.queueEvents)
          o(n.eventName, n.event);
        this.queueEvents = [];
      } else
        this.queueEvents.push({ eventName: t, event: s });
    };
  }
  wireBeans(e) {
    this.gridOptions = e.gridOptions, this.validation = e.validation, this.api = e.gridApi, this.gridId = e.context.getGridId();
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions.context;
  }
  postConstruct() {
    this.validateGridOptions(this.gridOptions), this.eventSvc.addGlobalListener(this.globalEventHandlerFactory().bind(this), !0), this.eventSvc.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propEventSvc.setFrameworkOverrides(this.beans.frameworkOverrides), this.addManagedEventListeners({
      gridOptionsChanged: ({ options: e }) => {
        this.updateGridOptions({ options: e, force: !0, source: "gridOptionsUpdated" });
      }
    });
  }
  destroy() {
    super.destroy(), this.queueEvents = [];
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(e) {
    return this.gridOptions[e] ?? XS[e];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(e) {
    return this.mergeGridCommonParams(this.gridOptions[e]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(e) {
    return T(this.gridOptions[e]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(e) {
    return e && ((s) => e(this.addGridCommonParams(s)));
  }
  updateGridOptions({
    options: e,
    force: t,
    source: s = "api"
  }) {
    const i = { id: Sx++, properties: [] }, o = [], { gridOptions: n, validation: r } = this;
    for (const a of Object.keys(e)) {
      const l = e[a];
      r == null || r.warnOnInitialPropertyUpdate(s, a);
      const d = t || typeof l == "object" && s === "api", c = n[a];
      if (d || c !== l) {
        n[a] = l;
        const u = {
          type: a,
          currentValue: l,
          previousValue: c,
          changeSet: i,
          source: s
        };
        o.push(u);
      }
    }
    this.validateGridOptions(this.gridOptions), i.properties = o.map((a) => a.type), o.forEach((a) => {
      oo(this, `Updated property ${a.type} from`, a.previousValue, " to ", a.currentValue), this.propEventSvc.dispatchEvent(a);
    });
  }
  addPropertyEventListener(e, t) {
    this.propEventSvc.addEventListener(e, t);
  }
  removePropertyEventListener(e, t) {
    this.propEventSvc.removeEventListener(e, t);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  /** Prefer _addGridCommonParams from gridOptionsUtils for bundle size savings */
  addGridCommonParams(e) {
    return e.api = this.api, e.context = this.gridOptionsContext, e;
  }
  validateOptions(e, t) {
    for (const s of Object.keys(e)) {
      const i = e[s];
      if (i == null || i === !1)
        continue;
      let o = t[s];
      typeof o == "function" && (o = o(e, this.gridOptions, this.beans)), o && this.assertModuleRegistered(o, s);
    }
  }
  validateGridOptions(e) {
    var t;
    this.validateOptions(e, wx), (t = this.validation) == null || t.processGridOptions(e);
  }
  validateColDef(e, t, s) {
    var i, o;
    (s || !((i = this.beans.dataTypeSvc) != null && i.isColPendingInference(t))) && (this.validateOptions(e, ix), (o = this.validation) == null || o.validateColDef(e));
  }
  assertModuleRegistered(e, t) {
    const s = Array.isArray(e) ? e.some((i) => this.isModuleRegistered(i)) : this.isModuleRegistered(e);
    return s || K(200, {
      ...this.getModuleErrorParams(),
      moduleName: e,
      reasonOrId: t
    }), s;
  }
  getModuleErrorParams() {
    return {
      gridId: this.gridId,
      gridScoped: Wa(),
      rowModelType: this.get("rowModelType"),
      isUmd: KC()
    };
  }
  isModuleRegistered(e) {
    return Qr(e, this.gridId, this.get("rowModelType"));
  }
};
function qh(e) {
  const t = { "aria-hidden": "true" };
  return {
    tag: "div",
    cls: "ag-cell-label-container",
    role: "presentation",
    children: [
      {
        tag: "span",
        ref: "eMenu",
        cls: "ag-header-icon ag-header-cell-menu-button",
        attrs: t
      },
      {
        tag: "span",
        ref: "eFilterButton",
        cls: "ag-header-icon ag-header-cell-filter-button",
        attrs: t
      },
      {
        tag: "div",
        ref: "eLabel",
        cls: "ag-header-cell-label",
        role: "presentation",
        children: [
          { tag: "span", ref: "eText", cls: "ag-header-cell-text" },
          {
            tag: "span",
            ref: "eFilter",
            cls: "ag-header-icon ag-header-label-icon ag-filter-icon",
            attrs: t
          },
          e ? { tag: "ag-sort-indicator", ref: "eSortIndicator" } : null
        ]
      }
    ]
  };
}
var Fx = qh(!0), Px = qh(!1), Dx = class extends L {
  constructor() {
    super(...arguments), this.eFilter = x, this.eFilterButton = x, this.eSortIndicator = x, this.eMenu = x, this.eLabel = x, this.eText = x, this.eSortOrder = x, this.eSortAsc = x, this.eSortDesc = x, this.eSortMixed = x, this.eSortNone = x, this.isLoadingInnerComponent = !1;
  }
  refresh(e) {
    var s, i, o;
    const t = this.params;
    if (this.params = e, this.workOutTemplate(e, !!((s = this.beans) != null && s.sortSvc)) != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || e.enableSorting != this.currentSort || this.currentSuppressMenuHide != null && this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || t.enableFilterButton != e.enableFilterButton || t.enableFilterIcon != e.enableFilterIcon)
      return !1;
    if (this.innerHeaderComponent) {
      const n = { ...e };
      me(n, e.innerHeaderComponentParams), (o = (i = this.innerHeaderComponent).refresh) == null || o.call(i, n);
    } else
      this.setDisplayName(e);
    return !0;
  }
  workOutTemplate(e, t) {
    const s = e.template;
    return s ? s != null && s.trim ? s.trim() : s : t ? Fx : Px;
  }
  init(e) {
    this.params = e;
    const { sortSvc: t, touchSvc: s, rowNumbersSvc: i, userCompFactory: o } = this.beans, n = t == null ? void 0 : t.getSortIndicatorSelector();
    this.currentTemplate = this.workOutTemplate(e, !!n), this.setTemplate(this.currentTemplate, n ? [n] : void 0), s == null || s.setupForHeader(this), this.setMenu(), this.setupSort(), i == null || i.setupForHeader(this), this.setupFilterIcon(), this.setupFilterButton(), this.workOutInnerHeaderComponent(o, e), this.setDisplayName(e);
  }
  workOutInnerHeaderComponent(e, t) {
    const s = MC(e, t, t);
    s && (this.isLoadingInnerComponent = !0, s.newAgStackInstance().then((i) => {
      this.isLoadingInnerComponent = !1, i && (this.isAlive() ? (this.innerHeaderComponent = i, this.eText && this.eText.appendChild(i.getGui())) : this.destroyBean(i));
    }));
  }
  setDisplayName(e) {
    const { displayName: t } = e, s = this.currentDisplayName;
    this.currentDisplayName = t, !(!this.eText || s === t || this.innerHeaderComponent || this.isLoadingInnerComponent) && (this.eText.textContent = _n(t));
  }
  addInIcon(e, t, s) {
    const i = k(e, this.beans, s);
    i && t.appendChild(i);
  }
  workOutShowMenu() {
    var e;
    return this.params.enableMenu && !!((e = this.beans.menuSvc) != null && e.isHeaderMenuButtonEnabled());
  }
  shouldSuppressMenuHide() {
    var e;
    return !!((e = this.beans.menuSvc) != null && e.isHeaderMenuButtonAlwaysShowEnabled());
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      De(this.eMenu), this.eMenu = void 0;
      return;
    }
    const { gos: e, eMenu: t, params: s } = this, i = fe(e);
    this.addInIcon(i ? "menu" : "menuAlt", t, s.column), t.classList.toggle("ag-header-menu-icon", !i);
    const o = this.shouldSuppressMenuHide();
    this.currentSuppressMenuHide = o, this.addManagedElementListeners(t, { click: () => this.showColumnMenu(this.eMenu) }), this.toggleMenuAlwaysShow(o);
  }
  toggleMenuAlwaysShow(e) {
    var t;
    (t = this.eMenu) == null || t.classList.toggle("ag-header-menu-always-show", e);
  }
  showColumnMenu(e) {
    const { currentSuppressMenuHide: t, params: s } = this;
    t || this.toggleMenuAlwaysShow(!0), s.showColumnMenu(e, () => {
      t || this.toggleMenuAlwaysShow(!1);
    });
  }
  onMenuKeyboardShortcut(e) {
    var l;
    const { params: t, gos: s, beans: i, eMenu: o, eFilterButton: n } = this, r = t.column, a = fe(s);
    if (e && !a) {
      if ((l = i.menuSvc) != null && l.isFilterMenuInHeaderEnabled(r))
        return t.showFilter(n ?? o ?? this.getGui()), !0;
    } else if (t.enableMenu)
      return this.showColumnMenu(o ?? n ?? this.getGui()), !0;
    return !1;
  }
  setupSort() {
    const { sortSvc: e } = this.beans;
    if (!e)
      return;
    const { enableSorting: t, column: s } = this.params;
    if (this.currentSort = t, !this.eSortIndicator) {
      this.eSortIndicator = this.createBean(e.createSortIndicator(!0));
      const { eSortIndicator: i, eSortOrder: o, eSortAsc: n, eSortDesc: r, eSortMixed: a, eSortNone: l } = this;
      i.attachCustomElements(o, n, r, a, l);
    }
    this.eSortIndicator.setupSort(s), this.currentSort && e.setupHeader(this, s, this.eLabel);
  }
  setupFilterIcon() {
    const { eFilter: e, params: t } = this;
    if (!e)
      return;
    const s = () => {
      const i = t.column.isFilterActive();
      G(e, i, { skipAriaHidden: !0 });
    };
    this.configureFilter(t.enableFilterIcon, e, s, "filterActive");
  }
  setupFilterButton() {
    const { eFilterButton: e, params: t } = this;
    if (!e)
      return;
    this.configureFilter(
      t.enableFilterButton,
      e,
      this.onFilterChangedButton.bind(this),
      "filter"
    ) ? this.addManagedElementListeners(e, {
      click: () => t.showFilter(e)
    }) : this.eFilterButton = void 0;
  }
  configureFilter(e, t, s, i) {
    if (!e)
      return De(t), !1;
    const o = this.params.column;
    return this.addInIcon(i, t, o), this.addManagedListeners(o, { filterChanged: s }), s(), !0;
  }
  onFilterChangedButton() {
    const e = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", e);
  }
  getAnchorElementForMenu(e) {
    const { eFilterButton: t, eMenu: s } = this;
    return e ? t ?? s ?? this.getGui() : s ?? t ?? this.getGui();
  }
  destroy() {
    super.destroy(), this.innerHeaderComponent && (this.destroyBean(this.innerHeaderComponent), this.innerHeaderComponent = void 0);
  }
}, Mx = {
  tag: "div",
  cls: "ag-header-group-cell-label",
  role: "presentation",
  children: [
    { tag: "span", ref: "agLabel", cls: "ag-header-group-text", role: "presentation" },
    { tag: "span", ref: "agOpened", cls: "ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded" },
    { tag: "span", ref: "agClosed", cls: "ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed" }
  ]
}, Ex = class extends L {
  constructor() {
    super(Mx), this.agOpened = x, this.agClosed = x, this.agLabel = x, this.isLoadingInnerComponent = !1;
  }
  init(e) {
    const { userCompFactory: t, touchSvc: s } = this.beans;
    this.params = e, this.checkWarnings(), this.workOutInnerHeaderGroupComponent(t, e), this.setupLabel(e), this.addGroupExpandIcon(e), this.setupExpandIcons(), s == null || s.setupForHeaderGroup(this);
  }
  checkWarnings() {
    this.params.template && P(89);
  }
  workOutInnerHeaderGroupComponent(e, t) {
    const s = AC(e, t, t);
    s && (this.isLoadingInnerComponent = !0, s.newAgStackInstance().then((i) => {
      this.isLoadingInnerComponent = !1, i && (this.isAlive() ? (this.innerHeaderGroupComponent = i, this.agLabel.appendChild(i.getGui())) : this.destroyBean(i));
    }));
  }
  setupExpandIcons() {
    const {
      agOpened: e,
      agClosed: t,
      params: { columnGroup: s },
      beans: i
    } = this;
    this.addInIcon("columnGroupOpened", e), this.addInIcon("columnGroupClosed", t);
    const o = (l) => {
      if (gt(l))
        return;
      const d = !s.isExpanded();
      i.colGroupSvc.setColumnGroupOpened(
        s.getProvidedColumnGroup(),
        d,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(i, t, o), this.addTouchAndClickListeners(i, e, o);
    const n = (l) => {
      vt(l);
    };
    this.addManagedElementListeners(t, { dblclick: n }), this.addManagedElementListeners(e, { dblclick: n }), this.addManagedElementListeners(this.getGui(), { dblclick: o }), this.updateIconVisibility();
    const r = s.getProvidedColumnGroup(), a = this.updateIconVisibility.bind(this);
    this.addManagedListeners(r, {
      expandedChanged: a,
      expandableChanged: a
    });
  }
  addTouchAndClickListeners(e, t, s) {
    var i;
    (i = e.touchSvc) == null || i.setupForHeaderGroupElement(this, t, s), this.addManagedElementListeners(t, { click: s });
  }
  updateIconVisibility() {
    const {
      agOpened: e,
      agClosed: t,
      params: { columnGroup: s }
    } = this;
    if (s.isExpandable()) {
      const i = s.isExpanded();
      G(e, i), G(t, !i);
    } else
      G(e, !1), G(t, !1);
  }
  addInIcon(e, t) {
    const s = k(e, this.beans, null);
    s && t.appendChild(s);
  }
  addGroupExpandIcon(e) {
    if (!e.columnGroup.isExpandable()) {
      const { agOpened: t, agClosed: s } = this;
      G(t, !1), G(s, !1);
      return;
    }
  }
  setupLabel(e) {
    var o;
    const { displayName: t, columnGroup: s } = e, i = this.innerHeaderGroupComponent || this.isLoadingInnerComponent;
    T(t) && !i && (this.agLabel.textContent = _n(t)), this.toggleCss("ag-sticky-label", !((o = s.getColGroupDef()) != null && o.suppressStickyLabel));
  }
  destroy() {
    super.destroy(), this.innerHeaderGroupComponent && (this.destroyBean(this.innerHeaderGroupComponent), this.innerHeaderGroupComponent = void 0);
  }
}, Ax = {
  moduleName: "ColumnHeaderComp",
  version: Q,
  userComponents: {
    agColumnHeader: Dx
  },
  icons: {
    // button to launch legacy column menu
    menu: "menu",
    // button to launch new enterprise column menu
    menuAlt: "menu-alt"
  }
}, Ix = {
  moduleName: "ColumnGroupHeaderComp",
  version: Q,
  userComponents: {
    agColumnGroupHeader: Ex
  },
  icons: {
    // header column group shown when expanded (click to contract)
    columnGroupOpened: "expanded",
    // header column group shown when contracted (click to expand)
    columnGroupClosed: "contracted"
  }
}, Tx = class extends S {
  constructor() {
    super(...arguments), this.beanName = "animationFrameSvc", this.p1 = { list: [], sorted: !1 }, this.p2 = { list: [], sorted: !1 }, this.f1 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastScrollTop = 0, this.taskCount = 0;
  }
  setScrollTop(e) {
    this.scrollGoingDown = e >= this.lastScrollTop, e === 0 && (this.scrollGoingDown = !0), this.lastScrollTop = e;
  }
  postConstruct() {
    this.active = !this.gos.get("suppressAnimationFrame"), this.batchFrameworkComps = this.beans.frameworkOverrides.batchFrameworkComps;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verify() {
    this.active === !1 && P(92);
  }
  createTask(e, t, s, i) {
    this.verify();
    let o = s;
    i && this.batchFrameworkComps && (o = "f1");
    const n = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[o], n), this.schedule();
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort(
      (s, i) => s.index !== i.index ? t * (i.index - s.index) : i.createOrder - s.createOrder
    ), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verify(), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    const { p1: t, p2: s, f1: i, destroyTasks: o, beans: n } = this, { ctrlsSvc: r, frameworkOverrides: a } = n, l = t.list, d = s.list, c = i.list, u = Date.now();
    let h = 0;
    const g = e <= 0, p = r.getScrollFeature();
    for (; g || h < e; ) {
      if (!p.scrollGridIfNeeded()) {
        let m;
        if (l.length)
          this.sortTaskList(t), m = l.pop().task;
        else if (d.length)
          this.sortTaskList(s), m = d.pop().task;
        else if (c.length)
          a.wrapOutgoing(() => {
            for (; (g || h < e) && !p.scrollGridIfNeeded(); ) {
              if (c.length)
                this.sortTaskList(i), m = c.pop().task, m();
              else
                break;
              h = Date.now() - u;
            }
          }), m = () => {
          };
        else if (o.length)
          m = o.pop();
        else
          break;
        m();
      }
      h = Date.now() - u;
    }
    l.length || d.length || c.length || o.length ? this.requestFrame() : this.ticking = !1;
  }
  flushAllFrames() {
    this.active && this.executeFrame(-1);
  }
  schedule() {
    this.active && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    Ct(this.beans, e);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
}, Lx = {
  moduleName: "AnimationFrame",
  version: Q,
  beans: [Tx]
}, kx = class extends S {
  constructor() {
    super(...arguments), this.beanName = "touchSvc";
  }
  mockBodyContextMenu(e, t) {
    this.mockContextMenu(e, e.eBodyViewport, t);
  }
  mockHeaderContextMenu(e, t) {
    this.mockContextMenu(e, e.eGui, t);
  }
  mockRowContextMenu(e) {
    if (!As())
      return;
    const t = (s, i, o) => {
      var a;
      const { rowCtrl: n, cellCtrl: r } = e.getControlsForEventTarget((o == null ? void 0 : o.target) ?? null);
      r != null && r.column && r.dispatchCellContextMenuEvent(o ?? null), (a = this.beans.contextMenuSvc) == null || a.handleContextMenuMouseEvent(void 0, o, n, r);
    };
    this.mockContextMenu(e, e.element, t);
  }
  handleCellDoubleClick(e, t) {
    return (() => {
      if (!As() || pu("dblclick"))
        return !1;
      const i = Date.now(), o = i - e.lastIPadMouseClickEvent < 200;
      return e.lastIPadMouseClickEvent = i, o;
    })() ? (e.onCellDoubleClicked(t), t.preventDefault(), !0) : !1;
  }
  setupForHeader(e) {
    const { gos: t, sortSvc: s, menuSvc: i } = this.beans;
    if (t.get("suppressTouch"))
      return;
    const { params: o, eMenu: n, eFilterButton: r } = e, a = new Xt(e.getGui(), !0), l = e.shouldSuppressMenuHide(), d = l && T(n) && o.enableMenu, c = d ? new Xt(n, !0) : a;
    if (o.enableMenu || i != null && i.isHeaderContextMenuEnabled(o.column)) {
      const u = d ? "tap" : "longTap", h = (g) => o.showColumnMenuAfterMouseClick(g.touchStart);
      e.addManagedListeners(c, { [u]: h });
    }
    if (o.enableSorting) {
      const u = (h) => {
        const g = h.touchStart.target;
        l && (n != null && n.contains(g) || r != null && r.contains(g)) || s == null || s.progressSort(o.column, !1, "uiColumnSorted");
      };
      e.addManagedListeners(a, { tap: u });
    }
    if (o.enableFilterButton && r) {
      const u = new Xt(r, !0);
      e.addManagedListeners(u, {
        tap: () => o.showFilter(r)
      }), e.addDestroyFunc(() => u.destroy());
    }
    e.addDestroyFunc(() => a.destroy()), d && e.addDestroyFunc(() => c.destroy());
  }
  setupForHeaderGroup(e) {
    var s;
    const t = e.params;
    if ((s = this.beans.menuSvc) != null && s.isHeaderContextMenuEnabled(
      t.columnGroup.getProvidedColumnGroup()
    )) {
      const i = new Xt(t.eGridHeader, !0), o = (n) => t.showColumnMenuAfterMouseClick(n.touchStart);
      e.addManagedListeners(i, { longTap: o }), e.addDestroyFunc(() => i.destroy());
    }
  }
  setupForHeaderGroupElement(e, t, s) {
    const i = new Xt(t, !0);
    e.addManagedListeners(i, { tap: s }), e.addDestroyFunc(() => i.destroy());
  }
  mockContextMenu(e, t, s) {
    if (!As())
      return;
    const i = new Xt(t), o = (n) => {
      uo(this.gos, n.touchEvent) && s(void 0, n.touchStart, n.touchEvent);
    };
    e.addManagedListeners(i, { longTap: o }), e.addDestroyFunc(() => i.destroy());
  }
}, Gx = {
  moduleName: "Touch",
  version: Q,
  beans: [kx]
}, Ox = class extends S {
  constructor() {
    super(...arguments), this.beanName = "cellNavigation";
  }
  wireBeans(e) {
    this.rowSpanSvc = e.rowSpanSvc;
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, s = !1) {
    return s ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const s = e === y.UP, i = e === y.DOWN, o = e === y.LEFT;
    let n, r;
    const { pageBounds: a, gos: l, visibleCols: d } = this.beans;
    if (s || i)
      r = s ? a.getFirstRow() : a.getLastRow(), n = t.column;
    else {
      const c = l.get("enableRtl");
      r = t.rowIndex, n = (o !== c ? d.allCols : [...d.allCols].reverse()).find(
        (h) => this.isCellGoodToFocusOn({
          rowIndex: r,
          rowPinned: null,
          column: h
        })
      );
    }
    return n ? {
      rowIndex: r,
      rowPinned: null,
      column: n
    } : null;
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let s = t, i = !1;
    for (; !i; ) {
      switch (e) {
        case y.UP:
          s = this.getCellAbove(s);
          break;
        case y.DOWN:
          s = this.getCellBelow(s);
          break;
        case y.RIGHT:
          s = this.gos.get("enableRtl") ? this.getCellToLeft(s) : this.getCellToRight(s);
          break;
        case y.LEFT:
          s = this.gos.get("enableRtl") ? this.getCellToRight(s) : this.getCellToLeft(s);
          break;
        default:
          s = null, P(8, { key: e });
          break;
      }
      s ? i = this.isCellGoodToFocusOn(s) : i = !0;
    }
    return s;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let s;
    const { pinnedRowModel: i, rowModel: o } = this.beans;
    switch (e.rowPinned) {
      case "top":
        s = i == null ? void 0 : i.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        s = i == null ? void 0 : i.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        s = o.getRow(e.rowIndex);
        break;
    }
    return s ? !this.isSuppressNavigable(t, s) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.beans.visibleCols.getColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.beans.visibleCols.getColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellBelow(e) {
    var i;
    if (!e)
      return null;
    const t = ((i = this.rowSpanSvc) == null ? void 0 : i.getCellEnd(e)) ?? e, s = Jr(this.beans, t);
    return s ? {
      rowIndex: s.rowIndex,
      column: e.column,
      rowPinned: s.rowPinned
    } : null;
  }
  getCellAbove(e) {
    var i;
    if (!e)
      return null;
    const t = ((i = this.rowSpanSvc) == null ? void 0 : i.getCellStart(e)) ?? e, s = xn(this.beans, {
      rowIndex: t.rowIndex,
      rowPinned: t.rowPinned
    });
    return s ? {
      rowIndex: s.rowIndex,
      column: e.column,
      rowPinned: s.rowPinned
    } : null;
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    const { visibleCols: t, pagination: s } = this.beans, i = t.allCols;
    let o = e.rowIndex, n = e.rowPinned, r = t.getColAfter(e.column);
    if (!r) {
      r = i[0];
      const a = Jr(this.beans, e);
      if (ie(a) || !a.rowPinned && !((s == null ? void 0 : s.isRowInPage(a.rowIndex)) ?? !0))
        return null;
      o = a ? a.rowIndex : null, n = a ? a.rowPinned : null;
    }
    return { rowIndex: o, column: r, rowPinned: n };
  }
  getNextTabbedCellBackwards(e) {
    const { beans: t } = this, { visibleCols: s, pagination: i } = t, o = s.allCols;
    let n = e.rowIndex, r = e.rowPinned, a = s.getColBefore(e.column);
    if (!a) {
      a = Z(o);
      const l = xn(t, { rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (ie(l) || !l.rowPinned && !((i == null ? void 0 : i.isRowInPage(l.rowIndex)) ?? !0))
        return null;
      n = l ? l.rowIndex : null, r = l ? l.rowPinned : null;
    }
    return { rowIndex: n, column: a, rowPinned: r };
  }
  isSuppressNavigable(e, t) {
    const { suppressNavigable: s } = e.colDef;
    if (typeof s == "boolean")
      return s;
    if (typeof s == "function") {
      const i = e.createColumnFunctionCallbackParams(t);
      return s(i);
    }
    return !1;
  }
};
function Bx(e) {
  return e.focusSvc.getFocusedCell();
}
function Nx(e) {
  return e.focusSvc.clearFocusedCell();
}
function Hx(e, t, s, i) {
  e.focusSvc.setFocusedCell({ rowIndex: t, column: s, rowPinned: i, forceBrowserFocus: !0 });
}
function Vx(e, t) {
  var s;
  return ((s = e.navigation) == null ? void 0 : s.tabToNextCell(!1, t)) ?? !1;
}
function _x(e, t) {
  var s;
  return ((s = e.navigation) == null ? void 0 : s.tabToNextCell(!0, t)) ?? !1;
}
function Wx(e, t, s = !1) {
  var o;
  const i = (o = e.headerNavigation) == null ? void 0 : o.getHeaderPositionForColumn(t, s);
  i && e.focusSvc.focusHeaderPosition({ headerPosition: i });
}
var zx = class extends S {
  constructor() {
    super(), this.beanName = "navigation", this.onPageDown = Vl(this.onPageDown, 100), this.onPageUp = Vl(this.onPageUp, 100);
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const s = e.key, i = e.altKey, o = e.ctrlKey || e.metaKey, n = !!this.beans.rangeSvc && e.shiftKey, r = vv(this.gos, e);
    let a = !1;
    switch (s) {
      case y.PAGE_HOME:
      case y.PAGE_END:
        !o && !i && (this.onHomeOrEndKey(s), a = !0);
        break;
      case y.LEFT:
      case y.RIGHT:
      case y.UP:
      case y.DOWN:
        if (!r)
          return !1;
        o && !i && !n && (this.onCtrlUpDownLeftRight(s, r), a = !0);
        break;
      case y.PAGE_DOWN:
      case y.PAGE_UP:
        !o && !i && (a = this.handlePageUpDown(s, r, t));
        break;
    }
    return a && e.preventDefault(), a;
  }
  handlePageUpDown(e, t, s) {
    return s && (t = this.beans.focusSvc.getFocusedCell()), t ? (e === y.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo(e) {
    const { scrollIndex: t, scrollType: s, scrollColumn: i, focusIndex: o, focusColumn: n } = e, { scrollFeature: r } = this.gridBodyCon;
    T(i) && !i.isPinned() && r.ensureColumnVisible(i), T(t) && r.ensureIndexVisible(t, s), e.isAsync || r.ensureIndexVisible(o);
    const { focusSvc: a, rangeSvc: l } = this.beans;
    a.setFocusedCell({
      rowIndex: o,
      column: n,
      rowPinned: null,
      forceBrowserFocus: !0
    }), l == null || l.setRangeToCell({ rowIndex: o, rowPinned: null, column: n });
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const t = this.beans, s = xr(t), i = this.getViewportHeight(), { pageBounds: o, rowModel: n, rowAutoHeight: r } = t, a = o.getPixelOffset(), l = s.top + i, d = n.getRowIndexAtPixel(l + a);
    r != null && r.active ? this.navigateToNextPageWithAutoHeight(e, d) : this.navigateToNextPage(e, d);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const t = this.beans, s = xr(t), { pageBounds: i, rowModel: o, rowAutoHeight: n } = t, r = i.getPixelOffset(), a = s.top, l = o.getRowIndexAtPixel(a + r);
    n != null && n.active ? this.navigateToNextPageWithAutoHeight(e, l, !0) : this.navigateToNextPage(e, l, !0);
  }
  navigateToNextPage(e, t, s = !1) {
    const { pageBounds: i, rowModel: o } = this.beans, n = this.getViewportHeight(), r = i.getFirstRow(), a = i.getLastRow(), l = i.getPixelOffset(), d = o.getRow(e.rowIndex), c = s ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (d == null ? void 0 : d.rowHeight) - n - l
    ) : n - l, u = (d == null ? void 0 : d.rowTop) + c;
    let h = o.getRowIndexAtPixel(u + l);
    if (h === e.rowIndex) {
      const p = s ? -1 : 1;
      t = h = e.rowIndex + p;
    }
    let g;
    s ? (g = "bottom", h < r && (h = r), t < r && (t = r)) : (g = "top", h > a && (h = a), t > a && (t = a)), this.isRowTallerThanView(o.getRow(h)) && (t = h, g = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: g,
      scrollColumn: null,
      focusIndex: h,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, s = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: s ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const i = this.getNextFocusIndexForAutoHeight(e, s);
      this.navigateTo({
        scrollIndex: t,
        scrollType: s ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: i,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    const s = t ? -1 : 1, i = this.getViewportHeight(), { pageBounds: o, rowModel: n } = this.beans, r = o.getLastRow();
    let a = 0, l = e.rowIndex;
    for (; l >= 0 && l <= r; ) {
      const d = n.getRow(l);
      if (d) {
        const c = d.rowHeight ?? 0;
        if (a + c > i)
          break;
        a += c;
      }
      l += s;
    }
    return Math.max(0, Math.min(l, r));
  }
  getViewportHeight() {
    const e = this.beans, t = xr(e), s = this.beans.scrollVisibleSvc.getScrollbarWidth();
    let i = t.bottom - t.top;
    return e.ctrlsSvc.get("center").isHorizontalScrollShowing() && (i -= s), i;
  }
  isRowTallerThanView(e) {
    if (!e)
      return !1;
    const t = e.rowHeight;
    return typeof t != "number" ? !1 : t > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const s = this.beans.cellNavigation.getNextCellToFocus(e, t, !0), { rowIndex: i } = s, o = s.column;
    this.navigateTo({
      scrollIndex: i,
      scrollType: null,
      scrollColumn: o,
      focusIndex: i,
      focusColumn: o
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === y.PAGE_HOME, { visibleCols: s, pageBounds: i, rowModel: o } = this.beans, n = s.allCols, r = t ? i.getFirstRow() : i.getLastRow(), a = o.getRow(r);
    if (!a)
      return;
    const l = (t ? n : [...n].reverse()).find(
      (d) => !d.isSuppressNavigable(a)
    );
    l && this.navigateTo({
      scrollIndex: r,
      scrollType: null,
      scrollColumn: l,
      focusIndex: r,
      focusColumn: l
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const s = t.shiftKey, i = this.tabToNextCellCommon(e, s, t), o = this.beans, { ctrlsSvc: n, pageBounds: r, focusSvc: a, gos: l } = o;
    if (i !== !1) {
      i ? t.preventDefault() : i === null && n.get("gridCtrl").allowFocusForNextCoreContainer(s);
      return;
    }
    if (s) {
      const { rowIndex: d, rowPinned: c } = e.getRowPosition();
      (c ? d === 0 : d === r.getFirstRow()) && (l.get("headerHeight") === 0 || ks(o) ? Tt(o, !0, !0) : (t.preventDefault(), a.focusPreviousFromFirstCell(t)));
    } else
      e instanceof Yo && e.focusCell(!0), (!s && a.focusOverlay(!1) || Tt(o, s)) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const s = this.beans, { focusSvc: i, rowRenderer: o } = s, n = i.getFocusedCell();
    if (!n)
      return !1;
    let r = To(s, n);
    return !r && (r = o.getRowByPosition(n), !r || !r.isFullWidth()) ? !1 : !!this.tabToNextCellCommon(r, e, t);
  }
  tabToNextCellCommon(e, t, s) {
    let i = e.editing;
    if (!i && e instanceof Yo) {
      const r = e.rowCtrl;
      r && (i = r.editing);
    }
    let o;
    return i ? this.gos.get("editType") === "fullRow" ? o = this.moveToNextEditingRow(e, t, s) : o = this.moveToNextEditingCell(e, t, s) : o = this.moveToNextCellNotEditing(e, t, s), o === null ? o : o || !!this.beans.focusSvc.focusedHeader;
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, s = null) {
    var n;
    const i = e.cellPosition;
    e.eGui.focus(), e.stopEditing();
    const o = this.findNextCellToFocusOn(i, t, !0);
    return o === !1 ? null : o == null ? !1 : ((n = this.beans.editSvc) == null || n.startEditing(o, null, !0, s), o.focusCell(!1), !0);
  }
  // returns null if no navigation should be performed
  moveToNextEditingRow(e, t, s = null) {
    const i = e.cellPosition, o = this.findNextCellToFocusOn(i, t, !0);
    if (o === !1)
      return null;
    if (o == null)
      return !1;
    const n = o.cellPosition, r = this.isCellEditable(i), a = this.isCellEditable(n), l = n && i.rowIndex === n.rowIndex && i.rowPinned === n.rowPinned, { editSvc: d, rowEditSvc: c } = this.beans;
    if (r && (d == null || d.setFocusOutOnEditor(e)), !l) {
      const u = e.rowCtrl;
      d == null || d.stopRowEditing(u);
      const h = o.rowCtrl;
      c == null || c.startEditing(h, void 0, void 0, s);
    }
    return a ? (d == null || d.setFocusInOnEditor(o), o.focusCell()) : o.focusCell(!0), !0;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(e, t, s) {
    const i = this.beans.visibleCols.allCols;
    let o;
    if (e instanceof ea) {
      if (o = {
        ...e.getRowPosition(),
        column: t ? i[0] : Z(i)
      }, this.gos.get("embedFullWidthRows") && s) {
        const r = e.findFullWidthInfoForEvent(s);
        r && (o.column = r.column);
      }
    } else
      o = e.getFocusedCellPosition();
    const n = this.findNextCellToFocusOn(o, t, !1);
    if (n === !1)
      return null;
    if (n instanceof Yo)
      n.focusCell(!0);
    else if (n)
      return this.tryToFocusFullWidthRow(n, t);
    return T(n);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(e, t, s) {
    let i = e;
    const o = this.beans, { cellNavigation: n, gos: r, focusSvc: a, rowRenderer: l, rangeSvc: d } = o;
    for (; ; ) {
      e !== i && (e = i), t || (i = this.getLastCellOfColSpan(i)), i = n.getNextTabbedCell(i, t);
      const c = r.getCallback("tabToNextCell");
      if (T(c)) {
        const p = c({
          backwards: t,
          editing: s,
          previousCellPosition: e,
          nextCellPosition: i || null
        });
        if (p === !0)
          i = e;
        else {
          if (p === !1)
            return !1;
          i = {
            rowIndex: p.rowIndex,
            column: p.column,
            rowPinned: p.rowPinned
          };
        }
      }
      if (!i)
        return null;
      if (i.rowIndex < 0) {
        const g = Mt(o);
        return a.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: g + i.rowIndex,
            column: i.column
          },
          fromCell: !0
        }), null;
      }
      const u = r.get("editType") === "fullRow";
      if (s && !u && !this.isCellEditable(i))
        continue;
      this.ensureCellVisible(i);
      const h = To(o, i);
      if (!h) {
        const g = l.getRowByPosition(i);
        if (!g || !g.isFullWidth() || s)
          continue;
        return { ...g.getRowPosition(), column: i == null ? void 0 : i.column };
      }
      if (!n.isSuppressNavigable(h.column, h.rowNode))
        return h.setFocusedCellPosition(i), d == null || d.setRangeToCell(i), h;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  lookupRowNodeForCell({ rowIndex: e, rowPinned: t }) {
    const { pinnedRowModel: s, rowModel: i } = this.beans;
    return t === "top" ? s == null ? void 0 : s.getPinnedTopRow(e) : t === "bottom" ? s == null ? void 0 : s.getPinnedBottomRow(e) : i.getRow(e);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, s, i) {
    let o = s, n = !1;
    const r = this.beans, { cellNavigation: a, focusSvc: l, gos: d } = r;
    for (; o && (o === s || !this.isValidNavigateCell(o)); )
      d.get("enableRtl") ? t === y.LEFT && (o = this.getLastCellOfColSpan(o)) : t === y.RIGHT && (o = this.getLastCellOfColSpan(o)), o = a.getNextCellToFocus(t, o), n = ie(o);
    if (n && e && e.key === y.UP && (o = {
      rowIndex: -1,
      rowPinned: null,
      column: s.column
    }), i) {
      const u = d.getCallback("navigateToNextCell");
      if (T(u)) {
        const g = u({
          key: t,
          previousCellPosition: s,
          nextCellPosition: o || null,
          event: e
        });
        T(g) ? o = {
          rowPinned: g.rowPinned,
          rowIndex: g.rowIndex,
          column: g.column
        } : o = null;
      }
    }
    if (!o)
      return;
    if (o.rowIndex < 0) {
      const u = Mt(r);
      l.focusHeaderPosition({
        headerPosition: { headerRowIndex: u + o.rowIndex, column: s.column },
        event: e || void 0,
        fromCell: !0
      });
      return;
    }
    const c = this.getNormalisedPosition(o);
    c ? this.focusPosition(c) : this.tryToFocusFullWidthRow(o);
  }
  getNormalisedPosition(e) {
    var i;
    if (!!((i = this.beans.spannedRowRenderer) != null && i.getCellByPosition(e)))
      return e;
    this.ensureCellVisible(e);
    const s = To(this.beans, e);
    return s ? (e = s.getFocusedCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t) {
    const { visibleCols: s, rowRenderer: i, focusSvc: o, eventSvc: n } = this.beans, r = s.allCols, a = i.getRowByPosition(e);
    if (!a || !a.isFullWidth())
      return !1;
    const l = o.getFocusedCell(), d = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? Z(r) : r[0])
    };
    this.focusPosition(d);
    const c = t ?? (l != null && Zu(d, l));
    return n.dispatchEvent({
      type: "fullWidthRowFocused",
      rowIndex: d.rowIndex,
      rowPinned: d.rowPinned,
      column: d.column,
      isFullWidthCell: !0,
      fromBelow: c
    }), !0;
  }
  focusPosition(e) {
    const { focusSvc: t, rangeSvc: s } = this.beans;
    t.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), s == null || s.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!zn(this.beans, e);
  }
  getLastCellOfColSpan(e) {
    const t = To(this.beans, e);
    if (!t)
      return e;
    const s = t.getColSpanningList();
    return s.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: Z(s),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = Vn(this.gos), s = this.beans.rowModel.getRow(e.rowIndex), i = t && (s == null ? void 0 : s.sticky), { scrollFeature: o } = this.gridBodyCon;
    !i && ie(e.rowPinned) && o.ensureIndexVisible(e.rowIndex), e.column.isPinned() || o.ensureColumnVisible(e.column);
  }
};
function xr(e) {
  return e.ctrlsSvc.getScrollFeature().getVScrollPosition();
}
var Yh = {
  moduleName: "KeyboardNavigation",
  version: Q,
  beans: [zx, Ox, jS],
  apiFunctions: {
    getFocusedCell: Bx,
    clearFocusedCell: Nx,
    setFocusedCell: Hx,
    setFocusedHeader: Wx,
    tabToNextCell: Vx,
    tabToPreviousCell: _x
  }
}, Ux = class extends S {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsListener";
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    }), this.onModelUpdated();
  }
  onModelUpdated(e) {
    this.calculatePages(), this.eventSvc.dispatchEvent({
      type: "paginationChanged",
      animate: (e == null ? void 0 : e.animate) ?? !1,
      newData: (e == null ? void 0 : e.newData) ?? !1,
      newPage: (e == null ? void 0 : e.newPage) ?? !1,
      newPageSize: (e == null ? void 0 : e.newPageSize) ?? !1,
      keepRenderedRows: (e == null ? void 0 : e.keepRenderedRows) ?? !1
    });
  }
  calculatePages() {
    const { pageBounds: e, pagination: t, rowModel: s } = this.beans;
    t ? t.calculatePages() : e.calculateBounds(0, s.getRowCount() - 1);
  }
}, jx = class extends S {
  constructor() {
    super(...arguments), this.beanName = "pageBounds", this.pixelOffset = 0;
  }
  getFirstRow() {
    var e;
    return ((e = this.topRowBounds) == null ? void 0 : e.rowIndex) ?? -1;
  }
  getLastRow() {
    var e;
    return ((e = this.bottomRowBounds) == null ? void 0 : e.rowIndex) ?? -1;
  }
  getCurrentPageHeight() {
    const { topRowBounds: e, bottomRowBounds: t } = this;
    return !e || !t ? 0 : Math.max(t.rowTop + t.rowHeight - e.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const { topRowBounds: e, bottomRowBounds: t } = this, s = (e == null ? void 0 : e.rowTop) ?? 0, i = t ? t.rowTop + t.rowHeight : 0;
    return { pageFirstPixel: s, pageLastPixel: i };
  }
  calculateBounds(e, t) {
    const { rowModel: s } = this.beans, i = s.getRowBounds(e);
    i && (i.rowIndex = e), this.topRowBounds = i;
    const o = s.getRowBounds(t);
    o && (o.rowIndex = t), this.bottomRowBounds = o, this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    var t;
    const e = ((t = this.topRowBounds) == null ? void 0 : t.rowTop) ?? 0;
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventSvc.dispatchEvent({ type: "paginationPixelOffsetChanged" }));
  }
}, $x = (
  /*css*/
  ".ag-pinned-left-floating-bottom,.ag-pinned-left-floating-top,.ag-pinned-right-floating-bottom,.ag-pinned-right-floating-top{min-width:0;overflow:hidden;position:relative}.ag-pinned-left-sticky-top,.ag-pinned-right-sticky-top{height:100%;overflow:hidden;position:relative}.ag-sticky-bottom-full-width-container,.ag-sticky-top-full-width-container{height:100%;overflow:hidden;width:100%}.ag-pinned-left-header,.ag-pinned-right-header{display:inline-block;height:100%;overflow:hidden;position:relative}.ag-body-horizontal-scroll:not(.ag-scrollbar-invisible){.ag-horizontal-left-spacer:not(.ag-scroller-corner){border-right:var(--ag-pinned-column-border)}.ag-horizontal-right-spacer:not(.ag-scroller-corner){border-left:var(--ag-pinned-column-border)}}.ag-pinned-right-header{border-left:var(--ag-pinned-column-border)}.ag-pinned-left-header{border-right:var(--ag-pinned-column-border)}.ag-cell.ag-cell-first-right-pinned:not(.ag-cell-range-left,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-left:var(--ag-pinned-column-border)}.ag-cell.ag-cell-last-left-pinned:not(.ag-cell-range-right,.ag-cell-range-single-cell,.ag-cell-focus:not(.ag-cell-range-selected):focus-within){border-right:var(--ag-pinned-column-border)}.ag-pinned-left-header .ag-header-cell-resize:after{left:calc(50% - var(--ag-header-column-resize-handle-width))}.ag-pinned-right-header .ag-header-cell-resize:after{left:50%}.ag-pinned-left-header .ag-header-cell-resize{right:-3px}.ag-pinned-right-header .ag-header-cell-resize{left:-3px}"
), Kx = class extends S {
  constructor(e, t) {
    super(), this.isLeft = e, this.elements = t, this.getWidth = e ? () => this.beans.pinnedCols.leftWidth : () => this.beans.pinnedCols.rightWidth;
  }
  postConstruct() {
    this.addManagedEventListeners({
      [`${this.isLeft ? "left" : "right"}PinnedWidthChanged`]: this.onPinnedWidthChanged.bind(this)
    });
  }
  onPinnedWidthChanged() {
    const e = this.getWidth(), t = e > 0;
    for (const s of this.elements)
      s && (G(s, t), Et(s, e));
  }
}, qx = class extends S {
  constructor() {
    super(...arguments), this.beanName = "pinnedCols";
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (t) => {
      this.gridBodyCtrl = t.gridBodyCtrl;
    });
    const e = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e
    }), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const { gos: e, visibleCols: t, eventSvc: s } = this.beans, i = xe(e, "print"), o = i ? 0 : t.getColsLeftWidth(), n = i ? 0 : t.getDisplayedColumnsRightWidth();
    o != this.leftWidth && (this.leftWidth = o, s.dispatchEvent({ type: "leftPinnedWidthChanged" })), n != this.rightWidth && (this.rightWidth = n, s.dispatchEvent({ type: "rightPinnedWidthChanged" }));
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.eBodyViewport, t = io(e);
    if (t <= 50)
      return;
    const s = this.getPinnedColumnsOverflowingViewport(t - 50), i = this.gos.getCallback("processUnpinnedColumns"), { columns: o, hasLockedPinned: n } = s;
    let r = o;
    !r.length && !n || (i && (r = i({
      columns: r,
      viewportWidth: t
    })), !(!r || !r.length) && (r = r.filter((a) => !qi(a)), this.setColsPinned(r, null, "viewportSizeFeature")));
  }
  createPinnedWidthFeature(e, ...t) {
    return new Kx(e, t);
  }
  setColsPinned(e, t, s) {
    const { colModel: i, colAnimation: o, visibleCols: n, gos: r } = this.beans;
    if (!i.cols || !(e != null && e.length))
      return;
    if (xe(r, "print")) {
      P(37);
      return;
    }
    o == null || o.start();
    let a;
    t === !0 || t === "left" ? a = "left" : t === "right" ? a = "right" : a = null;
    const l = [];
    e.forEach((d) => {
      if (!d)
        return;
      const c = i.getCol(d);
      c && c.getPinned() !== a && (this.setColPinned(c, a), l.push(c));
    }), l.length && (n.refresh(s), Iu(this.eventSvc, l, s)), o == null || o.finish();
  }
  initCol(e) {
    const { pinned: t, initialPinned: s } = e.colDef;
    t !== void 0 ? this.setColPinned(e, t) : this.setColPinned(e, s);
  }
  setColPinned(e, t) {
    t === !0 || t === "left" ? e.pinned = "left" : t === "right" ? e.pinned = "right" : e.pinned = null, e.dispatchStateUpdatedEvent("pinned");
  }
  setupHeaderPinnedWidth(e) {
    const { scrollVisibleSvc: t } = this.beans;
    if (e.pinned == null)
      return;
    const s = e.pinned === "left", i = e.pinned === "right";
    e.hidden = !0;
    const o = () => {
      const n = s ? this.leftWidth : this.rightWidth;
      if (n == null)
        return;
      const r = n == 0, a = e.hidden !== r, l = this.gos.get("enableRtl"), d = t.getScrollbarWidth(), u = t.verticalScrollShowing && (l && s || !l && i) ? n + d : n;
      e.comp.setPinnedContainerWidth(`${u}px`), e.comp.setDisplayed(!r), a && (e.hidden = r, e.refresh());
    };
    e.addManagedEventListeners({
      leftPinnedWidthChanged: o,
      rightPinnedWidthChanged: o,
      scrollVisibilityChanged: o,
      scrollbarWidthChanged: o
    });
  }
  getHeaderResizeDiff(e, t) {
    if (t.getPinned()) {
      const { leftWidth: i, rightWidth: o } = this, n = io(this.beans.ctrlsSvc.getGridBodyCtrl().eBodyViewport) - 50;
      if (i + o + e > n)
        if (n > i + o)
          e = n - i - o;
        else
          return 0;
    }
    return e;
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.rightWidth ?? 0, s = this.leftWidth ?? 0, i = t + s;
    let o = !1;
    if (i < e)
      return { columns: [], hasLockedPinned: o };
    const { visibleCols: n } = this.beans, r = [...n.leftCols], a = [...n.rightCols];
    let l = 0, d = 0;
    const c = 0, u = [];
    let h = i - c - e;
    for (; (d < r.length || l < a.length) && h > 0; ) {
      if (l < a.length) {
        const g = a[l++];
        if (g.colDef.lockPinned) {
          o = !0;
          continue;
        }
        h -= g.getActualWidth(), u.push(g);
      }
      if (d < r.length && h > 0) {
        const g = r[d++];
        if (g.colDef.lockPinned) {
          o = !0;
          continue;
        }
        h -= g.getActualWidth(), u.push(g);
      }
    }
    return { columns: u, hasLockedPinned: o };
  }
}, Yx = {
  moduleName: "PinnedColumn",
  version: Q,
  beans: [qx],
  css: [$x]
}, Zx = class extends S {
  constructor() {
    super(), this.beanName = "ariaAnnounce", this.descriptionContainer = null, this.pendingAnnouncements = /* @__PURE__ */ new Map(), this.lastAnnouncement = "", this.updateAnnouncement = ct(this, this.updateAnnouncement.bind(this), 200);
  }
  postConstruct() {
    const e = this.beans, t = pe(e), s = this.descriptionContainer = t.createElement("div");
    s.classList.add("ag-aria-description-container"), Gc(s, "polite"), Yf(s, "additions text"), qf(s, !0), e.eGridDiv.appendChild(s);
  }
  /**
   * @param key used for debouncing calls
   */
  announceValue(e, t) {
    this.pendingAnnouncements.set(t, e), this.updateAnnouncement();
  }
  updateAnnouncement() {
    if (!this.descriptionContainer)
      return;
    const e = Array.from(this.pendingAnnouncements.values()).join(". ");
    this.pendingAnnouncements.clear(), this.descriptionContainer.textContent = "", setTimeout(() => {
      if (this.isAlive() && this.descriptionContainer) {
        let t = e;
        this.lastAnnouncement === t && (t = `${t}.`), this.lastAnnouncement = t, this.descriptionContainer.textContent = t;
      }
    }, 50);
  }
  destroy() {
    var t;
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (de(e), (t = e.parentElement) == null || t.removeChild(e)), this.descriptionContainer = null, this.pendingAnnouncements.clear();
  }
}, Qx = {
  moduleName: "Aria",
  version: Q,
  beans: [Zx]
};
function Xx(e) {
  var t;
  (t = e.overlays) == null || t.showLoadingOverlay();
}
function Jx(e) {
  var t;
  (t = e.overlays) == null || t.showNoRowsOverlay();
}
function eR(e) {
  var t;
  (t = e.overlays) == null || t.hideOverlay();
}
var tR = (
  /*css*/
  ".ag-overlay{inset:0;pointer-events:none;position:absolute;z-index:2}.ag-overlay-panel,.ag-overlay-wrapper{display:flex;height:100%;width:100%}.ag-overlay-wrapper{align-items:center;flex:none;justify-content:center;text-align:center}.ag-overlay-loading-wrapper{pointer-events:all}.ag-overlay-loading-center{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-popup-shadow);padding:var(--ag-spacing)}"
), sR = {
  tag: "div",
  cls: "ag-overlay",
  role: "presentation",
  children: [
    {
      tag: "div",
      cls: "ag-overlay-panel",
      role: "presentation",
      children: [{ tag: "div", ref: "eOverlayWrapper", cls: "ag-overlay-wrapper", role: "presentation" }]
    }
  ]
}, Zh = class extends L {
  constructor() {
    super(sR), this.eOverlayWrapper = x, this.activePromise = null, this.activeOverlay = null, this.updateListenerDestroyFunc = null, this.activeCssClass = null, this.elToFocusAfter = null, this.registerCSS(tR);
  }
  handleKeyDown(e) {
    if (e.key !== y.TAB || e.defaultPrevented || gt(e))
      return;
    const t = this.beans;
    if (Be(t, this.eOverlayWrapper, !1, e.shiftKey))
      return;
    let i = !1;
    e.shiftKey ? i = t.focusSvc.focusGridView({
      column: Z(t.visibleCols.allCols),
      backwards: !0,
      canFocusOverlay: !1
    }) : i = Tt(t, !1), i && e.preventDefault();
  }
  updateLayoutClasses(e, t) {
    const s = this.eOverlayWrapper.classList, { AUTO_HEIGHT: i, NORMAL: o, PRINT: n } = lt;
    s.toggle(i, t.autoHeight), s.toggle(o, t.normal), s.toggle(n, t.print);
  }
  postConstruct() {
    this.createManagedBean(new qa(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.beans.overlays.setOverlayWrapperComp(this), this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    this.activeCssClass && t.toggle(this.activeCssClass, !1), this.activeCssClass = e, t.toggle(e, !0);
  }
  showOverlay(e, t, s, i) {
    if (this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.elToFocusAfter = null, this.activePromise = e, !!e) {
      if (this.setDisplayed(!0, { skipAriaHidden: !0 }), s && this.isGridFocused()) {
        const o = te(this.beans);
        o && !yi(this.beans) && (this.elToFocusAfter = o);
      }
      e.then((o) => {
        if (this.activePromise !== e) {
          this.activeOverlay !== o && (this.destroyBean(o), o = null);
          return;
        }
        if (this.activePromise = null, !!o) {
          if (this.activeOverlay !== o && (this.eOverlayWrapper.appendChild(o.getGui()), this.activeOverlay = o, i)) {
            const n = o;
            this.updateListenerDestroyFunc = this.addManagedPropertyListener(i, ({ currentValue: r }) => {
              var a;
              (a = n.refresh) == null || a.call(n, N(this.gos, { ...r ?? {} }));
            });
          }
          s && this.isGridFocused() && Ve(this.eOverlayWrapper);
        }
      });
    }
  }
  updateOverlayWrapperPaddingTop(e) {
    this.eOverlayWrapper.style.setProperty("padding-top", `${e}px`);
  }
  destroyActiveOverlay() {
    var i;
    this.activePromise = null;
    const e = this.activeOverlay;
    if (!e)
      return;
    let t = this.elToFocusAfter;
    this.activeOverlay = null, this.elToFocusAfter = null, t && !this.isGridFocused() && (t = null);
    const s = this.updateListenerDestroyFunc;
    s && (s(), this.updateListenerDestroyFunc = null), this.destroyBean(e), de(this.eOverlayWrapper), (i = t == null ? void 0 : t.focus) == null || i.call(t, { preventScroll: !0 });
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  isGridFocused() {
    const e = te(this.beans);
    return !!e && this.beans.eGridDiv.contains(e);
  }
  destroy() {
    this.elToFocusAfter = null, this.destroyActiveOverlay(), this.beans.overlays.setOverlayWrapperComp(void 0), super.destroy();
  }
}, iR = {
  selector: "AG-OVERLAY-WRAPPER",
  component: Zh
}, oR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "overlays", this.state = 0, this.showInitialOverlay = !0, this.wrapperPadding = 0;
  }
  postConstruct() {
    this.isClientSide = Ke(this.gos), this.isServerSide = !this.isClientSide && nt(this.gos);
    const e = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      rowDataUpdated: e,
      gridSizeChanged: this.refreshWrapperPadding.bind(this),
      rowCountReady: () => {
        this.showInitialOverlay = !1, this.updateOverlayVisibility();
      }
    }), this.addManagedPropertyListener("loading", e);
  }
  setOverlayWrapperComp(e) {
    this.eWrapper = e, this.updateOverlayVisibility();
  }
  /** Returns true if the overlay is visible. */
  isVisible() {
    return this.state !== 0 && !!this.eWrapper;
  }
  /** Returns true if the overlay is visible and is exclusive (popup over the grid) */
  isExclusive() {
    return this.state === 1 && !!this.eWrapper;
  }
  showLoadingOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos, t = e.get("loading");
    !t && (t !== void 0 || e.get("suppressLoadingOverlay")) || this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos;
    e.get("loading") || e.get("suppressNoRowsOverlay") || this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    if (this.showInitialOverlay = !1, this.gos.get("loading")) {
      P(99);
      return;
    }
    this.doHideOverlay();
  }
  getOverlayWrapperSelector() {
    return iR;
  }
  getOverlayWrapperCompClass() {
    return Zh;
  }
  updateOverlayVisibility() {
    if (!this.eWrapper) {
      this.state = 0;
      return;
    }
    const {
      state: e,
      isClientSide: t,
      isServerSide: s,
      beans: { gos: i, colModel: o, rowModel: n }
    } = this;
    let r = this.gos.get("loading");
    r !== void 0 && (this.showInitialOverlay = !1), this.showInitialOverlay && r === void 0 && !i.get("suppressLoadingOverlay") && (r = !i.get("columnDefs") || !o.ready || !i.get("rowData") && t), r ? e !== 1 && this.doShowLoadingOverlay() : (this.showInitialOverlay = !1, t && n.isEmpty() && !i.get("suppressNoRowsOverlay") ? e !== 2 && this.doShowNoRowsOverlay() : (e === 1 || !s && e !== 0) && this.doHideOverlay());
  }
  doShowLoadingOverlay() {
    this.eWrapper && (this.state = 1, this.showOverlay(
      OC(this.beans.userCompFactory, N(this.gos, {})),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    ), this.updateExclusive());
  }
  doShowNoRowsOverlay() {
    this.eWrapper && (this.state = 2, this.showOverlay(
      BC(this.beans.userCompFactory, N(this.gos, {})),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    ), this.updateExclusive());
  }
  doHideOverlay() {
    this.eWrapper && (this.state = 0, this.eWrapper.hideOverlay(), this.updateExclusive());
  }
  showOverlay(e, t, s) {
    var o;
    const i = (e == null ? void 0 : e.newAgStackInstance()) ?? null;
    (o = this.eWrapper) == null || o.showOverlay(i, t, this.isExclusive(), s), this.refreshWrapperPadding();
  }
  updateExclusive() {
    const e = this.exclusive;
    this.exclusive = this.isExclusive(), this.exclusive !== e && this.eventSvc.dispatchEvent({
      type: "overlayExclusiveChanged"
    });
  }
  refreshWrapperPadding() {
    const e = this.eWrapper;
    if (!e)
      return;
    let t = 0;
    if (this.state === 2) {
      const s = this.beans.ctrlsSvc.get("gridHeaderCtrl");
      t = (s == null ? void 0 : s.headerHeight) || 0;
    } else this.wrapperPadding !== 0 && (t = 0);
    this.wrapperPadding !== t && (this.wrapperPadding = t, e.updateOverlayWrapperPaddingTop(t));
  }
}, nR = {
  moduleName: "Overlay",
  version: Q,
  userComponents: {
    agLoadingOverlay: Aw,
    agNoRowsOverlay: Tw
  },
  apiFunctions: {
    showLoadingOverlay: Xx,
    showNoRowsOverlay: Jx,
    hideOverlay: eR
  },
  beans: [oR]
}, rR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "rowContainerHeight", this.scrollY = 0, this.uiBodyHeight = 0;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) }), this.maxDivHeight = am(), oo(this.gos, "RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const e = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition().top, t = this.getUiBodyHeight();
    (e !== this.scrollY || t !== this.uiBodyHeight) && (this.scrollY = e, this.uiBodyHeight = t, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    oo(
      this.gos,
      `RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`
    ), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventSvc.dispatchEvent({ type: "rowContainerHeightChanged" }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventSvc.dispatchEvent({ type: "heightScaleChanged" }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && // null happens when in print layout
    this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const e = this.beans.ctrlsSvc.getScrollFeature().getVScrollPosition();
    return e.bottom - e.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), s = e / t;
    return this.maxScrollY * s;
  }
}, aR = 400, lR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "rowRenderer", this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((n) => n.onCellSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((n) => n.updateRangeBordersIfRangeCount());
      }, s = () => {
        this.eventSvc.addEventListener("cellSelectionChanged", e), this.eventSvc.addEventListener("columnMoved", t), this.eventSvc.addEventListener("columnPinned", t), this.eventSvc.addEventListener("columnVisible", t);
      }, i = () => {
        this.eventSvc.removeEventListener("cellSelectionChanged", e), this.eventSvc.removeEventListener("columnMoved", t), this.eventSvc.removeEventListener("columnPinned", t), this.eventSvc.removeEventListener("columnVisible", t);
      };
      this.addDestroyFunc(() => i()), this.addManagedPropertyListeners(["enableRangeSelection", "cellSelection"], () => {
        xi(this.gos) ? s() : i();
      }), xi(this.gos) && s();
    };
  }
  wireBeans(e) {
    this.pageBounds = e.pageBounds, this.colModel = e.colModel, this.pinnedRowModel = e.pinnedRowModel, this.rowModel = e.rowModel, this.focusSvc = e.focusSvc, this.rowContainerHeight = e.rowContainerHeight, this.ctrlsSvc = e.ctrlsSvc;
  }
  postConstruct() {
    this.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      pinnedRowsChanged: this.onPinnedRowsChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this, {})
    }), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListener("suppressCellFocus", (i) => this.onSuppressCellFocusChanged(i.currentValue)), this.addManagedPropertyListeners(
      [
        "groupSuppressBlankHeader",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ],
      () => this.redrawRows()
    ), this.addManagedPropertyListener("cellSelection", ({ currentValue: i, previousValue: o }) => {
      (!o && i || o && !i) && this.redrawRows();
    });
    const { stickyRowSvc: e, gos: t, showRowGroupCols: s } = this.beans;
    if (s && this.addManagedPropertyListener("showOpenedGroup", () => {
      const i = s.getShowRowGroupCols();
      i.length && this.refreshCells({ columns: i, force: !0 });
    }), e)
      this.stickyRowFeature = e.createStickyRowFeature(
        this,
        this.createRowCon.bind(this),
        this.destroyRowCtrls.bind(this)
      );
    else {
      const i = this.gridBodyCtrl;
      i.setStickyTopHeight(0), i.setStickyBottomHeight(0);
    }
    this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = xe(t, "print"), this.embedFullWidthRows = this.printLayout || t.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new dR(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    var e;
    return ((e = this.stickyRowFeature) == null ? void 0 : e.stickyTopRowCtrls) ?? [];
  }
  getStickyBottomRowCtrls() {
    var e;
    return ((e = this.stickyRowFeature) == null ? void 0 : e.stickyBottomRowCtrls) ?? [];
  }
  updateAllRowCtrls() {
    var i;
    const e = Object.values(this.rowCtrlsByRowIndex), t = Object.values(this.zombieRowCtrls), s = ((i = this.cachedRowCtrls) == null ? void 0 : i.getEntries()) ?? [];
    t.length > 0 || s.length > 0 ? this.allRowCtrls = [...e, ...t, ...s] : this.allRowCtrls = e;
  }
  /**
   * Checks if the cell is rendered or not. Also returns true if row ctrl is present but has not rendered
   * cells yet.
   * @returns true if cellCtrl is present, or if the row is present but has not rendered rows yet
   */
  isCellBeingRendered(e, t) {
    var o;
    const s = this.rowCtrlsByRowIndex[e];
    return !t || !s ? !!s : s.isFullWidth() ? !0 : !!((o = this.beans.spannedRowRenderer) == null ? void 0 : o.getCellByPosition({ rowIndex: e, column: t, rowPinned: null })) || !!s.getCellCtrl(t) || !s.isRowRendered();
  }
  /**
   * Notifies all row and cell controls of any change in focused cell.
   * @param event cell focused event
   */
  updateCellFocus(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  /**
   * Called when a new cell is focused in the grid
   * - if the focused cell isn't rendered; re-draw rows to dry to render it
   * - subsequently updates all cell and row controls with the new focused cell
   * @param event cell focused event
   */
  onCellFocusChanged(e) {
    if (e && e.rowIndex != null && !e.rowPinned) {
      const t = this.beans.colModel.getCol(e.column) ?? void 0;
      this.isCellBeingRendered(e.rowIndex, t) || this.redraw();
    }
    this.updateCellFocus(e);
  }
  onSuppressCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onSuppressCellFocusChanged(e)), this.getFullWidthRowCtrls().forEach((t) => t.onSuppressCellFocusChanged(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (e) => this.onCellFocusChanged(e),
      cellFocusCleared: () => this.updateCellFocus(),
      flashCells: (e) => {
        const { cellFlashSvc: t } = this.beans;
        t && this.getAllCellCtrls().forEach((s) => t.onFlashCells(s, e));
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
      }
    }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    }), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.colModel.getCols().forEach((t) => {
      const s = (l) => {
        this.getAllCellCtrls().forEach((d) => {
          d.column === t && l(d);
        });
      }, i = () => {
        s((l) => l.onLeftChanged());
      }, o = () => {
        s((l) => l.onWidthChanged());
      }, n = () => {
        s((l) => l.onFirstRightPinnedChanged());
      }, r = () => {
        s((l) => l.onLastLeftPinnedChanged());
      }, a = () => {
        s((l) => l.onColDefChanged());
      };
      t.__addEventListener("leftChanged", i), t.__addEventListener("widthChanged", o), t.__addEventListener("firstRightPinnedChanged", n), t.__addEventListener("lastLeftPinnedChanged", r), t.__addEventListener("colDefChanged", a), this.destroyFuncsForColumnListeners.push(() => {
        t.__removeEventListener("leftChanged", i), t.__removeEventListener("widthChanged", o), t.__removeEventListener("firstRightPinnedChanged", n), t.__removeEventListener("lastLeftPinnedChanged", r), t.__removeEventListener("colDefChanged", a);
      });
    });
  }
  onDomLayoutChanged() {
    const e = xe(this.gos, "print"), t = e || this.gos.get("embedFullWidthRows"), s = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, s && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  /**
   * @param column AgColumn
   * @returns An array with HTMLElement for every cell of the column passed as param.
   * If the cell is spanning across multiple columns, it only returns the html element
   * if the column passed is the first column of the span (used for auto width calculation).
   */
  getAllCellsNotSpanningForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((s) => {
      var o;
      const i = (o = s.getCellCtrl(e, !0)) == null ? void 0 : o.eGui;
      i && t.push(i);
    }), t;
  }
  refreshFloatingRowComps(e = !0) {
    this.refreshFloatingRows(this.topRowCtrls, "top", e), this.refreshFloatingRows(this.bottomRowCtrls, "bottom", e);
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(e, t, s) {
    const { pinnedRowModel: i, beans: o, printLayout: n } = this, r = Object.fromEntries(e.map((l) => [l.rowNode.id, l]));
    i == null || i.forEachPinnedRow(t, (l, d) => {
      const c = e[d];
      c && i.getPinnedRowById(c.rowNode.id, t) === void 0 && (c.destroyFirstPass(), c.destroySecondPass()), l.id in r && s ? (e[d] = r[l.id], delete r[l.id]) : e[d] = new ea(l, o, !1, !1, n);
    });
    const a = (t === "top" ? i == null ? void 0 : i.getPinnedTopRowCount() : i == null ? void 0 : i.getPinnedBottomRowCount()) ?? 0;
    e.length = a;
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  onPinnedRowsChanged() {
    this.redrawAfterModelUpdate({ recycleRows: !0 });
  }
  redrawRow(e, t = !1) {
    var s, i;
    if (e.sticky)
      (s = this.stickyRowFeature) == null || s.refreshStickyNode(e);
    else if ((i = this.cachedRowCtrls) != null && i.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const o = (n) => {
        const r = n[e.rowIndex];
        r && r.rowNode === e && (r.destroyFirstPass(), r.destroySecondPass(), n[e.rowIndex] = this.createRowCon(e, !1, !1));
      };
      switch (e.rowPinned) {
        case "top":
          o(this.topRowCtrls);
          break;
        case "bottom":
          o(this.bottomRowCtrls);
          break;
        default:
          o(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(!1);
  }
  redrawRows(e) {
    if (e != null) {
      e == null || e.forEach((s) => this.redrawRow(s, !0)), this.dispatchDisplayedRowsChanged(!1);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    var a;
    this.getLockOnRefresh();
    const t = (a = this.beans.focusSvc) == null ? void 0 : a.getFocusCellToUseAfterRefresh();
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const s = !e.domLayoutChanged && !!e.recycleRows, i = e.animate && ci(this.gos), o = s ? this.getRowsToRecycle() : null;
    s || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender();
    const { stickyRowFeature: n, gos: r } = this;
    if (n) {
      n.checkStickyRows();
      const l = n.extraTopHeight + n.extraBottomHeight;
      l && this.updateContainerHeights(l);
    }
    this.recycleRows(o, i), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(r.get("enableRowPinning") ? s : void 0), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    var i;
    const t = e.newData || e.newPage, s = this.gos.get("suppressScrollOnNewData");
    t && !s && (this.gridBodyCtrl.scrollFeature.scrollToTop(), (i = this.stickyRowFeature) == null || i.resetOffsets());
  }
  updateContainerHeights(e = 0) {
    const { rowContainerHeight: t } = this;
    if (this.printLayout) {
      t.setModelHeight(null);
      return;
    }
    let s = this.pageBounds.getCurrentPageHeight();
    s === 0 && (s = 1), t.setModelHeight(s + e);
  }
  getLockOnRefresh() {
    var e, t;
    if (this.refreshInProgress)
      throw new Error(ds(252));
    this.refreshInProgress = !0, (t = (e = this.beans.frameworkOverrides).getLockOnRefresh) == null || t.call(e);
  }
  releaseLockOnRefresh() {
    var e, t;
    this.refreshInProgress = !1, (t = (e = this.beans.frameworkOverrides).releaseLockOnRefresh) == null || t.call(e);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    if (!e)
      return;
    const t = this.beans.focusSvc, s = this.findPositionToFocus(e);
    if (!s) {
      t.focusHeaderPosition({
        headerPosition: {
          headerRowIndex: Mt(this.beans) - 1,
          column: e.column
        }
      });
      return;
    }
    if (e.rowIndex !== s.rowIndex || e.rowPinned != s.rowPinned) {
      t.setFocusedCell({
        ...s,
        preventScrollOnBrowserFocus: !0,
        forceBrowserFocus: !0
      });
      return;
    }
    t.doesRowOrCellHaveBrowserFocus() || this.updateCellFocus(
      N(this.gos, {
        ...s,
        forceBrowserFocus: !0,
        preventScrollOnBrowserFocus: !0,
        type: "cellFocused"
      })
    );
  }
  findPositionToFocus(e) {
    const { pagination: t, pageBounds: s } = this.beans;
    let i = e;
    for (i.rowPinned == null && t && s && !t.isRowInPage(i.rowIndex) && (i = { rowPinned: null, rowIndex: s.getFirstRow() }); i; ) {
      if (i.rowPinned == null && s)
        if (i.rowIndex < s.getFirstRow()) {
          if (i = xn(this.beans, { rowPinned: null, rowIndex: 0 }), !i)
            return null;
        } else i.rowIndex > s.getLastRow() && (i = { rowPinned: null, rowIndex: s.getLastRow() });
      const o = this.getRowByPosition(i);
      if (o != null && o.isAlive())
        return { ...o.getRowPosition(), column: e.column };
      i = xn(this.beans, i);
    }
    return null;
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), s = t.length;
    for (let i = 0; i < s; i++) {
      const o = t[i].getAllCellCtrls(), n = o.length;
      for (let r = 0; r < n; r++)
        e.push(o[r]);
    }
    return e;
  }
  getAllRowCtrls() {
    const { spannedRowRenderer: e } = this.beans, t = this.getStickyTopRowCtrls(), s = this.getStickyBottomRowCtrls();
    return [
      ...this.topRowCtrls,
      ...this.bottomRowCtrls,
      ...t,
      ...s,
      ...(e == null ? void 0 : e.getCtrls("top")) ?? [],
      ...(e == null ? void 0 : e.getCtrls("bottom")) ?? [],
      ...(e == null ? void 0 : e.getCtrls("center")) ?? [],
      ...Object.values(this.rowCtrlsByRowIndex)
    ];
  }
  addRenderedRowListener(e, t, s) {
    const i = this.rowCtrlsByRowIndex[t];
    i && i.addEventListener(e, s);
  }
  refreshCells(e = {}) {
    const t = {
      forceRefresh: e.force,
      newData: !1,
      suppressFlash: e.suppressFlash
    };
    for (const s of this.getCellCtrls(e.rowNodes, e.columns))
      s.refreshOrDestroyCell(t);
    this.refreshFullWidth(e.rowNodes);
  }
  refreshFullWidth(e) {
    if (!e)
      return;
    let t = !1;
    for (const s of this.getRowCtrls(e)) {
      if (!s.isFullWidth())
        continue;
      s.refreshFullWidth() || (t = !0, this.redrawRow(s.rowNode, !0));
    }
    t && this.dispatchDisplayedRowsChanged(!1);
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(e) {
    const t = Cd(e), s = this.getAllRowCtrls();
    return !e || !t ? s : s.filter((i) => {
      const o = i.rowNode;
      return vd(o, t);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    let s;
    T(t) && (s = {}, t.forEach((o) => {
      const n = this.colModel.getCol(o);
      T(n) && (s[n.getId()] = !0);
    }));
    const i = [];
    return this.getRowCtrls(e).forEach((o) => {
      o.getAllCellCtrls().forEach((n) => {
        const r = n.column.getId();
        s && !s[r] || i.push(n);
      });
    }), i;
  }
  destroy() {
    this.removeAllRowComps(!0), super.destroy();
  }
  removeAllRowComps(e = !1) {
    var s;
    const t = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(t, e), (s = this.stickyRowFeature) == null || s.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    for (const s of Object.keys(this.rowCtrlsByRowIndex))
      this.rowCtrlsByRowIndex[s].rowNode.id == null && e.push(s);
    this.removeRowCtrls(e);
    const t = {};
    for (const s of Object.values(this.rowCtrlsByRowIndex)) {
      const i = s.rowNode;
      t[i.id] = s;
    }
    return this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e, t = !1) {
    e.forEach((s) => {
      const i = this.rowCtrlsByRowIndex[s];
      i && (i.destroyFirstPass(t), i.destroySecondPass()), delete this.rowCtrlsByRowIndex[s];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: !0 });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = {}) {
    const { focusSvc: t, animationFrameSvc: s } = this.beans, { afterScroll: i } = e;
    let o;
    const n = this.stickyRowFeature;
    n && (o = (t == null ? void 0 : t.getFocusCellToUseAfterRefresh()) || void 0);
    const r = this.firstRenderedRow, a = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let l = !1;
    if (n) {
      l = n.checkStickyRows();
      const c = n.extraTopHeight + n.extraBottomHeight;
      c && this.updateContainerHeights(c);
    }
    const d = this.firstRenderedRow !== r || this.lastRenderedRow !== a;
    if (!(i && !l && !d) && (this.getLockOnRefresh(), this.recycleRows(null, !1, i), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(i && !l), o != null)) {
      const c = t == null ? void 0 : t.getFocusCellToUseAfterRefresh();
      o != null && c == null && (s == null || s.flushAllFrames(), this.restoreFocusedCell(o));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const s = {};
    e.forEach((n) => s[n] = !0);
    const o = Object.keys(this.rowCtrlsByRowIndex).filter((n) => !s[n]);
    this.removeRowCtrls(o, t);
  }
  calculateIndexesToDraw(e) {
    var r, a;
    const t = [];
    for (let l = this.firstRenderedRow; l <= this.lastRenderedRow; l++)
      t.push(l);
    const s = this.beans.pagination, i = (a = (r = this.beans.focusSvc) == null ? void 0 : r.getFocusedCell()) == null ? void 0 : a.rowIndex;
    i != null && (i < this.firstRenderedRow || i > this.lastRenderedRow) && (!s || s.isRowInPage(i)) && i < this.rowModel.getRowCount() && t.push(i);
    const o = (l) => {
      const d = l.rowNode.rowIndex;
      d == null || d === i || (d < this.firstRenderedRow || d > this.lastRenderedRow) && this.doNotUnVirtualiseRow(l) && t.push(d);
    };
    for (const l of Object.values(this.rowCtrlsByRowIndex))
      o(l);
    if (e)
      for (const l of Object.values(e))
        o(l);
    t.sort((l, d) => l - d);
    const n = [];
    for (let l = 0; l < t.length; l++) {
      const d = t[l], c = this.rowModel.getRow(d);
      c && !c.sticky && n.push(d);
    }
    return n;
  }
  recycleRows(e, t = !1, s = !1) {
    const i = this.calculateIndexesToDraw(e);
    if ((this.printLayout || s) && (t = !1), this.removeRowCompsNotToDraw(i, !t), i.forEach((o) => {
      this.createOrUpdateRowCtrl(o, e, t, s);
    }), e) {
      const { animationFrameSvc: o } = this.beans;
      (o == null ? void 0 : o.active) && s && !this.printLayout ? o.addDestroyTask(() => {
        this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
      }) : this.destroyRowCtrls(e, t);
    }
    this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    this.eventSvc.dispatchEvent({
      type: "displayedRowsChanged",
      afterScroll: e
    });
  }
  onDisplayedColumnsChanged() {
    const { visibleCols: e } = this.beans, t = e.isPinningLeft(), s = e.isPinningRight();
    (this.pinningLeft !== t || s !== this.pinningRight) && (this.pinningLeft = t, this.pinningRight = s, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const s = t.rowNode.rowIndex;
      e.push(s.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: !0 });
  }
  getFullWidthRowCtrls(e) {
    const t = Cd(e);
    return this.getAllRowCtrls().filter((s) => {
      if (!s.isFullWidth())
        return !1;
      const i = s.rowNode;
      return !(t != null && !vd(i, t));
    });
  }
  createOrUpdateRowCtrl(e, t, s, i) {
    let o, n = this.rowCtrlsByRowIndex[e];
    if (n || (o = this.rowModel.getRow(e), T(o) && T(t) && t[o.id] && o.alreadyRendered && (n = t[o.id], t[o.id] = null)), !n)
      if (o || (o = this.rowModel.getRow(e)), T(o))
        n = this.createRowCon(o, s, i);
      else
        return;
    return o && (o.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = n, n;
  }
  destroyRowCtrls(e, t) {
    const s = [];
    if (e) {
      for (const i of Object.values(e))
        if (i) {
          if (this.cachedRowCtrls && i.isCacheable()) {
            this.cachedRowCtrls.addRow(i);
            continue;
          }
          if (i.destroyFirstPass(!t), t) {
            const o = i.instanceId;
            this.zombieRowCtrls[o] = i, s.push(() => {
              i.destroySecondPass(), delete this.zombieRowCtrls[o];
            });
          } else
            i.destroySecondPass();
        }
    }
    t && (s.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), window.setTimeout(() => s.forEach((i) => i()), aR));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = Bs(this.beans);
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    const { rowContainerHeight: e, pageBounds: t, rowModel: s } = this;
    e.updateOffset();
    let i, o;
    if (!s.isRowsToRender())
      i = 0, o = -1;
    else if (this.printLayout)
      this.beans.environment.refreshRowHeightVariable(), i = t.getFirstRow(), o = t.getLastRow();
    else {
      const c = this.getRowBufferInPixels(), u = this.ctrlsSvc.getScrollFeature(), h = this.gos.get("suppressRowVirtualisation");
      let g = !1, p, f;
      do {
        const v = t.getPixelOffset(), { pageFirstPixel: F, pageLastPixel: R } = t.getCurrentPagePixelRange(), D = e.divStretchOffset, M = u.getVScrollPosition(), I = M.top, J = M.bottom;
        h ? (p = F + D, f = R + D) : (p = Math.max(I + v - c, F) + D, f = Math.min(J + v + c, R) + D), this.firstVisibleVPixel = Math.max(I + v, F) + D, this.lastVisibleVPixel = Math.min(J + v, R) + D, g = this.ensureAllRowsInRangeHaveHeightsCalculated(p, f);
      } while (g);
      let m = s.getRowIndexAtPixel(p), b = s.getRowIndexAtPixel(f);
      const w = t.getFirstRow(), C = t.getLastRow();
      m < w && (m = w), b > C && (b = C), i = m, o = b;
    }
    const n = xe(this.gos, "normal"), r = this.gos.get("suppressMaxRenderedRowRestriction"), a = Math.max(this.getRowBuffer(), 500);
    n && !r && o - i > a && (o = i + a);
    const l = i !== this.firstRenderedRow, d = o !== this.lastRenderedRow;
    (l || d) && (this.firstRenderedRow = i, this.lastRenderedRow = o, this.eventSvc.dispatchEvent({
      type: "viewportChanged",
      firstRow: i,
      lastRow: o
    }));
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    this.dataFirstRenderedFired || (this.dataFirstRenderedFired = !0, Ct(this.beans, () => {
      this.beans.eventSvc.dispatchEvent({
        type: "firstDataRendered",
        firstRow: this.firstRenderedRow,
        lastRow: this.lastRenderedRow
      });
    }));
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    var a, l;
    const s = (a = this.pinnedRowModel) == null ? void 0 : a.ensureRowHeightsValid(), i = (l = this.stickyRowFeature) == null ? void 0 : l.ensureRowHeightsValid(), { pageBounds: o, rowModel: n } = this, r = n.ensureRowHeightsValid(
      e,
      t,
      o.getFirstRow(),
      o.getLastRow()
    );
    return (r || i) && this.eventSvc.dispatchEvent({
      type: "recalculateRowBounds"
    }), i || r || s ? (this.updateContainerHeights(), !0) : !1;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    const i = e.rowNode, o = this.focusSvc.isRowFocused(i.rowIndex, i.rowPinned), n = e.editing, r = i.detail;
    return o || n || r ? !!this.isRowPresent(i) : !1;
  }
  isRowPresent(e) {
    var t;
    return this.rowModel.isRowPresent(e) ? ((t = this.beans.pagination) == null ? void 0 : t.isRowInPage(e.rowIndex)) ?? !0 : !1;
  }
  createRowCon(e, t, s) {
    var r, a;
    const i = ((r = this.cachedRowCtrls) == null ? void 0 : r.getRow(e)) ?? null;
    if (i)
      return i;
    const o = s && !this.printLayout && !!((a = this.beans.animationFrameSvc) != null && a.active);
    return new ea(e, this.beans, t, o, this.printLayout);
  }
  getRenderedNodes() {
    const e = Object.values(this.rowCtrlsByRowIndex).map((i) => i.rowNode), t = this.getStickyTopRowCtrls().map((i) => i.rowNode), s = this.getStickyBottomRowCtrls().map((i) => i.rowNode);
    return [...t, ...e, ...s];
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: s } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[s];
        break;
      case "bottom":
        t = this.bottomRowCtrls[s];
        break;
      default:
        t = this.rowCtrlsByRowIndex[s], t || (t = this.getStickyTopRowCtrls().find((i) => i.rowNode.rowIndex === s) || null, t || (t = this.getStickyBottomRowCtrls().find((i) => i.rowNode.rowIndex === s) || null));
        break;
    }
    return t;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const i = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !i;
  }
}, dR = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.rowNode.id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.rowNode != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, s = this.entriesMap[t];
    delete this.entriesMap[t], Ae(this.entriesList, s);
  }
  removeFromCache(e) {
    const t = e.rowNode.id;
    delete this.entriesMap[t], Ae(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
};
function Cd(e) {
  if (!e)
    return;
  const t = {
    top: {},
    bottom: {},
    normal: {}
  };
  return e.forEach((s) => {
    const i = s.id;
    switch (s.rowPinned) {
      case "top":
        t.top[i] = s;
        break;
      case "bottom":
        t.bottom[i] = s;
        break;
      default:
        t.normal[i] = s;
        break;
    }
  }), t;
}
function vd(e, t) {
  const s = e.id;
  switch (e.rowPinned) {
    case "top":
      return t.top[s] != null;
    case "bottom":
      return t.bottom[s] != null;
    default:
      return t.normal[s] != null;
  }
}
var cR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "rowNodeSorter";
  }
  postConstruct() {
    const { gos: e } = this;
    this.isAccentedSort = e.get("accentedSort"), this.primaryColumnsSortGroups = dt(e), this.addManagedPropertyListener(
      "accentedSort",
      (t) => this.isAccentedSort = t.currentValue
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = dt(e)
    );
  }
  doFullSort(e, t) {
    const s = e.map((i, o) => ({
      currentPos: o,
      rowNode: i
    }));
    return s.sort(this.compareRowNodes.bind(this, t)), s.map((i) => i.rowNode);
  }
  compareRowNodes(e, t, s) {
    const i = t.rowNode, o = s.rowNode;
    for (let n = 0, r = e.length; n < r; n++) {
      const a = e[n], l = a.sort === "desc", d = this.getValue(i, a.column), c = this.getValue(o, a.column);
      let u;
      const h = this.getComparator(a, i);
      if (h ? u = h(d, c, i, o, l) : u = Cm(d, c, this.isAccentedSort), !isNaN(u) && u !== 0)
        return a.sort === "asc" ? u : u * -1;
    }
    return t.currentPos - s.currentPos;
  }
  getComparator(e, t) {
    const s = e.column, i = s.getColDef().comparator;
    if (i != null)
      return i;
    if (!s.getColDef().showRowGroup)
      return;
    const o = !t.group && s.getColDef().field;
    if (!o)
      return;
    const n = this.beans.colModel.getColDefCol(o);
    if (n)
      return n.getColDef().comparator;
  }
  getValue(e, t) {
    var a, l;
    const { valueSvc: s, colModel: i, showRowGroupCols: o, gos: n } = this.beans;
    if (!this.primaryColumnsSortGroups)
      return s.getValue(t, e, !1);
    if (e.rowGroupColumn === t) {
      if (Oa(n, i.isPivotActive())) {
        const u = (a = e.allLeafChildren) == null ? void 0 : a[0];
        return u ? s.getValue(t, u, !1) : void 0;
      }
      const c = o == null ? void 0 : o.getShowRowGroupCol(t.getId());
      return c ? (l = e.groupData) == null ? void 0 : l[c.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return s.getValue(t, e, !1);
  }
};
function uR(e) {
  var t;
  (t = e.sortSvc) == null || t.onSortChanged("api");
}
var ll = {
  moduleName: "Sort",
  version: Q,
  beans: [tx, cR],
  apiFunctions: {
    onSortChanged: uR
  },
  userComponents: {
    agSortIndicator: al
  },
  icons: {
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
    sortUnSort: "none"
  }
}, hR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "syncSvc", this.waitingForColumns = !1;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.beans.ctrlsSvc.whenReady(this, () => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    const { colModel: t, rowModel: s } = this.beans;
    t.setColumnDefs(e ?? [], "gridInitializing"), s.start();
  }
  gridReady() {
    const { eventSvc: e, gos: t } = this;
    e.dispatchEvent({
      type: "gridReady"
    }), oo(t, `initialised successfully, enterprise = ${t.isModuleRegistered("EnterpriseCore")}`);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = !1, this.setColumnsAndData(t);
        return;
      }
      this.beans.colModel.setColumnDefs(t, Ls(e.source));
    }
  }
}, gR = "paste", pR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "changeDetectionSvc", this.clientSideRowModel = null;
  }
  postConstruct() {
    const { gos: e, rowModel: t } = this.beans;
    Ke(e) && (this.clientSideRowModel = t), this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(e) {
    const { gos: t, rowRenderer: s } = this.beans;
    if (e.source === gR || t.get("suppressChangeDetection"))
      return;
    const i = e.node, o = [i], n = this.clientSideRowModel, r = n == null ? void 0 : n.rootNode;
    if (r && !i.isRowPinned()) {
      const a = t.get("aggregateOnlyChangedColumns"), l = new Xu(a, r);
      l.addParentNode(i.parent, [e.column]), n.doAggregate(l), l.forEachChangedNodeDepthFirst((d) => {
        o.push(d), d.sibling && o.push(d.sibling);
      });
    }
    s.refreshCells({ rowNodes: o });
  }
}, fR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "expressionSvc", this.cache = {};
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    K(15, { expression: e });
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(
        t.value,
        t.context,
        t.oldValue,
        t.newValue,
        t.value,
        t.node,
        t.data,
        t.colDef,
        t.rowIndex,
        t.api,
        t.getValue,
        t.column,
        t.columnGroup
      );
    } catch (s) {
      return K(16, { expression: e, params: t, e: s }), null;
    }
  }
  createExpressionFunction(e) {
    const t = this.cache;
    if (t[e])
      return t[e];
    const s = this.createFunctionBody(e), i = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      s
    );
    return t[e] = i, i;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
}, mR = {
  moduleName: "Expression",
  version: Q,
  beans: [fR]
}, CR = {
  moduleName: "ChangeDetection",
  version: Q,
  beans: [pR]
}, vR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "valueSvc", this.initialised = !1, this.isSsrm = !1;
  }
  wireBeans(e) {
    this.expressionSvc = e.expressionSvc, this.colModel = e.colModel, this.valueCache = e.valueCache, this.dataTypeSvc = e.dataTypeSvc;
  }
  postConstruct() {
    this.initialised || this.init();
  }
  init() {
    this.executeValueGetter = this.valueCache ? this.executeValueGetterWithValueCache.bind(this) : this.executeValueGetterWithoutValueCache.bind(this), this.isSsrm = nt(this.gos), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
    const e = (t) => this.callColumnCellValueChangedHandler(t);
    this.eventSvc.addEventListener("cellValueChanged", e, !0), this.addDestroyFunc(() => this.eventSvc.removeEventListener("cellValueChanged", e, !0)), this.addManagedPropertyListener("treeData", (t) => this.isTreeData = t.currentValue);
  }
  /**
   * Use this function to get a displayable cell value.
   * The values from this function are not used for sorting, filtering, or aggregation purposes.
   * Handles: groupHideOpenParents, showOpenedGroup and groupSuppressBlankHeader behaviours
   */
  getValueForDisplay(e, t, s = !1, i = !1) {
    const { showRowGroupColValueSvc: o } = this.beans, n = !e && t.group, r = e == null ? void 0 : e.colDef.showRowGroup, a = !this.isTreeData || t.footer;
    if (o && a && (n || r)) {
      const p = o.getGroupValue(t, e);
      if (p == null)
        return {
          value: null,
          valueFormatted: null
        };
      if (!s)
        return {
          value: p.value,
          valueFormatted: null
        };
      const f = o.formatAndPrefixGroupColValue(p, e, i);
      return {
        value: p.value,
        valueFormatted: f
      };
    }
    if (!e)
      return {
        value: t.key,
        valueFormatted: null
      };
    const l = t.leafGroup && this.colModel.isPivotMode(), d = t.group && t.expanded && !t.footer && !l, c = this.gos.get("groupSuppressBlankHeader") || !t.sibling, u = d && !c, h = this.getValue(e, t, u), g = s && !(i && e.colDef.useValueFormatterForExport === !1);
    return {
      value: h,
      valueFormatted: g ? this.formatValue(e, t, h) : null
    };
  }
  getValue(e, t, s = !1) {
    var p;
    if (this.initialised || this.init(), !t)
      return;
    const i = e.getColDef(), o = i.field, n = e.getColId(), r = t.data;
    let a;
    const l = i.showRowGroup;
    if (typeof l == "string" && (((p = this.beans.rowGroupColsSvc) == null ? void 0 : p.getColumnIndex(l)) ?? -1) > t.level)
      return null;
    const d = typeof l != "string" || !t.group, c = t.groupData && n in t.groupData, u = !s && t.aggData && t.aggData[n] !== void 0, h = this.isSsrm && s && !!e.getColDef().aggFunc, g = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === !0 || e.getColDef().showRowGroup === t.field);
    if (this.isTreeData && u)
      a = t.aggData[n];
    else if (this.isTreeData && i.valueGetter)
      a = this.executeValueGetter(i.valueGetter, r, e, t);
    else if (this.isTreeData && o && r)
      a = $o(r, o, e.isFieldContainsDots());
    else if (c)
      a = t.groupData[n];
    else if (u)
      a = t.aggData[n];
    else if (i.valueGetter) {
      if (!d)
        return a;
      a = this.executeValueGetter(i.valueGetter, r, e, t);
    } else if (g)
      a = $o(r, t.field, e.isFieldContainsDots());
    else if (o && r && !h) {
      if (!d)
        return a;
      a = $o(r, o, e.isFieldContainsDots());
    }
    if (this.cellExpressions && typeof a == "string" && a.indexOf("=") === 0) {
      const f = a.substring(1);
      a = this.executeValueGetter(f, r, e, t);
    }
    return a;
  }
  parseValue(e, t, s, i) {
    var r;
    const o = e.getColDef(), n = o.valueParser;
    if (T(n)) {
      const a = N(this.gos, {
        node: t,
        data: t == null ? void 0 : t.data,
        oldValue: i,
        newValue: s,
        colDef: o,
        column: e
      });
      return typeof n == "function" ? n(a) : (r = this.expressionSvc) == null ? void 0 : r.evaluate(n, a);
    }
    return s;
  }
  getDeleteValue(e, t) {
    return T(e.getColDef().valueParser) ? this.parseValue(e, t, "", this.getValueForDisplay(e, t).value) ?? null : null;
  }
  formatValue(e, t, s, i, o = !0) {
    let n = null, r;
    const a = e.getColDef();
    if (i ? r = i : o && (r = a.valueFormatter), r) {
      const l = N(this.gos, {
        value: s,
        node: t,
        data: t ? t.data : null,
        colDef: a,
        column: e
      });
      typeof r == "function" ? n = r(l) : n = this.expressionSvc ? this.expressionSvc.evaluate(r, l) : null;
    } else if (a.refData)
      return a.refData[s] || "";
    return n == null && Array.isArray(s) && (n = s.join(", ")), n;
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, s, i) {
    var c, u;
    const o = this.colModel.getColDefCol(t);
    if (!e || !o)
      return !1;
    ie(e.data) && (e.data = {});
    const { field: n, valueSetter: r } = o.getColDef();
    if (ie(n) && ie(r))
      return P(17), !1;
    if (this.dataTypeSvc && !this.dataTypeSvc.checkType(o, s))
      return P(135), !1;
    const a = N(this.gos, {
      node: e,
      data: e.data,
      oldValue: this.getValue(o, e),
      newValue: s,
      colDef: o.getColDef(),
      column: o
    });
    a.newValue = s;
    let l;
    if (T(r) ? typeof r == "function" ? l = r(a) : l = (c = this.expressionSvc) == null ? void 0 : c.evaluate(r, a) : l = this.setValueUsingField(e.data, n, s, o.isFieldContainsDots()), l === void 0 && (l = !0), !l)
      return !1;
    e.resetQuickFilterAggregateText(), (u = this.valueCache) == null || u.onDataChanged();
    const d = this.getValue(o, e);
    return this.eventSvc.dispatchEvent({
      type: "cellValueChanged",
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: a.column,
      colDef: a.colDef,
      data: e.data,
      node: e,
      oldValue: a.oldValue,
      newValue: d,
      value: d,
      source: i
    }), !0;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.beans.frameworkOverrides.wrapOutgoing(() => {
      t({
        node: e.node,
        data: e.data,
        oldValue: e.oldValue,
        newValue: e.newValue,
        colDef: e.colDef,
        column: e.column,
        api: e.api,
        context: e.context
      });
    });
  }
  setValueUsingField(e, t, s, i) {
    if (!t)
      return !1;
    let o = !1;
    if (!i)
      o = e[t] === s, o || (e[t] = s);
    else {
      const n = t.split(".");
      let r = e;
      for (; n.length > 0 && r; ) {
        const a = n.shift();
        n.length === 0 ? (o = r[a] === s, o || (r[a] = s)) : r = r[a];
      }
    }
    return !o;
  }
  executeValueGetterWithValueCache(e, t, s, i) {
    const o = s.getColId(), n = this.valueCache.getValue(i, o);
    if (n !== void 0)
      return n;
    const r = this.executeValueGetterWithoutValueCache(e, t, s, i);
    return this.valueCache.setValue(i, o, r), r;
  }
  executeValueGetterWithoutValueCache(e, t, s, i) {
    var r;
    const o = N(this.gos, {
      data: t,
      node: i,
      column: s,
      colDef: s.getColDef(),
      getValue: this.getValueCallback.bind(this, i)
    });
    let n;
    return typeof e == "function" ? n = e(o) : n = (r = this.expressionSvc) == null ? void 0 : r.evaluate(e, o), n;
  }
  getValueCallback(e, t) {
    const s = this.colModel.getColDefCol(t);
    return s ? this.getValue(s, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const s = this.getValue(e, t), i = e.getColDef().keyCreator;
    let o = s;
    if (i) {
      const n = N(this.gos, {
        value: s,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data
      });
      o = i(n);
    }
    return typeof o == "string" || o == null || (o = String(o), o === "[object Object]" && P(121)), o;
  }
}, wR = {
  moduleName: "CommunityCore",
  version: Q,
  beans: [
    ZS,
    Mb,
    Ny,
    cC,
    rR,
    xy,
    US,
    Rx,
    nC,
    jx,
    Ux,
    lR,
    vR,
    qS,
    zS,
    YS,
    Vy,
    hR,
    Ly,
    ky
  ],
  icons: {
    // icon on select dropdowns (select cell editor, charts tool panels)
    selectOpen: "small-down",
    /** @deprecated v33 */
    smallDown: "small-down",
    /** @deprecated v33 */
    colorPicker: "color-picker",
    /** @deprecated v33 */
    smallUp: "small-up",
    /** @deprecated v33 */
    checkboxChecked: "small-up",
    /** @deprecated v33 */
    checkboxIndeterminate: "checkbox-indeterminate",
    /** @deprecated v33 */
    checkboxUnchecked: "checkbox-unchecked",
    /** @deprecated v33 */
    radioButtonOn: "radio-button-on",
    /** @deprecated v33 */
    radioButtonOff: "radio-button-off",
    /** @deprecated v33 */
    smallLeft: "small-left",
    /** @deprecated v33 */
    smallRight: "small-right"
  },
  apiFunctions: {
    getGridId: Eb,
    destroy: Ab,
    isDestroyed: Ib,
    getGridOption: Tb,
    setGridOption: Lb,
    updateGridOptions: Fh,
    isModuleRegistered: kb
  },
  dependsOn: [
    Ay,
    ol,
    ly,
    ll,
    Ax,
    Ah,
    Ix,
    nR,
    CR,
    Lx,
    Yh,
    Yx,
    Qx,
    Gx,
    By,
    Iy,
    mR
  ]
};
function Qh(e) {
  const { inputValue: t, allSuggestions: s, hideIrrelevant: i, filterByPercentageOfBestMatch: o } = e;
  let n = s.map((l, d) => ({
    value: l,
    relevance: bR(t, l),
    idx: d
  }));
  if (n.sort((l, d) => d.relevance - l.relevance), i && (n = n.filter((l) => l.relevance !== 0)), n.length > 0 && o && o > 0) {
    const d = n[0].relevance * o;
    n = n.filter((c) => d - c.relevance < 0);
  }
  const r = [], a = [];
  for (const l of n)
    r.push(l.value), a.push(l.idx);
  return { values: r, indices: a };
}
function bR(e, t) {
  if (e === t)
    return 1e3;
  const s = e.length, i = t.length;
  if (s === 0 || i === 0)
    return 0;
  const o = e.toLocaleLowerCase(), n = t.toLocaleLowerCase(), r = n.indexOf(o);
  if (r !== -1)
    return 980 - r * 2;
  if ([...o].filter((u) => n.includes(u)).length === 0)
    return 0;
  let l = Array.from({ length: i + 1 }, (u, h) => h);
  for (let u = 0; u < s; u++) {
    const h = [u + 1];
    for (let g = 0; g < i; g++) {
      const p = l[g + 1] + 1, f = h[g] + 1;
      let m = l[g] + (e[u] !== t[g] ? 1 : 0);
      i > 10 && g > i / 2 && (m += 1), u > 0 && g > 0 && e[u - 1] === t[g - 1] && (m -= 4), h.push(Math.min(p, f, m));
    }
    l = h;
  }
  const d = Math.round(l[i]), c = Math.max(1, 1e3 - d * 30);
  return Math.max(1, c);
}
var Xh = {
  AdvancedFilter: 1,
  AllEnterprise: 1,
  CellSelection: 1,
  Clipboard: 1,
  ColumnMenu: 1,
  ColumnsToolPanel: 1,
  ContextMenu: 1,
  ExcelExport: 1,
  FiltersToolPanel: 1,
  Find: 1,
  GridCharts: 1,
  IntegratedCharts: 1,
  GroupFilter: 1,
  MasterDetail: 1,
  Menu: 1,
  MultiFilter: 1,
  Pivot: 1,
  RangeSelection: 1,
  RichSelect: 1,
  RowNumbers: 1,
  RowGrouping: 1,
  RowGroupingPanel: 1,
  ServerSideRowModelApi: 1,
  ServerSideRowModel: 1,
  SetFilter: 1,
  SideBar: 1,
  Sparklines: 1,
  StatusBar: 1,
  TreeData: 1,
  ViewportRowModel: 1
}, Rr = [
  "TextFilter",
  "NumberFilter",
  "DateFilter",
  "SetFilter",
  "MultiFilter",
  "GroupFilter",
  "CustomFilter"
], yR = {
  EditCore: [
    "TextEditor",
    "NumberEditor",
    "DateEditor",
    "CheckboxEditor",
    "LargeTextEditor",
    "SelectEditor",
    "RichSelect",
    "CustomEditor"
  ],
  CheckboxCellRenderer: ["AllCommunity"],
  ClientSideRowModelHierarchy: ["RowGrouping", "Pivot", "TreeData"],
  ColumnFilter: Rr,
  ColumnGroupHeaderComp: ["AllCommunity"],
  ColumnGroup: ["AllCommunity"],
  ColumnHeaderComp: ["AllCommunity"],
  ColumnMove: ["AllCommunity"],
  ColumnResize: ["AllCommunity"],
  CommunityCore: ["AllCommunity"],
  CsrmSsrmSharedApi: ["ClientSideRowModelApi", "ServerSideRowModelApi"],
  EnterpriseCore: ["AllEnterprise"],
  FilterCore: [...Rr, "QuickFilter", "ExternalFilter", "AdvancedFilter"],
  GroupCellRenderer: ["RowGrouping", "Pivot", "TreeData", "MasterDetail", "ServerSideRowModel"],
  KeyboardNavigation: ["AllCommunity"],
  LoadingCellRenderer: ["ServerSideRowModel"],
  MenuCore: ["ColumnMenu", "ContextMenu"],
  MenuItem: ["ColumnMenu", "ContextMenu", "MultiFilter", "IntegratedCharts", "ColumnsToolPanel"],
  Overlay: ["AllCommunity"],
  PinnedColumn: ["AllCommunity"],
  SharedAggregation: ["RowGrouping", "Pivot", "TreeData", "ServerSideRowModel"],
  SharedDragAndDrop: ["AllCommunity"],
  SharedMasterDetail: ["MasterDetail", "ServerSideRowModel"],
  SharedMenu: [...Rr, "ColumnMenu", "ContextMenu"],
  SharedPivot: ["Pivot", "ServerSideRowModel"],
  SharedRowGrouping: ["RowGrouping", "ServerSideRowModel"],
  SharedRowSelection: ["RowSelection", "ServerSideRowModel"],
  SkeletonCellRenderer: ["ServerSideRowModel"],
  Sort: ["AllCommunity"],
  SsrmInfiniteSharedApi: ["InfiniteRowModel", "ServerSideRowModelApi"],
  SharedTreeData: ["TreeData", "ServerSideRowModel"]
}, SR = {
  InfiniteRowModel: "infinite",
  ClientSideRowModelApi: "clientSide",
  ClientSideRowModel: "clientSide",
  ServerSideRowModelApi: "serverSide",
  ServerSideRowModel: "serverSide",
  ViewportRowModel: "viewport"
};
function xR(e, t) {
  const s = [];
  return (Array.isArray(e) ? e : [e]).forEach((i) => {
    const o = yR[i];
    o ? o.forEach((n) => {
      const r = SR[n];
      (!r || r === t) && s.push(n);
    }) : s.push(i);
  }), s;
}
var Jh = () => `No AG Grid modules are registered! It is recommended to start with all Community features via the AllCommunityModule:
                    
    import { ModuleRegistry, AllCommunityModule } from 'ag-grid-community';
    
    ModuleRegistry.registerModules([ AllCommunityModule ]);
    `, RR = (e) => {
  const t = e.map(
    (i) => `import { ${Yi(i)} } from '${Xh[i] ? "ag-grid-enterprise" : "ag-grid-community"}';`
  );
  return e.some((i) => i === "IntegratedCharts" || i === "Sparklines") && t.push("import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';"), `import { ModuleRegistry } from 'ag-grid-community'; 
${t.join(` 
`)} 

ModuleRegistry.registerModules([ ${e.map((i) => Yi(i, !0)).join(", ")} ]); 

For more info see: ${di}/modules/`;
};
function Yi(e, t = !1) {
  return t && (e === "IntegratedCharts" || e === "Sparklines") ? `${e}Module.with(AgChartsEnterpriseModule)` : `${e}Module`;
}
function FR(e, t) {
  const s = t.filter((n) => n === "IntegratedCharts" || n === "Sparklines");
  let i = "";
  return !(globalThis == null ? void 0 : globalThis.agCharts) && s.length > 0 ? i = `Unable to use ${e} as either the ag-charts-community or ag-charts-enterprise script needs to be included alongside ag-grid-enterprise.
` : t.some((n) => Xh[n]) && (i = i + `Unable to use ${e} as that requires the ag-grid-enterprise script to be included.
`), i;
}
function eg({
  moduleName: e,
  rowModelType: t
}) {
  return `To use the ${e}Module you must set the gridOption "rowModelType='${t}'"`;
}
var wd = ({
  reasonOrId: e,
  moduleName: t,
  gridScoped: s,
  gridId: i,
  rowModelType: o,
  additionalText: n,
  isUmd: r
}) => {
  const a = xR(t, o), l = typeof e == "string" ? e : ER[e];
  if (r)
    return FR(l, a);
  const d = a.filter((h) => h === "IntegratedCharts" || h === "Sparklines"), c = d.length > 0 ? `${d.map((h) => Yi(h)).join()} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.` : "";
  return `${`Unable to use ${l} as ${a.length > 1 ? "one of " + a.map((h) => Yi(h)).join(", ") : Yi(a[0])} is not registered${s ? " for gridId: " + i : ""}. ${c} Check if you have registered the module:
`}
${RR(a)}` + (n ? ` 

${n}` : "");
}, bd = (e) => `${e} must be initialised with an AG Charts module. One of 'AgChartsCommunityModule' / 'AgChartsEnterpriseModule'.

import { AgChartsEnterpriseModule } from 'ag-charts-enterprise';
import { ModuleRegistry } from 'ag-grid-community';
import { ${e} } from 'ag-grid-enterprise';
    
ModuleRegistry.registerModules([${e}.with(AgChartsEnterpriseModule)]);
    `, PR = (e) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${e}()). The reason why it could not be used has been logged in the previous line. For this reason the grid has defaulted to using a workaround which doesn't perform as well. Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.`, DR = {
  1: () => "`rowData` must be an array",
  2: ({ nodeId: e }) => `Duplicate node id '${e}' detected from getRowId callback, this could cause issues in your grid.`,
  3: () => "Calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.",
  4: ({ id: e }) => `Could not find row id=${e}, data item was not found for this id`,
  5: ({ data: e }) => [
    "Could not find data item as object was not found.",
    e,
    " Consider using getRowId to help the Grid find matching row data"
  ],
  6: () => "'groupHideOpenParents' only works when specifying specific columns for 'colDef.showRowGroup'",
  7: () => "Pivoting is not supported with aligned grids as it may produce different columns in each grid.",
  8: ({ key: e }) => `Unknown key for navigation ${e}`,
  9: ({ variable: e }) => `No value for ${e == null ? void 0 : e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e == null ? void 0 : e.defaultValue} will be used and updated when styles load.`,
  10: ({ eventType: e }) => `As of v33, the '${e}' event is deprecated. Use the global 'modelUpdated' event to determine when row children have changed.`,
  11: () => "No gridOptions provided to createGrid",
  12: ({ colKey: e }) => ["column ", e, " not found"],
  13: () => "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid.",
  14: ({ groupPrefix: e }) => `Row IDs cannot start with ${e}, this is a reserved prefix for AG Grid's row grouping feature.`,
  15: ({ expression: e }) => ["value should be either a string or a function", e],
  16: ({ expression: e, params: t, e: s }) => [
    "Processing of the expression failed",
    "Expression = ",
    e,
    "Params = ",
    t,
    "Exception = ",
    s
  ],
  17: () => "you need either field or valueSetter set on colDef for editing to work",
  18: () => "alignedGrids contains an undefined option.",
  19: () => "alignedGrids - No api found on the linked grid.",
  20: () => `You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`,
  21: () => "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid.",
  22: ({ key: e }) => `${e} is an initial property and cannot be updated.`,
  23: () => "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead.",
  24: () => "row height must be a number if not using standard row model",
  25: ({ id: e }) => ["The getRowId callback must return a string. The ID ", e, " is being cast to a string."],
  26: ({ fnName: e, preDestroyLink: t }) => `Grid API function ${e}() cannot be called as the grid has been destroyed.
 Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
 To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${t}`,
  27: ({ fnName: e, module: t }) => `API function '${e}' not registered to module '${t}'`,
  28: () => "setRowCount cannot be used while using row grouping.",
  29: () => "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?",
  30: ({ toIndex: e }) => [
    "tried to insert columns in invalid location, toIndex = ",
    e,
    "remember that you should not count the moving columns when calculating the new index"
  ],
  31: () => "infinite loop in resizeColumnSets",
  32: () => "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state.",
  33: () => "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON.",
  34: ({ key: e }) => `the column type '${e}' is a default column type and cannot be overridden.`,
  35: () => "Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type.",
  36: ({ t: e }) => "colDef.type '" + e + "' does not correspond to defined gridOptions.columnTypes",
  37: () => "Changing the column pinning status is not allowed with domLayout='print'",
  38: ({ iconName: e }) => `provided icon '${e}' needs to be a string or a function`,
  39: () => "Applying column order broke a group where columns should be married together. Applying new order has been discarded.",
  40: ({ e, method: t }) => `${e}
${PR(t)}`,
  41: () => "Browser did not allow document.execCommand('copy'). Ensure 'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise the browser will prevent it for security reasons.",
  42: () => "Browser does not support document.execCommand('copy') for clipboard operations",
  43: ({ iconName: e }) => `As of v33, icon '${e}' is deprecated. Use the icon CSS name instead.`,
  44: () => 'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.',
  45: ({ parentCellDataType: e }) => `The data type definition ${e} does not exist.`,
  46: () => 'The "baseDataType" property of a data type definition must match that of its parent.',
  47: ({ cellDataType: e }) => `Missing data type definition - "${e}"`,
  48: ({ property: e }) => `Cell data type is "object" but no Value ${e} has been provided. Please either provide an object data type definition with a Value ${e}, or set "colDef.value${e}"`,
  49: ({ methodName: e }) => `Framework component is missing the method ${e}()`,
  50: ({ compName: e }) => `Could not find component ${e}, did you forget to configure this component?`,
  51: () => "Export cancelled. Export is not allowed as per your configuration.",
  52: () => "There is no `window` associated with the current `document`",
  53: () => "unknown value type during csv conversion",
  54: () => "Could not find document body, it is needed for drag and drop and context menu.",
  55: () => "addRowDropZone - A container target needs to be provided",
  56: () => "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again.",
  57: () => "unable to show popup filter, filter instantiation failed",
  58: () => "no values found for select cellEditor",
  59: () => "cannot select pinned rows",
  60: () => "cannot select node until it has finished loading",
  61: () => "since version v32.2.0, rowNode.isFullWidthCell() has been deprecated. Instead check `rowNode.detail` followed by the user provided `isFullWidthRow` grid option.",
  62: ({ colId: e }) => `setFilterModel() - no column found for colId: ${e}`,
  63: ({ colId: e }) => `setFilterModel() - unable to fully apply model, filtering disabled for colId: ${e}`,
  64: ({ colId: e }) => `setFilterModel() - unable to fully apply model, unable to create filter for colId: ${e}`,
  65: () => "filter missing setModel method, which is needed for setFilterModel",
  66: () => "filter API missing getModel method, which is needed for getFilterModel",
  67: () => "Filter is missing isFilterActive() method",
  68: () => "Column Filter API methods have been disabled as Advanced Filters are enabled.",
  69: ({ guiFromFilter: e }) => `getGui method from filter returned ${e}; it should be a DOM element.`,
  70: ({ newFilter: e }) => `Grid option quickFilterText only supports string inputs, received: ${typeof e}`,
  71: () => "debounceMs is ignored when apply button is present",
  72: ({ keys: e }) => ["ignoring FilterOptionDef as it doesn't contain one of ", e],
  73: () => "invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'",
  74: () => "no filter options for filter",
  75: () => "Unknown button type specified",
  76: ({ filterModelType: e }) => [
    'Unexpected type of filter "',
    e,
    '", it looks like the filter was configured with incorrect Filter Options'
  ],
  77: () => "Filter model is missing 'conditions'",
  78: () => 'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.',
  79: () => '"filterParams.maxNumConditions" must be greater than or equal to zero.',
  80: () => '"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.',
  81: () => '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".',
  82: ({ param: e }) => `DateFilter ${e} is not a number`,
  83: () => "DateFilter minValidYear should be <= maxValidYear",
  84: () => "DateFilter minValidDate should be <= maxValidDate",
  85: () => "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored.",
  86: () => "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored.",
  87: () => "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate.",
  88: ({ index: e }) => `Invalid row index for ensureIndexVisible: ${e}`,
  89: () => "A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)",
  90: () => "datasource is missing getRows method",
  91: () => "Filter is missing method doesFilterPass",
  92: () => "AnimationFrameService called but animation frames are off",
  93: () => "cannot add multiple ranges when `cellSelection.suppressMultiRanges = true`",
  94: ({
    paginationPageSizeOption: e,
    pageSizeSet: t,
    pageSizesSet: s,
    pageSizeOptions: i
  }) => `'paginationPageSize=${e}'${t ? "" : " (default value)"}, but ${e} is not included in${s ? "" : " the default"} paginationPageSizeSelector=[${i == null ? void 0 : i.join(", ")}].`,
  95: ({
    paginationPageSizeOption: e,
    paginationPageSizeSelector: t
  }) => `Either set '${t}' to an array that includes ${e} or to 'false' to disable the page size selector.`,
  96: ({ id: e, data: t }) => [
    "Duplicate ID",
    e,
    "found for pinned row with data",
    t,
    "When `getRowId` is defined, it must return unique IDs for all pinned rows. Use the `rowPinned` parameter."
  ],
  97: ({ colId: e }) => `cellEditor for column ${e} is missing getGui() method`,
  98: () => "popup cellEditor does not work with fullRowEdit - you cannot use them both - either turn off fullRowEdit, or stop using popup editors.",
  99: () => "Since v32, `api.hideOverlay()` does not hide the loading overlay when `loading=true`. Set `loading=false` instead.",
  100: ({ rowModelType: e }) => `selectAll only available when rowModelType='clientSide', ie not ${e}`,
  101: ({
    propertyName: e,
    componentName: t,
    agGridDefaults: s,
    jsComps: i
  }) => {
    const o = [], n = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(s ?? []).filter(
        (a) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(a)
      ),
      ...Object.keys(i ?? [])
    ], r = Qh({
      inputValue: t,
      allSuggestions: n,
      hideIrrelevant: !0,
      filterByPercentageOfBestMatch: 0.8
    }).values;
    return o.push(
      `Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.
`
    ), r.length > 0 && o.push(`         Did you mean: [${r.slice(0, 3)}]?
`), o.push("If using a custom component check it has been registered correctly."), o;
  },
  102: () => "selectAll: 'filtered' only works when gridOptions.rowModelType='clientSide'",
  103: () => "Invalid selection state. When using client-side row model, the state must conform to `string[]`.",
  104: ({ value: e, param: t }) => `Numeric value ${e} passed to ${t} param will be interpreted as ${e} seconds. If this is intentional use "${e}s" to silence this warning.`,
  105: ({ e }) => ["chart rendering failed", e],
  106: () => `Theming API and Legacy Themes are both used in the same page. A Theming API theme has been provided to the 'theme' grid option, but the file (ag-grid.css) is also included and will cause styling issues. Remove ag-grid.css from the page. See the migration guide: ${di}/theming-migration/`,
  107: ({ key: e, value: t }) => `Invalid value for theme param ${e} - ${t}`,
  108: ({ e }) => ["chart update failed", e],
  109: ({ aggFuncOrString: e }) => `unrecognised aggregation function ${e}`,
  110: () => "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup",
  111: () => "Invalid selection state. When `groupSelects` is enabled, the state must conform to `IServerSideGroupSelectionState`.",
  113: () => "Set Filter cannot initialise because you are using a row model that does not contain all rows in the browser. Either use a different filter type, or configure Set Filter such that you provide it with values",
  114: ({ component: e }) => `Could not find component with name of ${e}. Is it in Vue.components?`,
  // 115: () => 'The provided selection state should be an object.' as const,
  116: () => "Invalid selection state. The state must conform to `IServerSideSelectionState`.",
  117: () => "selectAll must be of boolean type.",
  118: () => "Infinite scrolling must be enabled in order to set the row count.",
  119: () => "Unable to instantiate filter",
  120: () => "MultiFloatingFilterComp expects MultiFilter as its parent",
  121: () => "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (see AG Grid docs) or b) to toString() on the object to return a key",
  122: () => "could not find the document, document is empty",
  123: () => "Advanced Filter is only supported with the Client-Side Row Model or Server-Side Row Model.",
  124: () => "No active charts to update.",
  125: ({ chartId: e }) => `Unable to update chart. No active chart found with ID: ${e}.`,
  126: () => "unable to restore chart as no chart model is provided",
  127: ({ allRange: e }) => `unable to create chart as ${e ? "there are no columns in the grid" : "no range is selected"}.`,
  128: ({ feature: e }) => `${e} is only available if using 'multiRow' selection mode.`,
  129: ({ feature: e, rowModel: t }) => `${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`,
  130: () => 'cannot multi select unless selection mode is "multiRow"',
  // 131: () => 'cannot range select while selecting multiple rows' as const,
  132: () => "Row selection features are not available unless `rowSelection` is enabled.",
  133: ({ iconName: e }) => `icon '${e}' function should return back a string or a dom object`,
  134: ({ iconName: e }) => `Did not find icon '${e}'`,
  135: () => "Data type of the new value does not match the cell data type of the column",
  136: () => "Unable to update chart as the 'type' is missing. It must be either 'rangeChartUpdate', 'pivotChartUpdate', or 'crossFilterChartUpdate'.",
  137: ({ type: e, currentChartType: t }) => `Unable to update chart as a '${e}' update type is not permitted on a ${t}.`,
  138: ({ chartType: e }) => `invalid chart type supplied: ${e}`,
  139: ({ customThemeName: e }) => `a custom chart theme with the name ${e} has been supplied but not added to the 'chartThemes' list`,
  140: ({ name: e }) => `no stock theme exists with the name '${e}' and no custom chart theme with that name was supplied to 'customChartThemes'`,
  141: () => "cross filtering with row grouping is not supported.",
  142: () => "cross filtering is only supported in the client side row model.",
  143: ({ panel: e }) => `'${e}' is not a valid Chart Tool Panel name`,
  144: ({ type: e }) => `Invalid charts data panel group name supplied: '${e}'`,
  145: ({ group: e }) => `As of v32, only one charts customize panel group can be expanded at a time. '${e}' will not be expanded.`,
  146: ({ comp: e }) => `Unable to instantiate component '${e}' as its module hasn't been loaded. Add 'ValidationModule' to see which module is required.`,
  147: ({ group: e }) => `Invalid charts customize panel group name supplied: '${e}'`,
  148: ({ group: e }) => `invalid chartGroupsDef config '${e}'`,
  149: ({ group: e, chartType: t }) => `invalid chartGroupsDef config '${e}.${t}'`,
  150: () => "'seriesChartTypes' are required when the 'customCombo' chart type is specified.",
  151: ({ chartType: e }) => `invalid chartType '${e}' supplied in 'seriesChartTypes', converting to 'line' instead.`,
  152: ({ colId: e }) => `no 'seriesChartType' found for colId = '${e}', defaulting to 'line'.`,
  153: ({ chartDataType: e }) => `unexpected chartDataType value '${e}' supplied, instead use 'category', 'series' or 'excluded'`,
  154: ({ colId: e }) => `cross filtering requires a 'agSetColumnFilter' or 'agMultiColumnFilter' to be defined on the column with id: ${e}`,
  155: ({ option: e }) => `'${e}' is not a valid Chart Toolbar Option`,
  156: ({ panel: e }) => `Invalid panel in chartToolPanelsDef.panels: '${e}'`,
  157: ({ unrecognisedGroupIds: e }) => ["unable to find group(s) for supplied groupIds:", e],
  158: () => "can not expand a column item that does not represent a column group header",
  159: () => "Invalid params supplied to createExcelFileForExcel() - `ExcelExportParams.data` is empty.",
  160: () => "Export cancelled. Export is not allowed as per your configuration.",
  161: () => "The Excel Exporter is currently on Multi Sheet mode. End that operation by calling 'api.getMultipleSheetAsExcel()' or 'api.exportMultipleSheetsAsExcel()'",
  162: ({ id: e, dataType: t }) => `Unrecognized data type for excel export [${e}.dataType=${t}]`,
  163: ({ featureName: e }) => `Excel table export does not work with ${e}. The exported Excel file will not contain any Excel tables.
 Please turn off ${e} to enable Excel table exports.`,
  164: () => "Unable to add data table to Excel sheet: A table already exists.",
  165: () => "Unable to add data table to Excel sheet: Missing required parameters.",
  166: ({ unrecognisedGroupIds: e }) => ["unable to find groups for these supplied groupIds:", e],
  167: ({ unrecognisedColIds: e }) => ["unable to find columns for these supplied colIds:", e],
  168: () => "detailCellRendererParams.template should be function or string",
  169: () => 'Reference to eDetailGrid was missing from the details template. Please add data-ref="eDetailGrid" to the template.',
  170: ({ providedStrategy: e }) => `invalid cellRendererParams.refreshStrategy = ${e} supplied, defaulting to refreshStrategy = 'rows'.`,
  171: () => "could not find detail grid options for master detail, please set gridOptions.detailCellRendererParams.detailGridOptions",
  172: () => "could not find getDetailRowData for master / detail, please set gridOptions.detailCellRendererParams.getDetailRowData",
  173: ({ group: e }) => `invalid chartGroupsDef config '${e}'`,
  174: ({ group: e, chartType: t }) => `invalid chartGroupsDef config '${e}.${t}'`,
  175: ({ menuTabName: e, itemsToConsider: t }) => [
    `Trying to render an invalid menu item '${e}'. Check that your 'menuTabs' contains one of `,
    t
  ],
  176: ({ key: e }) => `unknown menu item type ${e}`,
  177: () => "valid values for cellSelection.handle.direction are 'x', 'y' and 'xy'. Default to 'xy'.",
  178: ({ colId: e }) => `column ${e} is not visible`,
  179: () => "totalValueGetter should be either a function or a string (expression)",
  180: () => "agRichSelectCellEditor requires cellEditorParams.values to be set",
  181: () => "agRichSelectCellEditor cannot have `multiSelect` and `allowTyping` set to `true`. AllowTyping has been turned off.",
  182: () => 'you cannot mix groupDisplayType = "multipleColumns" with treeData, only one column can be used to display groups when doing tree data',
  183: () => "Group Column Filter only works on group columns. Please use a different filter.",
  184: ({ parentGroupData: e, childNodeData: t }) => ["duplicate group keys for row data, keys should be unique", [e, t]],
  185: ({ data: e }) => ["getDataPath() should not return an empty path", [e]],
  186: ({
    rowId: e,
    rowData: t,
    duplicateRowsData: s
  }) => [
    "duplicate group keys for row data, keys should be unique",
    e,
    t,
    ...s ?? []
  ],
  187: ({ rowId: e, firstData: t, secondData: s }) => [
    `Duplicate node id ${e}. Row IDs are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`,
    "first instance",
    t,
    "second instance",
    s
  ],
  188: () => "getRowId callback must be provided for Server Side Row Model selection to work correctly.",
  189: ({ startRow: e }) => `invalid value ${e} for startRow, the value should be >= 0`,
  190: ({ rowGroupId: e, data: t }) => [
    "null and undefined values are not allowed for server side row model keys",
    e ? `column = ${e}` : "",
    "data is ",
    t
  ],
  // 191: () => `cannot multi select unless selection mode is 'multiRow'` as const,
  // 192: () => `cannot use range selection when multi selecting rows` as const,
  // 193: () => "cannot multi select unless selection mode is 'multiRow'" as const,
  194: ({ method: e }) => `calling gridApi.${e}() is only possible when using rowModelType=\`clientSide\`.`,
  195: ({ justCurrentPage: e }) => `selecting just ${e ? "current page" : "filtered"} only works when gridOptions.rowModelType='clientSide'`,
  196: ({ key: e }) => `Provided ids must be of string type. Invalid id provided: ${e}`,
  197: () => "`toggledNodes` must be an array of string ids.",
  // 198: () => `cannot multi select unless selection mode is 'multiRow'` as const,
  199: () => "getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model. Use `api.getServerSideSelectionState()` instead.",
  200: wd,
  201: ({ rowModelType: e }) => `Could not find row model for rowModelType = ${e}`,
  202: () => "`getSelectedNodes` and `getSelectedRows` functions cannot be used with `groupSelectsChildren` and the server-side row model. Use `api.getServerSideSelectionState()` instead.",
  203: () => "Server Side Row Model does not support Dynamic Row Height and Cache Purging. Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.",
  204: () => "Server Side Row Model does not support Auto Row Height and Cache Purging. Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.",
  205: ({ duplicateIdText: e }) => `Unable to display rows as duplicate row ids (${e}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`,
  206: () => "getRowId callback must be implemented for transactions to work. Transaction was ignored.",
  207: () => 'The Set Filter Parameter "defaultToNothingSelected" value was ignored because it does not work when "excelMode" is used.',
  208: () => "Set Filter Value Formatter must return string values. Please ensure the Set Filter Value Formatter returns string values for complex objects.",
  209: () => `Set Filter Key Creator is returning null for provided values and provided values are primitives. Please provide complex objects. See ${di}/filter-set-filter-list/#filter-value-types`,
  210: () => "Set Filter has a Key Creator, but provided values are primitives. Did you mean to provide complex objects?",
  211: () => "property treeList=true for Set Filter params, but you did not provide a treeListPathGetter or values of type Date.",
  212: () => "please review all your toolPanel components, it seems like at least one of them doesn't have an id",
  213: () => "Advanced Filter does not work with Filters Tool Panel. Filters Tool Panel has been disabled.",
  214: ({ key: e }) => `unable to lookup Tool Panel as invalid key supplied: ${e}`,
  215: ({ key: e, defaultByKey: t }) => `the key ${e} is not a valid key for specifying a tool panel, valid keys are: ${Object.keys(t ?? {}).join(",")}`,
  216: ({ name: e }) => `Missing component for '${e}'`,
  217: ({ invalidColIds: e }) => ["unable to find grid columns for the supplied colDef(s):", e],
  218: ({ property: e, defaultOffset: t }) => `${e} must be a number, the value you provided is not a valid number. Using the default of ${t}px.`,
  219: ({ property: e }) => `Property ${e} does not exist on the target object.`,
  220: ({ lineDash: e }) => `'${e}' is not a valid 'lineDash' option.`,
  221: () => "agAggregationComponent should only be used with the client and server side row model.",
  222: () => "agFilteredRowCountComponent should only be used with the client side row model.",
  223: () => "agSelectedRowCountComponent should only be used with the client and server side row model.",
  224: () => "agTotalAndFilteredRowCountComponent should only be used with the client side row model.",
  225: () => "agTotalRowCountComponent should only be used with the client side row model.",
  226: () => "viewport is missing init method.",
  227: () => "menu item icon must be DOM node or string",
  228: ({ menuItemOrString: e }) => `unrecognised menu item ${e}`,
  229: ({ index: e }) => ["invalid row index for ensureIndexVisible: ", e],
  230: () => "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://www.ag-grid.com/react-data-grid/master-detail-custom-detail/",
  // @deprecated v32 mark for removal as part of v32 deprecated features
  231: () => "As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.",
  232: () => "Using both rowData and v-model. rowData will be ignored.",
  233: ({ methodName: e }) => `Framework component is missing the method ${e}()`,
  234: () => 'Group Column Filter does not work with the colDef property "field". This property will be ignored.',
  235: () => 'Group Column Filter does not work with the colDef property "filterValueGetter". This property will be ignored.',
  236: () => 'Group Column Filter does not work with the colDef property "filterParams". This property will be ignored.',
  237: () => "Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.",
  238: () => "setRowCount can only accept a positive row count.",
  239: () => 'Theming API and CSS File Themes are both used in the same page. In v33 we released the Theming API as the new default method of styling the grid. See the migration docs https://www.ag-grid.com/react-data-grid/theming-migration/. Because no value was provided to the `theme` grid option it defaulted to themeQuartz. But the file (ag-grid.css) is also included and will cause styling issues. Either pass the string "legacy" to the theme grid option to use v32 style themes, or remove ag-grid.css from the page to use Theming API.',
  240: ({ theme: e }) => `theme grid option must be a Theming API theme object or the string "legacy", received: ${e}`,
  // 241: () => `cannot select multiple rows when rowSelection.mode is set to 'singleRow'` as const,
  // 242: () => 'cannot select multiple rows when using rangeSelect' as const,
  243: () => "Failed to deserialize state - each provided state object must be an object.",
  244: () => "Failed to deserialize state - `selectAllChildren` must be a boolean value or undefined.",
  245: () => "Failed to deserialize state - `toggledNodes` must be an array.",
  246: () => "Failed to deserialize state - Every `toggledNode` requires an associated string id.",
  247: () => `Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule. 
Please rebuild the selection state and reapply it.`,
  248: () => "SetFloatingFilter expects SetFilter as its parent",
  249: () => "Must supply a Value Formatter in Set Filter params when using a Key Creator",
  250: () => "Must supply a Key Creator in Set Filter params when `treeList = true` on a group column, and Tree Data or Row Grouping is enabled.",
  251: ({ chartType: e }) => `AG Grid: Unable to create chart as an invalid chartType = '${e}' was supplied.`,
  252: () => `cannot get grid to draw rows when it is in the middle of drawing rows. 
Your code probably called a grid API method while the grid was in the render stage. 
To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). 
To see what part of your code that caused the refresh check this stacktrace.`,
  253: ({ version: e }) => ["Illegal version string: ", e],
  254: () => "Cannot create chart: no chart themes available.",
  255: ({ point: e }) => `Lone surrogate U+${e == null ? void 0 : e.toString(16).toUpperCase()} is not a scalar value`,
  256: () => "Unable to initialise. See validation error, or load ValidationModule if missing.",
  257: () => bd("IntegratedChartsModule"),
  258: () => bd("SparklinesModule"),
  259: ({ part: e }) => `the argument to theme.withPart must be a Theming API part object, received: ${e}`,
  260: ({
    propName: e,
    compName: t,
    gridScoped: s,
    gridId: i,
    rowModelType: o
  }) => wd({
    reasonOrId: `AG Grid '${e}' component: ${t}`,
    moduleName: pi[t],
    gridId: i,
    gridScoped: s,
    rowModelType: o
  }),
  261: () => "As of v33, `column.isHovered()` is deprecated. Use `api.isColumnHovered(column)` instead.",
  262: () => 'As of v33, icon key "smallDown" is deprecated. Use "advancedFilterBuilderSelect" for Advanced Filter Builder dropdown, "selectOpen" for Select cell editor and dropdowns (e.g. Integrated Charts menu), "richSelectOpen" for Rich Select cell editor.',
  263: () => 'As of v33, icon key "smallLeft" is deprecated. Use "panelDelimiterRtl" for Row Group Panel / Pivot Panel, "subMenuOpenRtl" for sub-menus.',
  264: () => 'As of v33, icon key "smallRight" is deprecated. Use "panelDelimiter" for Row Group Panel / Pivot Panel, "subMenuOpen" for sub-menus.',
  265: ({ colId: e }) => `Unable to infer chart data type for column '${e}' if first data entry is null. Please specify "chartDataType", or a "cellDataType" in the column definition. For more information, see ${di}/integrated-charts-range-chart#coldefchartdatatype .`,
  266: () => 'As of v33.1, using "keyCreator" with the Rich Select Editor has been deprecated. It now requires the "formatValue" callback to convert complex data to strings.',
  267: () => "Detail grids can not use a different theme to the master grid, the `theme` detail grid option will be ignored.",
  268: () => "Transactions aren't supported with tree data when using treeDataChildrenField",
  269: () => "When `masterSelects: 'detail'`, detail grids must be configured with multi-row selection",
  270: ({ id: e, parentId: t }) => `Cycle detected for row with id='${e}' and parent id='${t}'. Resetting the parent for row with id='${e}' and showing it as a root-level node.`,
  271: ({ id: e, parentId: t }) => `Parent row not found for row with id='${e}' and parent id='${t}'. Showing row with id='${e}' as a root-level node.`,
  272: () => Jh(),
  273: ({ providedId: e, usedId: t }) => `Provided column id '${e}' was already in use, ensure all column and group ids are unique. Using '${t}' instead.`,
  274: ({ prop: e }) => {
    let t = `Since v33, ${e} has been deprecated.`;
    switch (e) {
      case "maxComponentCreationTimeMs":
        t += " This property is no longer required and so will be removed in a future version.";
        break;
      case "setGridApi":
        t += " This method is not called by AG Grid. To access the GridApi see: https://ag-grid.com/react-data-grid/grid-interface/#grid-api ";
        break;
      case "children":
        t += " For multiple versions AgGridReact does not support children.";
        break;
    }
    return t;
  },
  275: eg,
  276: () => "Row Numbers Row Resizer cannot be used when Grid Columns have `autoHeight` enabled."
};
function MR(e, t) {
  const s = DR[e];
  if (!s)
    return [`Missing error text for error id ${e}!`];
  const i = s(t), n = `
See ${eu(e, t)}`;
  return Array.isArray(i) ? i.concat(n) : [i, n];
}
var ER = {
  1: "Charting Aggregation",
  2: "pivotResultFields",
  3: "setTooltip"
}, dl = class bs {
  /**
   * @param providedOptions
   * @returns Shallow copy of the provided options with global options merged in.
   */
  static applyGlobalGridOptions(t) {
    if (!bs.gridOptions)
      return { ...t };
    let s = {};
    return me(s, bs.gridOptions, !0, !0), bs.mergeStrategy === "deep" ? me(s, t, !0, !0) : s = { ...s, ...t }, bs.gridOptions.context && (s.context = bs.gridOptions.context), t.context && (bs.mergeStrategy === "deep" && s.context && me(t.context, s.context, !0, !0), s.context = t.context), s;
  }
};
dl.gridOptions = void 0;
dl.mergeStrategy = "shallow";
var AR = dl;
function IR(e, t, s) {
  if (!t)
    return K(11), {};
  let i;
  {
    const n = _({ tag: "div" });
    n.style.height = "100%", e.appendChild(n), e = n, i = () => e.remove();
  }
  return new LR().create(
    e,
    t,
    (n) => {
      const r = new Pb(e);
      n.createBean(r);
    },
    void 0,
    s,
    i
  );
}
var TR = 1, LR = class {
  create(e, t, s, i, o, n) {
    const r = AR.applyGlobalGridOptions(t), a = r.gridId ?? String(TR++), l = this.getRegisteredModules(o, a, r.rowModelType), d = this.createBeansList(r.rowModelType, l, a), c = this.createProvidedBeans(e, r, o);
    if (!d)
      return;
    const u = {
      providedBeanInstances: c,
      beanClasses: d,
      gridId: a,
      beanInitComparator: db,
      beanDestroyComparator: cb,
      derivedBeans: [ab],
      destroyCallback: n
    }, h = new ZC(u);
    return this.registerModuleFeatures(h, l), s(h), h.getBean("syncSvc").start(), i && i(h), h.getBean("gridApi");
  }
  getRegisteredModules(e, t, s) {
    var i;
    return co(wR, void 0, !0), (i = e == null ? void 0 : e.modules) == null || i.forEach((o) => co(o, t)), UC(t, yd(s));
  }
  registerModuleFeatures(e, t) {
    const s = e.getBean("registry"), i = e.getBean("apiFunctionSvc");
    t.forEach((o) => {
      s.registerModule(o);
      const n = o.apiFunctions;
      n && Object.keys(n).forEach((a) => {
        i == null || i.addFunction(a, n[a]);
      });
    });
  }
  createProvidedBeans(e, t, s) {
    let i = s ? s.frameworkOverrides : null;
    ie(i) && (i = new rb());
    const o = {
      gridOptions: t,
      eGridDiv: e,
      globalListener: s ? s.globalListener : null,
      globalSyncListener: s ? s.globalSyncListener : null,
      frameworkOverrides: i
    };
    return s && s.providedBeanInstances && Object.assign(o, s.providedBeanInstances), o;
  }
  createBeansList(e, t, s) {
    const i = {
      clientSide: "ClientSideRowModel",
      infinite: "InfiniteRowModel",
      serverSide: "ServerSideRowModel",
      viewport: "ViewportRowModel"
    }, o = yd(e), n = i[o];
    if (!n) {
      zi(201, { rowModelType: o }, `Unknown rowModelType ${o}.`);
      return;
    }
    if (!$C()) {
      zi(272, void 0, Jh());
      return;
    }
    if (!e) {
      const a = Object.entries(i).filter(
        ([l, d]) => Qr(d, s, l)
      );
      if (a.length == 1) {
        const [l, d] = a[0];
        if (l !== o) {
          const c = {
            moduleName: d,
            rowModelType: l
          };
          zi(275, c, eg(c));
          return;
        }
      }
    }
    if (!Qr(n, s, o)) {
      zi(
        200,
        {
          reasonOrId: `rowModelType = '${o}'`,
          moduleName: n,
          gridScoped: Wa(),
          gridId: s,
          rowModelType: o
        },
        `Missing module ${n}Module for rowModelType ${o}.`
      );
      return;
    }
    const r = /* @__PURE__ */ new Set();
    return t.forEach((a) => {
      var l;
      return (l = a.beans) == null ? void 0 : l.forEach((d) => r.add(d));
    }), Array.from(r);
  }
};
function yd(e) {
  return e ?? "clientSide";
}
function Di(e, t) {
  if (typeof e != "number")
    return "";
  const s = t(), i = s("thousandSeparator", ","), o = s("decimalSeparator", ".");
  return e.toString().replace(".", o).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${i}`);
}
var kR = {
  enableBrowserTooltips: !0,
  tooltipTrigger: !0,
  tooltipMouseTrack: !0,
  tooltipShowMode: !0,
  tooltipInteraction: !0,
  defaultColGroupDef: !0,
  suppressAutoSize: !0,
  skipHeaderOnAutoSize: !0,
  autoSizeStrategy: !0,
  components: !0,
  stopEditingWhenCellsLoseFocus: !0,
  undoRedoCellEditing: !0,
  undoRedoCellEditingLimit: !0,
  excelStyles: !0,
  cacheQuickFilter: !0,
  customChartThemes: !0,
  chartThemeOverrides: !0,
  chartToolPanelsDef: !0,
  loadingCellRendererSelector: !0,
  localeText: !0,
  keepDetailRows: !0,
  keepDetailRowsCount: !0,
  detailRowHeight: !0,
  detailRowAutoHeight: !0,
  tabIndex: !0,
  valueCache: !0,
  valueCacheNeverExpires: !0,
  enableCellExpressions: !0,
  suppressTouch: !0,
  suppressBrowserResizeObserver: !0,
  suppressPropertyNamesCheck: !0,
  debug: !0,
  dragAndDropImageComponent: !0,
  loadingOverlayComponent: !0,
  suppressLoadingOverlay: !0,
  noRowsOverlayComponent: !0,
  paginationPageSizeSelector: !0,
  paginateChildRows: !0,
  pivotPanelShow: !0,
  pivotSuppressAutoColumn: !0,
  suppressExpandablePivotGroups: !0,
  aggFuncs: !0,
  allowShowChangeAfterFilter: !0,
  ensureDomOrder: !0,
  enableRtl: !0,
  suppressColumnVirtualisation: !0,
  suppressMaxRenderedRowRestriction: !0,
  suppressRowVirtualisation: !0,
  rowDragText: !0,
  groupLockGroupColumns: !0,
  suppressGroupRowsSticky: !0,
  rowModelType: !0,
  cacheOverflowSize: !0,
  infiniteInitialRowCount: !0,
  serverSideInitialRowCount: !0,
  maxBlocksInCache: !0,
  maxConcurrentDatasourceRequests: !0,
  blockLoadDebounceMillis: !0,
  serverSideOnlyRefreshFilteredGroups: !0,
  serverSidePivotResultFieldSeparator: !0,
  viewportRowModelPageSize: !0,
  viewportRowModelBufferSize: !0,
  debounceVerticalScrollbar: !0,
  suppressAnimationFrame: !0,
  suppressPreventDefaultOnMouseWheel: !0,
  scrollbarWidth: !0,
  icons: !0,
  suppressRowTransform: !0,
  gridId: !0,
  enableGroupEdit: !0,
  initialState: !0,
  processUnpinnedColumns: !0,
  createChartContainer: !0,
  getLocaleText: !0,
  getRowId: !0,
  reactiveCustomComponents: !0,
  columnMenu: !0,
  suppressSetFilterByDefault: !0,
  getDataPath: !0,
  enableCellSpan: !0
}, ke = "clientSide", Fe = "serverSide", si = "infinite", GR = {
  onGroupExpandedOrCollapsed: [ke],
  refreshClientSideRowModel: [ke],
  isRowDataEmpty: [ke],
  forEachLeafNode: [ke],
  forEachNodeAfterFilter: [ke],
  forEachNodeAfterFilterAndSort: [ke],
  resetRowHeights: [ke],
  applyTransaction: [ke],
  applyTransactionAsync: [ke],
  flushAsyncTransactions: [ke],
  getBestCostNodeSelection: [ke],
  getServerSideSelectionState: [Fe],
  setServerSideSelectionState: [Fe],
  applyServerSideTransaction: [Fe],
  applyServerSideTransactionAsync: [Fe],
  applyServerSideRowData: [Fe],
  retryServerSideLoads: [Fe],
  flushServerSideAsyncTransactions: [Fe],
  refreshServerSide: [Fe],
  getServerSideGroupLevelState: [Fe],
  refreshInfiniteCache: [si],
  purgeInfiniteCache: [si],
  getInfiniteRowCount: [si],
  isLastRowIndexKnown: [si, Fe],
  expandAll: [ke, Fe],
  collapseAll: [ke, Fe],
  onRowHeightChanged: [ke, Fe],
  setRowCount: [si, Fe],
  getCacheBlockState: [si, Fe]
}, OR = {
  showLoadingOverlay: {
    version: "v32",
    message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
  },
  clearRangeSelection: {
    version: "v32.2",
    message: "Use `clearCellSelection` instead."
  },
  getInfiniteRowCount: {
    version: "v32.2",
    old: "getInfiniteRowCount()",
    new: "getDisplayedRowCount()"
  },
  selectAllFiltered: {
    version: "v33",
    old: "selectAllFiltered()",
    new: 'selectAll("filtered")'
  },
  deselectAllFiltered: {
    version: "v33",
    old: "deselectAllFiltered()",
    new: 'deselectAll("filtered")'
  },
  selectAllOnCurrentPage: {
    version: "v33",
    old: "selectAllOnCurrentPage()",
    new: 'selectAll("currentPage")'
  },
  deselectAllOnCurrentPage: {
    version: "v33",
    old: "deselectAllOnCurrentPage()",
    new: 'deselectAll("currentPage")'
  }
};
function BR(e, t, s) {
  const i = OR[e];
  if (i) {
    const { version: n, new: r, old: a, message: l } = i, d = a ?? e;
    return (...c) => {
      const u = r ? `Please use ${r} instead. ` : "";
      return Ki(`Since ${n} api.${d} is deprecated. ${u}${l ?? ""}`), t.apply(t, c);
    };
  }
  const o = GR[e];
  return o ? (...n) => {
    const r = s.rowModel.getType();
    if (!o.includes(r)) {
      li(
        `api.${e} can only be called when gridOptions.rowModelType is ${o.join(" or ")}`
      );
      return;
    }
    return t.apply(t, n);
  } : t;
}
var NR = {
  expanded: 1,
  contracted: 1,
  "tree-closed": 1,
  "tree-open": 1,
  "tree-indeterminate": 1,
  pin: 1,
  "eye-slash": 1,
  arrows: 1,
  left: 1,
  right: 1,
  group: 1,
  aggregation: 1,
  pivot: 1,
  "not-allowed": 1,
  chart: 1,
  cross: 1,
  cancel: 1,
  tick: 1,
  first: 1,
  previous: 1,
  next: 1,
  last: 1,
  linked: 1,
  unlinked: 1,
  "color-picker": 1,
  loading: 1,
  menu: 1,
  "menu-alt": 1,
  filter: 1,
  columns: 1,
  maximize: 1,
  minimize: 1,
  copy: 1,
  cut: 1,
  paste: 1,
  grip: 1,
  save: 1,
  csv: 1,
  excel: 1,
  "small-down": 1,
  "small-left": 1,
  "small-right": 1,
  "small-up": 1,
  asc: 1,
  desc: 1,
  none: 1,
  up: 1,
  down: 1,
  plus: 1,
  minus: 1,
  settings: 1,
  "checkbox-checked": 1,
  "checkbox-indeterminate": 1,
  "checkbox-unchecked": 1,
  "radio-button-on": 1,
  "radio-button-off": 1,
  eye: 1,
  "column-arrow": 1,
  "un-pin": 1,
  "pinned-top": 1,
  "pinned-bottom": 1
}, HR = {
  chart: "MenuCore",
  cancel: "EnterpriseCore",
  first: "Pagination",
  previous: "Pagination",
  next: "Pagination",
  last: "Pagination",
  linked: "IntegratedCharts",
  loadingMenuItems: "MenuCore",
  unlinked: "IntegratedCharts",
  menu: "ColumnHeaderComp",
  legacyMenu: "ColumnMenu",
  filter: "ColumnFilter",
  filterActive: "ColumnFilter",
  filterTab: "ColumnMenu",
  filtersToolPanel: "FiltersToolPanel",
  columns: ["MenuCore"],
  columnsToolPanel: ["ColumnsToolPanel"],
  maximize: "EnterpriseCore",
  minimize: "EnterpriseCore",
  save: "MenuCore",
  columnGroupOpened: "ColumnGroupHeaderComp",
  columnGroupClosed: "ColumnGroupHeaderComp",
  accordionOpen: "EnterpriseCore",
  accordionClosed: "EnterpriseCore",
  accordionIndeterminate: "EnterpriseCore",
  columnSelectClosed: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectOpen: ["ColumnsToolPanel", "ColumnMenu"],
  columnSelectIndeterminate: ["ColumnsToolPanel", "ColumnMenu"],
  columnMovePin: "SharedDragAndDrop",
  columnMoveHide: "SharedDragAndDrop",
  columnMoveMove: "SharedDragAndDrop",
  columnMoveLeft: "SharedDragAndDrop",
  columnMoveRight: "SharedDragAndDrop",
  columnMoveGroup: "SharedDragAndDrop",
  columnMoveValue: "SharedDragAndDrop",
  columnMovePivot: "SharedDragAndDrop",
  dropNotAllowed: "SharedDragAndDrop",
  ensureColumnVisible: ["ColumnsToolPanel", "ColumnMenu"],
  groupContracted: "GroupCellRenderer",
  groupExpanded: "GroupCellRenderer",
  setFilterGroupClosed: "SetFilter",
  setFilterGroupOpen: "SetFilter",
  setFilterGroupIndeterminate: "SetFilter",
  setFilterLoading: "SetFilter",
  close: "EnterpriseCore",
  check: "MenuItem",
  colorPicker: "CommunityCore",
  groupLoading: "LoadingCellRenderer",
  menuAlt: "ColumnHeaderComp",
  menuPin: "MenuCore",
  menuValue: "MenuCore",
  menuAddRowGroup: ["MenuCore", "ColumnsToolPanel"],
  menuRemoveRowGroup: ["MenuCore", "ColumnsToolPanel"],
  clipboardCopy: "MenuCore",
  clipboardCut: "MenuCore",
  clipboardPaste: "MenuCore",
  pivotPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  rowGroupPanel: ["ColumnsToolPanel", "RowGroupingPanel"],
  valuePanel: "ColumnsToolPanel",
  columnDrag: "EnterpriseCore",
  rowDrag: ["RowDrag", "DragAndDrop"],
  csvExport: "MenuCore",
  excelExport: "MenuCore",
  smallDown: "CommunityCore",
  selectOpen: "CommunityCore",
  richSelectOpen: "RichSelect",
  richSelectRemove: "RichSelect",
  smallLeft: "CommunityCore",
  smallRight: "CommunityCore",
  subMenuOpen: "MenuItem",
  subMenuOpenRtl: "MenuItem",
  panelDelimiter: "RowGroupingPanel",
  panelDelimiterRtl: "RowGroupingPanel",
  smallUp: "CommunityCore",
  sortAscending: ["MenuCore", "Sort"],
  sortDescending: ["MenuCore", "Sort"],
  sortUnSort: ["MenuCore", "Sort"],
  advancedFilterBuilder: "AdvancedFilter",
  advancedFilterBuilderDrag: "AdvancedFilter",
  advancedFilterBuilderInvalid: "AdvancedFilter",
  advancedFilterBuilderMoveUp: "AdvancedFilter",
  advancedFilterBuilderMoveDown: "AdvancedFilter",
  advancedFilterBuilderAdd: "AdvancedFilter",
  advancedFilterBuilderRemove: "AdvancedFilter",
  advancedFilterBuilderSelectOpen: "AdvancedFilter",
  chartsMenu: "IntegratedCharts",
  chartsMenuEdit: "IntegratedCharts",
  chartsMenuAdvancedSettings: "IntegratedCharts",
  chartsMenuAdd: "IntegratedCharts",
  chartsColorPicker: "IntegratedCharts",
  chartsThemePrevious: "IntegratedCharts",
  chartsThemeNext: "IntegratedCharts",
  chartsDownload: "IntegratedCharts",
  checkboxChecked: "CommunityCore",
  checkboxIndeterminate: "CommunityCore",
  checkboxUnchecked: "CommunityCore",
  radioButtonOn: "CommunityCore",
  radioButtonOff: "CommunityCore",
  rowPin: "PinnedRow",
  rowUnpin: "PinnedRow",
  rowPinBottom: "PinnedRow",
  rowPinTop: "PinnedRow"
}, VR = /* @__PURE__ */ new Set([
  "colorPicker",
  "smallUp",
  "checkboxChecked",
  "checkboxIndeterminate",
  "checkboxUnchecked",
  "radioButtonOn",
  "radioButtonOff",
  "smallDown",
  "smallLeft",
  "smallRight"
]), _R = class extends S {
  constructor() {
    super(...arguments), this.beanName = "validation";
  }
  wireBeans(e) {
    this.gridOptions = e.gridOptions, vm(this);
  }
  warnOnInitialPropertyUpdate(e, t) {
    e === "api" && kR[t] && P(22, { key: t });
  }
  processGridOptions(e) {
    this.processOptions(e, yx());
  }
  validateApiFunction(e, t) {
    return BR(e, t, this.beans);
  }
  missingUserComponent(e, t, s, i) {
    const o = pi[t];
    o ? this.gos.assertModuleRegistered(
      o,
      `AG Grid '${e}' component: ${t}`
    ) : P(101, {
      propertyName: e,
      componentName: t,
      agGridDefaults: s,
      jsComps: i
    });
  }
  checkRowEvents(e) {
    zR.has(e) && P(10, { eventType: e });
  }
  validateIcon(e) {
    if (VR.has(e) && P(43, { iconName: e }), NR[e])
      return;
    const t = HR[e];
    if (t) {
      K(200, {
        reasonOrId: `icon '${e}'`,
        moduleName: t,
        gridScoped: Wa(),
        gridId: this.beans.context.getGridId(),
        rowModelType: this.gos.get("rowModelType"),
        additionalText: "Alternatively, use the CSS icon name directly."
      });
      return;
    }
    P(134, { iconName: e });
  }
  isProvidedUserComp(e) {
    return !!pi[e];
  }
  /** Should only be called via the GridOptionsService */
  validateColDef(e) {
    this.processOptions(e, ax());
  }
  processOptions(e, t) {
    const { validations: s, deprecations: i, allProperties: o, propertyExceptions: n, objectName: r, docsUrl: a } = t;
    o && this.gridOptions.suppressPropertyNamesCheck !== !0 && this.checkProperties(
      e,
      [...n ?? [], ...Object.keys(i)],
      o,
      r,
      a
    );
    const l = /* @__PURE__ */ new Set();
    Object.keys(e).forEach((c) => {
      const u = i[c];
      if (u) {
        const { message: w, version: C } = u;
        l.add(`As of v${C}, ${String(c)} is deprecated. ${w ?? ""}`);
      }
      const h = e[c];
      if (h == null || h === !1)
        return;
      const g = s[c];
      if (!g)
        return;
      const { dependencies: p, validate: f, supportedRowModels: m, expectedType: b } = g;
      if (b) {
        const w = typeof h;
        if (w !== b) {
          l.add(
            `${String(c)} should be of type '${b}' but received '${w}' (${h}).`
          );
          return;
        }
      }
      if (m) {
        const w = this.gridOptions.rowModelType ?? "clientSide";
        if (!m.includes(w)) {
          l.add(
            `${String(c)} is not supported with the '${w}' row model. It is only valid with: ${m.join(", ")}.`
          );
          return;
        }
      }
      if (p) {
        const w = this.checkForRequiredDependencies(c, p, e);
        if (w) {
          l.add(w);
          return;
        }
      }
      if (f) {
        const w = f(e, this.gridOptions, this.beans);
        if (w) {
          l.add(w);
          return;
        }
      }
    }), l.size > 0 && l.forEach((c) => {
      Ki(c);
    });
  }
  checkForRequiredDependencies(e, t, s) {
    const o = Object.entries(t).filter(([n, r]) => {
      const a = s[n];
      return !r.required.includes(a);
    });
    return o.length === 0 ? null : o.map(
      ([n, r]) => `'${String(e)}' requires '${n}' to be one of [${r.required.map((a) => a === null ? "null" : a === void 0 ? "undefined" : a).join(", ")}]. ${r.reason ?? ""}`
    ).join(`
           `);
  }
  checkProperties(e, t, s, i, o) {
    const n = ["__ob__", "__v_skip", "__metadata__"], r = WR(
      Object.getOwnPropertyNames(e),
      [...n, ...t, ...s],
      s
    ), a = Object.keys(r);
    for (const l of a) {
      const d = r[l];
      let c = `invalid ${i} property '${l}' did you mean any of these: ${d.slice(0, 8).join(", ")}.`;
      s.includes("context") && (c += `
If you are trying to annotate ${i} with application data, use the '${i}.context' property instead.`), Ki(c);
    }
    if (a.length > 0 && o) {
      const l = this.beans.frameworkOverrides.getDocLink(o);
      Ki(`to see all the valid ${i} properties please check: ${l}`);
    }
  }
  getConsoleMessage(e, t) {
    return MR(e, t);
  }
};
function WR(e, t, s) {
  const i = {}, o = e.filter(
    (n) => !t.some((r) => r === n)
  );
  return o.length > 0 && o.forEach(
    (n) => i[n] = Qh({ inputValue: n, allSuggestions: s }).values
  ), i;
}
var zR = /* @__PURE__ */ new Set([
  "firstChildChanged",
  "lastChildChanged",
  "childIndexChanged"
]), UR = {
  moduleName: "Validation",
  version: Q,
  beans: [_R]
};
function tg(e) {
  e.sibling && (e.sibling.childrenAfterFilter = e.childrenAfterFilter);
}
var jR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "filterStage", this.refreshProps = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]), this.step = "filter";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    const { changedPath: t } = e;
    this.filter(t);
  }
  filter(e) {
    var s;
    const t = !!((s = this.filterManager) != null && s.isChildFilterPresent());
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const s = (i, o) => {
      i.hasChildren() && e && !o ? i.childrenAfterFilter = i.childrenAfterGroup.filter((n) => {
        const r = n.childrenAfterFilter && n.childrenAfterFilter.length > 0, a = n.data && this.filterManager.doesRowPassFilter({ rowNode: n });
        return r || a;
      }) : i.childrenAfterFilter = i.childrenAfterGroup, tg(i);
    };
    if (this.doingTreeDataFiltering()) {
      const i = (n, r) => {
        if (n.childrenAfterGroup)
          for (let a = 0; a < n.childrenAfterGroup.length; a++) {
            const l = n.childrenAfterGroup[a], d = r || this.filterManager.doesRowPassFilter({ rowNode: l });
            l.childrenAfterGroup ? i(n.childrenAfterGroup[a], d) : s(l, d);
          }
        s(n, r);
      }, o = (n) => i(n, !1);
      t.executeFromRootNode(o);
    } else {
      const i = (o) => s(o, !1);
      t.forEachChangedNodeDepthFirst(i, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
}, $R = class extends el {
  constructor() {
    super(...arguments), this.iconCreated = !1;
  }
  setComp(e, t, s, i, o) {
    this.comp = e;
    const n = So(this, this.beans.context, o);
    this.eButtonShowMainFilter = s, this.eFloatingFilterBody = i, this.setGui(t, n), this.setupActive(), this.refreshHeaderStyles(), this.setupWidth(n), this.setupLeft(n), this.setupHover(n), this.setupFocus(n), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(n), this.setupUi(), n.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) }), this.setupFilterChangedListener(n), n.addManagedListeners(this.column, { colDefChanged: () => this.onColDefChanged(n) }), n.addDestroyFunc(() => {
      this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.clearComponent();
    });
  }
  // empty abstract method
  resizeHeader() {
  }
  moveHeader() {
  }
  getHeaderClassParams() {
    const { column: e, beans: t } = this, s = e.colDef;
    return N(t.gos, {
      colDef: s,
      column: e,
      floatingFilter: !0
    });
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, s = !!e.floatingFilter;
    this.active = t && s;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = k("filter", this.beans, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus(e) {
    e.createManagedBean(
      new ms(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
  }
  setupAria() {
    const e = this.getLocaleTextFunc();
    Ee(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    var r;
    const { beans: t } = this;
    if (te(t) === this.eGui)
      return;
    const o = Be(t, this.eGui, null, e.shiftKey);
    if (o) {
      (r = t.headerNavigation) == null || r.scrollToColumn(this.column), e.preventDefault(), o.focus();
      return;
    }
    const n = this.findNextColumnWithFloatingFilter(e.shiftKey);
    n && t.focusSvc.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.rowCtrl.rowIndex,
        column: n
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.visibleCols;
    let s = this.column;
    do
      if (s = e ? t.getColBefore(s) : t.getColAfter(s), !s)
        break;
    while (!s.getColDef().filter || !s.getColDef().floatingFilter);
    return s;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case y.UP:
      case y.DOWN:
      case y.LEFT:
      case y.RIGHT:
        if (t)
          return;
        vt(e);
      case y.ENTER:
        t && Ve(this.eGui) && e.preventDefault();
        break;
      case y.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const s = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), i = !!e.relatedTarget && Is(e.relatedTarget, "ag-floating-filter");
    if (s && i && e.target === this.eGui) {
      const o = this.lastFocusEvent, n = !!(o && o.key === y.TAB);
      if (o && n) {
        const r = o.shiftKey;
        Ve(this.eGui, r);
      }
    }
    this.focusThis();
  }
  setupHover(e) {
    var t;
    (t = this.beans.colHover) == null || t.addHeaderFilterColumnHoverListener(e, this.comp, this.column, this.eGui);
  }
  setupLeft(e) {
    const t = new Ja(this.column, this.eGui, this.beans);
    e.createManagedBean(t);
  }
  setupFilterButton() {
    var e;
    this.suppressFilterButton = !((e = this.beans.menuSvc) != null && e.isFloatingFilterButtonEnabled(this.column)), this.highlightFilterButtonWhenActive = !fe(this.gos);
  }
  setupUserComp() {
    var t;
    if (!this.active)
      return;
    const e = (t = this.beans.filterManager) == null ? void 0 : t.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    var t;
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    (t = this.beans.menuSvc) == null || t.showFilterMenu({
      column: this.column,
      buttonElement: e,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter(e) {
    if (!this.active)
      return;
    const { filterManager: t } = this.beans, s = (i) => {
      if ((i == null ? void 0 : i.source) === "filterDestroyed" && !this.isAlive())
        return;
      const o = this.comp.getFloatingFilterComp();
      o && o.then((n) => {
        if (n) {
          const r = t == null ? void 0 : t.getCurrentFloatingFilterParentModel(this.column), a = i ? {
            // event can have additional params like `afterDataChange` which need to be passed through
            ...i,
            columns: i.columns ?? [],
            source: i.source === "api" ? "api" : "columnFilter"
          } : null;
          n.onParentModelChanged(r, a);
        }
      });
    };
    [this.destroySyncListener] = e.addManagedListeners(this.column, { filterChanged: s }), t != null && t.isFilterActive(this.column) && s(null);
  }
  setupWidth(e) {
    const t = () => {
      const s = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(s);
    };
    e.addManagedListeners(this.column, { widthChanged: t }), t();
  }
  setupFilterChangedListener(e) {
    this.active && ([this.destroyFilterChangedListener] = e.addManagedListeners(this.column, {
      filterChanged: this.updateFilterButton.bind(this)
    }), this.updateFilterButton());
  }
  updateFilterButton() {
    var e;
    if (!this.suppressFilterButton && this.comp) {
      const t = !!((e = this.beans.filterManager) != null && e.isFilterAllowed(this.column));
      this.comp.setButtonWrapperDisplayed(t), this.highlightFilterButtonWhenActive && t && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged(e) {
    var n;
    const t = this.active;
    this.setupActive();
    const s = !t && this.active;
    t && !this.active && (this.destroySyncListener(), this.destroyFilterChangedListener());
    const i = this.active ? (n = this.beans.filterManager) == null ? void 0 : n.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, o = this.comp.getFloatingFilterComp();
    !o || !i ? this.updateCompDetails(e, i, s) : o.then((r) => {
      var a;
      !r || (a = this.beans.filterManager) != null && a.areFilterCompsDifferent(this.userCompDetails ?? null, i) ? this.updateCompDetails(e, i, s) : this.updateFloatingFilterParams(i);
    });
  }
  updateCompDetails(e, t, s) {
    this.isAlive() && (this.setCompDetails(t), this.setupFilterButton(), this.setupUi(), s && (this.setupSyncWithFilter(e), this.setupFilterChangedListener(e)));
  }
  updateFloatingFilterParams(e) {
    var s;
    if (!e)
      return;
    const t = e.params;
    (s = this.comp.getFloatingFilterComp()) == null || s.then((i) => {
      i != null && i.refresh && typeof i.refresh == "function" && i.refresh(t);
    });
  }
  addResizeAndMoveKeyboardListeners() {
  }
  destroy() {
    super.destroy(), this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
};
function KR(e, t) {
  var i;
  const s = e.colModel.getCol(t);
  if (!s) {
    K(12, { colKey: t });
    return;
  }
  (i = e.menuSvc) == null || i.showColumnMenu({
    column: s,
    positionBy: "auto"
  });
}
function qR(e) {
  var t;
  (t = e.menuSvc) == null || t.hidePopupMenu();
}
var sg = {
  moduleName: "SharedMenu",
  version: Q,
  beans: [Mw],
  apiFunctions: {
    showColumnMenu: KR,
    hidePopupMenu: qR
  }
}, YR = 0, ZR = 200, QR = class extends S {
  constructor() {
    super(...arguments), this.beanName = "popupSvc", this.popupList = [];
  }
  postConstruct() {
    this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: s, column: i, node: o, event: n } = e, r = t.getBoundingClientRect(), a = this.getParentRect();
    this.setAlignedTo(t, s);
    let l = !1;
    const d = () => {
      const c = this.keepXYWithinBounds(
        s,
        r.top - a.top,
        0
        /* vertical */
      ), u = s.clientWidth > 0 ? s.clientWidth : 200;
      l || (s.style.minWidth = `${u}px`, l = !0);
      const g = a.right - a.left - u;
      let p;
      return this.gos.get("enableRtl") ? (p = m(), p < 0 && (p = f(), this.setAlignedStyles(s, "left")), p > g && (p = 0, this.setAlignedStyles(s, "right"))) : (p = f(), p > g && (p = m(), this.setAlignedStyles(s, "right")), p < 0 && (p = 0, this.setAlignedStyles(s, "left"))), { x: p, y: c };
      function f() {
        return r.right - a.left - 2;
      }
      function m() {
        return r.left - a.left - u;
      }
    };
    this.positionPopup({
      ePopup: s,
      keepWithinBounds: !0,
      updatePosition: d,
      postProcessCallback: () => this.callPostProcessPopup(
        "subMenu",
        s,
        t,
        n instanceof MouseEvent ? n : void 0,
        i,
        o
      )
    });
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: s, nudgeY: i, skipObserver: o } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: s,
      nudgeY: i,
      keepWithinBounds: !0,
      skipObserver: o,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(
        e.type,
        e.ePopup,
        null,
        e.mouseEvent,
        e.column,
        e.rowNode
      )
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const {
      ePopup: t,
      nudgeX: s,
      nudgeY: i,
      keepWithinBounds: o,
      eventSource: n,
      alignSide: r = "left",
      position: a = "over",
      column: l,
      rowNode: d,
      type: c
    } = e, u = n.getBoundingClientRect(), h = this.getParentRect();
    this.setAlignedTo(n, t);
    const g = () => {
      let p = u.left - h.left;
      r === "right" && (p -= t.offsetWidth - u.width);
      let f;
      return a === "over" ? (f = u.top - h.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, u, h, e.nudgeY || 0) === "under" ? f = u.top - h.top + u.height : f = u.top - t.offsetHeight - (i || 0) * 2 - h.top), { x: p, y: f };
    };
    this.positionPopup({
      ePopup: t,
      nudgeX: s,
      nudgeY: i,
      keepWithinBounds: o,
      updatePosition: g,
      postProcessCallback: () => this.callPostProcessPopup(c, t, n, null, l, d)
    });
  }
  shouldRenderUnderOrAbove(e, t, s, i) {
    const o = s.bottom - t.bottom, n = t.top - s.top, r = e.offsetHeight + i;
    return o > r ? "under" : n > r || n > o ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const s = this.getPopupIndex(e);
    if (s === -1)
      return;
    const i = this.popupList[s], { alignedToElement: o } = i;
    !o || (["right", "left", "over", "above", "under"].forEach((r) => {
      o.classList.remove(`ag-has-popup-positioned-${r}`), e.classList.remove(`ag-popup-positioned-${r}`);
    }), !t) || (o.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  setAlignedTo(e, t) {
    const s = this.getPopupIndex(t);
    if (s !== -1) {
      const i = this.popupList[s];
      i.alignedToElement = e;
    }
  }
  callPostProcessPopup(e, t, s, i, o, n) {
    const r = this.gos.getCallback("postProcessPopup");
    r && r({
      column: o,
      rowNode: n,
      ePopup: t,
      type: e,
      eventSource: s,
      mouseEvent: i
    });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: s, nudgeX: i, nudgeY: o, skipObserver: n, updatePosition: r } = e, a = { width: 0, height: 0 }, l = (d = !1) => {
      let { x: c, y: u } = r();
      d && t.clientWidth === a.width && t.clientHeight === a.height || (a.width = t.clientWidth, a.height = t.clientHeight, i && (c += i), o && (u += o), s && (c = this.keepXYWithinBounds(
        t,
        c,
        1
        /* horizontal */
      ), u = this.keepXYWithinBounds(
        t,
        u,
        0
        /* vertical */
      )), t.style.left = `${c}px`, t.style.top = `${u}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (l(), !n) {
      const d = fs(this.beans, t, () => l(!0));
      setTimeout(() => d(), ZR);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getParentRect() {
    const e = pe(this.beans);
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), jc(t);
  }
  keepXYWithinBounds(e, t, s) {
    const i = s === 0, o = i ? "clientHeight" : "clientWidth", n = i ? "top" : "left", r = i ? "height" : "width", a = i ? "scrollTop" : "scrollLeft", l = pe(this.beans), d = l.documentElement, c = this.getPopupParent(), u = e.getBoundingClientRect(), h = c.getBoundingClientRect(), g = l.documentElement.getBoundingClientRect(), p = c === l.body, f = Math.ceil(u[r]);
    let b = p ? (i ? Uc : dn)(d) + d[a] : c[o];
    p && (b -= Math.abs(g[n] - h[n]));
    const w = b - f;
    return Math.min(Math.max(t, 0), Math.abs(w));
  }
  addPopup(e) {
    const t = pe(this.beans), { eChild: s, ariaLabel: i, alwaysOnTop: o, positionCallback: n, anchorToElement: r } = e;
    if (!t)
      return P(122), { hideFunc: () => {
      } };
    const a = this.getPopupIndex(s);
    if (a !== -1)
      return { hideFunc: this.popupList[a].hideFunc };
    this.initialisePopupPosition(s);
    const l = this.createPopupWrapper(s, i, !!o), d = this.addEventListenersToPopup({ ...e, wrapperEl: l });
    return n && n(), this.addPopupToPopupList(s, l, d, r), {
      hideFunc: d
    };
  }
  initialisePopupPosition(e) {
    const s = this.getPopupParent().getBoundingClientRect();
    T(e.style.top) || (e.style.top = `${s.top * -1}px`), T(e.style.left) || (e.style.left = `${s.left * -1}px`);
  }
  createPopupWrapper(e, t, s) {
    const i = this.getPopupParent(), { environment: o, gos: n } = this.beans, r = _({ tag: "div" });
    return o.applyThemeClasses(r), r.classList.add("ag-popup"), e.classList.add(n.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || Ne(e, "dialog"), Ee(e, t), r.appendChild(e), i.appendChild(r), s ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), r;
  }
  handleThemeChange(e) {
    if (e.themeChanged) {
      const t = this.beans.environment;
      for (const s of this.popupList)
        t.applyThemeClasses(s.wrapper);
    }
  }
  addEventListenersToPopup(e) {
    const t = this.beans, s = pe(t), i = this.getPopupParent(), { wrapperEl: o, eChild: n, closedCallback: r, afterGuiAttached: a, closeOnEsc: l, modal: d } = e;
    let c = !1;
    const u = (f) => {
      if (!o.contains(te(t)))
        return;
      f.key === y.ESCAPE && !gt(f) && p({ keyboardEvent: f });
    }, h = (f) => p({ mouseEvent: f }), g = (f) => p({ touchEvent: f }), p = (f = {}) => {
      const { mouseEvent: m, touchEvent: b, keyboardEvent: w, forceHide: C } = f;
      !C && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent: m, touchEvent: b }, n) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      c) || (c = !0, i.removeChild(o), s.removeEventListener("keydown", u), s.removeEventListener("mousedown", h), s.removeEventListener("touchstart", g), s.removeEventListener("contextmenu", h), this.eventSvc.removeEventListener("dragStarted", h), r && r(m || b || w), this.removePopupFromPopupList(n));
    };
    return a && a({ hidePopup: p }), window.setTimeout(() => {
      l && s.addEventListener("keydown", u), d && (s.addEventListener("mousedown", h), this.eventSvc.addEventListener("dragStarted", h), s.addEventListener("touchstart", g), s.addEventListener("contextmenu", h));
    }, 0), p;
  }
  addPopupToPopupList(e, t, s, i) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: s,
      instanceId: YR++,
      isAnchored: !!i
    }), i && this.setPopupPositionRelatedToElement(e, i);
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const s = this.getPopupIndex(e);
    if (s === -1)
      return;
    const i = this.popupList[s];
    if (i.stopAnchoringPromise && i.stopAnchoringPromise.then((n) => n && n()), i.stopAnchoringPromise = void 0, i.isAnchored = !1, !t)
      return;
    const o = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: i.hideFunc
    });
    return i.stopAnchoringPromise = o, i.isAnchored = !0, o;
  }
  removePopupFromPopupList(e) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), s = t.getBoundingClientRect(), { element: i, ePopup: o } = e, n = i.getBoundingClientRect(), r = (u) => parseInt(u.substring(0, u.length - 1), 10), a = (u, h) => {
      const g = s[u] - n[u], p = r(o.style[u]);
      return {
        initialDiff: g,
        lastDiff: g,
        initial: p,
        last: p,
        direction: h
      };
    }, l = a(
      "top",
      0
      /* vertical */
    ), d = a(
      "left",
      1
      /* horizontal */
    ), c = this.beans.frameworkOverrides;
    return new q((u) => {
      c.wrapIncoming(() => {
        c.setInterval(() => {
          const h = t.getBoundingClientRect(), g = i.getBoundingClientRect();
          if (g.top == 0 && g.left == 0 && g.height == 0 && g.width == 0) {
            e.hidePopup();
            return;
          }
          const f = (m, b) => {
            const w = r(o.style[b]);
            m.last !== w && (m.initial = w, m.last = w);
            const C = h[b] - g[b];
            if (C != m.lastDiff) {
              const v = this.keepXYWithinBounds(
                o,
                m.initial + m.initialDiff - C,
                m.direction
              );
              o.style[b] = `${v}px`, m.last = v;
            }
            m.lastDiff = C;
          };
          f(l, "top"), f(d, "left");
        }, 200).then((h) => {
          u(() => {
            h != null && window.clearInterval(h);
          });
        });
      }, "popupPositioning");
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: s, touchEvent: i } = e, o = s || i;
    if (!o)
      return !1;
    const n = this.getPopupIndex(t);
    if (n === -1)
      return !1;
    for (let r = n; r < this.popupList.length; r++) {
      const a = this.popupList[r];
      if (qr(a.element, o))
        return !0;
    }
    return this.isElementWithinCustomPopup(o.target);
  }
  isElementWithinCustomPopup(e) {
    const t = pe(this.beans);
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const s = this.getWrapper(e);
    s && (s.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(s));
  }
  /** @return true if moved */
  bringPopupToFront(e) {
    const t = this.getPopupParent(), s = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), i = s.length, o = this.getWrapper(e);
    if (!o || i <= 1 || !t.contains(e))
      return;
    const n = [], r = [];
    for (const h of s)
      h !== o && (h.classList.contains("ag-always-on-top") ? r.push(h) : n.push(h));
    const a = [], l = r.length, u = o.classList.contains("ag-always-on-top") || !l ? [...n, ...r, o] : [...n, o, ...r];
    for (let h = 0; h <= i; h++) {
      const g = u[h];
      if (s[h] === u[h] || g === o)
        continue;
      g.querySelectorAll("div").forEach((f) => {
        f.scrollTop !== 0 && a.push([f, f.scrollTop]);
      }), h === 0 ? t.insertAdjacentElement("afterbegin", g) : u[h - 1].insertAdjacentElement("afterend", g);
    }
    for (; a.length; ) {
      const h = a.pop();
      h[0].scrollTop = h[1];
    }
  }
}, cl = {
  moduleName: "Popup",
  version: Q,
  beans: [QR]
}, XR = (
  /*css*/
  ".ag-set-filter{--ag-indentation-level:0}.ag-set-filter-item{align-items:center;display:flex;height:100%}:where(.ag-ltr) .ag-set-filter-item{padding-left:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}:where(.ag-rtl) .ag-set-filter-item{padding-right:calc(var(--ag-widget-container-horizontal-padding) + var(--ag-indentation-level)*var(--ag-set-filter-indent-size))}.ag-set-filter-item-checkbox{display:flex;height:100%;width:100%}.ag-set-filter-group-icons{display:block;>*{cursor:pointer}}:where(.ag-ltr) .ag-set-filter-group-icons{margin-right:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-set-filter-group-icons{margin-left:var(--ag-widget-container-horizontal-padding)}.ag-filter-body-wrapper{display:flex;flex-direction:column}:where(.ag-menu:not(.ag-tabs) .ag-filter) .ag-filter-body-wrapper,:where(.ag-menu:not(.ag-tabs) .ag-filter)>:not(.ag-filter-wrapper){min-width:180px}.ag-filter-filter{flex:1 1 0px}.ag-filter-condition{display:flex;justify-content:center}.ag-floating-filter-body{display:flex;flex:1 1 auto;height:100%;position:relative}.ag-floating-filter-full-body{align-items:center;display:flex;flex:1 1 auto;height:100%;overflow:hidden;width:100%}:where(.ag-floating-filter-full-body)>div{flex:1 1 auto}.ag-floating-filter-input{align-items:center;display:flex;width:100%;>*{flex:1 1 auto}:where(.ag-input-field-input[type=date]){width:1px}}.ag-floating-filter-button{display:flex;flex:none}.ag-date-floating-filter-wrapper{display:flex}.ag-set-floating-filter-input :where(input)[disabled]{pointer-events:none}.ag-floating-filter-button-button{-webkit-appearance:none;-moz-appearance:none;appearance:none;border:none;height:var(--ag-icon-size);width:var(--ag-icon-size)}.ag-filter-loading{align-items:unset;background-color:var(--ag-chrome-background-color);height:100%;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);position:absolute;width:100%;z-index:1;:where(.ag-menu) &{background-color:var(--ag-menu-background-color)}}.ag-filter-separator{border-top:1px solid var(--menu-separator-color)}:where(.ag-filter-select) .ag-picker-field-wrapper{width:0}.ag-filter-condition-operator{height:17px}:where(.ag-ltr) .ag-filter-condition-operator-or{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-condition-operator-or{margin-right:calc(var(--ag-spacing)*2)}.ag-set-filter-select-all{padding-top:var(--ag-widget-container-vertical-padding)}.ag-filter-no-matches,.ag-set-filter-list{height:calc(var(--ag-list-item-height)*6)}.ag-filter-no-matches{padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}.ag-set-filter-tree-list{height:calc(var(--ag-list-item-height)*10)}.ag-set-filter-filter{margin-left:var(--ag-widget-container-horizontal-padding);margin-right:var(--ag-widget-container-horizontal-padding);margin-top:var(--ag-widget-container-vertical-padding)}.ag-filter-to{margin-top:var(--ag-widget-vertical-spacing)}.ag-mini-filter{margin:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}:where(.ag-ltr) .ag-set-filter-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-rtl) .ag-set-filter-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-widget-container-horizontal-padding))}:where(.ag-filter-menu) .ag-set-filter-list{min-width:200px}.ag-filter-virtual-list-item:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-filter-apply-panel{display:flex;justify-content:flex-end;overflow:hidden;padding:var(--ag-widget-vertical-spacing) var(--ag-widget-container-horizontal-padding) var(--ag-widget-container-vertical-padding)}.ag-filter-apply-panel-button{line-height:1.5}:where(.ag-ltr) .ag-filter-apply-panel-button{margin-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-filter-apply-panel-button{margin-right:calc(var(--ag-spacing)*2)}.ag-simple-filter-body-wrapper{display:flex;flex-direction:column;min-height:calc(var(--ag-list-item-height) + var(--ag-widget-container-vertical-padding) + var(--ag-widget-vertical-spacing));overflow-y:auto;padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding);padding-bottom:calc(var(--ag-widget-container-vertical-padding) - var(--ag-widget-vertical-spacing));&>*{margin-bottom:var(--ag-widget-vertical-spacing)}:where(.ag-resizer-wrapper){margin:0}}.ag-multi-filter-menu-item{margin:var(--ag-spacing) 0}.ag-multi-filter-group-title-bar{background-color:transparent;color:var(--ag-header-text-color);font-weight:500;padding:calc(var(--ag-spacing)*1.5) var(--ag-spacing)}.ag-group-filter-field-select-wrapper{display:flex;flex-direction:column;gap:var(--ag-widget-vertical-spacing);padding:var(--ag-widget-container-vertical-padding) var(--ag-widget-container-horizontal-padding)}"
);
function JR(e) {
  const t = e.filterManager;
  return !!(t != null && t.isColumnFilterPresent()) || !!(t != null && t.isAggregateFilterPresent());
}
function eF(e, t) {
  var s;
  return ((s = e.filterManager) == null ? void 0 : s.getColumnFilterInstance(t)) ?? Promise.resolve(void 0);
}
function tF(e, t) {
  var i;
  const s = e.colModel.getColDefCol(t);
  if (s)
    return (i = e.filterManager) == null ? void 0 : i.destroyFilter(s, "api");
}
function sF(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var s;
    return (s = e.filterManager) == null ? void 0 : s.setFilterModel(t);
  });
}
function iF(e) {
  var t;
  return ((t = e.filterManager) == null ? void 0 : t.getFilterModel()) ?? {};
}
function oF(e, t) {
  var s;
  return ((s = e.filterManager) == null ? void 0 : s.getColumnFilterModel(t)) ?? null;
}
function nF(e, t, s) {
  var i;
  return ((i = e.filterManager) == null ? void 0 : i.setColumnFilterModel(t, s)) ?? Promise.resolve();
}
function rF(e, t) {
  var i;
  const s = e.colModel.getCol(t);
  if (!s) {
    K(12, { colKey: t });
    return;
  }
  (i = e.menuSvc) == null || i.showFilterMenu({
    column: s,
    containerType: "columnFilter",
    positionBy: "auto"
  });
}
var Sd = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, xd = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
];
function aF(e, t) {
  return e == null ? -1 : t == null ? 1 : parseFloat(e) - parseFloat(t);
}
var lF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colFilter", this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [];
  }
  postConstruct() {
    var e, t;
    this.addManagedEventListeners({
      gridColumnsChanged: this.onColumnsChanged.bind(this),
      beforeRefreshModel: ({ params: s }) => {
        var i;
        (s.rowDataUpdated || (i = s.changedProps) != null && i.has("treeData")) && this.onNewRowsLoaded("rowDataUpdated");
      },
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.initialFilterModel = {
      ...((t = (e = this.gos.get("initialState")) == null ? void 0 : e.filter) == null ? void 0 : t.filterModel) ?? {}
    };
  }
  setFilterModel(e, t = "api") {
    const { colModel: s, dataTypeSvc: i, filterManager: o } = this.beans;
    if (i != null && i.isPendingInference) {
      this.filterModelUpdateQueue.push({ model: e, source: t });
      return;
    }
    const n = [], r = this.getFilterModel(!0);
    if (e) {
      const a = new Set(Object.keys(e));
      this.allColumnFilters.forEach((l, d) => {
        const c = e[d];
        n.push(Ho(l.filterPromise, c)), a.delete(d);
      }), a.forEach((l) => {
        const d = s.getColDefCol(l) || s.getCol(l);
        if (!d) {
          P(62, { colId: l });
          return;
        }
        if (!d.isFilterAllowed()) {
          P(63, { colId: l });
          return;
        }
        const c = this.getOrCreateFilterWrapper(d);
        if (!c) {
          P(64, { colId: l });
          return;
        }
        n.push(Ho(c.filterPromise, e[l]));
      });
    } else
      this.allColumnFilters.forEach((a) => {
        n.push(Ho(a.filterPromise, null));
      });
    q.all(n).then(() => {
      const a = this.getFilterModel(!0), l = [];
      this.allColumnFilters.forEach((d, c) => {
        const u = r ? r[c] : null, h = a ? a[c] : null;
        Ta(u, h) || l.push(d.column);
      }), l.length > 0 && (o == null || o.onFilterChanged({ columns: l, source: t }));
    });
  }
  getFilterModel(e) {
    var n;
    const t = {}, {
      allColumnFilters: s,
      initialFilterModel: i,
      beans: { colModel: o }
    } = this;
    if (s.forEach((r, a) => {
      const l = this.getModelFromFilterWrapper(r);
      T(l) && (t[a] = l);
    }), !e)
      for (const r of Object.keys(i)) {
        const a = i[r];
        T(a) && !s.has(r) && ((n = o.getCol(r)) != null && n.isFilterAllowed()) && (t[r] = a);
      }
    return t;
  }
  getModelFromFilterWrapper(e) {
    const { filter: t } = e;
    return t ? typeof t.getModel != "function" ? (P(66), null) : t.getModel() : this.getModelFromInitialState(e.column);
  }
  getModelFromInitialState(e) {
    return this.initialFilterModel[e.getColId()] ?? null;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableColumnFilters() {
    this.initialFilterModel = {};
    const { allColumnFilters: e } = this;
    return e.size ? (e.forEach(
      (t) => this.disposeFilterWrapper(t, "advancedFilterEnabled")
    ), !0) : !1;
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, !0);
  }
  updateActiveFilters() {
    const e = (a) => a ? a.isFilterActive ? a.isFilterActive() : (P(67), !1) : !1, { colModel: t, gos: s } = this.beans, i = !!no(s), o = (a) => {
      if (!a.isPrimary())
        return !0;
      const d = !t.isPivotActive();
      return !a.isValueActive() || !d ? !1 : t.isPivotMode() ? !0 : i;
    }, n = [], r = [];
    return this.forEachColumnFilter((a, l) => {
      e(a) && (o(l.column) ? n.push(a) : r.push(a));
    }).then(() => {
      this.activeAggregateFilters = n, this.activeColumnFilters = r;
    });
  }
  updateFilterFlagInColumns(e, t) {
    return this.forEachColumnFilter(
      (s, i) => this.setColFilterActive(i.column, s.isFilterActive(), e, t)
    );
  }
  forEachColumnFilter(e) {
    const t = [];
    return this.allColumnFilters.forEach((s) => {
      const i = s.filterPromise;
      i && t.push(i.then((o) => e(o, s)));
    }), q.all(t);
  }
  doColumnFiltersPass(e, t, s) {
    const { data: i, aggData: o } = e, n = s ? this.activeAggregateFilters : this.activeColumnFilters, r = s ? o : i;
    for (let a = 0; a < n.length; a++) {
      const l = n[a];
      if (!(l == null || l === t)) {
        if (typeof l.doesFilterPass != "function") {
          K(91);
          continue;
        }
        if (!l.doesFilterPass({ node: e, data: r }))
          return !1;
      }
    }
    return !0;
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e) {
    const { rowRenderer: t, filterManager: s } = this.beans, i = () => {
      this.isAlive() && (s == null || s.onFilterChanged(e));
    };
    t.isRefreshInProgress() ? setTimeout(i, 0) : i();
  }
  updateBeforeFilterChanged(e = {}) {
    const { filterInstance: t, additionalEventAttributes: s } = e;
    return this.updateDependentFilters(), this.updateActiveFilters().then(
      () => this.updateFilterFlagInColumns("filterChanged", s).then(() => {
        this.allColumnFilters.forEach((i) => {
          i.filterPromise && i.filterPromise.then((o) => {
            o && o !== t && o.onAnyFilterChanged && o.onAnyFilterChanged();
          });
        }), this.processingFilterChange = !0;
      })
    );
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !(this.gos.get("allowShowChangeAfterFilter") ?? !1) && this.processingFilterChange;
  }
  onNewRowsLoaded(e) {
    this.forEachColumnFilter((t) => {
      var s;
      (s = t.onNewRowsLoaded) == null || s.call(t);
    }).then(() => this.updateFilterFlagInColumns(e, { afterDataChange: !0 })).then(() => this.updateActiveFilters());
  }
  createGetValue(e) {
    const { filterValueSvc: t, colModel: s } = this.beans;
    return (i, o) => {
      const n = o ? s.getCol(o) : e;
      return n ? t.getValue(n, i) : void 0;
    };
  }
  isFilterActive(e) {
    const { filter: t } = this.cachedFilter(e) ?? {};
    return t ? t.isFilterActive() : this.getModelFromInitialState(e) != null;
  }
  getOrCreateFilterWrapper(e) {
    if (!e.isFilterAllowed())
      return null;
    let t = this.cachedFilter(e);
    return t || (t = this.createFilterWrapper(e), this.setColumnFilterWrapper(e, t)), t;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    let t;
    const { gos: s, dataTypeSvc: i } = this.beans;
    if (dr(s))
      t = "agSetColumnFilter";
    else {
      const o = i == null ? void 0 : i.getBaseDataType(e);
      o === "number" ? t = "agNumberColumnFilter" : o === "date" || o === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    let t;
    const { gos: s, dataTypeSvc: i } = this.beans;
    if (dr(s))
      t = "agSetColumnFloatingFilter";
    else {
      const o = i == null ? void 0 : i.getBaseDataType(e);
      o === "number" ? t = "agNumberColumnFloatingFilter" : o === "date" || o === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e, t) {
    const s = this.getDefaultFilter(e), i = e.getColDef();
    let o;
    const n = {
      ...this.createFilterParams(e, i),
      filterModifiedCallback: () => this.filterModifiedCallbackFactory(o, e)(),
      filterChangedCallback: (a) => this.filterChangedCallbackFactory(o, e)(a),
      doesRowPassOtherFilter: (a) => {
        var l;
        return ((l = this.beans.filterManager) == null ? void 0 : l.doesRowPassOtherFilters(o, a)) ?? !0;
      }
    }, r = Bu(this.beans.userCompFactory, i, n, s);
    return r ? {
      filterPromise: () => {
        const a = r.newAgStackInstance();
        return a.then((l) => {
          o = l, t && (t.filter = l ?? void 0);
        }), a;
      },
      compDetails: r
    } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return N(this.gos, {
      column: e,
      colDef: t,
      rowModel: this.beans.rowModel,
      // @deprecated v33.1
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: () => !0
    });
  }
  createFilterWrapper(e) {
    const t = {
      column: e,
      filterPromise: null,
      compDetails: null
    }, { filterPromise: s, compDetails: i } = this.createFilterInstance(e, t);
    return t.filterPromise = (s == null ? void 0 : s()) ?? null, t.compDetails = i, t;
  }
  onColumnsChanged() {
    const e = [], { colModel: t, filterManager: s } = this.beans;
    this.allColumnFilters.forEach((o, n) => {
      let r;
      o.column.isPrimary() ? r = t.getColDefCol(n) : r = t.getCol(n), !(r && r === o.column) && (e.push(o.column), this.disposeFilterWrapper(o, "columnChanged"), this.disposeColumnListener(n));
    });
    const i = e.every(Rd);
    e.length > 0 && !i ? s == null || s.onFilterChanged({ columns: e, source: "api" }) : this.updateDependentFilters();
  }
  updateDependentFilters() {
    var e, t;
    (t = (e = this.beans.autoColSvc) == null ? void 0 : e.getColumns()) == null || t.forEach((s) => {
      Rd(s) && this.getOrCreateFilterWrapper(s);
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    if (!e.isFilterAllowed())
      return !1;
    const { filter: s } = this.allColumnFilters.get(e.getColId()) ?? {};
    return s && typeof (s == null ? void 0 : s.isFilterAllowed) == "function" ? s.isFilterAllowed() : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const s = (c) => {
      var h;
      const u = (h = this.getOrCreateFilterWrapper(e)) == null ? void 0 : h.filterPromise;
      u != null && u.then((g) => {
        c(vn(g));
      });
    }, i = e.getColDef(), o = {
      ...this.createFilterParams(e, i),
      filterChangedCallback: () => s(
        (c) => this.filterChangedCallbackFactory(c, e)()
      )
    }, { userCompFactory: n, frameworkOverrides: r } = this.beans, a = HC(
      n,
      i,
      o
    );
    let l = ah(
      r,
      i,
      () => this.getDefaultFloatingFilter(e)
    );
    l == null && (l = "agReadOnlyFloatingFilter");
    const d = N(this.gos, {
      column: e,
      filterParams: a,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: s,
      showParentFilter: t
    });
    return Nu(n, i, d, l);
  }
  getCurrentFloatingFilterParentModel(e) {
    return this.getModelFromFilterWrapper(this.cachedFilter(e) ?? { column: e });
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    const s = e.getColId(), i = this.allColumnFilters.get(s);
    this.disposeColumnListener(s), delete this.initialFilterModel[s], i && this.disposeFilterWrapper(i, t).then((o) => {
      var n;
      o && this.isAlive() && ((n = this.beans.filterManager) == null || n.onFilterChanged({
        columns: [e],
        source: "api"
      }));
    });
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    var s;
    return ((s = e.filterPromise) == null ? void 0 : s.then((i) => {
      const o = !!(i != null && i.isFilterActive());
      return this.destroyBean(i), this.setColFilterActive(e.column, !1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId()), this.eventSvc.dispatchEvent({
        type: "filterDestroyed",
        source: t,
        column: e.column
      }), o;
    })) ?? q.resolve(!1);
  }
  filterModifiedCallbackFactory(e, t) {
    return () => {
      this.eventSvc.dispatchEvent({
        type: "filterModified",
        column: t,
        filterInstance: e
      });
    };
  }
  filterChangedCallbackFactory(e, t) {
    return (s) => {
      const i = (s == null ? void 0 : s.source) ?? "columnFilter", o = {
        filter: e,
        additionalEventAttributes: s,
        columns: [t],
        source: i
      };
      this.callOnFilterChangedOutsideRenderCycle(o);
    };
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t)
      return;
    const s = t.column, { compDetails: i } = s.isFilterAllowed() ? this.createFilterInstance(s) : { compDetails: null };
    if (this.areFilterCompsDifferent(t.compDetails, i)) {
      this.destroyFilter(s, "paramsUpdated");
      return;
    }
    const o = s.getColDef().filterParams;
    if (!t.filterPromise) {
      this.destroyFilter(s, "paramsUpdated");
      return;
    }
    t.filterPromise.then((n) => {
      (n != null && n.refresh ? n.refresh({
        ...this.createFilterParams(s, s.getColDef()),
        filterModifiedCallback: this.filterModifiedCallbackFactory(n, s),
        filterChangedCallback: this.filterChangedCallbackFactory(n, s),
        doesRowPassOtherFilter: (a) => {
          var l;
          return ((l = this.beans.filterManager) == null ? void 0 : l.doesRowPassOtherFilters(n, a)) ?? !0;
        },
        ...o
      }) : !0) === !1 && this.destroyFilter(s, "paramsUpdated");
    });
  }
  setColumnFilterWrapper(e, t) {
    const s = e.getColId();
    this.allColumnFilters.set(s, t), this.allColumnListeners.set(
      s,
      this.addManagedListeners(e, { colDefChanged: () => this.checkDestroyFilter(s) })[0]
    );
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e)
      return !0;
    const { componentClass: s } = e, { componentClass: i } = t;
    return !(s === i || // react hooks returns new wrappers, so check nested render method
    (s == null ? void 0 : s.render) && (i == null ? void 0 : i.render) && s.render === i.render);
  }
  hasFloatingFilters() {
    return this.beans.colModel.getCols().some((t) => t.getColDef().floatingFilter);
  }
  getColumnFilterInstance(e) {
    return new Promise((t) => {
      this.getFilterInstanceImpl(e).then((s) => {
        t(vn(s));
      });
    });
  }
  getFilterInstanceImpl(e) {
    var i;
    const t = this.beans.colModel.getColDefCol(e);
    return t ? ((i = this.getOrCreateFilterWrapper(t)) == null ? void 0 : i.filterPromise) ?? q.resolve(null) : q.resolve(void 0);
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model: e, source: t }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({ key: e, model: t, resolve: s }) => {
      this.setColumnFilterModel(e, t).then(() => s());
    }), this.columnFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    const t = this.getFilterWrapper(e);
    return t ? this.getModelFromFilterWrapper(t) : null;
  }
  setColumnFilterModel(e, t) {
    const { colModel: s, dataTypeSvc: i } = this.beans;
    if (i != null && i.isPendingInference) {
      let a = () => {
      };
      const l = new Promise((d) => {
        a = d;
      });
      return this.columnFilterModelUpdateQueue.push({ key: e, model: t, resolve: a }), l;
    }
    const o = s.getColDefCol(e), n = o ? this.getOrCreateFilterWrapper(o) : null;
    return n ? ((a) => new Promise((l) => {
      a.then((d) => l(d));
    }))(Ho(n.filterPromise, t)) : Promise.resolve();
  }
  getFilterWrapper(e) {
    const t = this.beans.colModel.getColDefCol(e);
    return t ? this.cachedFilter(t) ?? null : null;
  }
  setColDefPropertiesForDataType(e, t, s) {
    const i = dr(this.gos), o = this.getLocaleTextFunc(), n = (r) => {
      const { filterParams: a } = e;
      e.filterParams = typeof a == "object" ? {
        ...a,
        ...r
      } : r;
    };
    switch (t.baseDataType) {
      case "number": {
        i && n({
          comparator: aF
        });
        break;
      }
      case "boolean": {
        n(i ? {
          valueFormatter: (r) => T(r.value) ? o(String(r.value), r.value ? "True" : "False") : o("blanks", "(Blanks)")
        } : {
          maxNumConditions: 1,
          debounceMs: 0,
          filterOptions: [
            "empty",
            {
              displayKey: "true",
              displayName: "True",
              predicate: (r, a) => a,
              numberOfInputs: 0
            },
            {
              displayKey: "false",
              displayName: "False",
              predicate: (r, a) => a === !1,
              numberOfInputs: 0
            }
          ]
        });
        break;
      }
      case "date": {
        n(i ? {
          valueFormatter: (r) => {
            const a = s(r);
            return T(a) ? a : o("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListFormatter: (r, a) => {
            if (r === "NaN")
              return o("invalidDate", "Invalid Date");
            if (a === 1 && r != null) {
              const l = xd[Number(r) - 1];
              return o(l, Sd[l]);
            }
            return r ?? o("blanks", "(Blanks)");
          }
        } : {
          isValidDate: Fd
        });
        break;
      }
      case "dateString": {
        const r = t.dateParser;
        n(i ? {
          valueFormatter: (a) => {
            const l = s(a);
            return T(l) ? l : o("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListPathGetter: (a) => {
            const l = r(a ?? void 0);
            return l ? [String(l.getFullYear()), String(l.getMonth() + 1), String(l.getDate())] : null;
          },
          treeListFormatter: (a, l) => {
            if (l === 1 && a != null) {
              const d = xd[Number(a) - 1];
              return o(d, Sd[d]);
            }
            return a ?? o("blanks", "(Blanks)");
          }
        } : {
          comparator: (a, l) => {
            const d = r(l);
            return l == null || d < a ? -1 : d > a ? 1 : 0;
          },
          isValidDate: (a) => typeof a == "string" && Fd(r(a))
        });
        break;
      }
      case "object": {
        i ? n({
          valueFormatter: (r) => {
            const a = s(r);
            return T(a) ? a : o("blanks", "(Blanks)");
          }
        }) : e.filterValueGetter = (r) => s({
          column: r.column,
          node: r.node,
          value: this.beans.valueSvc.getValue(r.column, r.node)
        });
        break;
      }
    }
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setColFilterActive(e, t, s, i) {
    e.filterActive !== t && (e.filterActive = t, e.dispatchColEvent("filterActiveChanged", s)), e.dispatchColEvent("filterChanged", s, i);
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
function Ho(e, t) {
  return e ? new q((s) => {
    e.then((i) => {
      typeof i.setModel != "function" && (P(65), s()), (i.setModel(t) || q.resolve()).then(() => s());
    });
  }) : q.resolve();
}
function Rd(e) {
  return e.getColDef().filter === "agGroupColumnFilter";
}
function Fd(e) {
  return e instanceof Date && !isNaN(e.getTime());
}
function dF(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isAnyFilterPresent());
}
function cF(e, t = "api") {
  var s;
  (s = e.filterManager) == null || s.onFilterChanged({ source: t });
}
var uF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "filterManager", this.advFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.quickFilter = e.quickFilter, this.advancedFilter = e.advancedFilter, this.colFilter = e.colFilter;
  }
  postConstruct() {
    const e = this.refreshFiltersForAggregations.bind(this), t = this.updateAdvFilterColumns.bind(this);
    this.addManagedEventListeners({
      columnValueChanged: e,
      columnPivotChanged: e,
      columnPivotModeChanged: e,
      newColumnsLoaded: t,
      columnVisible: t,
      advancedFilterEnabledChanged: ({ enabled: i }) => this.onAdvFilterEnabledChanged(i),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.quickFilter && this.addManagedListeners(this.quickFilter, {
      quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" })
    });
    const { gos: s } = this;
    this.alwaysPassFilter = s.get("alwaysPassFilter"), this.addManagedPropertyListener("alwaysPassFilter", () => {
      this.alwaysPassFilter = s.get("alwaysPassFilter"), this.onFilterChanged({ source: "api" });
    });
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" && e({});
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" && t(e);
  }
  setFilterModel(e, t = "api") {
    var s;
    if (this.isAdvFilterEnabled()) {
      this.warnAdvFilters();
      return;
    }
    (s = this.colFilter) == null || s.setFilterModel(e, t);
  }
  getFilterModel() {
    var e;
    return ((e = this.colFilter) == null ? void 0 : e.getFilterModel()) ?? {};
  }
  isColumnFilterPresent() {
    var e;
    return !!((e = this.colFilter) != null && e.isColumnFilterPresent());
  }
  isAggregateFilterPresent() {
    var e;
    return !!((e = this.colFilter) != null && e.isAggregateFilterPresent());
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.externalFilterPresent || this.isAdvFilterPresent();
  }
  isAnyFilterPresent() {
    return this.isChildFilterPresent() || this.isAggregateFilterPresent();
  }
  isAdvFilterPresent() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isFilterPresent();
  }
  onAdvFilterEnabledChanged(e) {
    var t, s;
    e ? (t = this.colFilter) != null && t.disableColumnFilters() && this.onFilterChanged({ source: "advancedFilter" }) : (s = this.advancedFilter) != null && s.isFilterPresent() && (this.advancedFilter.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvFilterEnabled() {
    var e;
    return !!((e = this.advancedFilter) != null && e.isEnabled());
  }
  isAdvFilterHeaderActive() {
    return this.isAdvFilterEnabled() && this.advancedFilter.isHeaderActive();
  }
  refreshFiltersForAggregations() {
    no(this.gos) && this.onFilterChanged();
  }
  onFilterChanged(e = {}) {
    const { source: t, additionalEventAttributes: s, columns: i = [] } = e;
    this.externalFilterPresent = this.isExternalFilterPresentCallback(), (this.colFilter ? this.colFilter.updateBeforeFilterChanged(e) : q.resolve()).then(() => {
      var n;
      const o = {
        source: t,
        type: "filterChanged",
        columns: i
      };
      s && me(o, s), this.eventSvc.dispatchEvent(o), (n = this.colFilter) == null || n.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var e;
    return !!((e = this.colFilter) != null && e.isSuppressFlashingCellsBecauseFiltering());
  }
  isQuickFilterPresent() {
    var e;
    return !!((e = this.quickFilter) != null && e.isFilterPresent());
  }
  updateAggFiltering() {
    this.aggFiltering = !!no(this.gos);
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.beans.colModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    var s;
    const { rowNode: t } = e;
    return (s = this.alwaysPassFilter) != null && s.call(this, t) ? !0 : !(this.isAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(t) || this.isAggregateFilterPresent() && !this.colFilter.doAggregateFiltersPass(t, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    var s;
    const { rowNode: t } = e;
    return (s = this.alwaysPassFilter) != null && s.call(this, t) ? !0 : !(this.isNonAggregateQuickFilterPresent() && !this.quickFilter.doesRowPass(t) || this.externalFilterPresent && !this.doesExternalFilterPass(t) || this.isColumnFilterPresent() && !this.colFilter.doColumnFiltersPass(t, e.filterInstanceToSkip) || this.isAdvFilterPresent() && !this.advancedFilter.doesFilterPass(t));
  }
  isFilterActive(e) {
    var t;
    return !!((t = this.colFilter) != null && t.isFilterActive(e));
  }
  getOrCreateFilterWrapper(e) {
    var t;
    return ((t = this.colFilter) == null ? void 0 : t.getOrCreateFilterWrapper(e)) ?? null;
  }
  getDefaultFloatingFilter(e) {
    return this.colFilter.getDefaultFloatingFilter(e);
  }
  createFilterParams(e, t) {
    return this.colFilter.createFilterParams(e, t);
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t;
    return this.isAdvFilterEnabled() ? !1 : !!((t = this.colFilter) != null && t.isFilterAllowed(e));
  }
  getFloatingFilterCompDetails(e, t) {
    var s;
    return (s = this.colFilter) == null ? void 0 : s.getFloatingFilterCompDetails(e, t);
  }
  getCurrentFloatingFilterParentModel(e) {
    var t;
    return (t = this.colFilter) == null ? void 0 : t.getCurrentFloatingFilterParentModel(e);
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var s;
    (s = this.colFilter) == null || s.destroyFilter(e, t);
  }
  areFilterCompsDifferent(e, t) {
    var s;
    return !!((s = this.colFilter) != null && s.areFilterCompsDifferent(e, t));
  }
  getAdvFilterModel() {
    return this.isAdvFilterEnabled() ? this.advancedFilter.getModel() : null;
  }
  setAdvFilterModel(e, t = "api") {
    var s;
    if (this.isAdvFilterEnabled()) {
      if ((s = this.beans.dataTypeSvc) != null && s.isPendingInference) {
        this.advFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilter.setModel(e ?? null), this.onFilterChanged({ source: t });
    }
  }
  toggleAdvFilterBuilder(e, t) {
    this.isAdvFilterEnabled() && this.advancedFilter.getCtrl().toggleFilterBuilder({ source: t, force: e });
  }
  updateAdvFilterColumns() {
    this.isAdvFilterEnabled() && this.advancedFilter.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    var e;
    return this.isAdvFilterEnabled() ? !1 : !!((e = this.colFilter) != null && e.hasFloatingFilters());
  }
  getColumnFilterInstance(e) {
    var t;
    return this.isAdvFilterEnabled() ? (this.warnAdvFilters(), Promise.resolve(void 0)) : ((t = this.colFilter) == null ? void 0 : t.getColumnFilterInstance(e)) ?? Promise.resolve(void 0);
  }
  warnAdvFilters() {
    P(68);
  }
  setupAdvFilterHeaderComp(e) {
    var t;
    (t = this.advancedFilter) == null || t.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvFilterHeaderActive() ? this.advancedFilter.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advFilterModelUpdateQueue.forEach((e) => this.setAdvFilterModel(e)), this.advFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    var t;
    return (t = this.colFilter) == null ? void 0 : t.getColumnFilterModel(e);
  }
  setColumnFilterModel(e, t) {
    var s;
    return this.isAdvFilterEnabled() ? (this.warnAdvFilters(), Promise.resolve()) : ((s = this.colFilter) == null ? void 0 : s.setColumnFilterModel(e, t)) ?? Promise.resolve();
  }
  setColDefPropertiesForDataType(e, t, s) {
    var i;
    (i = this.colFilter) == null || i.setColDefPropertiesForDataType(e, t, s);
  }
}, hF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "filterMenuFactory";
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc;
  }
  hideActiveMenu() {
    var e;
    (e = this.hidePopup) == null || e.call(this);
  }
  showMenuAfterMouseEvent(e, t, s, i) {
    e && !e.isColumn || this.showPopup(
      e,
      (o) => {
        var n;
        (n = this.popupSvc) == null || n.positionPopupUnderMouseEvent({
          column: e,
          type: s,
          mouseEvent: t,
          ePopup: o
        });
      },
      s,
      t.target,
      fe(this.gos),
      i
    );
  }
  showMenuAfterButtonClick(e, t, s, i) {
    if (e && !e.isColumn)
      return;
    let o = -1, n = "left";
    const r = fe(this.gos);
    !r && this.gos.get("enableRtl") && (o = 1, n = "right");
    const a = r ? void 0 : 4 * o, l = r ? void 0 : 4;
    this.showPopup(
      e,
      (d) => {
        var c;
        (c = this.popupSvc) == null || c.positionPopupByComponent({
          type: s,
          eventSource: t,
          ePopup: d,
          nudgeX: a,
          nudgeY: l,
          alignSide: n,
          keepWithinBounds: !0,
          position: "under",
          column: e
        });
      },
      s,
      t,
      r,
      i
    );
  }
  showPopup(e, t, s, i, o, n) {
    var f;
    const r = e ? this.createBean(new $a(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = r, !(r != null && r.hasFilter()) || !e) {
      K(57);
      return;
    }
    const a = _({
      tag: "div",
      cls: `ag-menu${o ? "" : " ag-filter-menu"}`,
      role: "presentation"
    });
    [this.tabListener] = this.addManagedElementListeners(a, {
      keydown: (m) => this.trapFocusWithin(m, a)
    }), a.appendChild(r == null ? void 0 : r.getGui());
    let l;
    const d = () => r == null ? void 0 : r.afterGuiDetached(), c = cu(this.gos) ? i ?? this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody : void 0, u = (m) => {
      Dn(e, !1, "contextMenu");
      const b = m instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), b && i && He(i)) {
        const w = Ua(i);
        w == null || w.focus({ preventScroll: !0 });
      }
      d(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, s, e), n == null || n();
    }, h = this.getLocaleTextFunc(), g = o && s !== "columnFilter" ? h("ariaLabelColumnMenu", "Column Menu") : h("ariaLabelColumnFilter", "Column Filter"), p = (f = this.popupSvc) == null ? void 0 : f.addPopup({
      modal: !0,
      eChild: a,
      closeOnEsc: !0,
      closedCallback: u,
      positionCallback: () => t(a),
      anchorToElement: c,
      ariaLabel: g
    });
    p && (this.hidePopup = l = p.hideFunc), r.afterInit().then(() => {
      t(a), r.afterGuiAttached({ container: s, hidePopup: l });
    }), Dn(e, !0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, s, e);
  }
  trapFocusWithin(e, t) {
    e.key !== y.TAB || e.defaultPrevented || Be(this.beans, t, !1, e.shiftKey) || (e.preventDefault(), Ve(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, s) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: t,
      column: s ?? null,
      columnGroup: null
    });
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && (e.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
}, gF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "filterValueSvc";
  }
  getValue(e, t) {
    if (!t)
      return;
    const s = e.getColDef(), { filterValueGetter: i } = s;
    return i ? this.executeFilterValueGetter(i, t.data, e, t, s) : this.beans.valueSvc.getValue(e, t);
  }
  executeFilterValueGetter(e, t, s, i, o) {
    const { expressionSvc: n, valueSvc: r } = this.beans, a = N(this.gos, {
      data: t,
      node: i,
      column: s,
      colDef: o,
      getValue: r.getValueCallback.bind(r, i)
    });
    return typeof e == "function" ? e(a) : n == null ? void 0 : n.evaluate(e, a);
  }
}, ig = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  mapCustomOptions() {
    const { filterOptions: e } = this;
    e && e.forEach((t) => {
      if (typeof t == "string")
        return;
      const s = [["displayKey"], ["displayName"], ["predicate", "test"]], i = (o) => o.some((n) => t[n] != null) ? !0 : (P(72, { keys: o }), !1);
      if (!s.every(i)) {
        this.filterOptions = e.filter((o) => o === t) || [];
        return;
      }
      this.customFilterOptions[t.displayKey] = t;
    });
  }
  selectDefaultItem(e) {
    const { filterOptions: t } = this;
    if (e.defaultOption)
      this.defaultOption = e.defaultOption;
    else if (t.length >= 1) {
      const s = t[0];
      typeof s == "string" ? this.defaultOption = s : s.displayKey ? this.defaultOption = s.displayKey : P(73);
    } else
      P(74);
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
};
function Pd(e, t, s) {
  return s == null ? e.splice(t) : e.splice(t, s);
}
function Dd(e) {
  return e == null || typeof e == "string" && e.trim().length === 0;
}
function pF(e) {
  return e === "AND" || e === "OR" ? e : "AND";
}
function fF(e, t, s) {
  if (e == null)
    return;
  const { predicate: i } = e;
  if (i != null && !t.some((o) => o == null))
    return i(t, s);
}
function mF(e, t) {
  let s = e.length;
  return s > t && (e.splice(t), P(78), s = t), s;
}
var CF = class extends Ka {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(e) {
    const t = this.optionsFactory.getCustomOption(e);
    if (t) {
      const { numberOfInputs: i } = t;
      return i ?? 1;
    }
    return e && ["empty", "notBlank", "blank"].indexOf(e) >= 0 ? 0 : e === "inRange" ? 2 : 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(!0);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, s) => {
      const i = s === 0 ? e : this.optionsFactory.defaultOption;
      t.setValue(i, !0);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? {
      filterType: this.filterType,
      operator: this.getJoinOperator(),
      conditions: e
    } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    const { eJoinOperatorsOr: e, defaultJoinOperator: t } = this;
    return e.length === 0 ? t : e[0].getValue() === !0 ? "OR" : "AND";
  }
  areModelsEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e && t || e && !t)
      return !1;
    const s = !e.operator, i = !t.operator;
    if (!s && i || s && !i)
      return !1;
    let n;
    if (s) {
      const r = e, a = t;
      n = this.areSimpleModelsEqual(r, a);
    } else {
      const r = e, a = t;
      n = r.operator === a.operator && pt(
        r.conditions,
        a.conditions,
        (l, d) => this.areSimpleModelsEqual(l, d)
      );
    }
    return n;
  }
  shouldRefresh(e) {
    var n;
    const t = this.getModel(), s = t ? t.conditions ?? [t] : null, i = ((n = e.filterOptions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : r.displayKey)) ?? this.getDefaultFilterOptions();
    return !(!(!s || s.every((r) => i.find((a) => a === r.type) !== void 0)) || typeof e.maxNumConditions == "number" && s && s.length > e.maxNumConditions);
  }
  refresh(e) {
    return !this.shouldRefresh(e) || !super.refresh(e) ? !1 : (this.setParams(e), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), !0);
  }
  setModelIntoUi(e) {
    if (e.operator) {
      const s = e;
      let i = s.conditions;
      i == null && (i = [], P(77));
      const o = mF(i, this.maxNumConditions), n = this.getNumConditions();
      if (o < n)
        this.removeConditionsAndOperators(o);
      else if (o > n)
        for (let a = n; a < o; a++)
          this.createJoinOperatorPanel(), this.createOption();
      const r = s.operator === "OR";
      this.eJoinOperatorsAnd.forEach((a) => a.setValue(!r, !0)), this.eJoinOperatorsOr.forEach((a) => a.setValue(r, !0)), i.forEach((a, l) => {
        this.eTypes[l].setValue(a.type, !0), this.setConditionIntoUi(a, l);
      });
    } else {
      const s = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(s.type, !0), this.setConditionIntoUi(s, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), q.resolve();
  }
  doesFilterPass(e) {
    const t = this.getModel();
    if (t == null)
      return !0;
    const { operator: s } = t, i = [];
    if (s) {
      const n = t;
      i.push(...n.conditions ?? []);
    } else
      i.push(t);
    return i[s && s === "OR" ? "some" : "every"]((n) => this.individualConditionPasses(e, n));
  }
  setParams(e) {
    super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = pF(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new ig(), this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1");
  }
  setNumConditions(e) {
    let t = e.maxNumConditions ?? 2;
    t < 1 && (P(79), t = 1), this.maxNumConditions = t;
    let s = e.numAlwaysVisibleConditions ?? 1;
    s < 1 && (P(80), s = 1), s > t && (P(81), s = t), this.numAlwaysVisibleConditions = s;
  }
  createOption() {
    const e = this.createManagedBean(new ob());
    this.eTypes.push(e), e.addCss("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
    const t = this.createValueElement();
    this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
    const s = this.getNumConditions() - 1;
    this.forEachPositionInput(s, (i) => this.resetInput(i)), this.addChangedListeners(e, s);
  }
  createJoinOperatorPanel() {
    const e = _({ tag: "div", cls: "ag-filter-condition" });
    this.eJoinOperatorPanels.push(e);
    const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"), s = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
    this.eFilterBody.appendChild(e);
    const i = this.eJoinOperatorPanels.length - 1, o = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, i, o), this.resetJoinOperatorOr(s, i, o), this.isReadOnly() || (t.onValueChange(this.listener), s.onValueChange(this.listener));
  }
  createJoinOperator(e, t, s) {
    const i = this.createManagedBean(new Yw());
    e.push(i);
    const o = "ag-filter-condition-operator";
    return i.addCss(o), i.addCss(`${o}-${s}`), t.appendChild(i.getGui()), i;
  }
  createFilterListOptions() {
    this.filterListOptions = this.optionsFactory.filterOptions.map(
      (e) => typeof e == "string" ? this.createBoilerplateListOption(e) : this.createCustomListOption(e)
    );
  }
  putOptionsIntoDropdown(e) {
    const { filterListOptions: t } = this;
    t.forEach((s) => {
      e.addOption(s);
    }), e.setDisabled(t.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, s = this.optionsFactory.getCustomOption(e.displayKey);
    return {
      value: t,
      text: s ? this.getLocaleTextFunc()(s.displayKey, s.displayName) : this.translate(t)
    };
  }
  createBodyTemplate() {
    return null;
  }
  getAgComponents() {
    return [];
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    let e = -1, t = !0;
    for (let s = 0; s < this.getNumConditions(); s++)
      this.isConditionUiComplete(s) ? e = s : t = !1;
    if (this.shouldAddNewConditionAtEnd(t))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const s = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (e < s) {
        this.removeConditionsAndOperators(s + 1);
        const i = e + 1, o = s - i;
        o > 0 && this.removeConditionsAndOperators(i, o), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = e;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((i, o) => {
      const n = this.isConditionDisabled(o, e);
      i.setDisabled(n || this.filterListOptions.length <= 1), o === 1 && (so(this.eJoinOperatorPanels[0], n), this.eJoinOperatorsAnd[0].setDisabled(n), this.eJoinOperatorsOr[0].setDisabled(n));
    }), this.eConditionBodies.forEach((i, o) => {
      G(i, this.isConditionBodyVisible(o));
    });
    const s = (t ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((i) => {
      i.setValue(!s, !0);
    }), this.eJoinOperatorsOr.forEach((i) => {
      i.setValue(s, !0);
    }), this.forEachInput((i, o, n, r) => {
      this.setElementDisplayed(i, o < r), this.setElementDisabled(i, this.isConditionDisabled(n, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions())
      return;
    const { eTypes: s, eConditionBodies: i, eJoinOperatorPanels: o, eJoinOperatorsAnd: n, eJoinOperatorsOr: r } = this;
    this.removeComponents(s, e, t), this.removeElements(i, e, t), this.removeValueElements(e, t);
    const a = Math.max(e - 1, 0);
    this.removeElements(o, a, t), this.removeComponents(n, a, t), this.removeComponents(r, a, t);
  }
  removeElements(e, t, s) {
    Pd(e, t, s).forEach((o) => De(o));
  }
  removeComponents(e, t, s) {
    Pd(e, t, s).forEach((o) => {
      De(o.getGui()), this.destroyBean(o);
    });
  }
  afterGuiAttached(e) {
    var t;
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !(e != null && e.suppressFocus)) {
      const { eFilterBody: s, eTypes: i } = this;
      let o;
      if (!this.isReadOnly()) {
        const n = this.getInputs(0)[0];
        n instanceof ii && this.isConditionBodyVisible(0) ? o = n.getInputElement() : o = (t = i[0]) == null ? void 0 : t.getFocusableElement();
      }
      (o ?? s).focus({ preventScroll: !0 });
    }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const e = this.getModel();
    this.resetUiToActiveModel(e);
    let t = -1, s = -1, i = !1;
    const o = this.getJoinOperator();
    for (let r = this.getNumConditions() - 1; r >= 0; r--)
      if (this.isConditionUiComplete(r))
        t === -1 && (t = r, s = r);
      else {
        const a = r >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(r - 1), l = r < t;
        (a || l) && (this.removeConditionsAndOperators(r, 1), i = !0, l && s--);
      }
    let n = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), n = !0), this.shouldAddNewConditionAtEnd(s === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), n = !0), n && this.updateConditionStatusesAndValues(s, o), i && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = s;
  }
  getPlaceholderText(e, t) {
    let s = this.translate(e);
    if (typeof this.filterPlaceholder == "function") {
      const i = this.eTypes[t].getValue(), o = this.translate(i);
      s = this.filterPlaceholder({
        filterOptionKey: i,
        filterOption: o,
        placeholder: s
      });
    } else typeof this.filterPlaceholder == "string" && (s = this.filterPlaceholder);
    return s;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const e = this.getLocaleTextFunc();
    this.forEachInput((t, s, i, o) => {
      if (!(t instanceof ii))
        return;
      const n = s === 0 && o > 1 ? "inRangeStart" : s === 0 ? "filterOoo" : "inRangeEnd", r = s === 0 && o > 1 ? e("ariaFilterFromValue", "Filter from value") : s === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(n, i)), t.setInputAriaLabel(r);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setElementValue(e, t, s) {
    e instanceof ii && e.setValue(t != null ? String(t) : null, !0);
  }
  setElementDisplayed(e, t) {
    e instanceof L && G(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    e instanceof L && so(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof ii && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, s) => {
      this.forEachPositionTypeInput(s, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const s = this.getConditionType(e);
    this.forEachPositionTypeInput(e, s, t);
  }
  forEachPositionTypeInput(e, t, s) {
    const i = this.getNumberOfInputs(t), o = this.getInputs(e);
    for (let n = 0; n < o.length; n++) {
      const r = o[n];
      r != null && s(r, n, e, i);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return this.getNumberOfInputs(t) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === "empty" || this.getValues(e).some((s) => s == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++)
      this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinOperatorsAnd.forEach(
      (t, s) => this.resetJoinOperatorAnd(t, s, this.joinOperatorId + s)
    ), this.eJoinOperatorsOr.forEach(
      (t, s) => this.resetJoinOperatorOr(t, s, this.joinOperatorId + s)
    ), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), q.resolve();
  }
  resetType(e) {
    const s = this.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.defaultOption, !0).setAriaLabel(s).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, s) {
    this.resetJoinOperator(
      e,
      t,
      this.defaultJoinOperator === "AND",
      this.translate("andCondition"),
      s
    );
  }
  resetJoinOperatorOr(e, t, s) {
    this.resetJoinOperator(
      e,
      t,
      this.defaultJoinOperator === "OR",
      this.translate("orCondition"),
      s
    );
  }
  resetJoinOperator(e, t, s, i, o) {
    this.updateJoinOperatorDisabled(
      e.setValue(s, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${o}`).setLabel(i),
      t
    );
  }
  updateJoinOperatorsDisabled() {
    const e = (t, s) => this.updateJoinOperatorDisabled(t, s);
    this.eJoinOperatorsAnd.forEach(e), this.eJoinOperatorsOr.forEach(e);
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(e, t) {
    const s = this.mapValuesFromModel(e);
    this.forEachInput((i, o, n) => {
      n === t && this.setElementValue(i, s[o] != null ? s[o] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, s, i) => {
      this.setElementValue(t, s === 0 && i === 0 ? e : null, !0);
    });
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (s) => {
      this.attachElementOnChange(s, this.listener);
    }));
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(e, t) {
    const s = this.getCellValue(e.node), i = this.mapValuesFromModel(t), o = this.optionsFactory.getCustomOption(t.type), n = fF(o, i, s);
    return n ?? (s == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(i, s, t, e));
  }
  hasInvalidInputs() {
    return !1;
  }
}, vF = class {
  constructor(e, t, s) {
    this.getLocaleTextFunc = e, this.optionsFactory = t, this.valueFormatter = s;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e) {
    if (!e)
      return null;
    const t = e.operator != null, s = this.getLocaleTextFunc();
    if (t) {
      const i = e, n = (i.conditions ?? []).map((a) => this.getModelAsString(a)), r = i.operator === "AND" ? "andCondition" : "orCondition";
      return n.join(
        ` ${s(r, nh[r])} `
      );
    } else {
      if (e.type === "blank" || e.type === "notBlank")
        return s(e.type, e.type);
      {
        const i = e, o = this.optionsFactory.getCustomOption(i.type), { displayKey: n, displayName: r, numberOfInputs: a } = o || {};
        return n && r && a === 0 ? (s(n, r), r) : this.conditionToString(i, o);
      }
    }
  }
  updateParams(e) {
    this.optionsFactory = e.optionsFactory;
  }
  formatValue(e) {
    const t = this.valueFormatter;
    return t ? t(e ?? null) ?? "" : String(e);
  }
}, wF = class extends L {
  constructor() {
    super(...arguments), this.defaultDebounceMs = 0;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.defaultOption;
      return;
    }
    const t = e.operator;
    let s;
    t ? s = e.conditions[0] : s = e, this.lastType = s.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const s = e;
    return this.isTypeEditable(s.type);
  }
  init(e) {
    this.setSimpleParams(e, !1);
  }
  setSimpleParams(e, t = !0) {
    const s = new ig();
    this.optionsFactory = s, s.init(e.filterParams, this.getDefaultOptions());
    const i = s.defaultOption;
    t || (this.lastType = i), this.readOnly = !!e.filterParams.readOnly;
    const o = this.isTypeEditable(i);
    this.setEditable(o);
  }
  refresh(e) {
    this.setSimpleParams(e);
  }
  hasSingleInput(e) {
    var s;
    const t = (s = this.optionsFactory.getCustomOption(e)) == null ? void 0 : s.numberOfInputs;
    return t == null || t == 1;
  }
  isTypeEditable(e) {
    const t = ["inRange", "empty", "blank", "notBlank"];
    return !!e && !this.readOnly && this.hasSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    return `${this.beans.colNames.getDisplayNameForColumn(e.column, "header", !0)} ${this.getLocaleTextFunc()("ariaFilterInput", "Filter Input")}`;
  }
}, bF = class extends S {
  constructor(e) {
    super(), this.params = e, this.eInput = x, this.onValueChanged = () => {
    };
  }
  setupGui(e) {
    var i;
    this.eInput = this.createManagedBean(new tl((i = this.params) == null ? void 0 : i.config));
    const t = this.eInput.getGui();
    e.appendChild(t);
    const s = (o) => this.onValueChanged(o);
    this.addManagedListeners(t, {
      input: s,
      keydown: s
    });
  }
  setEditable(e) {
    this.eInput.setDisabled(!e);
  }
  getValue() {
    return this.eInput.getValue();
  }
  setValue(e, t) {
    this.eInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.onValueChanged = e;
  }
  setParams({ ariaLabel: e, autoComplete: t }) {
    const { eInput: s } = this;
    s.setInputAriaLabel(e), t !== void 0 && s.setAutoComplete(t);
  }
};
function og(e) {
  const t = e == null ? void 0 : e.trim();
  return t === "" ? e : t;
}
var yF = {
  tag: "div",
  ref: "eFloatingFilterInputContainer",
  cls: "ag-floating-filter-input",
  role: "presentation"
}, SF = class extends wF {
  constructor() {
    super(...arguments), this.eFloatingFilterInputContainer = x, this.defaultDebounceMs = 500;
  }
  postConstruct() {
    this.setTemplate(yF);
  }
  onParentModelChanged(e, t) {
    t != null && t.afterFloatingFilter || t != null && t.afterDataChange || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.inputSvc.setValue(this.filterModelFormatter.getModelAsString(e)));
  }
  init(e) {
    this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.inputSvc = this.createFloatingFilterInputService(e), this.inputSvc.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    this.params = e;
    const t = e.browserAutoComplete ?? !1, { inputSvc: s, defaultDebounceMs: i, readOnly: o } = this;
    if (s.setParams({
      ariaLabel: this.getAriaLabel(e),
      autoComplete: t
    }), this.applyActive = Fn(e.filterParams), !o) {
      const n = rh(e.filterParams, i), r = ct(
        this,
        this.syncUpWithParentFilter.bind(this),
        n
      );
      s.setValueChangedListener(r);
    }
  }
  refresh(e) {
    super.refresh(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const { inputSvc: t } = this, s = t.getValue();
    de(this.eFloatingFilterInputContainer), this.destroyBean(t), this.setupFloatingFilterInputService(e), t.setValue(s, !0);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === y.ENTER;
    if (this.applyActive && !t)
      return;
    const { inputSvc: s, params: i } = this;
    let o = s.getValue();
    i.filterParams.trimInput && (o = og(o), s.setValue(o, !0)), i.parentFilterInstance((n) => {
      n == null || n.onFloatingFilterChanged(this.lastType || null, o || null);
    });
  }
  setEditable(e) {
    this.inputSvc.setEditable(e);
  }
}, ng = [
  "contains",
  "notContains",
  "equals",
  "notEqual",
  "startsWith",
  "endsWith",
  "blank",
  "notBlank"
], rg = class extends vF {
  conditionToString(e, t) {
    const { numberOfInputs: s } = t || {}, { filter: i, filterTo: o, type: n } = e;
    return n == "inRange" || s === 2 ? `${i}-${o}` : i != null ? `${i}` : `${n}`;
  }
}, xF = class extends CF {
  constructor() {
    super("textFilter"), this.filterType = "text", this.defaultFormatter = (e) => e, this.defaultLowercaseFormatter = (e) => e == null ? null : e.toString().toLowerCase(), this.defaultMatcher = ({ filterOption: e, value: t, filterText: s }) => {
      if (s == null)
        return !1;
      switch (e) {
        case "contains":
          return t.indexOf(s) >= 0;
        case "notContains":
          return t.indexOf(s) < 0;
        case "equals":
          return t === s;
        case "notEqual":
          return t != s;
        case "startsWith":
          return t.indexOf(s) === 0;
        case "endsWith": {
          const i = t.lastIndexOf(s);
          return i >= 0 && i === t.length - s.length;
        }
        default:
          return !1;
      }
    }, this.eValuesFrom = [], this.eValuesTo = [], this.defaultDebounceMs = 500;
  }
  setParams(e) {
    this.textFilterParams = e, super.setParams(e), this.matcher = e.textMatcher || this.defaultMatcher, this.formatter = e.textFormatter || (e.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter), this.filterModelFormatter = new rg(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  createCondition(e) {
    const t = this.getConditionType(e), s = {
      filterType: this.filterType,
      type: t
    }, i = this.getValuesWithSideEffects(e, !0);
    return i.length > 0 && (s.filter = i[0]), i.length > 1 && (s.filterTo = i[1]), s;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    const { eValuesFrom: t, eValuesTo: s } = this;
    return e >= t.length ? [null, null] : [t[e], s[e]];
  }
  getValues(e) {
    return this.getValuesWithSideEffects(e, !1);
  }
  getValuesWithSideEffects(e, t) {
    const s = [];
    return this.forEachPositionInput(e, (i, o, n, r) => {
      if (o < r) {
        let a = ls(i.getValue());
        t && this.textFilterParams.trimInput && (a = og(a) ?? null, i.setValue(a, !0)), s.push(a);
      }
    }), s;
  }
  getDefaultFilterOptions() {
    return ng;
  }
  createValueElement() {
    const e = _({ tag: "div", cls: "ag-filter-body", role: "presentation" });
    return this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e;
  }
  createFromToElement(e, t, s) {
    const i = this.createManagedBean(new tl());
    i.addCss(`ag-filter-${s}`), i.addCss("ag-filter-filter"), t.push(i), e.appendChild(i.getGui());
  }
  removeValueElements(e, t) {
    const s = (i) => this.removeComponents(i, e, t);
    s(this.eValuesFrom), s(this.eValuesTo);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: s, type: i } = e || {};
    return [t || null, s || null].slice(0, this.getNumberOfInputs(i));
  }
  evaluateNullValue(e) {
    return e ? ["notEqual", "notContains", "blank"].indexOf(e) >= 0 : !1;
  }
  evaluateNonNullValue(e, t, s, i) {
    const o = e.map((h) => this.formatter(h)) || [], n = this.formatter(t), { api: r, colDef: a, column: l, context: d, textFormatter: c } = this.textFilterParams;
    if (s.type === "blank")
      return Dd(t);
    if (s.type === "notBlank")
      return !Dd(t);
    const u = {
      api: r,
      colDef: a,
      column: l,
      context: d,
      node: i.node,
      data: i.data,
      filterOption: s.type,
      value: n,
      textFormatter: c
    };
    return o.some((h) => this.matcher({ ...u, filterText: h }));
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
}, RF = class extends SF {
  init(e) {
    super.init(e), this.filterModelFormatter = new rg(
      this.getLocaleTextFunc.bind(this),
      this.optionsFactory
    );
  }
  refresh(e) {
    super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultOptions() {
    return ng;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new bF());
  }
}, FF = {
  moduleName: "ClientSideRowModelFilter",
  version: Q,
  rowModels: ["clientSide"],
  beans: [jR]
}, PF = {
  moduleName: "FilterCore",
  version: Q,
  beans: [uF],
  apiFunctions: {
    isAnyFilterPresent: dF,
    onFilterChanged: cF
  },
  css: [XR],
  dependsOn: [FF]
}, DF = {
  moduleName: "FilterValue",
  version: Q,
  beans: [gF]
}, ul = {
  moduleName: "ColumnFilter",
  version: Q,
  beans: [lF, hF],
  dynamicBeans: { headerFilterCellCtrl: $R },
  icons: {
    // open filter button - header, floating filter, menu
    filter: "filter",
    // filter is applied - header (legacy column menu), filter tool panel
    filterActive: "filter"
  },
  apiFunctions: {
    isColumnFilterPresent: JR,
    getColumnFilterInstance: eF,
    destroyFilter: tF,
    setFilterModel: sF,
    getFilterModel: iF,
    getColumnFilterModel: oF,
    setColumnFilterModel: nF,
    showColumnFilter: rF
  },
  dependsOn: [PF, cl, DF, sg]
}, MF = {
  moduleName: "TextFilter",
  version: Q,
  dependsOn: [ul],
  userComponents: {
    agTextColumnFilter: xF,
    agTextColumnFloatingFilter: RF
  }
}, EF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "selectionColSvc";
  }
  postConstruct() {
    this.addManagedPropertyListener("rowSelection", (e) => {
      this.onSelectionOptionsChanged(
        e.currentValue,
        e.previousValue,
        Ls(e.source)
      );
    }), this.addManagedPropertyListener("selectionColumnDef", this.updateColumns.bind(this));
  }
  addColumns(e) {
    const t = this.columns;
    t != null && (e.list = t.list.concat(e.list), e.tree = t.tree.concat(e.tree), yu(e));
  }
  createColumns(e, t) {
    var h, g;
    const s = () => {
      var p;
      gs(this.beans, (p = this.columns) == null ? void 0 : p.tree), this.columns = null;
    }, i = e.treeDepth, n = (((h = this.columns) == null ? void 0 : h.treeDepth) ?? -1) == i, r = this.generateSelectionCols();
    if (bu(r, ((g = this.columns) == null ? void 0 : g.list) ?? []) && n)
      return;
    s();
    const { colGroupSvc: l } = this.beans, d = (l == null ? void 0 : l.findDepth(e.tree)) ?? 0, c = (l == null ? void 0 : l.balanceTreeForAutoCols(r, d)) ?? [];
    this.columns = {
      list: r,
      tree: c,
      treeDepth: d,
      map: {}
    }, t((p) => {
      if (!p)
        return null;
      const f = p.filter((m) => !yo(m));
      return [...r, ...f];
    });
  }
  updateColumns(e) {
    var s;
    const t = Ls(e.source);
    (s = this.columns) == null || s.list.forEach((i) => {
      const o = this.createSelectionColDef(e.currentValue);
      i.setColDef(o, null, t), Wt(this.beans, { state: [{ ...o, colId: i.getColId() }] }, t);
    });
  }
  getColumn(e) {
    var t;
    return ((t = this.columns) == null ? void 0 : t.list.find((s) => Ha(s, e))) ?? null;
  }
  getColumns() {
    var e;
    return ((e = this.columns) == null ? void 0 : e.list) ?? null;
  }
  isSelectionColumnEnabled() {
    var r, a;
    const { gos: e, beans: t } = this, s = e.get("rowSelection");
    if (typeof s != "object" || !Dt(e))
      return !1;
    const i = (((a = (r = t.autoColSvc) == null ? void 0 : r.getColumns()) == null ? void 0 : a.length) ?? 0) > 0;
    if (s.checkboxLocation === "autoGroupColumn" && i)
      return !1;
    const o = !!Ts(s), n = jo(s);
    return o || n;
  }
  createSelectionColDef(e) {
    const { gos: t } = this.beans, s = e ?? t.get("selectionColumnDef"), i = t.get("enableRtl"), { rowSpan: o, spanRows: n, ...r } = s ?? {};
    return {
      // overridable properties
      width: 50,
      resizable: !1,
      suppressHeaderMenuButton: !0,
      sortable: !1,
      suppressMovable: !0,
      lockPosition: i ? "right" : "left",
      comparator(a, l, d, c) {
        const u = d.isSelected(), h = c.isSelected();
        return u === h ? 0 : u ? 1 : -1;
      },
      editable: !1,
      suppressFillHandle: !0,
      pinned: null,
      // overrides
      ...r,
      // non-overridable properties
      colId: vu,
      chartDataType: "excluded"
    };
  }
  generateSelectionCols() {
    if (!this.isSelectionColumnEnabled())
      return [];
    const e = this.createSelectionColDef(), t = e.colId;
    this.gos.validateColDef(e, t, !0);
    const s = new Ai(e, null, t, !1);
    return this.createBean(s), [s];
  }
  onSelectionOptionsChanged(e, t, s) {
    const i = t && typeof t != "string" ? Ts(t) : void 0, o = e && typeof e != "string" ? Ts(e) : void 0, n = i !== o, r = t && typeof t != "string" ? jo(t) : void 0, a = e && typeof e != "string" ? jo(e) : void 0, l = r !== a, d = ao(e), c = ao(t);
    (n || l || d !== c) && this.beans.colModel.refreshAll(s);
  }
  destroy() {
    var e;
    gs(this.beans, (e = this.columns) == null ? void 0 : e.tree), super.destroy();
  }
  /**
   * Refreshes visibility of the selection column based on which columns are currently visible.
   * Called by the VisibleColsService with the columns that are currently visible in left/center/right
   * containers. This method *MUTATES* those arrays directly.
   *
   * The selection column should be visible if all of the following are true
   * - The selection column is not disabled
   * - The number of visible columns excluding the selection column and row numbers column is greater than 0
   * @param leftCols Visible columns in the left-pinned container
   * @param centerCols Visible columns in the center viewport
   * @param rightCols Visible columns in the right-pinned container
   */
  refreshVisibility(e, t, s) {
    var l, d;
    if (!((l = this.columns) != null && l.list.length))
      return;
    const i = e.length + t.length + s.length;
    if (i === 0)
      return;
    const o = this.columns.list[0];
    if (!o.isVisible())
      return;
    const n = () => {
      let c;
      switch (o.pinned) {
        case "left":
        case !0:
          c = e;
          break;
        case "right":
          c = s;
          break;
        default:
          c = t;
      }
      c && Ae(c, o);
    };
    (((d = this.beans.rowNumbersSvc) == null ? void 0 : d.getColumn(wu)) ? 2 : 1) === i && n();
  }
};
function AF(e, t) {
  var r;
  if (!t.nodes.every((a) => a.rowPinned && !za(a) ? (P(59), !1) : a.id === void 0 ? (P(60), !1) : !0))
    return;
  const { nodes: i, source: o, newValue: n } = t;
  (r = e.selectionSvc) == null || r.setNodesSelected({ nodes: i, source: o ?? "api", newValue: n });
}
function IF(e, t, s = "apiSelectAll") {
  var i;
  (i = e.selectionSvc) == null || i.selectAllRowNodes({ source: s, selectAll: t });
}
function TF(e, t, s = "apiSelectAll") {
  var i;
  (i = e.selectionSvc) == null || i.deselectAllRowNodes({ source: s, selectAll: t });
}
function LF(e, t = "apiSelectAllFiltered") {
  var s;
  (s = e.selectionSvc) == null || s.selectAllRowNodes({ source: t, selectAll: "filtered" });
}
function kF(e, t = "apiSelectAllFiltered") {
  var s;
  (s = e.selectionSvc) == null || s.deselectAllRowNodes({ source: t, selectAll: "filtered" });
}
function GF(e, t = "apiSelectAllCurrentPage") {
  var s;
  (s = e.selectionSvc) == null || s.selectAllRowNodes({ source: t, selectAll: "currentPage" });
}
function OF(e, t = "apiSelectAllCurrentPage") {
  var s;
  (s = e.selectionSvc) == null || s.deselectAllRowNodes({ source: t, selectAll: "currentPage" });
}
function BF(e) {
  var t;
  return ((t = e.selectionSvc) == null ? void 0 : t.getSelectedNodes()) ?? [];
}
function NF(e) {
  var t;
  return ((t = e.selectionSvc) == null ? void 0 : t.getSelectedRows()) ?? [];
}
var HF = {
  moduleName: "SharedRowSelection",
  version: Q,
  beans: [EF],
  apiFunctions: {
    setNodesSelected: AF,
    selectAll: IF,
    deselectAll: TF,
    selectAllFiltered: LF,
    deselectAllFiltered: kF,
    selectAllOnCurrentPage: GF,
    deselectAllOnCurrentPage: OF,
    getSelectedNodes: BF,
    getSelectedRows: NF
  }
}, VF = class extends zw {
  constructor() {
    super(...arguments), this.beanName = "csrmNodeSvc";
  }
}, Fr = class {
  constructor() {
    this.removals = /* @__PURE__ */ new Set(), this.updates = /* @__PURE__ */ new Set(), this.adds = /* @__PURE__ */ new Set();
  }
  /** Marks a row as removed. Order of operations is: remove, update, add */
  remove(e) {
    this.adds.delete(e) || (this.updates.delete(e), this.removals.add(e));
  }
  /** Marks a row as updated. Order of operations is: remove, update, add */
  update(e) {
    this.adds.has(e) || this.updates.add(e);
  }
  /** Marks a row as added. Order of operation is: remove, update, add */
  add(e) {
    this.adds.add(e);
  }
};
function _F(e) {
  if (ie(e.childrenAfterSort))
    return;
  const t = e.childrenAfterSort;
  for (let s = 0; s < t.length; s++) {
    const i = t[s], o = s === 0, n = s === e.childrenAfterSort.length - 1;
    i.setFirstChild(o), i.lastChild !== n && (i.lastChild = n, i.dispatchRowEvent("lastChildChanged")), i.childIndex !== s && (i.childIndex = s, i.dispatchRowEvent("childIndexChanged"));
  }
}
function ag(e) {
  e.sibling && (e.sibling.childrenAfterSort = e.childrenAfterSort), _F(e);
}
var WF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "sortStage", this.refreshProps = /* @__PURE__ */ new Set(["postSortRows", "groupDisplayType", "accentedSort"]), this.step = "sort";
  }
  execute(e) {
    const t = this.beans, s = t.sortSvc.getSortOptions(), i = T(s) && s.length > 0, o = i && !!e.changedRowNodes && // in time we can remove this check, so that delta sort is always
    // on if transactions are present. it's off for now so that we can
    // selectively turn it on and test it with some select users before
    // rolling out to everyone.
    this.gos.get("deltaSort"), n = s.some(({ column: r }) => dt(t.gos) ? r.isPrimary() && r.isRowGroupActive() : !!r.getColDef().showRowGroup);
    this.sort(
      t,
      s,
      i,
      o,
      e.changedRowNodes,
      e.changedPath,
      n
    );
  }
  sort(e, t, s, i, o, n, r) {
    const { gos: a, colModel: l, rowGroupColsSvc: d, rowNodeSorter: c, rowRenderer: u, showRowGroupCols: h } = e, g = a.get("groupMaintainOrder"), p = l.getCols().some((C) => C.isRowGroupActive()), f = l.isPivotMode(), m = a.getCallback("postSortRows");
    let b = !1;
    const w = (C) => {
      var D, M;
      const v = f && C.leafGroup, F = g && p && !C.leafGroup && !r;
      let R;
      if (F) {
        const I = (D = d == null ? void 0 : d.columns) == null ? void 0 : D[C.level + 1], J = (I == null ? void 0 : I.getSort()) === null, W = C.childrenAfterAggFilter.slice(0);
        if (C.childrenAfterSort && !J) {
          const E = {};
          C.childrenAfterSort.forEach((oe, j) => {
            E[oe.id] = j;
          }), W.sort(
            (oe, j) => (E[oe.id] ?? 0) - (E[j.id] ?? 0)
          );
        }
        R = W;
      } else !s || v ? R = C.childrenAfterAggFilter.slice(0) : i && o ? R = zF(c, C, o, n, t) : R = c.doFullSort(C.childrenAfterAggFilter, t);
      if (b || (b = ((M = C.childrenAfterSort) == null ? void 0 : M[0]) !== R[0]), C.childrenAfterSort = R, ag(C), m) {
        const I = { nodes: C.childrenAfterSort };
        m(I);
      }
    };
    if (n == null || n.forEachChangedNodeDepthFirst(w), b && this.gos.get("groupHideOpenParents")) {
      const C = h == null ? void 0 : h.getShowRowGroupCols();
      C != null && C.length && u.refreshCells({ columns: C, force: !0 });
    }
  }
};
function zF(e, t, s, i, o) {
  const n = t.childrenAfterAggFilter, r = t.childrenAfterSort;
  if (!r)
    return e.doFullSort(n, o);
  const a = /* @__PURE__ */ new Set(), l = [], { updates: d, adds: c } = s;
  for (let h = 0, g = n.length; h < g; ++h) {
    const p = n[h];
    d.has(p) || c.has(p) || i && !i.canSkip(p) ? l.push({
      currentPos: l.length,
      rowNode: p
    }) : a.add(p.id);
  }
  const u = r.filter((h) => a.has(h.id)).map((h, g) => ({ currentPos: g, rowNode: h }));
  return l.sort((h, g) => e.compareRowNodes(o, h, g)), UF(e, o, l, u);
}
function UF(e, t, s, i) {
  const o = [];
  let n = 0, r = 0;
  const a = s.length, l = i.length;
  for (; n < a && r < l; ) {
    const d = s[n], c = i[r], u = e.compareRowNodes(t, d, c);
    let h;
    u < 0 ? (h = d, ++n) : (h = c, ++r), o.push(h.rowNode);
  }
  for (; n < a; )
    o.push(s[n++].rowNode);
  for (; r < l; )
    o.push(i[r++].rowNode);
  return o;
}
var jF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.rootNode = null, this.rowsToDisplay = [], this.lastHighlightedRow = null, this.started = !1, this.isRefreshingModel = !1, this.rowNodesCountReady = !1, this.rowCountReady = !1, this.onRowHeightChanged_debounced = ct(this, this.onRowHeightChanged.bind(this), 100);
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.valueCache = e.valueCache, this.filterStage = e.filterStage, this.sortStage = e.sortStage, this.flattenStage = e.flattenStage, this.groupStage = e.groupStage, this.aggStage = e.aggStage, this.pivotStage = e.pivotStage, this.filterAggStage = e.filterAggStage;
  }
  postConstruct() {
    this.orderedStages = [
      this.groupStage,
      this.filterStage,
      this.pivotStage,
      this.aggStage,
      this.sortStage,
      this.filterAggStage,
      this.flattenStage
    ].filter((i) => !!i);
    const e = this.refreshModel.bind(this, { step: "group" }), t = this.refreshModel.bind(this, {
      step: "group",
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      // we want animations cos sorting or filtering could be applied
      animate: !this.gos.get("suppressAnimationFrame")
    });
    this.addManagedEventListeners({
      newColumnsLoaded: t,
      columnRowGroupChanged: e,
      columnValueChanged: this.onValueChanged.bind(this),
      columnPivotChanged: this.refreshModel.bind(this, { step: "pivot" }),
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      columnPivotModeChanged: e,
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      gridReady: this.onGridReady.bind(this)
    }), this.addPropertyListeners(), this.rootNode = new Us(this.beans);
    const s = this.getNewNodeManager();
    this.nodeManager = s, s.activate(this.rootNode);
  }
  getNewNodeManager() {
    const { gos: e, beans: t } = this;
    switch (hu(e)) {
      case "treeNested":
        return t.csrmChildrenTreeNodeSvc ?? t.csrmNodeSvc;
      case "treePath":
        return t.csrmPathTreeNodeSvc ?? t.csrmNodeSvc;
      default:
        return t.csrmNodeSvc;
    }
  }
  addPropertyListeners() {
    const e = [
      "treeData",
      "treeDataChildrenField",
      ...this.orderedStages.flatMap(({ refreshProps: t }) => [...t])
    ];
    this.addManagedPropertyListeners(e, (t) => {
      var i;
      const s = (i = t.changeSet) == null ? void 0 : i.properties;
      s && this.onPropChange(s);
    }), this.addManagedPropertyListener("rowData", () => this.onPropChange(["rowData"])), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.started = !0, this.rowNodesCountReady ? this.refreshModel({ step: "group", rowDataUpdated: !0, newData: !0 }) : this.setInitialData();
  }
  setInitialData() {
    this.gos.get("rowData") && this.onPropChange(["rowData"]);
  }
  ensureRowHeightsValid(e, t, s, i) {
    let o, n = !1;
    do {
      o = !1;
      const r = this.getRowIndexAtPixel(e), a = this.getRowIndexAtPixel(t), l = Math.max(r, s), d = Math.min(a, i);
      for (let c = l; c <= d; c++) {
        const u = this.getRow(c);
        if (u.rowHeightEstimated) {
          const h = Je(this.beans, u);
          u.setRowHeight(h.height), o = !0, n = !0;
        }
      }
      o && this.setRowTopAndRowIndex();
    } while (o);
    return n;
  }
  onPropChange(e) {
    if (!this.rootNode)
      return;
    const t = this.gos, s = new Set(e), i = {
      step: "nothing",
      changedProps: s
    }, o = s.has("rowData"), n = this.nodeManager, r = this.getNewNodeManager(), a = n !== r || o && s.has("treeData") && t.get("treeData") || s.has("treeDataChildrenField") && t.get("treeData");
    let l;
    if ((a || o) && (l = t.get("rowData"), l != null && !Array.isArray(l) && (l = null, P(1))), a && (o || (l = (n == null ? void 0 : n.extractRowData()) ?? l), n !== r && (n == null || n.deactivate(), this.nodeManager = r), r.activate(this.rootNode)), l)
      if (!a && !this.isEmpty() && l.length > 0 && t.exists("getRowId") && // this property is a backwards compatibility property, for those who want
      // the old behaviour of Row IDs but NOT Immutable Data.
      !t.get("resetRowDataOnUpdate"))
        i.keepRenderedRows = !0, i.animate = !this.gos.get("suppressAnimationFrame"), i.changedRowNodes = new Fr(), r.setImmutableRowData(i, l);
      else {
        i.rowDataUpdated = !0, i.newData = !0;
        const { selectionSvc: c, pinnedRowModel: u } = this.beans;
        c == null || c.reset("rowDataChanged"), u != null && u.isManual() && u.reset(), this.rowNodesCountReady = !0, r.setNewRowData(l);
      }
    if (i.rowDataUpdated)
      i.step = "group";
    else if (i.step === "nothing") {
      for (const { refreshProps: d, step: c } of this.orderedStages)
        if (e.some((u) => d.has(u))) {
          i.step = c;
          break;
        }
    }
    i.step !== "nothing" && this.refreshModel(i);
  }
  setRowTopAndRowIndex() {
    const { beans: e, rowsToDisplay: t } = this, s = e.environment.getDefaultRowHeight();
    let i = 0;
    const o = /* @__PURE__ */ new Set(), n = xe(this.gos, "normal");
    for (let r = 0, a = t.length; r < a; ++r) {
      const l = t[r];
      if (l.id != null && o.add(l.id), l.rowHeight == null) {
        const d = Je(e, l, n, s);
        l.setRowHeight(d.height, d.estimated);
      }
      l.setRowTop(i), l.setRowIndex(r), i += l.rowHeight;
    }
    return o;
  }
  clearRowTopAndRowIndex(e, t) {
    const s = e.active, i = (n) => {
      n && n.id != null && !t.has(n.id) && n.clearRowTopAndRowIndex();
    }, o = (n) => {
      if (n !== null && (i(n), i(n.detailNode), i(n.sibling), n.hasChildren() && n.childrenAfterGroup)) {
        const r = n.level == -1;
        s && !r && !n.expanded || n.childrenAfterGroup.forEach(o);
      }
    };
    o(this.rootNode);
  }
  clearHighlight() {
    const e = this.lastHighlightedRow;
    e && (e.highlighted = null, e.dispatchRowEvent("rowHighlightChanged"), this.lastHighlightedRow = null);
  }
  highlightRow(e, t) {
    const s = e !== this.lastHighlightedRow, i = t !== e.highlighted;
    (s || i) && (s && this.clearHighlight(), e.highlighted = t, e.dispatchRowEvent("rowHighlightChanged"), this.lastHighlightedRow = e);
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  /**
   * Returns the number of rows with level === 1
   */
  getTopLevelRowCount() {
    const e = this.rootNode;
    if (!e || this.rowsToDisplay.length === 0)
      return 0;
    if (this.rowsToDisplay && this.rowsToDisplay[0] === e)
      return 1;
    const s = e.childrenAfterAggFilter, i = e.sibling ? 1 : 0;
    return (s ? s.length : 0) + i;
  }
  /**
   * Get the row display index by the top level index
   * top level index is the index of rows with level === 1
   */
  getTopLevelRowDisplayedIndex(e) {
    const { rootNode: t, rowsToDisplay: s } = this;
    if (!t || !s.length || s[0] === t)
      return e;
    const { childrenAfterSort: o } = t, n = (a) => {
      let l = o[a];
      if (this.gos.get("groupHideOpenParents"))
        for (; l.expanded && l.childrenAfterSort && l.childrenAfterSort.length > 0; )
          l = l.childrenAfterSort[0];
      return l.rowIndex;
    }, { footerSvc: r } = this.beans;
    return r ? r.getTopDisplayIndex(s, e, o, n) : n(e);
  }
  /**
   * The opposite of `getTopLevelRowDisplayedIndex`
   */
  getTopLevelIndexFromDisplayedIndex(e) {
    var r;
    const { rootNode: t, rowsToDisplay: s } = this;
    if (!t || !s.length || s[0] === t)
      return e;
    let o = this.getRow(e);
    for (o.footer && (o = o.sibling); o.parent && o.parent !== t; )
      o = o.parent;
    const n = (r = t.childrenAfterSort) == null ? void 0 : r.findIndex((a) => a === o);
    return n === -1 ? e : n ?? e;
  }
  getRowBounds(e) {
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = ci(this.gos);
    this.refreshModel({ step: "map", keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = ci(this.gos), i = e.columns.length === 0 || e.columns.some((o) => o.isPrimary()) ? "filter" : "filter_aggregates";
    this.refreshModel({ step: i, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = ci(this.gos);
    this.refreshModel({
      step: "sort",
      keepRenderedRows: !0,
      animate: e
    });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.refreshModel({ step: this.colModel.isPivotActive() ? "pivot" : "aggregate" });
  }
  createChangePath(e) {
    const t = new Xu(!1, this.rootNode);
    return e || (t.active = !1), t;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction"))
      return !1;
    const { changedRowNodes: t, newData: s, rowDataUpdated: i } = e;
    return !(!t || s || !i || t.removals.size || t.adds.size);
  }
  refreshModel(e) {
    var i, o;
    if (!this.rootNode)
      return;
    const t = e.changedPath ?? (e.changedPath = this.createChangePath(!e.newData && !!e.rowDataUpdated));
    if ((o = (i = this.nodeManager).refreshModel) == null || o.call(i, e, this.started), this.eventSvc.dispatchEvent({ type: "beforeRefreshModel", params: e }), !this.started || (e.rowDataUpdated && this.eventSvc.dispatchEvent({ type: "rowDataUpdated" }), this.isRefreshingModel || this.colModel.changeEventsDispatching || this.isSuppressModelUpdateAfterUpdateTransaction(e)))
      return;
    switch (this.isRefreshingModel = !0, e.step) {
      case "group":
        this.doRowGrouping(
          e.changedRowNodes,
          t,
          !!e.rowNodesOrderChanged,
          !!e.afterColumnsChanged
        );
      case "filter":
        this.doFilter(t);
      case "pivot":
        this.doPivot(t);
      case "aggregate":
        this.doAggregate(t);
      case "filter_aggregates":
        this.doFilterAggregates(t);
      case "sort":
        this.doSort(e.changedRowNodes, t);
      case "map":
        this.doRowsToDisplay();
    }
    const s = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(t, s), this.isRefreshingModel = !1, this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      animate: e.animate,
      keepRenderedRows: e.keepRenderedRows,
      newData: e.newData,
      newPage: !1,
      keepUndoRedoStack: e.keepUndoRedoStack
    });
  }
  isEmpty() {
    var e, t, s;
    return !((t = (e = this.rootNode) == null ? void 0 : e.allLeafChildren) != null && t.length) || !((s = this.colModel) != null && s.ready);
  }
  isRowsToRender() {
    return this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let s = !1, i = !1;
    const o = [], n = lo(this.gos);
    return this.forEachNodeAfterFilterAndSort((r) => {
      if (i)
        return;
      if (s && (r === t || r === e) && (i = !0, r.group && n)) {
        o.push(...r.allLeafChildren);
        return;
      }
      if (!s) {
        if (r !== t && r !== e)
          return;
        s = !0;
      }
      if (!r.group || !n) {
        o.push(r);
        return;
      }
    }), o;
  }
  getTopLevelNodes() {
    var e;
    return ((e = this.rootNode) == null ? void 0 : e.childrenAfterGroup) ?? null;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    const t = this.rowsToDisplay;
    if (this.isEmpty() || t.length === 0)
      return -1;
    let s = 0, i = t.length - 1;
    if (e <= 0)
      return 0;
    if (Z(t).rowTop <= e)
      return t.length - 1;
    let n = -1, r = -1;
    for (; ; ) {
      const a = Math.floor((s + i) / 2), l = t[a];
      if (this.isRowInPixel(l, e) || (l.rowTop < e ? s = a + 1 : l.rowTop > e && (i = a - 1), n === s && r === i))
        return a;
      n = s, r = i;
    }
  }
  isRowInPixel(e, t) {
    const s = e.rowTop, i = e.rowTop + e.rowHeight;
    return s <= t && i > t;
  }
  forEachLeafNode(e) {
    var t, s;
    (s = (t = this.rootNode) == null ? void 0 : t.allLeafChildren) == null || s.forEach((i, o) => e(i, o));
  }
  forEachNode(e, t = !1) {
    this.depthFirstSearchRowNodes(e, t);
  }
  forEachDisplayedNode(e) {
    this.rowsToDisplay.forEach(e);
  }
  forEachNodeAfterFilter(e, t = !1) {
    this.depthFirstSearchRowNodes(e, t, (s) => s.childrenAfterAggFilter);
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    this.depthFirstSearchRowNodes(e, t, (s) => s.childrenAfterSort);
  }
  forEachPivotNode(e, t = !1, s = !1) {
    const { colModel: i, rowGroupColsSvc: o } = this.beans;
    if (!i.isPivotMode())
      return;
    if (!(o != null && o.columns.length)) {
      e(this.rootNode, 0);
      return;
    }
    const n = s ? "childrenAfterSort" : "childrenAfterGroup";
    this.depthFirstSearchRowNodes(
      e,
      t,
      (r) => r.leafGroup ? null : r[n]
    );
  }
  /**
   * Iterate through each node and all of its children
   * @param callback the function to execute for each node
   * @param includeFooterNodes whether to also iterate over footer nodes
   * @param nodes the nodes to start iterating over
   * @param getChildren a function to determine the recursion strategy
   * @param startIndex the index to start from
   * @returns the index ended at
   */
  depthFirstSearchRowNodes(e, t = !1, s = (n) => n.childrenAfterGroup, i = this.rootNode, o = 0) {
    let n = o;
    if (!i)
      return n;
    const r = i === this.rootNode;
    r || e(i, n++);
    const { footerSvc: a } = this.beans;
    if (i.hasChildren() && !i.footer) {
      const l = s(i);
      if (l) {
        n = (a == null ? void 0 : a.addTotalRows(n, i, e, t, r, "top")) ?? n;
        for (const d of l)
          n = this.depthFirstSearchRowNodes(e, t, s, d, n);
        return (a == null ? void 0 : a.addTotalRows(n, i, e, t, r, "bottom")) ?? n;
      }
    }
    return n;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    var s;
    const t = this.rootNode;
    t && ((s = this.aggStage) == null || s.execute({ rowNode: t, changedPath: e }));
  }
  doFilterAggregates(e) {
    const t = this.rootNode;
    this.filterAggStage ? this.filterAggStage.execute({ rowNode: t, changedPath: e }) : t.childrenAfterAggFilter = t.childrenAfterFilter;
  }
  doSort(e, t) {
    this.sortStage ? this.sortStage.execute({
      rowNode: this.rootNode,
      changedRowNodes: e,
      changedPath: t
    }) : t.forEachChangedNodeDepthFirst((s) => {
      s.childrenAfterSort = s.childrenAfterAggFilter.slice(0), ag(s);
    });
  }
  doRowGrouping(e, t, s, i) {
    var r;
    const o = this.rootNode;
    if (!((r = this.groupStage) == null ? void 0 : r.execute({
      rowNode: o,
      changedPath: t,
      changedRowNodes: e,
      rowNodesOrderChanged: s,
      afterColumnsChanged: i
    })) && !this.nodeManager.treeData) {
      const a = o.sibling;
      o.childrenAfterGroup = o.allLeafChildren, a && (a.childrenAfterGroup = o.childrenAfterGroup), o.updateHasChildren();
    }
    this.rowNodesCountReady && (this.rowCountReady = !0, this.eventSvc.dispatchEventOnce({ type: "rowCountReady" }));
  }
  doFilter(e) {
    this.filterStage ? this.filterStage.execute({ rowNode: this.rootNode, changedPath: e }) : e.forEachChangedNodeDepthFirst((t) => {
      t.childrenAfterFilter = t.childrenAfterGroup, tg(t);
    }, !0);
  }
  doPivot(e) {
    var t;
    (t = this.pivotStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(Rn) == 0) {
      let s;
      return this.forEachNode((i) => {
        i.id === e && (s = i);
      }), s;
    }
    return this.nodeManager.getRowNode(e);
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const s = this.gos.get("asyncTransactionWaitMillis");
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.isAlive() && this.executeBatchUpdateRowData();
      }, s);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    var o, n;
    (o = this.valueCache) == null || o.onDataChanged();
    const e = [], t = [], s = new Fr();
    let i = !1;
    (n = this.rowDataTransactionBatch) == null || n.forEach((r) => {
      this.rowNodesCountReady = !0;
      const { rowNodeTransaction: a, rowsInserted: l } = this.nodeManager.updateRowData(
        r.rowDataTransaction,
        s
      );
      l && (i = !0), t.push(a), r.callback && e.push(r.callback.bind(null, a));
    }), this.commitTransactions(i, s), e.length > 0 && window.setTimeout(() => {
      e.forEach((r) => r());
    }, 0), t.length > 0 && this.eventSvc.dispatchEvent({
      type: "asyncTransactionsFlushed",
      results: t
    }), this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  /**
   * Used to apply transaction changes.
   * Called by gridApi & rowDragFeature
   */
  updateRowData(e) {
    var o;
    (o = this.valueCache) == null || o.onDataChanged(), this.rowNodesCountReady = !0;
    const t = new Fr(), { rowNodeTransaction: s, rowsInserted: i } = this.nodeManager.updateRowData(e, t);
    return this.commitTransactions(i, t), s;
  }
  /**
   * Common to:
   * - executeBatchUpdateRowData (batch transactions)
   * - updateRowData (single transaction)
   * - setImmutableRowData (generated transaction)
   *
   * @param rowNodeTrans - the transactions to apply
   * @param orderChanged - whether the order of the rows has changed, either via generated transaction or user provided addIndex
   */
  commitTransactions(e, t) {
    this.refreshModel({
      step: "group",
      rowDataUpdated: !0,
      rowNodesOrderChanged: e,
      keepRenderedRows: !0,
      animate: !this.gos.get("suppressAnimationFrame"),
      changedRowNodes: t,
      changedPath: this.createChangePath(!0)
    });
  }
  doRowsToDisplay() {
    const { flattenStage: e, rootNode: t } = this;
    let s;
    if (e)
      s = e.execute({ rowNode: t });
    else {
      s = (t == null ? void 0 : t.childrenAfterSort) ?? [];
      for (const i of s)
        i.setUiLevel(0);
    }
    this.rowsToDisplay = s;
  }
  onRowHeightChanged() {
    this.refreshModel({
      step: "map",
      keepRenderedRows: !0,
      keepUndoRedoStack: !0
    });
  }
  resetRowHeights() {
    const e = this.rootNode;
    if (!e)
      return;
    const t = this.resetRowHeightsForAllRowNodes();
    e.setRowHeight(e.rowHeight, !0), e.sibling && e.sibling.setRowHeight(e.sibling.rowHeight, !0), t && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const s = t.detailNode;
      s && s.setRowHeight(s.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges(e) {
    var t;
    if (e.rowHeightChanged) {
      if ((t = this.beans.rowAutoHeight) != null && t.active)
        return;
      this.resetRowHeights();
    }
  }
  onGridReady() {
    this.started || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
  destroy() {
    super.destroy(), this.clearHighlight(), this.started = !1, this.rootNode = null, this.nodeManager = null, this.rowDataTransactionBatch = null, this.orderedStages = Zr, this.rowsToDisplay = Zr;
  }
  /**
   * @deprecated v33.1
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
}, $F = {
  moduleName: "ClientSideRowModel",
  version: Q,
  rowModels: ["clientSide"],
  beans: [VF, jF, WF],
  dependsOn: [ll]
}, KF = class {
  constructor() {
    this.ieCompatibility = !1;
  }
  init() {
    this.ieCompatibility = this.md5("hello") != "5d41402abc4b2a76b9719d911017c592";
  }
  md5cycle(e, t) {
    let s = e[0], i = e[1], o = e[2], n = e[3];
    s = this.ff(s, i, o, n, t[0], 7, -680876936), n = this.ff(n, s, i, o, t[1], 12, -389564586), o = this.ff(o, n, s, i, t[2], 17, 606105819), i = this.ff(i, o, n, s, t[3], 22, -1044525330), s = this.ff(s, i, o, n, t[4], 7, -176418897), n = this.ff(n, s, i, o, t[5], 12, 1200080426), o = this.ff(o, n, s, i, t[6], 17, -1473231341), i = this.ff(i, o, n, s, t[7], 22, -45705983), s = this.ff(s, i, o, n, t[8], 7, 1770035416), n = this.ff(n, s, i, o, t[9], 12, -1958414417), o = this.ff(o, n, s, i, t[10], 17, -42063), i = this.ff(i, o, n, s, t[11], 22, -1990404162), s = this.ff(s, i, o, n, t[12], 7, 1804603682), n = this.ff(n, s, i, o, t[13], 12, -40341101), o = this.ff(o, n, s, i, t[14], 17, -1502002290), i = this.ff(i, o, n, s, t[15], 22, 1236535329), s = this.gg(s, i, o, n, t[1], 5, -165796510), n = this.gg(n, s, i, o, t[6], 9, -1069501632), o = this.gg(o, n, s, i, t[11], 14, 643717713), i = this.gg(i, o, n, s, t[0], 20, -373897302), s = this.gg(s, i, o, n, t[5], 5, -701558691), n = this.gg(n, s, i, o, t[10], 9, 38016083), o = this.gg(o, n, s, i, t[15], 14, -660478335), i = this.gg(i, o, n, s, t[4], 20, -405537848), s = this.gg(s, i, o, n, t[9], 5, 568446438), n = this.gg(n, s, i, o, t[14], 9, -1019803690), o = this.gg(o, n, s, i, t[3], 14, -187363961), i = this.gg(i, o, n, s, t[8], 20, 1163531501), s = this.gg(s, i, o, n, t[13], 5, -1444681467), n = this.gg(n, s, i, o, t[2], 9, -51403784), o = this.gg(o, n, s, i, t[7], 14, 1735328473), i = this.gg(i, o, n, s, t[12], 20, -1926607734), s = this.hh(s, i, o, n, t[5], 4, -378558), n = this.hh(n, s, i, o, t[8], 11, -2022574463), o = this.hh(o, n, s, i, t[11], 16, 1839030562), i = this.hh(i, o, n, s, t[14], 23, -35309556), s = this.hh(s, i, o, n, t[1], 4, -1530992060), n = this.hh(n, s, i, o, t[4], 11, 1272893353), o = this.hh(o, n, s, i, t[7], 16, -155497632), i = this.hh(i, o, n, s, t[10], 23, -1094730640), s = this.hh(s, i, o, n, t[13], 4, 681279174), n = this.hh(n, s, i, o, t[0], 11, -358537222), o = this.hh(o, n, s, i, t[3], 16, -722521979), i = this.hh(i, o, n, s, t[6], 23, 76029189), s = this.hh(s, i, o, n, t[9], 4, -640364487), n = this.hh(n, s, i, o, t[12], 11, -421815835), o = this.hh(o, n, s, i, t[15], 16, 530742520), i = this.hh(i, o, n, s, t[2], 23, -995338651), s = this.ii(s, i, o, n, t[0], 6, -198630844), n = this.ii(n, s, i, o, t[7], 10, 1126891415), o = this.ii(o, n, s, i, t[14], 15, -1416354905), i = this.ii(i, o, n, s, t[5], 21, -57434055), s = this.ii(s, i, o, n, t[12], 6, 1700485571), n = this.ii(n, s, i, o, t[3], 10, -1894986606), o = this.ii(o, n, s, i, t[10], 15, -1051523), i = this.ii(i, o, n, s, t[1], 21, -2054922799), s = this.ii(s, i, o, n, t[8], 6, 1873313359), n = this.ii(n, s, i, o, t[15], 10, -30611744), o = this.ii(o, n, s, i, t[6], 15, -1560198380), i = this.ii(i, o, n, s, t[13], 21, 1309151649), s = this.ii(s, i, o, n, t[4], 6, -145523070), n = this.ii(n, s, i, o, t[11], 10, -1120210379), o = this.ii(o, n, s, i, t[2], 15, 718787259), i = this.ii(i, o, n, s, t[9], 21, -343485551), e[0] = this.add32(s, e[0]), e[1] = this.add32(i, e[1]), e[2] = this.add32(o, e[2]), e[3] = this.add32(n, e[3]);
  }
  cmn(e, t, s, i, o, n) {
    return t = this.add32(this.add32(t, e), this.add32(i, n)), this.add32(t << o | t >>> 32 - o, s);
  }
  ff(e, t, s, i, o, n, r) {
    return this.cmn(t & s | ~t & i, e, t, o, n, r);
  }
  gg(e, t, s, i, o, n, r) {
    return this.cmn(t & i | s & ~i, e, t, o, n, r);
  }
  hh(e, t, s, i, o, n, r) {
    return this.cmn(t ^ s ^ i, e, t, o, n, r);
  }
  ii(e, t, s, i, o, n, r) {
    return this.cmn(s ^ (t | ~i), e, t, o, n, r);
  }
  md51(e) {
    const t = e.length, s = [1732584193, -271733879, -1732584194, 271733878];
    let i;
    for (i = 64; i <= e.length; i += 64)
      this.md5cycle(s, this.md5blk(e.substring(i - 64, i)));
    e = e.substring(i - 64);
    const o = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (i = 0; i < e.length; i++)
      o[i >> 2] |= e.charCodeAt(i) << (i % 4 << 3);
    if (o[i >> 2] |= 128 << (i % 4 << 3), i > 55)
      for (this.md5cycle(s, o), i = 0; i < 16; i++)
        o[i] = 0;
    return o[14] = t * 8, this.md5cycle(s, o), s;
  }
  /* there needs to be support for Unicode here, * unless we pretend that we can redefine the MD-5
   * algorithm for multi-byte characters (perhaps by adding every four 16-bit characters and
   * shortening the sum to 32 bits). Otherwise I suthis.ggest performing MD-5 as if every character
   * was two bytes--e.g., 0040 0025 = @%--but then how will an ordinary MD-5 sum be matched?
   * There is no way to standardize text to something like UTF-8 before transformation; speed cost is
   * utterly prohibitive. The JavaScript standard itself needs to look at this: it should start
   * providing access to strings as preformed UTF-8 8-bit unsigned value arrays.
   */
  md5blk(e) {
    const t = [];
    for (let s = 0; s < 64; s += 4)
      t[s >> 2] = e.charCodeAt(s) + (e.charCodeAt(s + 1) << 8) + (e.charCodeAt(s + 2) << 16) + (e.charCodeAt(s + 3) << 24);
    return t;
  }
  rhex(e) {
    const t = "0123456789abcdef".split("");
    let s = "", i = 0;
    for (; i < 4; i++)
      s += t[e >> i * 8 + 4 & 15] + t[e >> i * 8 & 15];
    return s;
  }
  hex(e) {
    for (let t = 0; t < e.length; t++)
      e[t] = this.rhex(e[t]);
    return e.join("");
  }
  md5(e) {
    return this.hex(this.md51(e));
  }
  add32(e, t) {
    return this.ieCompatibility ? this.add32Compat(e, t) : this.add32Std(e, t);
  }
  /* this function is much faster, so if possible we use it. Some IEs are the only ones I know of that
   need the idiotic second function, generated by an if clause.  */
  add32Std(e, t) {
    return e + t & 4294967295;
  }
  add32Compat(e, t) {
    const s = (e & 65535) + (t & 65535);
    return (e >> 16) + (t >> 16) + (s >> 16) << 16 | s & 65535;
  }
}, Vo = {
  "01": "GRID",
  "02": "CHARTS",
  "0102": "BOTH"
}, Md = "https://www.ag-grid.com/licensing/", lg = class Ge {
  constructor(t) {
    this.watermarkMessage = void 0, this.totalMessageLength = 124, this.document = t, this.md5 = new KF(), this.md5.init();
  }
  validateLicense() {
    const t = this.getLicenseDetails(Ge.licenseKey), s = `AG Grid ${t.currentLicenseType === "BOTH" ? "and AG Charts " : ""}Enterprise`, i = t.suppliedLicenseType === void 0 ? "" : `AG ${t.suppliedLicenseType === "BOTH" ? "Grid and AG Charts" : t.suppliedLicenseType === "GRID" ? "Grid" : "Charts"} Enterprise`;
    if (t.missing)
      (!this.isWebsiteUrl() || this.isForceWatermark()) && this.outputMissingLicenseKey(s);
    else if (t.expired) {
      const o = Ge.getGridReleaseDate(), n = Ge.formatDate(o);
      this.outputExpiredKey(t.expiry, n, s, i);
    } else t.valid ? t.isTrial && t.trialExpired && this.outputExpiredTrialKey(t.expiry, s, i) : this.outputInvalidLicenseKey(
      !!t.incorrectLicenseType,
      s,
      i
    );
  }
  static extractExpiry(t) {
    const s = t.substring(t.lastIndexOf("_") + 1, t.length);
    return new Date(parseInt(Ge.decode(s), 10));
  }
  static extractLicenseComponents(t) {
    let s = t.replace(/[\u200B-\u200D\uFEFF]/g, "");
    if (s = s.replace(/\r?\n|\r/g, ""), t.length <= 32)
      return { md5: null, license: t, version: null, isTrial: null };
    const i = s.length - 32, o = s.substring(i), n = s.substring(0, i), [r, a, l] = Ge.extractBracketedInformation(s);
    return { md5: o, license: n, version: r, isTrial: a, type: l };
  }
  getLicenseDetails(t) {
    const s = Ge.chartsLicenseManager ? "BOTH" : "GRID";
    if (!(t != null && t.length))
      return {
        licenseKey: t,
        valid: !1,
        missing: !0,
        currentLicenseType: s
      };
    const i = Ge.getGridReleaseDate(), { md5: o, license: n, version: r, isTrial: a, type: l } = Ge.extractLicenseComponents(t);
    let d = o === this.md5.md5(n) && t.indexOf("For_Trialing_ag-Grid_Only") === -1, c, u, h = null, g = !1, p;
    function f() {
      c = h < /* @__PURE__ */ new Date(), u = void 0;
    }
    if (d && (h = Ge.extractExpiry(n), d = !isNaN(h.getTime()), d))
      switch (u = i > h, r) {
        case "legacy":
        case "2": {
          a && f();
          break;
        }
        case "3":
          l != null && l.length ? (p = l, l !== Vo["01"] && l !== Vo["0102"] || s === "BOTH" && p !== "BOTH" ? (d = !1, g = !0) : a && f()) : d = !1;
      }
    return d ? {
      licenseKey: t,
      valid: d,
      expiry: Ge.formatDate(h),
      expired: u,
      version: r,
      isTrial: a,
      trialExpired: c,
      incorrectLicenseType: g,
      currentLicenseType: s,
      suppliedLicenseType: p
    } : {
      licenseKey: t,
      valid: d,
      incorrectLicenseType: g,
      currentLicenseType: s,
      suppliedLicenseType: p
    };
  }
  isDisplayWatermark() {
    var t;
    return this.isForceWatermark() || !this.isLocalhost() && !this.isWebsiteUrl() && !!((t = this.watermarkMessage) != null && t.length);
  }
  getWatermarkMessage() {
    return this.watermarkMessage || "";
  }
  getHostname() {
    const s = (this.document.defaultView || window).location, { hostname: i = "" } = s;
    return i;
  }
  isForceWatermark() {
    const s = (this.document.defaultView || window).location, { pathname: i } = s;
    return i ? i.indexOf("forceWatermark") !== -1 : !1;
  }
  isWebsiteUrl() {
    return this.getHostname().match(/^((?:[\w-]+\.)?ag-grid\.com)$/) !== null;
  }
  isLocalhost() {
    return this.getHostname().match(/^(?:127\.0\.0\.1|localhost)$/) !== null;
  }
  static formatDate(t) {
    const s = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ], i = t.getDate(), o = t.getMonth(), n = t.getFullYear();
    return i + " " + s[o] + " " + n;
  }
  static getGridReleaseDate() {
    return new Date(parseInt(Ge.decode(Ge.RELEASE_INFORMATION), 10));
  }
  static decode(t) {
    const s = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    let i = "", o, n, r, a, l, d, c, u = 0;
    const h = t.replace(/[^A-Za-z0-9+/=]/g, "");
    for (; u < h.length; )
      a = s.indexOf(h.charAt(u++)), l = s.indexOf(h.charAt(u++)), d = s.indexOf(h.charAt(u++)), c = s.indexOf(h.charAt(u++)), o = a << 2 | l >> 4, n = (l & 15) << 4 | d >> 2, r = (d & 3) << 6 | c, i = i + String.fromCharCode(o), d != 64 && (i = i + String.fromCharCode(n)), c != 64 && (i = i + String.fromCharCode(r));
    return i = Ge.utf8_decode(i), i;
  }
  static utf8_decode(t) {
    t = t.replace(/rn/g, "n");
    let s = "";
    for (let i = 0; i < t.length; i++) {
      const o = t.charCodeAt(i);
      o < 128 ? s += String.fromCharCode(o) : o > 127 && o < 2048 ? (s += String.fromCharCode(o >> 6 | 192), s += String.fromCharCode(o & 63 | 128)) : (s += String.fromCharCode(o >> 12 | 224), s += String.fromCharCode(o >> 6 & 63 | 128), s += String.fromCharCode(o & 63 | 128));
    }
    return s;
  }
  static setChartsLicenseManager(t) {
    var s;
    this.chartsLicenseManager = t, (s = this.chartsLicenseManager) == null || s.setLicenseKey(this.licenseKey, !0);
  }
  static setLicenseKey(t) {
    var s;
    this.licenseKey = t, (s = this.chartsLicenseManager) == null || s.setLicenseKey(t, !0);
  }
  static extractBracketedInformation(t) {
    if (!t.includes("["))
      return ["legacy", !1, void 0];
    const s = t.match(/\[(.*?)\]/g).map((a) => a.replace("[", "").replace("]", ""));
    if (!s || s.length === 0)
      return ["legacy", !1, void 0];
    const i = s.filter((a) => a === "TRIAL").length === 1, o = s.filter((a) => a.indexOf("v") === 0)[0], n = o ? o.replace("v", "") : "legacy", r = Vo[s.filter((a) => Vo[a])[0]];
    return [n, i, r];
  }
  centerPadAndOutput(t) {
    const s = this.totalMessageLength - t.length;
    console.error(t.padStart(s / 2 + t.length, "*").padEnd(this.totalMessageLength, "*"));
  }
  padAndOutput(t, s = "*", i = "") {
    console.error(
      t.padEnd(this.totalMessageLength - i.length, s) + i
    );
  }
  outputInvalidLicenseKey(t, s, i) {
    t ? (this.centerPadAndOutput(""), this.centerPadAndOutput(` ${s} License `), this.centerPadAndOutput(" Incompatible License Key "), this.padAndOutput(
      `* Your license key is for ${i} only and does not cover you for ${s}.`,
      " ",
      "*"
    ), this.padAndOutput(`* To troubleshoot your license key visit ${Md}.`, " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput("")) : (this.centerPadAndOutput(""), this.centerPadAndOutput(` ${s} License `), this.centerPadAndOutput(" Invalid License Key "), this.padAndOutput("* Your license key is not valid.", " ", "*"), this.padAndOutput(`* To troubleshoot your license key visit ${Md}.`, " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput("")), this.watermarkMessage = "Invalid License";
  }
  outputExpiredTrialKey(t, s, i) {
    this.centerPadAndOutput(""), this.centerPadAndOutput(` ${s} License `), this.centerPadAndOutput(" Trial Period Expired. "), this.padAndOutput(
      `* Your trial only license for ${i} expired on ${t}.`,
      " ",
      "*"
    ), this.padAndOutput("* Please email info@ag-grid.com to purchase a license.", " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput(""), this.watermarkMessage = "Trial Period Expired";
  }
  outputMissingLicenseKey(t) {
    this.centerPadAndOutput(""), this.centerPadAndOutput(` ${t} License `), this.centerPadAndOutput(" License Key Not Found "), this.padAndOutput(`* All ${t} features are unlocked for trial.`, " ", "*"), this.padAndOutput(
      "* If you want to hide the watermark please email info@ag-grid.com for a trial license key.",
      " ",
      "*"
    ), this.centerPadAndOutput(""), this.centerPadAndOutput(""), this.watermarkMessage = "For Trial Use Only";
  }
  outputExpiredKey(t, s, i, o) {
    this.centerPadAndOutput(""), this.centerPadAndOutput(` ${i} License `), this.centerPadAndOutput(" Incompatible Software Version "), this.padAndOutput(
      `* Your license key works with versions of ${o} released before ${t}.`,
      " ",
      "*"
    ), this.padAndOutput(`* The version you are trying to use was released on ${s}.`, " ", "*"), this.padAndOutput("* Please contact info@ag-grid.com to renew your license key.", " ", "*"), this.centerPadAndOutput(""), this.centerPadAndOutput(""), this.watermarkMessage = "License Expired";
  }
};
lg.RELEASE_INFORMATION = "MTc0ODQ1MzQ2MTA5Mg==";
var _o = lg, qF = (
  /*css*/
  '.ag-watermark{bottom:20px;color:#9b9b9b;opacity:.7;position:absolute;transition:opacity 1s ease-out 3s;&:before{background-image:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDkiIGhlaWdodD0iMzYiIGZpbGw9Im5vbmUiIHZpZXdCb3g9IjAgMCAyMDkgMzYiPjxwYXRoIGZpbGw9IiM5QjlCOUIiIGQ9Ik0xOTIuOTkzIDIzLjY1OHYtNy45NDZoLTEzLjU0MWwtNy45NDcgNy45NDZ6TTIwOC4yNSAzLjk1aC0xNi45NzRsLTguMDEgNy45NDdoMjQuOTg0ek0xNjMuNjIyIDMxLjYwNWw0LjA2OS00LjA2OWgxMy43MzJ2Ny45NDdoLTE3LjgwMXoiLz48cGF0aCBmaWxsPSIjOUI5QjlCIiBkPSJNMTY2LjYxIDE5Ljc4aDguNzczbDguMDEtNy45NDZIMTY2LjYxek0xNTcuMDExIDMxLjYwNWg2LjYxMWw3Ljg4My03Ljk0N2gtMTQuNDk0ek0xOTEuMjc2IDMuOTVsLTQuMDY4IDQuMDdIMTYxLjI3Vi4wNzJoMzAuMDA2ek0yMC44NCAzMC4yMDZIOC4zNzhsLTIuMTYyIDUuMzRILjc1TDEyLjI1NyA4LjU5Mmg0Ljc2OEwyOC41MyAzNS41NDZoLTUuNTN6bS0xLjcxNy00LjI2TDE0LjYwOSAxNC45NWwtNC41MTQgMTAuOTk4ek0xMDQuNDM3IDE4LjUwOWMxLjU4OS0yLjM1MiA1LjU5NC0yLjYwNyA3LjI0Ny0yLjYwN3Y0LjU3OGMtMi4wMzQgMC00LjA2OS4wNjMtNS4yNzcuOTUzLTEuMjA3Ljg5LTEuODQzIDIuMDk4LTEuODQzIDMuNTZ2MTAuNTUzaC00Ljk1OVYxNS45MDJoNC43Njh6TTExOS4zNzYgMTUuOTAyaC00Ljk1OHYxOS42NDRoNC45NTh6TTExOS4zNzYgNy4xM2gtNC45NTh2NS44NDhoNC45NTh6TTE0My45NzkgNy4xM3YyOC40MTZoLTQuNzY4bC0uMTI3LTIuOTg4YTguMyA4LjMgMCAwIDEtMi42NyAyLjQ4Yy0xLjA4MS41NzItMi40MTYuODktMy45NDIuODktMS4zMzUgMC0yLjYwNi0uMjU1LTMuNjg3LS43LTEuMTQ0LS41MDgtMi4xNjItMS4xNDQtMi45ODgtMi4wMzRhOS42IDkuNiAwIDAgMS0xLjk3MS0zLjE3OWMtLjUwOC0xLjIwNy0uNjk5LTIuNjA2LS42OTktNC4xMzJzLjI1NC0yLjkyNC42OTktNC4xOTZjLjUwOS0xLjI3MSAxLjE0NS0yLjM1MiAxLjk3MS0zLjI0MnMxLjg0NC0xLjU4OSAyLjk4OC0yLjA5OCAyLjM1Mi0uNzYzIDMuNjg3LS43NjNjMS41MjYgMCAyLjc5Ny4yNTUgMy44NzguODI3czEuOTcxIDEuMzM1IDIuNjcgMi40MTZWNy4xOTNoNC45NTl6bS0xMC40MjYgMjQuNTM4YzEuNjUzIDAgMi45MjQtLjU3MiAzLjk0MS0xLjY1M3MxLjUyNi0yLjU0MyAxLjUyNi00LjMyMy0uNTA5LTMuMTc4LTEuNTI2LTQuMzIyYy0xLjAxNy0xLjA4MS0yLjI4OC0xLjY1My0zLjk0MS0xLjY1My0xLjU5IDAtMi45MjUuNTcyLTMuODc4IDEuNjUzLTEuMDE3IDEuMDgtMS41MjYgMi41NDMtMS41MjYgNC4zMjIgMCAxLjc4LjUwOSAzLjE4IDEuNTI2IDQuMjYgMS4wMTcgMS4xNDQgMi4yODggMS43MTYgMy44NzggMS43MTZNNTcuMjAyIDIwLjM1M0g0NC45MzN2NC4yNTloNi45OTNjLS4xOSAyLjE2MS0xLjAxNyAzLjgxNC0yLjQxNiA1LjE1LTEuMzk4IDEuMjctMy4xNzggMS45MDYtNS40NjcgMS45MDYtMS4yNzEgMC0yLjQ4LS4yNTQtMy40OTYtLjY5OWE3IDcgMCAwIDEtMi43MzQtMS45N2MtLjc2My0uODI3LTEuMzM1LTEuODQ0LTEuNzgtMy4wNTJzLS42MzYtMi40OC0uNjM2LTMuOTQyLjE5LTIuNzMzLjYzNi0zLjk0MWMuMzgxLTEuMjA4IDEuMDE3LTIuMTYyIDEuNzgtMy4wNTIuNzYzLS44MjYgMS42NTMtMS40NjIgMi43MzMtMS45N2E5LjEgOS4xIDAgMCAxIDMuNTYtLjdxNC4wMDUgMCA2LjEwMyAxLjkwN2wzLjMwNi0zLjMwNWMtMi40OC0xLjkwNy01LjY1OC0yLjkyNS05LjQwOS0yLjkyNS0yLjA5NyAwLTQuMDA0LjMxOC01LjcyMSAxLjAxOC0xLjcxNi42OTktMy4xNzkgMS41ODktNC4zODYgMi43OTdBMTIuMSAxMi4xIDAgMCAwIDMxLjIgMTYuMjJjLS42MzUgMS43MTctLjk1MyAzLjYyNC0uOTUzIDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1NyAxLjAxNyAyLjAzNSAwIDMuODc4LS4zMTggNS41MzEtMS4wMTcgMS42NTMtLjcgMy4wNTItMS41OSA0LjE5Ni0yLjc5N3ExLjcxNi0xLjgxMiAyLjY3LTQuMzg3Yy42MzYtMS43MTYuOTU0LTMuNjIzLjk1NC01LjY1OHYtLjgyNmMtLjE5MS0uMTI3LS4yNTUtLjQ0NS0uMjU1LS43TTk1Ljk4MiAyMC4zNTNoLTEyLjI3djQuMjU5aDYuOTkzYy0uMTkgMi4xNjEtMS4wMTcgMy44MTQtMi40MTYgNS4xNS0xLjM5OCAxLjI3LTMuMTc4IDEuOTA2LTUuNDY3IDEuOTA2LTEuMjcxIDAtMi40OC0uMjU0LTMuNDk2LS42OTlhNyA3IDAgMCAxLTIuNzM0LTEuOTdjLS43NjMtLjgyNy0xLjMzNS0xLjg0NC0xLjc4LTMuMDUycy0uNjM2LTIuNDgtLjYzNi0zLjk0Mi4xOS0yLjczMy42MzYtMy45NDFjLjM4MS0xLjIwOCAxLjAxNy0yLjE2MiAxLjc4LTMuMDUyLjc2My0uODI2IDEuNjUzLTEuNDYyIDIuNzM0LTEuOTdhOS4xIDkuMSAwIDAgMSAzLjU2LS43cTQuMDA1IDAgNi4xMDMgMS45MDdsMy4zMDUtMy4zMDVjLTIuNDc5LTEuOTA3LTUuNjU4LTIuOTI1LTkuNDA4LTIuOTI1LTIuMDk4IDAtNC4wMDUuMzE4LTUuNzIyIDEuMDE4LTEuNzE2LjY5OS0zLjE3OCAxLjU4OS00LjM4NiAyLjc5N2ExMi4xIDEyLjEgMCAwIDAtMi43OTcgNC4zODZjLS42MzYgMS43MTctLjk1NCAzLjYyNC0uOTU0IDUuNjU4cy4zMTggMy45NDIgMS4wMTcgNS42NThjLjcgMS43MTcgMS41OSAzLjE3OSAyLjc5NyA0LjM4N2ExMi4xIDEyLjEgMCAwIDAgNC4zODcgMi43OTdjMS43MTYuNyAzLjYyMyAxLjAxNyA1LjY1OCAxLjAxNyAyLjAzNCAwIDMuODc4LS4zMTggNS41My0xLjAxNyAxLjY1My0uNyAzLjA1Mi0xLjU5IDQuMTk2LTIuNzk3cTEuNzE4LTEuODEyIDIuNjctNC4zODdjLjYzNi0xLjcxNi45NTQtMy42MjMuOTU0LTUuNjU4di0uODI2Yy0uMTktLjEyNy0uMjU1LS40NDUtLjI1NS0uNyIvPjwvc3ZnPg==");background-repeat:no-repeat;background-size:170px 40px;content:"";display:block;height:40px;width:170px}}:where(.ag-ltr) .ag-watermark{right:25px}:where(.ag-rtl) .ag-watermark{left:25px}.ag-watermark-text{font-family:Impact,sans-serif;font-size:19px;font-weight:700;opacity:.5}:where(.ag-ltr) .ag-watermark-text{padding-left:.7rem}:where(.ag-rtl) .ag-watermark-text{padding-right:.7rem}'
), YF = {
  tag: "div",
  cls: "ag-watermark",
  children: [{ tag: "div", ref: "eLicenseTextRef", cls: "ag-watermark-text" }]
}, ZF = class extends L {
  constructor() {
    super(YF), this.eLicenseTextRef = x, this.registerCSS(qF);
  }
  wireBeans(e) {
    this.licenseManager = e.licenseManager;
  }
  postConstruct() {
    const e = this.shouldDisplayWatermark();
    this.setDisplayed(e), e && (this.eLicenseTextRef.textContent = this.licenseManager.getWatermarkMessage(), window.setTimeout(() => this.addCss("ag-opacity-zero"), 0), window.setTimeout(() => this.setDisplayed(!1), 5e3));
  }
  shouldDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
}, QF = {
  selector: "AG-WATERMARK",
  component: ZF
}, XF = class extends S {
  constructor() {
    super(...arguments), this.beanName = "licenseManager";
  }
  postConstruct() {
    this.validateLicense();
  }
  validateLicense() {
    this.licenseManager = new _o(pe(this.beans)), this.licenseManager.validateLicense();
  }
  static getLicenseDetails(e) {
    return new _o(null).getLicenseDetails(e);
  }
  getWatermarkSelector() {
    return QF;
  }
  isDisplayWatermark() {
    return this.licenseManager.isDisplayWatermark();
  }
  getWatermarkMessage() {
    return this.licenseManager.getWatermarkMessage();
  }
  static setLicenseKey(e) {
    _o.setLicenseKey(e);
  }
  static setChartsLicenseManager(e) {
    _o.setChartsLicenseManager(e);
  }
}, ce = "33.3.2", Ie = {
  moduleName: "EnterpriseCore",
  version: ce,
  beans: [XF],
  icons: {
    // accordion open (filter tool panel group, charts group)
    accordionOpen: "tree-open",
    // accordion closed (filter tool panel group, charts group)
    accordionClosed: "tree-closed",
    // accordion indeterminate - shown when some children are expanded and
    //     others are collapsed (filter tool panel group, charts group)
    accordionIndeterminate: "tree-indeterminate",
    // dialog title bar
    close: "cross",
    // X (remove) on column 'pill' after adding it to a drop zone list
    cancel: "cancel",
    // button in chart regular size window title bar (click to maximise)
    maximize: "maximize",
    // button in chart maximised window title bar (click to make regular size)
    minimize: "minimize",
    // drag handle used to pick up draggable columns
    columnDrag: "grip"
  },
  dependsOn: []
}, JF = (
  /*css*/
  ".ag-panel{background-color:var(--ag-panel-background-color);display:flex;flex-direction:column;overflow:hidden;position:relative}.ag-dialog{border:var(--ag-dialog-border);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dialog-shadow);position:absolute}.ag-panel-title-bar{align-items:center;background-color:var(--ag-panel-title-bar-background-color);border-bottom:var(--ag-panel-title-bar-border);color:var(--ag-panel-title-bar-text-color);cursor:default;display:flex;flex:none;font-weight:var(--ag-panel-title-bar-font-weight);height:var(--ag-header-height);padding:var(--ag-spacing) var(--ag-cell-horizontal-padding)}.ag-panel-title-bar-button{color:var(--ag-panel-title-bar-icon-color);cursor:pointer}:where(.ag-ltr) .ag-panel-title-bar-button{margin-left:calc(var(--ag-spacing)*2);margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-panel-title-bar-button{margin-left:var(--ag-spacing);margin-right:calc(var(--ag-spacing)*2)}.ag-panel-title-bar-title{flex:1 1 auto}.ag-panel-title-bar-buttons{display:flex}.ag-panel-content-wrapper{display:flex;flex:1 1 auto;overflow:hidden;position:relative}:where(.ag-dragging-fill-handle) .ag-dialog,:where(.ag-dragging-range-handle) .ag-dialog{opacity:.7;pointer-events:none}"
);
function eP(e) {
  const t = e.cssIdentifier || "default";
  return {
    tag: "div",
    cls: `ag-panel ag-${t}-panel`,
    attrs: { tabindex: "-1" },
    children: [
      {
        tag: "div",
        ref: "eTitleBar",
        cls: `ag-panel-title-bar ag-${t}-panel-title-bar ag-unselectable`,
        children: [
          {
            tag: "span",
            ref: "eTitle",
            cls: `ag-panel-title-bar-title ag-${t}-panel-title-bar-title`
          },
          {
            tag: "div",
            ref: "eTitleBarButtons",
            cls: `ag-panel-title-bar-buttons ag-${t}-panel-title-bar-buttons`
          }
        ]
      },
      {
        tag: "div",
        ref: "eContentWrapper",
        cls: `ag-panel-content-wrapper ag-${t}-panel-content-wrapper`
      }
    ]
  };
}
var tP = class extends L {
  constructor(e) {
    super(eP(e)), this.config = e, this.closable = !0, this.eContentWrapper = x, this.eTitleBar = x, this.eTitleBarButtons = x, this.eTitle = x, this.registerCSS(JF);
  }
  postConstruct() {
    const {
      component: e,
      closable: t,
      hideTitleBar: s,
      title: i,
      minWidth: o = 250,
      width: n,
      minHeight: r = 250,
      height: a,
      centered: l,
      popup: d,
      x: c,
      y: u
    } = this.config;
    this.positionableFeature = new Un(this.getGui(), {
      minWidth: o,
      width: n,
      minHeight: r,
      height: a,
      centered: l,
      x: c,
      y: u,
      popup: d,
      calculateTopBuffer: () => this.positionableFeature.getHeight() - this.getBodyHeight()
    }), this.createManagedBean(this.positionableFeature);
    const h = this.getGui();
    e && this.setBodyComponent(e), s ? G(this.eTitleBar, !1) : (i && this.setTitle(i), this.setClosable(t ?? this.closable)), this.addManagedElementListeners(this.eTitleBar, {
      mousedown: (g) => {
        if (h.contains(g.relatedTarget) || h.contains(te(this.beans)) || this.eTitleBarButtons.contains(g.target)) {
          g.preventDefault();
          return;
        }
        const p = this.eContentWrapper.querySelector(
          "button, [href], input, select, textarea, [tabindex]"
        );
        p && p.focus();
      }
    }), !(d && this.positionableFeature.isPositioned()) && (this.renderComponent && this.renderComponent(), this.positionableFeature.initialisePosition(), this.eContentWrapper.style.height = "0");
  }
  renderComponent() {
    const e = this.getGui();
    e.focus(), this.close = () => {
      e.parentElement.removeChild(e), this.destroy();
    };
  }
  getHeight() {
    return this.positionableFeature.getHeight();
  }
  setHeight(e) {
    this.positionableFeature.setHeight(e);
  }
  getWidth() {
    return this.positionableFeature.getWidth();
  }
  setWidth(e) {
    this.positionableFeature.setWidth(e);
  }
  setClosable(e) {
    if (e !== this.closable && (this.closable = e), e) {
      const t = this.closeButtonComp = new L({ tag: "div", cls: "ag-button" });
      this.createBean(t);
      const s = t.getGui(), i = k("close", this.beans);
      i.classList.add("ag-panel-title-bar-button-icon"), s.appendChild(i), this.addTitleBarButton(t), t.addManagedElementListeners(s, { click: this.onBtClose.bind(this) });
    } else if (this.closeButtonComp) {
      const t = this.closeButtonComp.getGui();
      t.parentElement.removeChild(t), this.closeButtonComp = this.destroyBean(this.closeButtonComp);
    }
  }
  setBodyComponent(e) {
    e.setParentComponent(this), this.eContentWrapper.appendChild(e.getGui());
  }
  addTitleBarButton(e, t) {
    const s = this.eTitleBarButtons, i = s.children, o = i.length;
    t == null && (t = o), t = Math.max(0, Math.min(t, o)), e.addCss("ag-panel-title-bar-button");
    const n = e.getGui();
    t === 0 ? s.insertAdjacentElement("afterbegin", n) : t === o ? s.insertAdjacentElement("beforeend", n) : i[t - 1].insertAdjacentElement("afterend", n), e.setParentComponent(this);
  }
  getBodyHeight() {
    return Gn(this.eContentWrapper);
  }
  getBodyWidth() {
    return io(this.eContentWrapper);
  }
  setTitle(e) {
    this.eTitle.innerText = e;
  }
  // called when user hits the 'x' in the top right
  onBtClose() {
    this.close();
  }
  destroy() {
    this.closeButtonComp && (this.closeButtonComp = this.destroyBean(this.closeButtonComp));
    const e = this.getGui();
    e && He(e) && this.close(), super.destroy();
  }
}, sP = class extends tP {
  constructor(e) {
    super({ ...e, popup: !0 }), this.isMaximizable = !1, this.isMaximized = !1, this.maximizeListeners = [], this.resizeListenerDestroy = null, this.lastPosition = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc;
  }
  postConstruct() {
    var r;
    const e = this.getGui(), { movable: t, resizable: s, maximizable: i, modal: o, postProcessPopupParams: n } = this.config;
    if (this.addCss("ag-dialog"), super.postConstruct(), n) {
      const { type: a, eventSource: l, column: d, mouseEvent: c, rowNode: u } = n;
      (r = this.popupSvc) == null || r.callPostProcessPopup(a, e, l, c, d, u);
    }
    if (this.tabGuardFeature = this.createManagedBean(new xh(this)), this.tabGuardFeature.initialiseTabGuard({
      isFocusableContainer: !0,
      onFocusIn: () => {
        var a;
        (a = this.popupSvc) == null || a.bringPopupToFront(e);
      },
      onTabKeyDown: (a) => {
        if (o)
          return;
        const l = a.shiftKey, d = Be(this.beans, e, !1, l);
        (!d || this.tabGuardFeature.getTabGuardCtrl().isTabGuard(d)) && Tt(this.beans, l) && a.preventDefault();
      }
    }), t && this.setMovable(t), i && this.setMaximizable(i), s && this.setResizable(s), !this.config.modal) {
      const a = this.beans.ctrlsSvc.get("gridCtrl");
      a.addFocusableContainer(this), this.addDestroyFunc(() => a.removeFocusableContainer(this));
    }
  }
  setAllowFocus(e) {
    this.tabGuardFeature.getTabGuardCtrl().setAllowFocus(e);
  }
  renderComponent() {
    var a;
    const e = this.getGui(), { alwaysOnTop: t, modal: s, title: i, afterGuiAttached: o } = this.config, n = this.getLocaleTextFunc(), r = (a = this.popupSvc) == null ? void 0 : a.addPopup({
      modal: s,
      eChild: e,
      closeOnEsc: !0,
      closedCallback: this.onClosed.bind(this),
      alwaysOnTop: t,
      ariaLabel: i || n("ariaLabelDialog", "Dialog"),
      afterGuiAttached: o
    });
    r && (this.close = r.hideFunc);
  }
  onClosed(e) {
    var t, s;
    this.destroy(), (s = (t = this.config).closedCallback) == null || s.call(t, e);
  }
  toggleMaximize() {
    const e = this.positionableFeature.getPosition();
    if (this.isMaximized) {
      const { x: t, y: s, width: i, height: o } = this.lastPosition;
      this.setWidth(i), this.setHeight(o), this.positionableFeature.offsetElement(t, s);
    } else
      this.lastPosition.width = this.getWidth(), this.lastPosition.height = this.getHeight(), this.lastPosition.x = e.x, this.lastPosition.y = e.y, this.positionableFeature.offsetElement(0, 0), this.setHeight("100%"), this.setWidth("100%");
    this.isMaximized = !this.isMaximized, this.refreshMaximizeIcon();
  }
  refreshMaximizeIcon() {
    G(this.maximizeIcon, !this.isMaximized), G(this.minimizeIcon, this.isMaximized);
  }
  clearMaximizebleListeners() {
    this.maximizeListeners.length && (this.maximizeListeners.forEach((e) => e()), this.maximizeListeners.length = 0), this.resizeListenerDestroy && (this.resizeListenerDestroy(), this.resizeListenerDestroy = null);
  }
  destroy() {
    this.maximizeButtonComp = this.destroyBean(this.maximizeButtonComp), this.clearMaximizebleListeners(), super.destroy();
  }
  setResizable(e) {
    this.positionableFeature.setResizable(e);
  }
  setMovable(e) {
    this.positionableFeature.setMovable(e, this.eTitleBar);
  }
  setMaximizable(e) {
    if (!e) {
      this.clearMaximizebleListeners(), this.maximizeButtonComp && (this.destroyBean(this.maximizeButtonComp), this.maximizeButtonComp = this.maximizeIcon = this.minimizeIcon = void 0);
      return;
    }
    const t = this.eTitleBar;
    if (!t || e === this.isMaximizable)
      return;
    const s = this.buildMaximizeAndMinimizeElements();
    this.refreshMaximizeIcon(), s.addManagedElementListeners(s.getGui(), {
      click: this.toggleMaximize.bind(this)
    }), this.addTitleBarButton(s, 0), this.maximizeListeners.push(
      ...this.addManagedElementListeners(t, {
        dblclick: this.toggleMaximize.bind(this)
      })
    ), [this.resizeListenerDestroy] = this.addManagedListeners(this.positionableFeature, {
      resize: () => {
        this.isMaximized = !1, this.refreshMaximizeIcon();
      }
    });
  }
  buildMaximizeAndMinimizeElements() {
    const e = this.maximizeButtonComp = this.createBean(
      new L({ tag: "div", cls: "ag-dialog-button" })
    ), t = e.getGui();
    return this.maximizeIcon = k("maximize", this.beans), t.appendChild(this.maximizeIcon), this.maximizeIcon.classList.add("ag-panel-title-bar-button-icon"), this.minimizeIcon = k("minimize", this.beans), t.appendChild(this.minimizeIcon), this.minimizeIcon.classList.add("ag-panel-title-bar-button-icon"), e;
  }
};
function iP(e) {
  return {
    tag: "div",
    cls: `ag-virtual-list-viewport ag-${e}-virtual-list-viewport`,
    role: "presentation",
    children: [
      {
        tag: "div",
        ref: "eContainer",
        cls: `ag-virtual-list-container ag-${e}-virtual-list-container`
      }
    ]
  };
}
var dg = class extends Ti {
  constructor(e) {
    super(iP((e == null ? void 0 : e.cssIdentifier) || "default")), this.renderedRows = /* @__PURE__ */ new Map(), this.rowHeight = 20, this.pageSize = -1, this.isScrolling = !1, this.isHeightFromTheme = !0, this.eContainer = x, this.awaitStableCallbacks = [];
    const { cssIdentifier: t = "default", ariaRole: s = "listbox", listName: i, moveItemCallback: o } = e || {};
    this.cssIdentifier = t, this.ariaRole = s, this.listName = i, this.moveItemCallback = o;
  }
  wireBeans(e) {
    this.environment = e.environment;
  }
  postConstruct() {
    this.addScrollListener(), this.rowHeight = this.getItemHeight(), this.addResizeObserver(), this.initialiseTabGuard({
      onFocusIn: (e) => this.onFocusIn(e),
      onFocusOut: (e) => this.onFocusOut(e),
      focusInnerElement: (e) => this.focusInnerElement(e),
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    }), this.refreshAriaProperties(), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanged.bind(this) });
  }
  onGridStylesChanged(e) {
    e.listItemHeightChanged && (this.rowHeight = this.getItemHeight(), this.refresh());
  }
  refreshAriaProperties() {
    var i;
    const t = this.getLocaleTextFunc()("ariaDefaultListName", this.listName || "List"), s = this.eContainer;
    Ne(s, ((i = this.model) == null ? void 0 : i.getRowCount()) > 0 ? this.ariaRole : "presentation"), Ee(s, t);
  }
  addResizeObserver() {
    const e = () => Ct(this.beans, () => this.drawVirtualRows()), t = fs(this.beans, this.getGui(), e);
    this.addDestroyFunc(t);
  }
  focusInnerElement(e) {
    return this.focusRow(e ? this.model.getRowCount() - 1 : 0), !0;
  }
  onFocusIn(e) {
    const t = e.target;
    t.classList.contains("ag-virtual-list-item") && (this.lastFocusedRowIndex = $f(t) - 1);
  }
  onFocusOut(e) {
    this.getFocusableElement().contains(e.relatedTarget) || (this.lastFocusedRowIndex = null);
  }
  handleKeyDown(e) {
    const { key: t, shiftKey: s } = e;
    switch (t) {
      case y.UP:
      case y.DOWN:
        {
          const i = t === y.UP;
          e.preventDefault(), s ? this.moveItem(i) : this.navigate(i);
        }
        break;
      case y.PAGE_HOME:
      case y.PAGE_END:
      case y.PAGE_UP:
      case y.PAGE_DOWN:
        this.navigateToPage(t) !== null && e.preventDefault();
        break;
    }
  }
  onTabKeyDown(e) {
    vt(e), this.forceFocusOutOfContainer(e.shiftKey);
  }
  getNextRow(e) {
    if (this.lastFocusedRowIndex == null)
      return;
    const t = this.lastFocusedRowIndex + (e ? -1 : 1);
    if (!(t < 0 || t >= this.model.getRowCount()))
      return t;
  }
  moveItem(e) {
    if (!this.moveItemCallback)
      return;
    const t = this.getComponentAt(this.lastFocusedRowIndex);
    t && this.moveItemCallback(t, e);
  }
  navigate(e) {
    const t = this.getNextRow(e);
    t !== void 0 && this.focusRow(t);
  }
  navigateToPage(e, t = "focused") {
    let s = !1;
    t === "focused" && (t = this.getLastFocusedRow(), s = !0);
    const i = this.model.getRowCount() - 1;
    let o = -1;
    return e === y.PAGE_HOME ? o = 0 : e === y.PAGE_END ? o = i : e === y.PAGE_DOWN ? o = Math.min(t + this.pageSize, i) : e === y.PAGE_UP && (o = Math.max(t - this.pageSize, 0)), o === -1 ? null : (s ? this.focusRow(o) : this.ensureIndexVisible(o), o);
  }
  getLastFocusedRow() {
    return this.lastFocusedRowIndex;
  }
  focusRow(e) {
    this.isScrolling || (this.isScrolling = !0, this.ensureIndexVisible(e), Ct(this.beans, () => {
      if (this.isScrolling = !1, !this.isAlive())
        return;
      const t = this.renderedRows.get(e);
      t && t.eDiv.focus();
    }));
  }
  getComponentAt(e) {
    const t = this.renderedRows.get(e);
    return t && t.rowComponent;
  }
  forEachRenderedRow(e) {
    this.renderedRows.forEach((t, s) => e(t.rowComponent, s));
  }
  getItemHeight() {
    return this.isHeightFromTheme ? this.environment.getDefaultListItemHeight() : this.rowHeight;
  }
  /**
   * Returns true if the view had to be scrolled, otherwise, false.
   */
  ensureIndexVisible(e, t = !0) {
    const s = this.model.getRowCount();
    if (typeof e != "number" || e < 0 || e >= s)
      return P(229, { index: e }), !1;
    const i = e * this.rowHeight, o = i + this.rowHeight, n = this.getGui(), r = n.scrollTop, a = n.offsetHeight, l = r + a, d = t ? 0 : this.rowHeight, c = r > i + d, u = l < o - d;
    if (c)
      return n.scrollTop = i, !0;
    if (u) {
      const h = o - a;
      return n.scrollTop = h, !0;
    }
    return !1;
  }
  setComponentCreator(e) {
    this.componentCreator = e;
  }
  setComponentUpdater(e) {
    this.componentUpdater = e;
  }
  getRowHeight() {
    return this.rowHeight;
  }
  getScrollTop() {
    return this.getGui().scrollTop;
  }
  setRowHeight(e) {
    this.isHeightFromTheme = !1, this.rowHeight = e, this.refresh();
  }
  refresh(e) {
    if (this.model == null || !this.isAlive())
      return;
    const t = this.model.getRowCount();
    this.eContainer.style.height = `${t * this.rowHeight}px`, this.refreshAriaProperties(), this.awaitStable(() => {
      this.isAlive() && (this.canSoftRefresh(e) ? this.drawVirtualRows(!0) : (this.clearVirtualRows(), this.drawVirtualRows()));
    });
  }
  awaitStable(e) {
    if (this.awaitStableCallbacks.push(e), this.awaitStableCallbacks.length > 1)
      return;
    const t = this.model.getRowCount();
    Zc(
      () => this.eContainer.clientHeight >= t * this.rowHeight,
      () => {
        if (!this.isAlive())
          return;
        const s = this.awaitStableCallbacks;
        this.awaitStableCallbacks = [], s.forEach((i) => i());
      }
    );
  }
  canSoftRefresh(e) {
    return !!(e && this.renderedRows.size && typeof this.model.areRowsEqual == "function" && this.componentUpdater);
  }
  clearVirtualRows() {
    this.renderedRows.forEach((e, t) => this.removeRow(t));
  }
  drawVirtualRows(e) {
    if (!this.isAlive() || !this.model)
      return;
    const t = this.getGui(), s = t.scrollTop, i = s + t.offsetHeight;
    if (s === i)
      this.clearVirtualRows();
    else {
      const o = Math.floor(s / this.rowHeight), n = Math.floor(i / this.rowHeight);
      this.pageSize = Math.floor((i - s) / this.rowHeight), this.ensureRowsRendered(o, n, e);
    }
  }
  ensureRowsRendered(e, t, s) {
    this.renderedRows.forEach((i, o) => {
      (o < e || o > t) && o !== this.lastFocusedRowIndex && this.removeRow(o);
    }), s && this.refreshRows();
    for (let i = e; i <= t; i++)
      this.renderedRows.has(i) || i < this.model.getRowCount() && this.insertRow(i);
  }
  insertRow(e) {
    const t = this.model.getRow(e), s = this.ariaRole === "tree" ? "treeitem" : "option", i = _({
      tag: "div",
      cls: `ag-virtual-list-item ag-${this.cssIdentifier}-virtual-list-item`,
      role: s,
      attrs: { tabindex: "-1" }
    });
    Pa(i, this.model.getRowCount()), Da(i, e + 1), i.style.height = `${this.rowHeight}px`, i.style.top = `${this.rowHeight * e}px`;
    const o = this.componentCreator(t, i);
    o.addGuiEventListener("focusin", () => this.lastFocusedRowIndex = e), i.appendChild(o.getGui()), this.renderedRows.has(e - 1) ? this.renderedRows.get(e - 1).eDiv.insertAdjacentElement("afterend", i) : this.renderedRows.has(e + 1) ? this.renderedRows.get(e + 1).eDiv.insertAdjacentElement("beforebegin", i) : this.eContainer.appendChild(i), this.renderedRows.set(e, { rowComponent: o, eDiv: i, value: t });
  }
  removeRow(e) {
    const t = this.renderedRows.get(e);
    this.eContainer.removeChild(t.eDiv), this.destroyBean(t.rowComponent), this.renderedRows.delete(e);
  }
  refreshRows() {
    const e = this.model.getRowCount();
    this.renderedRows.forEach((t, s) => {
      var i, o;
      if (s >= e)
        this.removeRow(s);
      else {
        const n = this.model.getRow(s);
        (o = (i = this.model).areRowsEqual) != null && o.call(i, t.value, n) ? this.componentUpdater(n, t.rowComponent) : this.removeRow(s);
      }
    });
  }
  addScrollListener() {
    this.addGuiEventListener("scroll", () => this.drawVirtualRows(), { passive: !0 });
  }
  setModel(e) {
    this.model = e;
  }
  getAriaElement() {
    return this.eContainer;
  }
  destroy() {
    this.isAlive() && (this.clearVirtualRows(), this.awaitStableCallbacks.length = 0, super.destroy());
  }
}, Pr = "ag-list-item-hovered", oP = class extends S {
  constructor(e, t, s) {
    super(), this.comp = e, this.virtualList = t, this.params = s, this.currentDragValue = null, this.lastHoveredListItem = null;
  }
  wireBeans(e) {
    this.dragAndDrop = e.dragAndDrop;
  }
  postConstruct() {
    this.addManagedListeners(this.params.eventSource, {
      [this.params.listItemDragStartEvent]: this.listItemDragStart.bind(this),
      [this.params.listItemDragEndEvent]: this.listItemDragEnd.bind(this)
    }), this.createDropTarget(), this.createAutoScrollService();
  }
  listItemDragStart(e) {
    this.currentDragValue = this.params.getCurrentDragValue(e), this.moveBlocked = this.params.isMoveBlocked(this.currentDragValue);
  }
  listItemDragEnd() {
    window.setTimeout(() => {
      this.currentDragValue = null, this.moveBlocked = !1;
    }, 10);
  }
  createDropTarget() {
    var t;
    const e = {
      isInterestedIn: (s) => s === this.params.dragSourceType,
      getIconName: () => this.moveBlocked ? "pinned" : "move",
      getContainer: () => this.comp.getGui(),
      onDragging: (s) => this.onDragging(s),
      onDragStop: () => this.onDragStop(),
      onDragLeave: () => this.onDragLeave(),
      onDragCancel: () => this.onDragCancel()
    };
    (t = this.dragAndDrop) == null || t.addDropTarget(e);
  }
  createAutoScrollService() {
    const e = this.virtualList.getGui();
    this.autoScrollService = new bv({
      scrollContainer: e,
      scrollAxis: "y",
      getVerticalPosition: () => e.scrollTop,
      setVerticalPosition: (t) => e.scrollTop = t
    });
  }
  onDragging(e) {
    if (!this.currentDragValue || this.moveBlocked)
      return;
    const t = this.getListDragItem(e), s = this.virtualList.getComponentAt(t.rowIndex);
    if (!s)
      return;
    const i = s.getGui().parentElement;
    this.lastHoveredListItem && this.lastHoveredListItem.rowIndex === t.rowIndex && this.lastHoveredListItem.position === t.position || (this.autoScrollService.check(e.event), this.clearHoveredItems(), this.lastHoveredListItem = t, Bl(i, Pr), Bl(i, `ag-item-highlight-${t.position}`));
  }
  getListDragItem(e) {
    const t = this.virtualList.getGui(), s = parseFloat(window.getComputedStyle(t).paddingTop), i = this.virtualList.getRowHeight(), o = this.virtualList.getScrollTop(), n = Math.max(0, (e.y - s + o) / i), r = this.params.getNumRows(this.comp) - 1, a = Math.min(r, n) | 0;
    return {
      rowIndex: a,
      position: Math.round(n) > n || n > r ? "bottom" : "top",
      component: this.virtualList.getComponentAt(a)
    };
  }
  onDragStop() {
    this.moveBlocked || (this.params.moveItem(this.currentDragValue, this.lastHoveredListItem), this.clearDragProperties());
  }
  onDragCancel() {
    this.clearDragProperties();
  }
  onDragLeave() {
    this.clearDragProperties();
  }
  clearDragProperties() {
    this.clearHoveredItems(), this.autoScrollService.ensureCleared();
  }
  clearHoveredItems() {
    this.virtualList.getGui().querySelectorAll(`.${Pr}`).forEach((t) => {
      [Pr, "ag-item-highlight-top", "ag-item-highlight-bottom"].forEach((s) => {
        t.classList.remove(s);
      });
    }), this.lastHoveredListItem = null;
  }
};
function nP(e) {
  var t;
  return ((t = e.sideBar) == null ? void 0 : t.comp.isDisplayed()) ?? !1;
}
function rP(e, t) {
  var s;
  (s = e.sideBar) == null || s.comp.setDisplayed(t);
}
function aP(e, t) {
  var s;
  (s = e.sideBar) == null || s.comp.setSideBarPosition(t);
}
function lP(e, t) {
  var s;
  (s = e.sideBar) == null || s.comp.openToolPanel(t, "api");
}
function dP(e) {
  var t;
  (t = e.sideBar) == null || t.comp.close("api");
}
function cP(e) {
  var t;
  return ((t = e.sideBar) == null ? void 0 : t.comp.openedItem()) ?? null;
}
function uP(e) {
  var t;
  (t = e.sideBar) == null || t.comp.refresh();
}
function hP(e) {
  var t;
  return ((t = e.sideBar) == null ? void 0 : t.comp.isToolPanelShowing()) ?? !1;
}
function gP(e, t) {
  var i;
  const s = (i = e.sideBar) == null ? void 0 : i.comp.getToolPanelInstance(t);
  return vn(s);
}
function pP(e) {
  var t;
  return (t = e.sideBar) == null ? void 0 : t.comp.getDef();
}
function oa(e, t) {
  if (!t)
    return null;
  const s = cs(e), i = s.indexOf(t);
  if (i === -1)
    return null;
  let o = -1;
  for (let n = i - 1; n >= 0; n--)
    if (s[n].classList.contains(Qo.TAB_GUARD_TOP)) {
      o = n;
      break;
    }
  return o <= 0 ? null : s[o - 1];
}
function cg(e, t) {
  if (!t)
    return !1;
  const s = e.querySelectorAll(`.${oh}`);
  if (!s.length)
    return !1;
  for (let i = 0; i < s.length; i++)
    if (s[i].contains(t))
      return !0;
  return !1;
}
var fP = (
  /*css*/
  '.ag-tool-panel-wrapper{display:flex;overflow:hidden auto;-webkit-user-select:none;-moz-user-select:none;user-select:none;width:var(--ag-side-bar-panel-width)}.ag-select-agg-func-item{align-items:center;display:flex;flex:1 1 auto;flex-flow:row nowrap;height:100%;overflow:hidden;position:relative;text-overflow:ellipsis;white-space:nowrap;>*{flex:none}}.ag-tool-panel-horizontal-resize{cursor:ew-resize;height:100%;position:absolute;top:0;width:5px;z-index:1}.ag-side-bar{background-color:var(--ag-side-bar-background-color);display:flex;flex-direction:row-reverse;position:relative}:where(.ag-ltr) :where(.ag-side-bar-left) .ag-tool-panel-horizontal-resize{right:-3px}:where(.ag-rtl) :where(.ag-side-bar-left) .ag-tool-panel-horizontal-resize{left:-3px}:where(.ag-ltr) :where(.ag-side-bar-right) .ag-tool-panel-horizontal-resize{left:-3px}:where(.ag-rtl) :where(.ag-side-bar-right) .ag-tool-panel-horizontal-resize{right:-3px}.ag-side-bar-left{flex-direction:row;order:-1}.ag-side-buttons{background-color:var(--ag-side-button-bar-background-color);padding-top:var(--ag-side-button-bar-top-padding);position:relative}.ag-side-button{background-color:var(--ag-side-button-background-color);border-bottom:var(--ag-side-button-border);border-top:var(--ag-side-button-border);color:var(--ag-side-button-text-color);margin-top:-1px;position:relative;&:before{background-color:transparent;bottom:0;content:"";display:block;position:absolute;top:0;transition:background-color var(--ag-side-button-selected-underline-transition-duration);width:var(--ag-side-button-selected-underline-width)}&:hover{background-color:var(--ag-side-button-hover-background-color);color:var(--ag-side-button-hover-text-color)}&.ag-selected{background-color:var(--ag-side-button-selected-background-color);border-bottom:var(--ag-side-button-selected-border);border-top:var(--ag-side-button-selected-border);color:var(--ag-side-button-selected-text-color);&:before{background-color:var(--ag-side-button-selected-underline-color)}}}:where(.ag-ltr) .ag-side-button{&:before{left:0}}:where(.ag-rtl) .ag-side-button{&:before{right:0}}.ag-side-button-button{align-items:center;display:flex;flex-direction:column;gap:var(--ag-spacing);position:relative;white-space:nowrap;width:100%;&:focus{box-shadow:none}}:where(.ag-ltr) .ag-side-button-button{padding:var(--ag-side-button-vertical-padding) var(--ag-side-button-right-padding) var(--ag-side-button-vertical-padding) var(--ag-side-button-left-padding)}:where(.ag-rtl) .ag-side-button-button{padding:var(--ag-side-button-vertical-padding) var(--ag-side-button-left-padding) var(--ag-side-button-vertical-padding) var(--ag-side-button-right-padding)}.ag-side-button-button:focus-visible{box-shadow:inset var(--ag-focus-shadow)}.ag-side-button-label{writing-mode:vertical-lr}@media (resolution <= 1.5x){.ag-side-button-label{font-family:"Segoe UI",var(--ag-font-family)}:where(.ag-ltr) .ag-side-button-label{transform:rotate(.05deg)}:where(.ag-rtl) .ag-side-button-label{transform:rotate(-.05deg)}}:where(.ag-ltr) .ag-side-bar-left,:where(.ag-rtl) .ag-side-bar-right{border-right:var(--ag-side-panel-border);:where(.ag-tool-panel-wrapper){border-left:var(--ag-side-panel-border)}}:where(.ag-ltr) .ag-side-bar-right,:where(.ag-rtl) .ag-side-bar-left{border-left:var(--ag-side-panel-border);:where(.ag-tool-panel-wrapper){border-right:var(--ag-side-panel-border)}}'
), mP = {
  tag: "div",
  cls: "ag-side-button",
  role: "presentation",
  children: [
    {
      tag: "button",
      ref: "eToggleButton",
      cls: "ag-button ag-side-button-button",
      role: "tab",
      attrs: { type: "button", tabindex: "-1", "aria-expanded": "false" },
      children: [
        {
          tag: "div",
          ref: "eIconWrapper",
          cls: "ag-side-button-icon-wrapper",
          attrs: { "aria-hidden": "true" }
        },
        { tag: "span", ref: "eLabel", cls: "ag-side-button-label" }
      ]
    }
  ]
}, CP = class extends L {
  constructor(e) {
    super(), this.toolPanelDef = e, this.eToggleButton = x, this.eIconWrapper = x, this.eLabel = x;
  }
  getToolPanelId() {
    return this.toolPanelDef.id;
  }
  postConstruct() {
    this.setTemplate(mP, []), this.setLabel(), this.setIcon(), this.addManagedElementListeners(this.eToggleButton, { click: this.onButtonPressed.bind(this) }), this.eToggleButton.setAttribute("id", `ag-${this.getCompId()}-button`);
  }
  setLabel() {
    const e = this.toolPanelDef, t = this.getLocaleTextFunc()(e.labelKey, e.labelDefault);
    this.eLabel.textContent = t;
  }
  setIcon() {
    this.eIconWrapper.insertAdjacentElement(
      "afterbegin",
      k(this.toolPanelDef.iconKey, this.beans)
    );
  }
  onButtonPressed() {
    this.dispatchLocalEvent({ type: "toggleButtonClicked" });
  }
  setSelected(e) {
    this.toggleCss("ag-selected", e), ot(this.eToggleButton, e);
  }
}, vP = { tag: "div", cls: "ag-side-buttons", role: "tablist" }, wP = class extends L {
  constructor() {
    super(vP), this.buttonComps = [];
  }
  postConstruct() {
    this.addManagedElementListeners(this.getFocusableElement(), { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    if (!(e.key !== y.TAB || !e.shiftKey)) {
      if (Tt(this.beans, !0)) {
        e.preventDefault();
        return;
      }
      vt(e);
    }
  }
  setActiveButton(e) {
    this.buttonComps.forEach((t) => {
      t.setSelected(e === t.getToolPanelId());
    });
  }
  addButtonComp(e) {
    const t = this.createBean(new CP(e));
    return this.buttonComps.push(t), this.appendChild(t), t.addEventListener("toggleButtonClicked", () => {
      this.dispatchLocalEvent({
        type: "sideBarButtonClicked",
        toolPanelId: e.id
      });
    }), t;
  }
  clearButtons() {
    this.buttonComps = this.destroyBeans(this.buttonComps), de(this.getGui()), super.destroy();
  }
  destroy() {
    this.clearButtons(), super.destroy();
  }
}, bP = {
  selector: "AG-SIDE-BAR-BUTTONS",
  component: wP
}, ug = {
  id: "columns",
  labelDefault: "Columns",
  labelKey: "columns",
  iconKey: "columnsToolPanel",
  toolPanel: "agColumnsToolPanel"
}, hg = {
  id: "filters",
  labelDefault: "Filters",
  labelKey: "filters",
  iconKey: "filtersToolPanel",
  toolPanel: "agFiltersToolPanel"
}, En = {
  columns: ug,
  filters: hg
};
function na(e) {
  if (!e)
    return;
  if (e === !0)
    return {
      toolPanels: [ug, hg],
      defaultToolPanel: "columns"
    };
  if (typeof e == "string")
    return na([e]);
  if (Array.isArray(e)) {
    const s = [];
    return e.forEach((i) => {
      const o = En[i];
      if (!o) {
        P(215, { key: i, defaultByKey: En });
        return;
      }
      s.push(o);
    }), s.length === 0 ? void 0 : {
      toolPanels: s,
      defaultToolPanel: s[0].id
    };
  }
  return {
    toolPanels: yP(e.toolPanels),
    defaultToolPanel: e.defaultToolPanel,
    hiddenByDefault: e.hiddenByDefault,
    position: e.position
  };
}
function yP(e) {
  const t = [];
  return e && e.forEach((s) => {
    let i = null;
    if (typeof s == "string") {
      const o = En[s];
      if (!o) {
        P(215, { key: s, defaultByKey: En });
        return;
      }
      i = o;
    } else
      i = s;
    t.push(i);
  }), t;
}
var SP = class extends L {
  constructor() {
    super({ tag: "div", cls: "ag-tool-panel-horizontal-resize" }), this.minWidth = 100, this.maxWidth = null;
  }
  postConstruct() {
    const e = this.beans.horizontalResizeSvc.addResizeBar({
      eResizeBar: this.getGui(),
      dragStartPixels: 1,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this),
      onResizeEnd: this.onResizeEnd.bind(this)
    });
    this.addDestroyFunc(e), this.inverted = this.gos.get("enableRtl");
  }
  dispatchResizeEvent(e, t, s) {
    this.eventSvc.dispatchEvent({
      type: "toolPanelSizeChanged",
      width: s,
      started: e,
      ended: t
    });
  }
  onResizeStart() {
    this.startingWidth = this.elementToResize.offsetWidth, this.dispatchResizeEvent(!0, !1, this.startingWidth);
  }
  onResizeEnd(e) {
    return this.onResizing(e, !0);
  }
  onResizing(e, t = !1) {
    const s = this.inverted ? -1 : 1;
    let i = Math.max(this.minWidth, Math.floor(this.startingWidth - e * s));
    this.maxWidth != null && (i = Math.min(this.maxWidth, i)), this.elementToResize.style.width = `${i}px`, this.dispatchResizeEvent(!1, t, i);
  }
};
function xP(e, t, s) {
  return e.getCompDetails(t, RP, void 0, s, !0);
}
var RP = {
  name: "toolPanel",
  optionalMethods: ["refresh", "getState"]
}, FP = {
  tag: "div",
  cls: "ag-tool-panel-wrapper",
  role: "tabpanel"
}, PP = class extends L {
  constructor() {
    super(FP);
  }
  postConstruct() {
    const e = this.getGui(), t = this.resizeBar = this.createManagedBean(new SP());
    e.setAttribute("id", `ag-${this.getCompId()}`), t.elementToResize = e, this.appendChild(t);
  }
  getToolPanelId() {
    return this.toolPanelId;
  }
  setToolPanelDef(e, t) {
    const { id: s, minWidth: i, maxWidth: o, width: n } = e;
    this.toolPanelId = s, this.width = n;
    const r = xP(this.beans.userCompFactory, e, t);
    if (r == null)
      return !1;
    const a = r.newAgStackInstance();
    this.params = r.params, a.then(this.setToolPanelComponent.bind(this));
    const l = this.resizeBar;
    return i != null && (l.minWidth = i), o != null && (l.maxWidth = o), !0;
  }
  setToolPanelComponent(e) {
    this.toolPanelCompInstance = e, this.appendChild(e.getGui()), this.addDestroyFunc(() => {
      this.destroyBean(e);
    });
    const t = this.width;
    t && (this.getGui().style.width = `${t}px`);
  }
  getToolPanelInstance() {
    return this.toolPanelCompInstance;
  }
  setResizerSizerSide(e) {
    const t = this.gos.get("enableRtl"), s = e === "left", i = t ? s : !s;
    this.resizeBar.inverted = i;
  }
  refresh() {
    var e;
    (e = this.toolPanelCompInstance) == null || e.refresh(this.params);
  }
}, DP = {
  tag: "div",
  cls: "ag-side-bar ag-unselectable",
  children: [
    {
      tag: "ag-side-bar-buttons",
      ref: "sideBarButtons"
    }
  ]
}, MP = class extends L {
  constructor() {
    super(DP, [bP]), this.sideBarButtons = x, this.toolPanelWrappers = [], this.registerCSS(fP);
  }
  postConstruct() {
    this.sideBarButtons.addEventListener("sideBarButtonClicked", this.onToolPanelButtonClicked.bind(this));
    const { beans: e, gos: t } = this, { sideBar: s } = t.get("initialState") ?? {};
    this.setSideBarDef({
      sideBarDef: na(t.get("sideBar")),
      sideBarState: s
    }), this.addManagedPropertyListener("sideBar", this.onSideBarUpdated.bind(this)), e.sideBar.comp = this;
    const i = this.getFocusableElement();
    this.createManagedBean(
      new ms(i, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), iv(e, this, i);
  }
  onTabKeyDown(e) {
    if (e.defaultPrevented)
      return;
    const { beans: t, sideBarButtons: s } = this, i = this.getGui(), o = s.getGui(), n = te(t), r = i.querySelector(".ag-tool-panel-wrapper:not(.ag-hidden)"), a = e.target, l = e.shiftKey;
    if (!r)
      return Tt(t, l) ? (e.preventDefault(), !0) : Tt(t, l, !0);
    if (o.contains(n)) {
      Ve(r, l) && e.preventDefault();
      return;
    }
    if (!l)
      return;
    let d = null;
    r.contains(n) ? d = Be(t, r, void 0, !0) : cg(r, a) && l && (d = oa(r, a)), d || (d = o.querySelector(".ag-selected button")), d && d !== e.target && (e.preventDefault(), d.focus());
  }
  handleKeyDown(e) {
    const t = te(this.beans), s = this.sideBarButtons;
    if (!s.getGui().contains(t))
      return;
    const i = s.getGui(), o = Array.prototype.slice.call(i.querySelectorAll(".ag-side-button")), n = o.findIndex((l) => l.contains(t));
    let r = null;
    switch (e.key) {
      case y.LEFT:
      case y.UP:
        r = Math.max(0, n - 1);
        break;
      case y.RIGHT:
      case y.DOWN:
        r = Math.min(n + 1, o.length - 1);
        break;
    }
    if (r === null)
      return;
    const a = o[r].querySelector("button");
    a && (a.focus(), e.preventDefault());
  }
  onToolPanelButtonClicked(e) {
    const t = e.toolPanelId;
    this.openedItem() === t ? this.openToolPanel(void 0, "sideBarButtonClicked") : this.openToolPanel(t, "sideBarButtonClicked");
  }
  clearDownUi() {
    this.sideBarButtons.clearButtons(), this.destroyToolPanelWrappers();
  }
  setSideBarDef({
    sideBarDef: e,
    sideBarState: t,
    existingToolPanelWrappers: s
  }) {
    if (this.setDisplayed(!1), this.sideBar = e, e && e.toolPanels) {
      const i = e.toolPanels;
      if (this.createToolPanelsAndSideButtons(i, t, s), !this.toolPanelWrappers.length)
        return;
      const o = t ? t.visible : !e.hiddenByDefault;
      if (this.setDisplayed(o), this.setSideBarPosition(t ? t.position : e.position), o)
        if (t) {
          const { openToolPanel: n } = t;
          n && this.openToolPanel(n, "sideBarInitializing");
        } else
          this.openToolPanel(e.defaultToolPanel, "sideBarInitializing");
    }
  }
  getDef() {
    return this.sideBar;
  }
  setSideBarPosition(e) {
    e || (e = "right"), this.position = e;
    const t = e === "left", s = t ? "right" : "left";
    return this.toggleCss("ag-side-bar-left", t), this.toggleCss("ag-side-bar-right", !t), this.toolPanelWrappers.forEach((i) => {
      i.setResizerSizerSide(s);
    }), this.dispatchSideBarUpdated(), this;
  }
  setDisplayed(e, t) {
    super.setDisplayed(e, t), this.dispatchSideBarUpdated();
  }
  getState() {
    const e = {};
    return this.toolPanelWrappers.forEach((t) => {
      var s, i;
      e[t.getToolPanelId()] = (i = (s = t.getToolPanelInstance()) == null ? void 0 : s.getState) == null ? void 0 : i.call(s);
    }), {
      visible: this.isDisplayed(),
      position: this.position,
      openToolPanel: this.openedItem(),
      toolPanels: e
    };
  }
  createToolPanelsAndSideButtons(e, t, s) {
    var i;
    for (const o of e)
      this.createToolPanelAndSideButton(
        o,
        (i = t == null ? void 0 : t.toolPanels) == null ? void 0 : i[o.id],
        s == null ? void 0 : s[o.id]
      );
  }
  validateDef(e) {
    var t;
    return e.id == null ? (P(212), !1) : e.toolPanel === "agFiltersToolPanel" && (t = this.beans.filterManager) != null && t.isAdvFilterEnabled() ? (P(213), !1) : !0;
  }
  createToolPanelAndSideButton(e, t, s) {
    if (!this.validateDef(e))
      return;
    let i;
    if (s)
      i = s;
    else if (i = this.createBean(new PP()), !i.setToolPanelDef(
      e,
      N(this.gos, {
        initialState: t,
        onStateUpdated: () => this.dispatchSideBarUpdated()
      })
    ))
      return;
    i.setDisplayed(!1);
    const o = i.getGui();
    this.appendChild(o), this.toolPanelWrappers.push(i);
    const n = this.sideBarButtons.addButtonComp(e);
    Nc(n.eToggleButton, o);
  }
  refresh() {
    this.toolPanelWrappers.forEach((e) => e.refresh());
  }
  openToolPanel(e, t = "api") {
    const s = this.openedItem();
    if (s === e)
      return;
    this.toolPanelWrappers.forEach((n) => {
      const r = e === n.getToolPanelId();
      n.setDisplayed(r);
    });
    const i = this.openedItem();
    s !== i && (this.sideBarButtons.setActiveButton(e), this.raiseToolPanelVisibleEvent(e, s ?? void 0, t));
  }
  getToolPanelInstance(e) {
    const t = this.toolPanelWrappers.filter((s) => s.getToolPanelId() === e)[0];
    if (!t) {
      P(214, { key: e });
      return;
    }
    return t.getToolPanelInstance();
  }
  raiseToolPanelVisibleEvent(e, t, s) {
    const i = !!e && !!t, o = this.eventSvc;
    t && o.dispatchEvent({
      type: "toolPanelVisibleChanged",
      source: s,
      key: t,
      visible: !1,
      switchingToolPanel: i
    }), e && o.dispatchEvent({
      type: "toolPanelVisibleChanged",
      source: s,
      key: e,
      visible: !0,
      switchingToolPanel: i
    });
  }
  close(e = "api") {
    this.openToolPanel(void 0, e);
  }
  isToolPanelShowing() {
    return !!this.openedItem();
  }
  openedItem() {
    let e = null;
    return this.toolPanelWrappers.forEach((t) => {
      t.isDisplayed() && (e = t.getToolPanelId());
    }), e;
  }
  onSideBarUpdated() {
    var s;
    const e = na(this.gos.get("sideBar")), t = {};
    e && this.sideBar && ((s = e.toolPanels) == null || s.forEach((i) => {
      var d, c;
      const { id: o } = i;
      if (!o)
        return;
      const n = (d = this.sideBar.toolPanels) == null ? void 0 : d.find(
        (u) => u.id === o
      );
      if (!n || i.toolPanel !== n.toolPanel)
        return;
      const r = this.toolPanelWrappers.find((u) => u.getToolPanelId() === o);
      if (!r)
        return;
      const a = N(this.gos, {
        ...i.toolPanelParams ?? {},
        onStateUpdated: () => this.dispatchSideBarUpdated()
      });
      ((c = r.getToolPanelInstance()) == null ? void 0 : c.refresh(a)) === !0 && (this.toolPanelWrappers = this.toolPanelWrappers.filter((u) => u !== r), De(r.getGui()), t[o] = r);
    })), this.clearDownUi(), this.setSideBarDef({ sideBarDef: e, existingToolPanelWrappers: t });
  }
  dispatchSideBarUpdated() {
    this.eventSvc.dispatchEvent({ type: "sideBarUpdated" });
  }
  destroyToolPanelWrappers() {
    this.toolPanelWrappers.forEach((e) => {
      De(e.getGui()), this.destroyBean(e);
    }), this.toolPanelWrappers.length = 0;
  }
  destroy() {
    this.destroyToolPanelWrappers(), super.destroy();
  }
}, EP = {
  selector: "AG-SIDE-BAR",
  component: MP
}, AP = class extends S {
  constructor() {
    super(...arguments), this.beanName = "sideBar";
  }
  getSelector() {
    return EP;
  }
}, hl = {
  moduleName: "SideBar",
  version: ce,
  beans: [AP],
  apiFunctions: {
    isSideBarVisible: nP,
    setSideBarVisible: rP,
    setSideBarPosition: aP,
    openToolPanel: lP,
    closeToolPanel: dP,
    getOpenedToolPanel: cP,
    refreshToolPanel: uP,
    isToolPanelShowing: hP,
    getToolPanelInstance: gP,
    getSideBar: pP
  },
  dependsOn: [Ie, Dh]
}, IP = { tag: "div" }, gg = class extends L {
  constructor() {
    super(IP);
  }
  init(e) {
    this.params = e, this.cssClassPrefix = this.params.cssClassPrefix ?? "ag-menu-option", this.addAriaAttributes(), this.addIcon(), this.addName(), this.addShortcut(), this.addSubMenu();
  }
  configureDefaults() {
    return !0;
  }
  addAriaAttributes() {
    const { checked: e, subMenu: t } = this.params, s = this.getGui();
    e && nm(s, e), t && ot(s, !1);
  }
  addIcon() {
    if (this.params.isCompact)
      return;
    const e = _({
      tag: "span",
      ref: "eIcon",
      cls: `${this.getClassName("part")} ${this.getClassName("icon")}`,
      role: "presentation"
    }), { checked: t, icon: s } = this.params;
    t ? e.appendChild(k("check", this.beans)) : s && (On(s) ? e.appendChild(s) : typeof s == "string" ? e.innerHTML = s : P(227)), this.getGui().appendChild(e);
  }
  addName() {
    const e = _({
      tag: "span",
      ref: "eName",
      cls: `${this.getClassName("part")} ${this.getClassName("text")}`,
      children: this.params.name || ""
    });
    this.getGui().appendChild(e);
  }
  addShortcut() {
    if (this.params.isCompact)
      return;
    const e = _({
      tag: "span",
      ref: "eShortcut",
      cls: `${this.getClassName("part")} ${this.getClassName("shortcut")}`,
      children: this.params.shortcut || ""
    });
    this.getGui().appendChild(e);
  }
  addSubMenu() {
    const e = _({
      tag: "span",
      ref: "ePopupPointer",
      cls: `${this.getClassName("part")} ${this.getClassName("popup-pointer")}`
    }), t = this.getGui();
    if (this.params.subMenu) {
      const s = this.gos.get("enableRtl") ? "subMenuOpenRtl" : "subMenuOpen";
      e.appendChild(k(s, this.beans));
    }
    t.appendChild(e);
  }
  getClassName(e) {
    return `${this.cssClassPrefix}-${e}`;
  }
}, TP = (
  /*css*/
  '.ag-menu-list{cursor:default;display:table;padding:var(--ag-spacing) 0;width:100%}.ag-menu-option,.ag-menu-separator{display:table-row}.ag-menu-option-part,.ag-menu-separator-part{display:table-cell;vertical-align:middle}.ag-menu-option{cursor:pointer;font-weight:500}:where(.ag-ltr) :where(.ag-menu-option-popup-pointer) .ag-icon{text-align:right}:where(.ag-rtl) :where(.ag-menu-option-popup-pointer) .ag-icon{text-align:left}.ag-menu-option-text{white-space:nowrap}.ag-menu-option-custom{display:contents}.ag-compact-menu-option{display:flex;flex-wrap:nowrap;width:100%}.ag-compact-menu-option-text{flex:1 1 auto;white-space:nowrap}.ag-menu-separator{height:calc(var(--ag-spacing)*2 + 1px)}.ag-menu-separator-part:after{border-top:1px solid var(--ag-menu-separator-color);content:"";display:block}.ag-compact-menu-option-active,.ag-menu-option-active{background-color:var(--ag-row-hover-color)}.ag-compact-menu-option-part,.ag-menu-option-part{line-height:var(--ag-icon-size);padding:calc(var(--ag-spacing) + 2px) 0}.ag-compact-menu-option-disabled,.ag-menu-option-disabled{cursor:not-allowed;opacity:.5}.ag-compact-menu-option-icon,.ag-menu-option-icon{width:var(--ag-icon-size)}:where(.ag-ltr) .ag-compact-menu-option-icon,:where(.ag-ltr) .ag-menu-option-icon{padding-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-compact-menu-option-icon,:where(.ag-rtl) .ag-menu-option-icon{padding-right:calc(var(--ag-spacing)*2)}.ag-compact-menu-option-text,.ag-menu-option-text{padding-left:calc(var(--ag-spacing)*2);padding-right:calc(var(--ag-spacing)*2)}:where(.ag-ltr) .ag-compact-menu-option-shortcut,:where(.ag-ltr) .ag-menu-option-shortcut{padding-right:var(--ag-spacing)}:where(.ag-rtl) .ag-compact-menu-option-shortcut,:where(.ag-rtl) .ag-menu-option-shortcut{padding-left:var(--ag-spacing)}:where(.ag-ltr) .ag-compact-menu-option-popup-pointer,:where(.ag-ltr) .ag-menu-option-popup-pointer{padding-right:var(--ag-spacing)}:where(.ag-rtl) .ag-compact-menu-option-popup-pointer,:where(.ag-rtl) .ag-menu-option-popup-pointer{padding-left:var(--ag-spacing)}.ag-menu-column-select-wrapper{height:265px;overflow:auto;:where(.ag-column-select){height:100%}}.ag-menu:where(.ag-tabs){min-width:290px}.ag-context-menu-loading-icon{pointer-events:none;position:absolute}'
), gl = {
  moduleName: "MenuItem",
  version: ce,
  userComponents: {
    agMenuItem: gg
  },
  icons: {
    // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
    check: "tick",
    // icon for sub menu item
    subMenuOpen: "small-right",
    // version of subMenuOpen used in RTL mode
    subMenuOpenRtl: "small-left"
  },
  css: [TP]
}, LP = (
  /*css*/
  ".ag-column-select{display:flex;flex:3 1 0px;flex-direction:column;overflow:hidden;position:relative}.ag-column-select-header{align-items:center;display:flex;flex:none;gap:var(--ag-widget-horizontal-spacing);height:var(--ag-header-height);padding-left:var(--ag-widget-container-horizontal-padding);padding-right:var(--ag-widget-container-horizontal-padding);position:relative}.ag-column-select-column,.ag-column-select-column-group{align-items:center;display:flex;gap:var(--ag-widget-horizontal-spacing);height:100%;position:relative;&:where(:not(:last-child)){margin-bottom:var(--ag-widget-vertical-spacing)}}:where(.ag-ltr) .ag-column-select-column,:where(.ag-ltr) .ag-column-select-column-group{padding-left:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}:where(.ag-rtl) .ag-column-select-column,:where(.ag-rtl) .ag-column-select-column-group{padding-right:calc(var(--ag-indentation-level)*var(--ag-column-select-indent-size))}.ag-column-select-header-icon{border-radius:var(--ag-border-radius);cursor:pointer;height:var(--ag-icon-size);position:relative;width:var(--ag-icon-size);&:focus-visible{box-shadow:var(--ag-focus-shadow)}}.ag-column-select-header-filter-wrapper{flex:1 1 auto}.ag-column-select-header-filter{width:100%}.ag-column-select-list{flex:1 1 0px;overflow:hidden}:where(.ag-ltr) .ag-column-select-add-group-indent{margin-left:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}:where(.ag-rtl) .ag-column-select-add-group-indent{margin-right:calc(var(--ag-icon-size) + var(--ag-spacing)*1.5)}.ag-column-select-column-group-readonly,.ag-column-select-column-readonly{opacity:.5;pointer-events:none}.ag-column-select-virtual-list-viewport{padding:calc(var(--ag-widget-container-vertical-padding)*.5) 0}.ag-column-select-virtual-list-item{padding:0 var(--ag-widget-container-horizontal-padding)}.ag-column-select-column-label{flex:1 1 auto;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-select-checkbox{display:flex}"
), kP = 300, GP = {
  tag: "div",
  cls: "ag-column-select-header",
  role: "presentation",
  children: [
    { tag: "div", ref: "eExpand", cls: "ag-column-select-header-icon" },
    { tag: "ag-checkbox", ref: "eSelect", cls: "ag-column-select-header-checkbox" },
    { tag: "ag-input-text-field", ref: "eFilterTextField", cls: "ag-column-select-header-filter-wrapper" }
  ]
}, OP = class extends L {
  constructor() {
    super(GP, [Ii, yh]), this.eExpand = x, this.eSelect = x, this.eFilterTextField = x;
  }
  postConstruct() {
    this.createExpandIcons(), this.addManagedListeners(this.eExpand, {
      click: this.onExpandClicked.bind(this),
      keydown: (t) => {
        t.key === y.SPACE && (t.preventDefault(), this.onExpandClicked());
      }
    }), this.addManagedElementListeners(this.eSelect.getInputElement(), { click: this.onSelectClicked.bind(this) }), this.addManagedPropertyListener("functionsReadOnly", () => this.onFunctionsReadOnlyPropChanged()), this.eFilterTextField.setAutoComplete(!1).onValueChange(() => this.onFilterTextChanged()), this.addManagedEventListeners({ newColumnsLoaded: this.showOrHideOptions.bind(this) });
    const e = this.getLocaleTextFunc();
    this.eSelect.setInputAriaLabel(e("ariaColumnSelectAll", "Toggle All Columns Visibility")), this.eFilterTextField.setInputAriaLabel(e("ariaFilterColumnsInput", "Filter Columns Input")), this.activateTabIndex([this.eExpand]);
  }
  onFunctionsReadOnlyPropChanged() {
    const e = this.gos.get("functionsReadOnly");
    this.eSelect.setReadOnly(e), this.eSelect.toggleCss("ag-column-select-column-readonly", e);
  }
  init(e) {
    this.params = e;
    const t = this.gos.get("functionsReadOnly");
    this.eSelect.setReadOnly(t), this.eSelect.toggleCss("ag-column-select-column-readonly", t), this.beans.colModel.ready && this.showOrHideOptions();
  }
  createExpandIcons() {
    const e = this.beans;
    this.eExpand.appendChild(this.eExpandChecked = k("columnSelectOpen", e)), this.eExpand.appendChild(this.eExpandUnchecked = k("columnSelectClosed", e)), this.eExpand.appendChild(this.eExpandIndeterminate = k("columnSelectIndeterminate", e)), this.setExpandState(
      0
      /* EXPANDED */
    );
  }
  // we only show expand / collapse if we are showing columns
  showOrHideOptions() {
    var r;
    const e = this.params, t = !e.suppressColumnFilter, s = !e.suppressColumnSelectAll, i = !e.suppressColumnExpandAll, o = !!((r = this.beans.colModel.colDefCols) != null && r.treeDepth), n = this.getLocaleTextFunc();
    this.eFilterTextField.setInputPlaceholder(n("searchOoo", "Search...")), G(this.eFilterTextField.getGui(), t), G(this.eSelect.getGui(), s), G(this.eExpand, i && o);
  }
  onFilterTextChanged() {
    this.onFilterTextChangedDebounced || (this.onFilterTextChangedDebounced = ct(
      this,
      () => {
        const e = this.eFilterTextField.getValue();
        this.dispatchLocalEvent({ type: "filterChanged", filterText: e });
      },
      kP
    )), this.onFilterTextChangedDebounced();
  }
  onSelectClicked() {
    this.dispatchLocalEvent({ type: this.selectState ? "unselectAll" : "selectAll" });
  }
  onExpandClicked() {
    this.dispatchLocalEvent({ type: this.expandState === 0 ? "collapseAll" : "expandAll" });
  }
  setExpandState(e) {
    this.expandState = e, G(
      this.eExpandChecked,
      e === 0
      /* EXPANDED */
    ), G(
      this.eExpandUnchecked,
      e === 1
      /* COLLAPSED */
    ), G(
      this.eExpandIndeterminate,
      e === 2
      /* INDETERMINATE */
    );
  }
  setSelectionState(e) {
    this.selectState = e, this.eSelect.setValue(this.selectState);
  }
}, BP = {
  selector: "AG-PRIMARY-COLS-HEADER",
  component: OP
};
function fi(e) {
  return !!e && typeof e.children < "u";
}
function es(e) {
  return fi(e) ? e.groupId : e.colId;
}
function pg(e, t, s) {
  const i = (r, a) => {
    const d = r.children.map(es).includes(es(a)), c = Z(r.children), u = c && es(c) !== es(a);
    return d && u;
  };
  if (!fi(e))
    return !0;
  const o = e, n = s;
  if (i(o, n) || o.groupId === t && !o.children.map(es).includes(es(n)))
    return o.children.push(n), !0;
  for (let r = o.children.length - 1; r >= 0 && !pg(o.children[r], t, s); r--)
    ;
  return !1;
}
function NP(e) {
  const t = (o, n) => fi(o) && fi(n) && es(o) === es(n), s = (o, n) => {
    if (!fi(n))
      return o;
    const r = o, a = n;
    return a.children && a.groupId && pg(r, a.groupId, a.children[0]) || a.children.forEach((l) => s(r, l)), r;
  }, i = [];
  for (let o = 1; o <= e.length; o++) {
    const n = e[o - 1], r = e[o];
    t(n, r) ? e[o] = s(n, r) : i.push(n);
  }
  return i;
}
function fg(e, t) {
  const s = [], i = (n, r) => {
    if (fi(n)) {
      const a = n, l = typeof a.groupId < "u" ? a.groupId : a.headerName, d = new ui(a, l, !1, r), c = [];
      return a.children.forEach((u) => {
        const h = i(u, r + 1);
        h && c.push(h);
      }), d.setChildren(c), d;
    } else {
      const a = n, l = a.colId ? a.colId : a.field, d = e.getColDefCol(l);
      return d || s.push(a), d;
    }
  }, o = [];
  return t.forEach((n) => {
    const r = i(n, 0);
    r && o.push(r);
  }), s.length > 0 && P(217, { invalidColIds: s }), o;
}
function mg(e, t) {
  const s = HP(e), i = NP(s);
  t(i);
}
function HP(e) {
  const t = (o, n) => {
    let r;
    if (ae(o))
      if (o.isPadding())
        r = n;
      else {
        const l = Object.assign({}, o.getColGroupDef());
        l.groupId = o.getGroupId(), l.children = [n], r = l;
      }
    else {
      const l = Object.assign({}, o.getColDef());
      l.colId = o.getColId(), r = l;
    }
    const a = o.getOriginalParent();
    return a ? t(a, r) : r;
  };
  return e.getCols().filter((o) => {
    const n = o.getColDef();
    return o.isPrimary() && !n.showRowGroup;
  }).map((o) => t(o, o.getColDef()));
}
var Ed = class {
  constructor(e, t, s, i = !1, o) {
    this.displayName = e, this.depth = s, this.group = i, this.localEventService = new hs(), i ? (this.columnGroup = t, this._expanded = o, this.children = []) : this.column = t;
  }
  get expanded() {
    return !!this._expanded;
  }
  set expanded(e) {
    e !== this._expanded && (this._expanded = e, this.localEventService.dispatchEvent({ type: "expandedChanged" }));
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
};
function Cg(e, t, s, i) {
  const o = VP(t);
  vg(e, o, s, i);
}
function vg(e, t, s, i) {
  e.colModel.isPivotMode() ? WP(e, t, s, i) : _P(e, t, s, i);
}
function VP(e) {
  const t = [], s = (i) => {
    i.forEach((o) => {
      o.passesFilter && (o.group ? s(o.children) : t.push(o.column));
    });
  };
  return s(e), t;
}
function _P(e, t, s, i) {
  const o = [];
  t.forEach((n) => {
    n.getColDef().lockVisible || n.isVisible() != s && o.push({
      colId: n.getId(),
      hide: !s
    });
  }), o.length > 0 && Wt(e, { state: o }, i);
}
function WP(e, t, s, i) {
  zP(e, t, s, i);
}
function zP(e, t, s, i) {
  const o = [], a = s ? (l) => {
    var d;
    if (!l.isAnyFunctionActive())
      if (l.isAllowValue()) {
        const c = typeof l.getAggFunc() == "string" ? l.getAggFunc() : (d = e.aggFuncSvc) == null ? void 0 : d.getDefaultAggFunc(l);
        o.push({
          colId: l.getId(),
          aggFunc: c
        });
      } else l.isAllowRowGroup() ? o.push({
        colId: l.getId(),
        rowGroup: !0
      }) : l.isAllowPivot() && o.push({
        colId: l.getId(),
        pivot: !0
      });
  } : (l) => {
    (l.isPivotActive() || l.isRowGroupActive() || l.isValueActive()) && o.push({
      colId: l.getId(),
      pivot: !1,
      rowGroup: !1,
      aggFunc: null
    });
  };
  t.forEach(a), o.length > 0 && Wt(e, { state: o }, i);
}
function wg(e, t) {
  const { columns: s, visibleState: i, pivotState: o, eventType: n } = t, r = s.map((a) => {
    const l = a.getColId();
    if (e.colModel.isPivotMode()) {
      const d = o == null ? void 0 : o[l];
      return {
        colId: l,
        pivot: d == null ? void 0 : d.pivot,
        rowGroup: d == null ? void 0 : d.rowGroup,
        aggFunc: d == null ? void 0 : d.aggFunc
      };
    } else
      return {
        colId: l,
        hide: !(i != null && i[l])
      };
  });
  Wt(e, { state: r }, n);
}
function bg(e) {
  return {
    pivot: e.isPivotActive(),
    rowGroup: e.isRowGroupActive(),
    aggFunc: e.isValueActive() ? e.getAggFunc() : void 0
  };
}
function Ad(e, t, s, i) {
  const o = t.getCol(s);
  e.groupData || (e.groupData = {});
  const n = o.getColId(), r = e.groupData[n];
  r !== i && (e.groupData[n] = i, e.dispatchCellChangedEvent(o, i, r));
}
function UP(e, t, s) {
  var i;
  e.group !== s && (e.group, e.group = s, e.updateHasChildren(), (i = t.selectionSvc) == null || i.updateRowSelectable(e), e.dispatchRowEvent("groupChanged"));
}
function po(e, t) {
  const { gos: s, rowGroupColsSvc: i } = t;
  if (!i || !e)
    return !1;
  const o = s.get("groupLockGroupColumns");
  if (!e.isRowGroupActive() || o === 0)
    return !1;
  if (o === -1)
    return !0;
  const n = i.columns.findIndex((r) => r.getColId() === e.getColId());
  return o > n;
}
var jP = class extends Ti {
  constructor(e) {
    super(), this.setTemplateFromElement(e.getGui(), void 0, void 0, !0);
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => this.handleKeyDown(e)
    });
  }
  handleKeyDown(e) {
    e.key === y.ESCAPE && this.closePanel();
  }
  onTabKeyDown(e) {
    e.defaultPrevented || (this.closePanel(), e.preventDefault());
  }
  closePanel() {
    const e = this.parentComponent;
    e.closeSubMenu(), setTimeout(() => e.getGui().focus(), 0);
  }
};
function $P(e, t, s) {
  return e.getCompDetails(t, KP, "agMenuItem", s, !0);
}
var KP = {
  name: "menuItem",
  optionalMethods: ["setActive", "select", "setExpanded", "configureDefaults"]
}, qP = { tag: "div", cls: "ag-menu", role: "presentation" }, ra = class extends S {
  constructor() {
    super(...arguments), this.ACTIVATION_DELAY = 80, this.isActive = !1, this.subMenuIsOpen = !1, this.subMenuIsOpening = !1, this.suppressRootStyles = !0, this.suppressAria = !0, this.suppressFocus = !0;
  }
  wireBeans(e) {
    this.popupSvc = e.popupSvc, this.userCompFactory = e.userCompFactory, this.registry = e.registry;
  }
  init(e) {
    var a;
    const { menuItemDef: t, isAnotherSubMenuOpen: s, level: i, childComponent: o, contextParams: n } = e;
    this.params = e.menuItemDef, this.level = i, this.isAnotherSubMenuOpen = s, this.childComponent = o, this.contextParams = n, this.cssClassPrefix = ((a = this.params.menuItemParams) == null ? void 0 : a.cssClassPrefix) ?? "ag-menu-option";
    const r = $P(
      this.userCompFactory,
      this.params,
      N(this.gos, {
        ...t,
        level: i,
        isAnotherSubMenuOpen: s,
        openSubMenu: (l) => this.openSubMenu(l),
        closeSubMenu: () => this.closeSubMenu(),
        closeMenu: (l) => this.closeMenu(l),
        updateTooltip: (l, d) => this.refreshTooltip(l, d),
        onItemActivated: () => this.onItemActivated()
      })
    );
    return (r == null ? void 0 : r.newAgStackInstance().then((l) => {
      var c;
      this.menuItemComp = l;
      const d = (c = l.configureDefaults) == null ? void 0 : c.call(l);
      d && this.configureDefaults(d === !0 ? void 0 : d);
    })) ?? q.resolve();
  }
  addListeners(e, t) {
    t != null && t.suppressClick || this.addManagedElementListeners(e, { click: (s) => this.onItemSelected(s) }), t != null && t.suppressKeyboardSelect || this.addManagedElementListeners(e, {
      keydown: (s) => {
        (s.key === y.ENTER || s.key === y.SPACE) && (s.preventDefault(), this.onItemSelected(s));
      }
    }), t != null && t.suppressMouseDown || this.addManagedElementListeners(e, {
      mousedown: (s) => {
        s.stopPropagation(), s.preventDefault();
      }
    }), t != null && t.suppressMouseOver || this.addManagedElementListeners(e, {
      mouseenter: () => this.onMouseEnter(),
      mouseleave: () => this.onMouseLeave()
    });
  }
  isDisabled() {
    return !!this.params.disabled;
  }
  openSubMenu(e = !1, t) {
    var d, c;
    if (this.closeSubMenu(), !this.params.subMenu)
      return;
    this.subMenuIsOpening = !0;
    const s = _(qP);
    this.eSubMenuGui = s;
    let i, o = () => {
      this.subMenuIsOpening = !1;
    };
    if (this.childComponent) {
      const u = this.createBean(new jP(this.childComponent));
      u.setParentComponent(this);
      const h = u.getGui(), g = "mouseenter", p = () => this.cancelDeactivate();
      h.addEventListener(g, p), i = () => {
        h.removeEventListener(g, p), this.destroyBean(u);
      }, s.appendChild(h), this.childComponent.afterGuiAttached && (o = () => {
        this.childComponent.afterGuiAttached(), this.subMenuIsOpening = !1;
      });
    } else if (this.params.subMenu) {
      const u = this.createBean(new qn(this.level + 1, this.contextParams));
      u.setParentComponent(this), u.addMenuItems(this.params.subMenu), s.appendChild(u.getGui()), this.addManagedListeners(u, { closeMenu: (h) => this.dispatchLocalEvent(h) }), u.addGuiEventListener("mouseenter", () => this.cancelDeactivate()), i = () => this.destroyBean(u), e && (o = () => {
        u.activateFirstItem(), this.subMenuIsOpening = !1;
      });
    }
    const { popupSvc: n } = this, r = () => {
      const u = this.eGui, { column: h, node: g } = this.contextParams;
      n == null || n.positionPopupForMenu({
        eventSource: u,
        ePopup: s,
        event: t instanceof MouseEvent ? t : void 0,
        column: h,
        node: g
      });
    }, a = this.getLocaleTextFunc(), l = n == null ? void 0 : n.addPopup({
      modal: !0,
      eChild: s,
      positionCallback: r,
      anchorToElement: this.eGui,
      ariaLabel: a("ariaLabelSubMenu", "SubMenu"),
      afterGuiAttached: o
    });
    this.subMenuIsOpen = !0, this.setAriaExpanded(!0), this.hideSubMenu = () => {
      var u, h;
      l && l.hideFunc(), this.subMenuIsOpen = !1, this.setAriaExpanded(!1), i(), (h = (u = this.menuItemComp).setExpanded) == null || h.call(u, !1), this.eSubMenuGui = void 0;
    }, (c = (d = this.menuItemComp).setExpanded) == null || c.call(d, !0);
  }
  setAriaExpanded(e) {
    this.suppressAria || ot(this.eGui, e);
  }
  closeSubMenu() {
    this.hideSubMenu && (this.hideSubMenu(), this.hideSubMenu = null, this.setAriaExpanded(!1));
  }
  isSubMenuOpen() {
    return this.subMenuIsOpen;
  }
  isSubMenuOpening() {
    return this.subMenuIsOpening;
  }
  activate(e, t) {
    var s, i;
    this.cancelActivate(), !(this.params.disabled && !t) && (this.isActive = !0, this.suppressRootStyles || this.eGui.classList.add(`${this.cssClassPrefix}-active`), (i = (s = this.menuItemComp).setActive) == null || i.call(s, !0), this.suppressFocus || Bn(this.beans, () => this.eGui.focus({ preventScroll: !t })), e && this.params.subMenu && window.setTimeout(() => {
      this.isAlive() && this.isActive && this.openSubMenu();
    }, 300), this.onItemActivated());
  }
  deactivate() {
    var e, t;
    this.cancelDeactivate(), this.suppressRootStyles || this.eGui.classList.remove(`${this.cssClassPrefix}-active`), (t = (e = this.menuItemComp).setActive) == null || t.call(e, !1), this.isActive = !1, this.subMenuIsOpen && this.closeSubMenu();
  }
  getGui() {
    return this.menuItemComp.getGui();
  }
  getParentComponent() {
    return this.parentComponent;
  }
  setParentComponent(e) {
    this.parentComponent = e;
  }
  getSubMenuGui() {
    return this.eSubMenuGui;
  }
  onItemSelected(e) {
    var t, s;
    (s = (t = this.menuItemComp).select) == null || s.call(t), this.params.action ? this.beans.frameworkOverrides.wrapOutgoing(
      () => this.params.action(
        N(this.gos, {
          ...this.contextParams
        })
      )
    ) : this.openSubMenu(e && e.type === "keydown", e), !(this.params.subMenu && !this.params.action || this.params.suppressCloseOnSelect) && this.closeMenu(e);
  }
  closeMenu(e) {
    const t = {
      type: "closeMenu"
    };
    e && (e instanceof MouseEvent ? t.mouseEvent = e : t.keyboardEvent = e), this.dispatchLocalEvent(t);
  }
  onItemActivated() {
    const e = {
      type: "menuItemActivated",
      menuItem: this
    };
    this.dispatchLocalEvent(e);
  }
  cancelActivate() {
    this.activateTimeoutId && (window.clearTimeout(this.activateTimeoutId), this.activateTimeoutId = 0);
  }
  cancelDeactivate() {
    this.deactivateTimeoutId && (window.clearTimeout(this.deactivateTimeoutId), this.deactivateTimeoutId = 0);
  }
  onMouseEnter() {
    this.cancelDeactivate(), this.isAnotherSubMenuOpen() ? this.activateTimeoutId = window.setTimeout(() => this.activate(!0), this.ACTIVATION_DELAY) : this.activate(!0);
  }
  onMouseLeave() {
    this.cancelActivate(), this.isSubMenuOpen() ? this.deactivateTimeoutId = window.setTimeout(() => this.deactivate(), this.ACTIVATION_DELAY) : this.deactivate();
  }
  configureDefaults(e) {
    var l, d, c;
    if (!this.menuItemComp) {
      setTimeout(() => this.configureDefaults(e));
      return;
    }
    let t = this.menuItemComp.getGui();
    const { suppressRootStyles: s, suppressTooltip: i, suppressAria: o, suppressTabIndex: n, suppressFocus: r } = e || {}, a = (d = (l = this.menuItemComp).getRootElement) == null ? void 0 : d.call(l);
    a && (s || t.classList.add("ag-menu-option-custom"), t = a), this.eGui = t, this.suppressRootStyles = !!s, this.suppressRootStyles || (t.classList.add(this.cssClassPrefix), (c = this.params.cssClasses) == null || c.forEach((u) => t.classList.add(u)), this.params.disabled && t.classList.add(`${this.cssClassPrefix}-disabled`)), i || this.refreshTooltip(this.params.tooltip), this.suppressAria = !!o, this.suppressAria || (Ne(t, "menuitem"), this.params.subMenu && rm(t, this.params.subMenuRole ?? "menu"), this.params.disabled && Qf(t, !0)), n || t.setAttribute("tabindex", "-1"), this.params.disabled || this.addListeners(t, e), this.suppressFocus = !!r;
  }
  refreshTooltip(e, t) {
    if (this.tooltip = e, this.tooltipFeature = this.destroyBean(this.tooltipFeature), !e || !this.menuItemComp)
      return;
    const s = this.registry.createDynamicBean("tooltipFeature", !1, {
      getGui: () => this.getGui(),
      getTooltipValue: () => this.tooltip,
      getLocation: () => "menu",
      shouldDisplayTooltip: t
    });
    s && (this.tooltipFeature = this.createBean(s));
  }
  destroy() {
    var e, t;
    this.tooltipFeature = this.destroyBean(this.tooltipFeature), (t = (e = this.menuItemComp) == null ? void 0 : e.destroy) == null || t.call(e), super.destroy();
  }
}, qn = class extends Ti {
  constructor(e = 0, t) {
    super({ tag: "div", cls: "ag-menu-list", role: "menu" }), this.level = e, this.menuItems = [], this.params = t ?? {
      column: null,
      node: null,
      value: null
    };
  }
  postConstruct() {
    this.initialiseTabGuard({
      onTabKeyDown: (e) => this.onTabKeyDown(e),
      handleKeyDown: (e) => Bn(this.beans, () => this.handleKeyDown(e)),
      onFocusIn: (e) => this.handleFocusIn(e),
      onFocusOut: (e) => this.handleFocusOut(e)
    });
  }
  onTabKeyDown(e) {
    var i;
    const t = this.getParentComponent();
    ((i = t == null ? void 0 : t.getGui()) == null ? void 0 : i.classList.contains("ag-focus-managed")) || e.preventDefault(), e.shiftKey && this.closeIfIsChild(e);
  }
  handleKeyDown(e) {
    switch (e.key) {
      case y.UP:
      case y.RIGHT:
      case y.DOWN:
      case y.LEFT:
        e.preventDefault(), this.handleNavKey(e.key);
        break;
      case y.ESCAPE:
        this.closeIfIsChild() && vt(e);
        break;
    }
  }
  handleFocusIn(e) {
    var s, i;
    const t = e.relatedTarget;
    !this.tabGuardFeature.getTabGuardCtrl().isTabGuard(t) && (this.getGui().contains(t) || (i = (s = this.activeMenuItem) == null ? void 0 : s.getSubMenuGui()) != null && i.contains(t)) || (this.activeMenuItem ? this.activeMenuItem.activate() : this.activateFirstItem());
  }
  handleFocusOut(e) {
    var s;
    const t = e.relatedTarget;
    !this.activeMenuItem || this.getGui().contains(t) || (s = this.activeMenuItem.getSubMenuGui()) != null && s.contains(t) || this.activeMenuItem.isSubMenuOpening() || this.activeMenuItem.deactivate();
  }
  clearActiveItem() {
    this.activeMenuItem && (this.activeMenuItem.deactivate(), this.activeMenuItem = null);
  }
  addMenuItems(e) {
    e != null && q.all(
      e.map((t) => t === "separator" ? q.resolve({ eGui: this.createSeparator() }) : typeof t == "string" ? (P(228, { menuItemOrString: t }), q.resolve({ eGui: null })) : this.addItem(t))
    ).then((t) => {
      (t ?? []).forEach((s) => {
        s != null && s.eGui && (this.appendChild(s.eGui), s.comp && this.menuItems.push(s.comp));
      });
    });
  }
  addItem(e) {
    const t = this.createManagedBean(new ra());
    return t.init({
      menuItemDef: e,
      isAnotherSubMenuOpen: () => this.menuItems.some((s) => s.isSubMenuOpen()),
      level: this.level,
      contextParams: this.params
    }).then(() => (t.setParentComponent(this), this.addManagedListeners(t, {
      closeMenu: (s) => {
        this.dispatchLocalEvent(s);
      },
      menuItemActivated: (s) => {
        this.activeMenuItem && this.activeMenuItem !== s.menuItem && this.activeMenuItem.deactivate(), this.activeMenuItem = s.menuItem;
      }
    }), {
      comp: t,
      eGui: t.getGui()
    }));
  }
  activateFirstItem() {
    const e = this.menuItems.filter((t) => !t.isDisabled())[0];
    e && e.activate();
  }
  createSeparator() {
    const e = { tag: "div", cls: "ag-menu-separator-part" };
    return _({
      tag: "div",
      cls: "ag-menu-separator",
      attrs: {
        "aria-hidden": "true"
      },
      children: [e, e, e, e]
    });
  }
  handleNavKey(e) {
    switch (e) {
      case y.UP:
      case y.DOWN: {
        const s = this.findNextItem(e === y.UP);
        s && s !== this.activeMenuItem && s.activate(!1, !0);
        return;
      }
    }
    const t = this.gos.get("enableRtl") ? y.RIGHT : y.LEFT;
    e === t ? this.closeIfIsChild() : this.openChild();
  }
  closeIfIsChild(e) {
    const t = this.getParentComponent();
    return t && t instanceof ra ? (e && e.preventDefault(), t.closeSubMenu(), t.getGui().focus(), !0) : !1;
  }
  openChild() {
    this.activeMenuItem && this.activeMenuItem.openSubMenu(!0);
  }
  findNextItem(e) {
    const t = [...this.menuItems];
    if (!t.length)
      return;
    if (!this.activeMenuItem)
      return e ? Z(t) : t[0];
    e && t.reverse();
    let s, i = !1;
    for (const o of t) {
      if (!i) {
        o === this.activeMenuItem && (i = !0);
        continue;
      }
      s = o;
      break;
    }
    return i && !s ? t[0] : s || this.activeMenuItem;
  }
  destroy() {
    this.clearActiveItem(), super.destroy();
  }
}, yg = class extends L {
  constructor(e, t, s) {
    super({ tag: "div", cls: "ag-menu" }), this.column = e, this.mouseEvent = t, this.parentEl = s, this.displayName = null;
  }
  postConstruct() {
    const {
      column: e,
      beans: { colNames: t }
    } = this;
    this.initializeProperties(e);
    let s;
    if (wt(e) ? s = t.getDisplayNameForColumn(e, "columnToolPanel") : s = t.getDisplayNameForProvidedColumnGroup(null, e, "columnToolPanel"), this.displayName = s, this.buildMenuItemMap(), this.isActive()) {
      this.mouseEvent.preventDefault();
      const i = this.getMappedMenuItems();
      if (i.length === 0)
        return;
      this.displayContextMenu(i);
    }
  }
  initializeProperties(e) {
    let t;
    ae(e) ? t = e.getLeafColumns() : t = [e], this.columns = t;
    const s = this.beans.colModel.isPivotMode();
    this.allowScrollIntoView = !s && t.some(this.isColumnValidForScrollIntoView), this.allowGrouping = t.some((i) => i.isPrimary() && i.isAllowRowGroup()), this.allowValues = t.some((i) => i.isPrimary() && i.isAllowValue()), this.allowPivoting = s && t.some((i) => i.isPrimary() && i.isAllowPivot());
  }
  buildMenuItemMap() {
    const e = this.getLocaleTextFunc(), { beans: t, displayName: s } = this, { rowGroupColsSvc: i, valueColsSvc: o, pivotColsSvc: n, colModel: r } = t, a = /* @__PURE__ */ new Map();
    this.menuItemMap = a;
    const l = r.isPivotMode();
    a.set("scrollIntoView", {
      allowedFunction: (d) => !d.isPinned() && !l && this.isColumnValidForScrollIntoView(d),
      activeFunction: () => !1,
      activateLabel: () => e("scrollColumnIntoView", `Scroll ${s} into View`, [s]),
      activateFunction: () => {
        const d = this.columns.find(this.isColumnValidForScrollIntoView);
        d && this.beans.ctrlsSvc.getScrollFeature().ensureColumnVisible(d);
      },
      deActivateFunction: () => {
      },
      addIcon: "ensureColumnVisible"
    }), a.set("rowGroup", {
      allowedFunction: (d) => d.isPrimary() && d.isAllowRowGroup() && !po(d, t),
      activeFunction: (d) => d.isRowGroupActive(),
      activateLabel: () => `${e("groupBy", "Group by")} ${s}`,
      deactivateLabel: () => `${e("ungroupBy", "Un-Group by")} ${s}`,
      activateFunction: () => i == null ? void 0 : i.setColumns(this.addColumnsToList(i.columns), "toolPanelUi"),
      deActivateFunction: () => i == null ? void 0 : i.setColumns(this.removeColumnsFromList(i.columns), "toolPanelUi"),
      addIcon: "menuAddRowGroup",
      removeIcon: "menuRemoveRowGroup"
    }), a.set("value", {
      allowedFunction: (d) => d.isPrimary() && d.isAllowValue(),
      activeFunction: (d) => d.isValueActive(),
      activateLabel: () => e("addToValues", `Add ${s} to values`, [s]),
      deactivateLabel: () => e("removeFromValues", `Remove ${s} from values`, [s]),
      activateFunction: () => o == null ? void 0 : o.setColumns(this.addColumnsToList(o.columns), "toolPanelUi"),
      deActivateFunction: () => o == null ? void 0 : o.setColumns(this.removeColumnsFromList(o.columns), "toolPanelUi"),
      addIcon: "valuePanel",
      removeIcon: "valuePanel"
    }), a.set("pivot", {
      allowedFunction: (d) => l && d.isPrimary() && d.isAllowPivot(),
      activeFunction: (d) => d.isPivotActive(),
      activateLabel: () => e("addToLabels", `Add ${s} to labels`, [s]),
      deactivateLabel: () => e("removeFromLabels", `Remove ${s} from labels`, [s]),
      activateFunction: () => n == null ? void 0 : n.setColumns(this.addColumnsToList(n.columns), "toolPanelUi"),
      deActivateFunction: () => n == null ? void 0 : n.setColumns(this.removeColumnsFromList(n.columns), "toolPanelUi"),
      addIcon: "pivotPanel",
      removeIcon: "pivotPanel"
    });
  }
  isColumnValidForScrollIntoView(e) {
    var i;
    if (!e.isVisible())
      return !1;
    const s = e.getParent();
    return s ? ((i = s.getDisplayedChildren()) == null ? void 0 : i.indexOf(e)) !== -1 : !0;
  }
  addColumnsToList(e) {
    return [...e].concat(this.columns.filter((t) => e.indexOf(t) === -1));
  }
  removeColumnsFromList(e) {
    return e.filter((t) => this.columns.indexOf(t) === -1);
  }
  displayContextMenu(e) {
    const t = this.getGui(), s = this.createBean(new qn()), i = this.getLocaleTextFunc();
    let o = () => {
    };
    t.appendChild(s.getGui()), s.addMenuItems(e), s.addManagedListeners(s, {
      closeMenu: () => {
        this.parentEl.focus(), o();
      }
    });
    const n = this.beans.popupSvc, r = n.addPopup({
      modal: !0,
      eChild: t,
      closeOnEsc: !0,
      afterGuiAttached: () => Ve(s.getGui()),
      ariaLabel: i("ariaLabelContextMenu", "Context Menu"),
      closedCallback: (a) => {
        a instanceof KeyboardEvent && this.parentEl.focus(), this.destroyBean(s);
      }
    });
    r && (o = r.hideFunc), n.positionPopupUnderMouseEvent({
      type: "columnContextMenu",
      mouseEvent: this.mouseEvent,
      ePopup: t
    });
  }
  isActive() {
    return this.allowScrollIntoView || this.allowGrouping || this.allowValues || this.allowPivoting;
  }
  getMappedMenuItems() {
    const e = [], { menuItemMap: t, columns: s, displayName: i, beans: o } = this;
    for (const n of t.values()) {
      const r = s.some((l) => n.allowedFunction(l) && !n.activeFunction(l)), a = s.some((l) => n.allowedFunction(l) && n.activeFunction(l));
      r && e.push({
        name: n.activateLabel(i),
        icon: k(n.addIcon, o, null),
        action: () => n.activateFunction()
      }), a && n.removeIcon && n.deactivateLabel && e.push({
        name: n.deactivateLabel(i),
        icon: k(n.removeIcon, o, null),
        action: () => {
          var l;
          return (l = n.deActivateFunction) == null ? void 0 : l.call(n);
        }
      });
    }
    return e;
  }
}, YP = {
  tag: "div",
  cls: "ag-column-select-column-group",
  children: [
    {
      tag: "span",
      ref: "eColumnGroupIcons",
      cls: "ag-column-group-icons",
      children: [
        { tag: "span", ref: "eGroupClosedIcon", cls: "ag-column-group-closed-icon" },
        { tag: "span", ref: "eGroupOpenedIcon", cls: "ag-column-group-opened-icon" }
      ]
    },
    { tag: "ag-checkbox", ref: "cbSelect", cls: "ag-column-select-checkbox" },
    { tag: "span", ref: "eLabel", cls: "ag-column-select-column-label" }
  ]
}, Sg = class extends L {
  constructor(e, t, s, i) {
    super(), this.modelItem = e, this.allowDragging = t, this.eventType = s, this.focusWrapper = i, this.cbSelect = x, this.eLabel = x, this.eGroupOpenedIcon = x, this.eGroupClosedIcon = x, this.eColumnGroupIcons = x, this.processingColumnStateChange = !1;
    const { columnGroup: o, depth: n, displayName: r } = e;
    this.columnGroup = o, this.columnDepth = n, this.displayName = r;
  }
  postConstruct() {
    this.setTemplate(YP, [Ii]);
    const { beans: e, cbSelect: t, eLabel: s, displayName: i, columnDepth: o, modelItem: n, focusWrapper: r, columnGroup: a } = this, { registry: l, gos: d } = e, c = k("columnDrag", e);
    this.eDragHandle = c, c.classList.add("ag-drag-handle", "ag-column-select-column-group-drag-handle");
    const u = t.getGui(), h = t.getInputElement();
    u.insertAdjacentElement("afterend", c), h.setAttribute("tabindex", "-1"), s.textContent = i ?? "", this.setupExpandContract(), this.addCss("ag-column-select-indent-" + o), this.getGui().style.setProperty("--ag-indentation-level", String(o)), this.tooltipFeature = this.createOptionalManagedBean(
      l.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getLocation: () => "columnToolPanelColumnGroup",
        shouldDisplayTooltip: sl(d, () => s)
      })
    ), this.addManagedEventListeners({ columnPivotModeChanged: this.onColumnStateChanged.bind(this) }), this.addManagedElementListeners(s, { click: this.onLabelClicked.bind(this) }), this.addManagedListeners(t, { fieldValueChanged: this.onCheckboxChanged.bind(this) }), this.addManagedListeners(n, { expandedChanged: this.onExpandChanged.bind(this) }), this.addManagedListeners(r, {
      keydown: this.handleKeyDown.bind(this),
      contextmenu: this.onContextMenu.bind(this)
    }), this.setOpenClosedIcons(), this.setupDragging(), this.onColumnStateChanged(), this.addVisibilityListenersToAllChildren(), this.refreshAriaExpanded(), this.refreshAriaLabel(), this.setupTooltip(), zu(a.getColGroupDef(), d, null, a).forEach((p) => this.toggleCss(p, !0));
  }
  getColumns() {
    return this.columnGroup.getLeafColumns();
  }
  setupTooltip() {
    const e = this.columnGroup.getColGroupDef();
    if (!e)
      return;
    const t = () => {
      var s;
      return (s = this.tooltipFeature) == null ? void 0 : s.setTooltipAndRefresh(e.headerTooltip);
    };
    t(), this.addManagedEventListeners({ newColumnsLoaded: t });
  }
  handleKeyDown(e) {
    switch (e.key) {
      case y.LEFT:
        e.preventDefault(), this.modelItem.expanded = !1;
        break;
      case y.RIGHT:
        e.preventDefault(), this.modelItem.expanded = !0;
        break;
      case y.SPACE:
        e.preventDefault(), this.isSelectable() && this.onSelectAllChanged(!this.isSelected());
        break;
    }
  }
  onContextMenu(e) {
    const { columnGroup: t, gos: s } = this;
    if (s.get("functionsReadOnly"))
      return;
    const i = this.createBean(new yg(t, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      i.isAlive() && this.destroyBean(i);
    });
  }
  addVisibilityListenersToAllChildren() {
    const e = this.onColumnStateChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      this.addManagedListeners(t, {
        visibleChanged: e,
        columnValueChanged: e,
        columnPivotChanged: e,
        columnRowGroupChanged: e
      });
    });
  }
  setupDragging() {
    if (!this.allowDragging) {
      G(this.eDragHandle, !1);
      return;
    }
    const e = this.beans, { gos: t, eventSvc: s, dragAndDrop: i } = e;
    let o = !t.get("suppressDragLeaveHidesColumns");
    const n = {
      type: Vs.ToolPanel,
      eElement: this.eDragHandle,
      dragItemName: this.displayName,
      getDefaultIconName: () => o ? "hide" : "notAllowed",
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        o = !t.get("suppressDragLeaveHidesColumns"), s.dispatchEvent({
          type: "columnPanelItemDragStart",
          column: this.columnGroup
        });
      },
      onDragStopped: () => {
        s.dispatchEvent({
          type: "columnPanelItemDragEnd"
        });
      },
      onGridEnter: (r) => {
        o && wg(e, {
          columns: this.columnGroup.getLeafColumns(),
          visibleState: r == null ? void 0 : r.visibleState,
          pivotState: r == null ? void 0 : r.pivotState,
          eventType: this.eventType
        });
      },
      onGridExit: () => {
        o && this.onChangeCommon(!1);
      }
    };
    i.addDragSource(n, !0), this.addDestroyFunc(() => i.removeDragSource(n));
  }
  createDragItem() {
    const e = this.columnGroup.getLeafColumns(), t = {}, s = {};
    return e.forEach((i) => {
      const o = i.getId();
      t[o] = i.isVisible(), s[o] = bg(i);
    }), {
      columns: e,
      visibleState: t,
      pivotState: s
    };
  }
  setupExpandContract() {
    const { beans: e, eGroupClosedIcon: t, eGroupOpenedIcon: s, eColumnGroupIcons: i } = this;
    t.appendChild(ho("columnSelectClosed", e, null)), s.appendChild(ho("columnSelectOpen", e, null));
    const o = this.onExpandOrContractClicked.bind(this);
    this.addManagedElementListeners(t, { click: o }), this.addManagedElementListeners(s, { click: o });
    const n = new Xt(i, !0);
    this.addManagedListeners(n, { tap: o }), this.addDestroyFunc(n.destroy.bind(n));
  }
  onLabelClicked() {
    const e = !this.cbSelect.getValue();
    this.onChangeCommon(e);
  }
  onCheckboxChanged(e) {
    this.onChangeCommon(e.selected);
  }
  getVisibleLeafColumns() {
    const e = [], t = (s) => {
      s.forEach((i) => {
        i.passesFilter && (i.group ? t(i.children) : e.push(i.column));
      });
    };
    return t(this.modelItem.children), e;
  }
  onChangeCommon(e) {
    this.refreshAriaLabel(), !this.processingColumnStateChange && Cg(this.beans, this.modelItem.children, e, this.eventType);
  }
  refreshAriaLabel() {
    const { cbSelect: e, focusWrapper: t, displayName: s } = this, i = this.getLocaleTextFunc(), o = i("ariaColumnGroup", "Column Group"), n = e.getValue(), r = n === void 0 ? i("ariaIndeterminate", "indeterminate") : n ? i("ariaVisible", "visible") : i("ariaHidden", "hidden"), a = i("ariaToggleVisibility", "Press SPACE to toggle visibility");
    Ee(t, `${s} ${o}`), e.setInputAriaLabel(`${a} (${r})`), kc(t, e.getInputElement().id);
  }
  onColumnStateChanged() {
    const e = this.workOutSelectedValue(), t = this.workOutReadOnlyValue();
    this.processingColumnStateChange = !0;
    const s = this.cbSelect;
    s.setValue(e), s.setReadOnly(t), this.toggleCss("ag-column-select-column-group-readonly", t), this.processingColumnStateChange = !1;
  }
  workOutSelectedValue() {
    const e = this.beans.colModel.isPivotMode(), t = this.getVisibleLeafColumns();
    let s = 0, i = 0;
    if (t.forEach((o) => {
      !e && o.getColDef().lockVisible || (this.isColumnChecked(o, e) ? s++ : i++);
    }), !(s > 0 && i > 0))
      return s > 0;
  }
  workOutReadOnlyValue() {
    const e = this.beans.colModel.isPivotMode();
    let t = 0;
    return this.columnGroup.getLeafColumns().forEach((s) => {
      e ? s.isAnyFunctionAllowed() && t++ : s.getColDef().lockVisible || t++;
    }), t === 0;
  }
  isColumnChecked(e, t) {
    if (t) {
      const s = e.isPivotActive(), i = e.isRowGroupActive(), o = e.isValueActive();
      return s || i || o;
    }
    return e.isVisible();
  }
  onExpandOrContractClicked() {
    const e = this.modelItem, t = e.expanded;
    e.expanded = !t;
  }
  onExpandChanged() {
    this.setOpenClosedIcons(), this.refreshAriaExpanded();
  }
  setOpenClosedIcons() {
    const e = this.modelItem.expanded;
    G(this.eGroupClosedIcon, !e), G(this.eGroupOpenedIcon, e);
  }
  refreshAriaExpanded() {
    ot(this.focusWrapper, this.modelItem.expanded);
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(e) {
    const t = this.cbSelect, s = t.getValue();
    !t.isReadOnly() && (e && !s || !e && s) && t.toggle();
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  setSelected(e) {
    this.cbSelect.setValue(e, !0);
  }
}, Dr = (e) => ae(e) ? e.getLeafColumns() : e ? [e] : [], ZP = (e, t, s, i) => {
  if (!s || !t)
    return null;
  const o = e.colModel.getCols(), n = o.indexOf(s), r = i ? n : n + 1, a = QP(o, t, r);
  return r - a;
}, QP = (e, t, s) => {
  if (!t)
    return 0;
  const i = t[0], o = t.length;
  return e.indexOf(i) < s ? o : 0;
}, Id = (e, t, s) => e.get("suppressMovableColumns") || t.colModel.isPivotMode() ? !0 : !!s.find(({ colDef: n }) => !!n.suppressMovable || !!n.lockPosition), Td = (e, t, s) => {
  var a;
  if (!s)
    return;
  const { component: i } = s;
  let o = null, n = s.position === "top";
  if (i instanceof Sg ? (o = i.getColumns()[0], n = !0) : i && (o = i.column), !o)
    return;
  const r = ZP(e, t, o, n);
  r != null && ((a = e.colMoves) == null || a.moveColumns(t, r, "toolPanelUi"));
}, XP = (e) => e.column, JP = {
  tag: "div",
  cls: "ag-column-select-column",
  children: [
    { tag: "ag-checkbox", ref: "cbSelect", cls: "ag-column-select-checkbox" },
    { tag: "span", ref: "eLabel", cls: "ag-column-select-column-label" }
  ]
}, eD = class extends L {
  constructor(e, t, s, i) {
    super(), this.modelItem = e, this.allowDragging = t, this.groupsExist = s, this.focusWrapper = i, this.eLabel = x, this.cbSelect = x, this.processingColumnStateChange = !1;
    const { column: o, depth: n, displayName: r } = e;
    this.column = o, this.columnDepth = n, this.displayName = r;
  }
  postConstruct() {
    this.setTemplate(JP, [Ii]);
    const {
      beans: e,
      cbSelect: t,
      displayName: s,
      eLabel: i,
      columnDepth: o,
      groupsExist: n,
      column: r,
      gos: a,
      focusWrapper: l
    } = this, d = k("columnDrag", e);
    this.eDragHandle = d, d.classList.add("ag-drag-handle", "ag-column-select-column-drag-handle");
    const c = t.getGui(), u = t.getInputElement();
    c.insertAdjacentElement("afterend", d), u.setAttribute("tabindex", "-1"), i.textContent = s, n && this.addCss("ag-column-select-add-group-indent"), this.addCss(`ag-column-select-indent-${o}`), this.getGui().style.setProperty("--ag-indentation-level", String(o)), this.tooltipFeature = this.createOptionalManagedBean(
      e.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getLocation: () => "columnToolPanelColumn",
        getColDef: () => r.getColDef(),
        shouldDisplayTooltip: sl(a, () => i)
      })
    ), this.setupDragging();
    const h = this.onColumnStateChanged.bind(this);
    this.addManagedEventListeners({ columnPivotModeChanged: h }), this.addManagedListeners(r, {
      columnValueChanged: h,
      columnPivotChanged: h,
      columnRowGroupChanged: h,
      visibleChanged: h
    }), this.addManagedListeners(l, {
      keydown: this.handleKeyDown.bind(this),
      contextmenu: this.onContextMenu.bind(this)
    }), this.addManagedPropertyListener("functionsReadOnly", this.onColumnStateChanged.bind(this)), this.addManagedListeners(t, { fieldValueChanged: this.onCheckboxChanged.bind(this) }), this.addManagedElementListeners(i, { click: this.onLabelClicked.bind(this) }), this.onColumnStateChanged(), this.refreshAriaLabel(), this.setupTooltip(), zu(r.getColDef(), a, r, null).forEach((p) => this.toggleCss(p, !0));
  }
  getColumn() {
    return this.column;
  }
  setupTooltip() {
    const e = () => {
      var t;
      return (t = this.tooltipFeature) == null ? void 0 : t.setTooltipAndRefresh(this.column.getColDef().headerTooltip);
    };
    e(), this.addManagedEventListeners({ newColumnsLoaded: e });
  }
  onContextMenu(e) {
    const { column: t, gos: s } = this;
    if (s.get("functionsReadOnly"))
      return;
    const i = this.createBean(new yg(t, e, this.focusWrapper));
    this.addDestroyFunc(() => {
      i.isAlive() && this.destroyBean(i);
    });
  }
  handleKeyDown(e) {
    e.key === y.SPACE && (e.preventDefault(), this.isSelectable() && this.onSelectAllChanged(!this.isSelected()));
  }
  onLabelClicked() {
    if (this.gos.get("functionsReadOnly"))
      return;
    const e = !this.cbSelect.getValue();
    this.onChangeCommon(e);
  }
  onCheckboxChanged(e) {
    this.onChangeCommon(e.selected);
  }
  onChangeCommon(e) {
    this.cbSelect.isReadOnly() || (this.refreshAriaLabel(), !this.processingColumnStateChange && vg(this.beans, [this.column], e, "toolPanelUi"));
  }
  refreshAriaLabel() {
    const { cbSelect: e, focusWrapper: t, displayName: s } = this, i = this.getLocaleTextFunc(), o = i("ariaColumn", "Column"), n = e.getValue() ? i("ariaVisible", "visible") : i("ariaHidden", "hidden"), r = i("ariaToggleVisibility", "Press SPACE to toggle visibility");
    Ee(t, `${s} ${o}`), this.cbSelect.setInputAriaLabel(`${r} (${n})`), kc(t, e.getInputElement().id);
  }
  setupDragging() {
    const e = this.eDragHandle;
    if (!this.allowDragging) {
      G(e, !1);
      return;
    }
    const t = this.beans, { gos: s, eventSvc: i, dragAndDrop: o } = t;
    let n = !s.get("suppressDragLeaveHidesColumns");
    const r = {
      type: Vs.ToolPanel,
      eElement: e,
      dragItemName: this.displayName,
      getDefaultIconName: () => n ? "hide" : "notAllowed",
      getDragItem: () => this.createDragItem(),
      onDragStarted: () => {
        n = !s.get("suppressDragLeaveHidesColumns"), i.dispatchEvent({
          type: "columnPanelItemDragStart",
          column: this.column
        });
      },
      onDragStopped: () => {
        i.dispatchEvent({
          type: "columnPanelItemDragEnd"
        });
      },
      onGridEnter: (a) => {
        n && wg(t, {
          columns: [this.column],
          visibleState: a == null ? void 0 : a.visibleState,
          pivotState: a == null ? void 0 : a.pivotState,
          eventType: "toolPanelUi"
        });
      },
      onGridExit: () => {
        n && this.onChangeCommon(!1);
      }
    };
    o.addDragSource(r, !0), this.addDestroyFunc(() => o.removeDragSource(r));
  }
  createDragItem() {
    const e = this.column.getColId(), t = { [e]: this.column.isVisible() }, s = { [e]: bg(this.column) };
    return {
      columns: [this.column],
      visibleState: t,
      pivotState: s
    };
  }
  onColumnStateChanged() {
    this.processingColumnStateChange = !0;
    const e = this.beans.colModel.isPivotMode();
    if (e) {
      const i = this.column.isAnyFunctionActive();
      this.cbSelect.setValue(i);
    } else
      this.cbSelect.setValue(this.column.isVisible());
    let t = !0, s = !0;
    if (e) {
      const i = this.gos.get("functionsReadOnly"), o = !this.column.isAnyFunctionAllowed();
      t = !i && !o, s = t;
    } else {
      const { enableRowGroup: i, enableValue: o, lockPosition: n, suppressMovable: r, lockVisible: a } = this.column.getColDef(), l = !!i || !!o, d = !!n || !!r;
      t = !a, s = l || !d;
    }
    this.cbSelect.setReadOnly(!t), this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !s), this.toggleCss("ag-column-select-column-readonly", !s && !t), this.cbSelect.setPassive(!1), this.processingColumnStateChange = !1;
  }
  getDisplayName() {
    return this.displayName;
  }
  onSelectAllChanged(e) {
    const t = this.cbSelect;
    e !== t.getValue() && (t.isReadOnly() || t.toggle());
  }
  isSelected() {
    return this.cbSelect.getValue();
  }
  isSelectable() {
    return !this.cbSelect.isReadOnly();
  }
  isExpandable() {
    return !1;
  }
  setExpanded(e) {
    P(158);
  }
}, tD = class {
  constructor(e) {
    this.items = e;
  }
  getRowCount() {
    return this.items.length;
  }
  getRow(e) {
    return this.items[e];
  }
}, sD = "ag-column-select-list", iD = class extends L {
  constructor() {
    super({ tag: "div", cls: sD, role: "presentation" }), this.destroyColumnItemFuncs = [], this.hasLoadedInitialState = !1, this.isInitialState = !1, this.skipRefocus = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel;
  }
  destroy() {
    this.destroyColumnTree(), super.destroy();
  }
  destroyColumnTree() {
    this.allColsTree = [], this.destroyColumnItemFuncs.forEach((e) => e()), this.destroyColumnItemFuncs = [];
  }
  init(e, t, s) {
    this.params = e;
    const { suppressSyncLayoutWithGrid: i, contractColumnSelection: o, suppressColumnMove: n } = e;
    this.allowDragging = t, this.eventType = s, i || this.addManagedEventListeners({ columnMoved: this.onColumnsChanged.bind(this) }), this.addManagedEventListeners({
      newColumnsLoaded: this.onColumnsChanged.bind(this)
    });
    const r = this.fireSelectionChangedEvent.bind(this);
    this.addManagedEventListeners({
      columnPivotChanged: r,
      columnPivotModeChanged: r,
      columnRowGroupChanged: r,
      columnValueChanged: r,
      columnVisible: r,
      newColumnsLoaded: r
    }), this.expandGroupsByDefault = !o;
    const a = n || i, l = this.createManagedBean(
      new dg({
        cssIdentifier: "column-select",
        ariaRole: "tree",
        moveItemCallback: (d, c) => {
          a || this.moveItems(d, c);
        }
      })
    );
    this.virtualList = l, this.appendChild(l.getGui()), l.setComponentCreator((d, c) => (Zf(c, d.depth + 1), this.createComponentFromItem(d, c))), this.colModel.ready && this.onColumnsChanged(), !a && this.createItemDragFeature();
  }
  createItemDragFeature() {
    const { gos: e, beans: t, eventSvc: s, virtualList: i } = this;
    this.createManagedBean(
      new oP(this, i, {
        dragSourceType: Vs.ToolPanel,
        listItemDragStartEvent: "columnPanelItemDragStart",
        listItemDragEndEvent: "columnPanelItemDragEnd",
        eventSource: s,
        getCurrentDragValue: (o) => XP(o),
        isMoveBlocked: (o) => Id(e, t, Dr(o)),
        getNumRows: (o) => o.getDisplayedColsList().length,
        moveItem: (o, n) => Td(t, Dr(o), n)
      })
    );
  }
  moveItems(e, t) {
    var p;
    const { gos: s, beans: i } = this, { modelItem: o } = e, { group: n, columnGroup: r, column: a, expanded: l } = o, d = Dr(n ? r : a);
    if (Id(s, i, d))
      return;
    const c = this.displayedColsList.indexOf(o), u = t ? -1 : 1;
    let h = 0;
    if (t) {
      const f = e.columnDepth > 0 && ((p = a.getParent()) == null ? void 0 : p.getChildren());
      f && f.length && a === f[0] && (h = -1);
    } else n && (h = l ? o.children.length : 0);
    const g = Math.min(Math.max(c + h + u, 0), this.displayedColsList.length - 1);
    this.skipRefocus = !0, Td(i, d, {
      position: t ? "top" : "bottom",
      component: this.virtualList.getComponentAt(g)
    }), this.focusRowIfAlive(g - h).then(() => {
      this.skipRefocus = !1;
    });
  }
  createComponentFromItem(e, t) {
    const s = this.allowDragging;
    if (e.group) {
      const o = new Sg(e, s, this.eventType, t);
      return this.createBean(o), o;
    }
    const i = new eD(e, s, this.groupsExist, t);
    return this.createBean(i), i;
  }
  onColumnsChanged() {
    const e = this.params;
    this.hasLoadedInitialState || (this.hasLoadedInitialState = !0, this.isInitialState = !!e.initialState);
    const t = this.getExpandedStates(), s = this.colModel.isPivotMode();
    !e.suppressSyncLayoutWithGrid && !s ? this.buildTreeFromWhatGridIsDisplaying() : this.buildTreeFromProvidedColumnDefs(), this.setExpandedStates(t), this.markFilteredColumns(), this.flattenAndFilterModel(), this.isInitialState = !1;
  }
  getDisplayedColsList() {
    return this.displayedColsList;
  }
  getExpandedStates() {
    const e = {};
    if (this.isInitialState) {
      const { expandedGroupIds: t } = this.params.initialState;
      return t.forEach((s) => {
        e[s] = !0;
      }), e;
    }
    return this.allColsTree ? (this.forEachItem((t) => {
      if (!t.group)
        return;
      const s = t.columnGroup;
      s && (e[s.getId()] = t.expanded);
    }), e) : {};
  }
  setExpandedStates(e) {
    if (!this.allColsTree)
      return;
    const { isInitialState: t } = this;
    this.forEachItem((s) => {
      if (!s.group)
        return;
      const i = s.columnGroup;
      if (i) {
        const o = e[i.getId()];
        (o != null || t) && (s.expanded = !!o);
      }
    });
  }
  buildTreeFromWhatGridIsDisplaying() {
    mg(this.colModel, this.setColumnLayout.bind(this));
  }
  setColumnLayout(e) {
    const t = fg(this.colModel, e);
    this.buildListModel(t), this.groupsExist = e.some((s) => s && typeof s.children < "u"), this.markFilteredColumns(), this.flattenAndFilterModel();
  }
  buildTreeFromProvidedColumnDefs() {
    var t;
    const e = this.colModel;
    this.buildListModel(e.getColDefColTree()), this.groupsExist = !!((t = e.colDefCols) != null && t.treeDepth);
  }
  buildListModel(e) {
    const t = this.onColumnExpanded.bind(this), s = (a) => {
      a.addEventListener("expandedChanged", t);
      const l = a.removeEventListener.bind(a, "expandedChanged", t);
      this.destroyColumnItemFuncs.push(l);
    }, i = this.beans.colNames, o = (a, l, d) => {
      a.forEach((c) => {
        ae(c) ? n(c, l, d) : r(c, l, d);
      });
    }, n = (a, l, d) => {
      const c = a.getColGroupDef();
      if (c && c.suppressColumnsToolPanel)
        return;
      if (a.isPadding()) {
        o(a.getChildren(), l, d);
        return;
      }
      const h = i.getDisplayNameForProvidedColumnGroup(null, a, "columnToolPanel"), g = new Ed(
        h,
        a,
        l,
        !0,
        this.expandGroupsByDefault
      );
      d.push(g), s(g), o(a.getChildren(), l + 1, g.children);
    }, r = (a, l, d) => {
      if (a.getColDef() && a.getColDef().suppressColumnsToolPanel)
        return;
      const u = i.getDisplayNameForColumn(a, "columnToolPanel");
      d.push(new Ed(u, a, l));
    };
    this.destroyColumnTree(), o(e, 0, this.allColsTree);
  }
  onColumnExpanded() {
    this.flattenAndFilterModel();
  }
  flattenAndFilterModel() {
    this.displayedColsList = [];
    const e = (i) => {
      i.passesFilter && (this.displayedColsList.push(i), i.group && i.expanded && i.children.forEach(e));
    }, t = this.virtualList;
    this.allColsTree.forEach(e), t.setModel(new tD(this.displayedColsList));
    let s = null;
    this.skipRefocus || (s = t.getLastFocusedRow()), t.refresh(), s != null && this.focusRowIfAlive(s), this.notifyListeners(), this.refreshAriaLabel();
  }
  refreshAriaLabel() {
    const e = this.getLocaleTextFunc(), t = e("ariaColumnPanelList", "Column List"), s = e("columns", "Columns"), i = this.displayedColsList.length;
    Ee(this.virtualList.getAriaElement(), `${t} ${i} ${s}`);
  }
  focusRowIfAlive(e) {
    return e === -1 ? Promise.resolve() : new Promise((t) => {
      window.setTimeout(() => {
        this.isAlive() && this.virtualList.focusRow(e), t();
      }, 0);
    });
  }
  forEachItem(e) {
    const t = (i) => {
      i.forEach((o) => {
        e(o), o.group && t(o.children);
      });
    }, s = this.allColsTree;
    s && t(s);
  }
  doSetExpandedAll(e) {
    this.forEachItem((t) => {
      t.group && (t.expanded = e);
    });
  }
  setGroupsExpanded(e, t) {
    if (!t) {
      this.doSetExpandedAll(e);
      return;
    }
    const s = [];
    this.forEachItem((o) => {
      if (!o.group)
        return;
      const n = o.columnGroup.getId();
      t.indexOf(n) >= 0 && (o.expanded = e, s.push(n));
    });
    const i = t.filter((o) => !s.includes(o));
    i.length > 0 && P(157, { unrecognisedGroupIds: i });
  }
  getExpandState() {
    let e = 0, t = 0;
    return this.forEachItem((s) => {
      s.group && (s.expanded ? e++ : t++);
    }), e > 0 && t > 0 ? 2 : t > 0 ? 1 : 0;
  }
  doSetSelectedAll(e) {
    Cg(this.beans, this.allColsTree, e, this.eventType);
  }
  getSelectionState() {
    let e = 0, t = 0;
    const s = this.colModel.isPivotMode();
    if (this.forEachItem((i) => {
      if (i.group || !i.passesFilter)
        return;
      const o = i.column, n = o.getColDef();
      let r;
      if (s) {
        if (!o.isAllowPivot() && !o.isAllowRowGroup() && !o.isAllowValue())
          return;
        r = o.isValueActive() || o.isPivotActive() || o.isRowGroupActive();
      } else {
        if (n.lockVisible)
          return;
        r = o.isVisible();
      }
      r ? e++ : t++;
    }), !(e > 0 && t > 0))
      return !(e === 0 || t > 0);
  }
  setFilterText(e) {
    this.filterText = T(e) ? e.toLowerCase() : null, this.markFilteredColumns(), this.flattenAndFilterModel();
  }
  markFilteredColumns() {
    const e = (s) => {
      if (!T(this.filterText))
        return !0;
      const i = s.displayName;
      return i == null || i.toLowerCase().indexOf(this.filterText) !== -1;
    }, t = (s, i) => {
      let o = !1;
      if (s.group) {
        const r = e(s);
        s.children.forEach((a) => {
          const l = t(a, r || i);
          l && (o = l);
        });
      }
      const n = i || o ? !0 : e(s);
      return s.passesFilter = n, n;
    };
    this.allColsTree.forEach((s) => t(s, !1));
  }
  notifyListeners() {
    this.fireGroupExpandedEvent(), this.fireSelectionChangedEvent();
  }
  fireGroupExpandedEvent() {
    const e = this.getExpandState();
    this.dispatchLocalEvent({ type: "groupExpanded", state: e });
  }
  fireSelectionChangedEvent() {
    if (!this.allColsTree)
      return;
    const e = this.getSelectionState();
    this.dispatchLocalEvent({ type: "selectionChanged", state: e });
  }
  getExpandedGroups() {
    const e = [];
    return this.allColsTree && this.forEachItem((t) => {
      t.group && t.expanded && e.push(t.columnGroup.getId());
    }), e;
  }
}, oD = {
  selector: "AG-PRIMARY-COLS-LIST",
  component: iD
}, nD = {
  tag: "div",
  cls: "ag-column-select",
  children: [
    { tag: "ag-primary-cols-header", ref: "primaryColsHeaderPanel" },
    { tag: "ag-primary-cols-list", ref: "primaryColsListPanel" }
  ]
}, xg = class extends L {
  constructor() {
    super(nD, [BP, oD]), this.primaryColsHeaderPanel = x, this.primaryColsListPanel = x, this.registerCSS(LP);
  }
  // we allow dragging in the toolPanel, but not when this component appears in the column menu
  init(e, t, s) {
    const { primaryColsHeaderPanel: i, primaryColsListPanel: o } = this;
    i.init(t);
    const n = t.suppressColumnFilter, r = t.suppressColumnSelectAll;
    t.suppressColumnExpandAll && n && r && i.setDisplayed(!1), this.addManagedListeners(o, {
      groupExpanded: (l) => {
        i.setExpandState(l.state), t.onStateUpdated();
      },
      selectionChanged: (l) => i.setSelectionState(l.state)
    }), o.init(t, e, s), this.addManagedListeners(i, {
      expandAll: o.doSetExpandedAll.bind(o, !0),
      collapseAll: o.doSetExpandedAll.bind(o, !1),
      selectAll: o.doSetSelectedAll.bind(o, !0),
      unselectAll: o.doSetSelectedAll.bind(o, !1),
      filterChanged: (l) => o.setFilterText(l.filterText)
    }), this.positionableFeature = this.createManagedBean(new Un(this.getGui(), { minHeight: 100 }));
  }
  toggleResizable(e) {
    this.positionableFeature.setResizable(e ? { bottom: !0 } : !1);
  }
  expandGroups(e) {
    this.primaryColsListPanel.setGroupsExpanded(!0, e);
  }
  collapseGroups(e) {
    this.primaryColsListPanel.setGroupsExpanded(!1, e);
  }
  setColumnLayout(e) {
    this.primaryColsListPanel.setColumnLayout(e);
  }
  syncLayoutWithGrid() {
    this.primaryColsListPanel.onColumnsChanged();
  }
  getExpandedGroups() {
    return this.primaryColsListPanel.getExpandedGroups();
  }
}, rD = (
  /*css*/
  ".ag-column-panel{display:flex;flex:1 1 auto;flex-direction:column;overflow:hidden}.ag-pivot-mode-panel{display:flex;height:var(--ag-header-height)}.ag-pivot-mode-select{align-items:center;display:flex}:where(.ag-ltr) .ag-pivot-mode-select{margin-left:var(--ag-widget-container-horizontal-padding)}:where(.ag-rtl) .ag-pivot-mode-select{margin-right:var(--ag-widget-container-horizontal-padding)}.ag-column-panel-column-select{border-bottom:var(--ag-tool-panel-separator-border)}.ag-column-panel-column-select:where(:nth-child(n+2 of :not(.ag-hidden))){border-top:var(--ag-tool-panel-separator-border)}:where(.ag-column-panel) .ag-column-drop-vertical{flex:1 1 0px;min-height:50px;&:where(:not(.ag-last-column-drop)){border-bottom:var(--ag-tool-panel-separator-border)}}"
), aD = class extends L {
  constructor() {
    super({ tag: "div", cls: "ag-column-panel" }), this.initialised = !1, this.childDestroyFuncs = [], this.registerCSS(rD);
  }
  wireBeans(e) {
    this.colToolPanelFactory = e.colToolPanelFactory;
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  init(e) {
    const s = {
      ...N(this.gos, {
        suppressColumnMove: !1,
        suppressColumnSelectAll: !1,
        suppressColumnFilter: !1,
        suppressColumnExpandAll: !1,
        contractColumnSelection: !1,
        suppressPivotMode: !1,
        suppressRowGroups: !1,
        suppressValues: !1,
        suppressPivots: !1,
        suppressSyncLayoutWithGrid: !1
      }),
      ...e
    };
    this.params = s;
    const { childDestroyFuncs: i, colToolPanelFactory: o, gos: n } = this, r = n.isModuleRegistered("SharedPivot"), a = r || n.isModuleRegistered("SharedRowGrouping");
    !s.suppressPivotMode && o && r && (this.pivotModePanel = o.createPivotModePanel(this, i));
    const l = this.createBean(new xg());
    if (this.primaryColsPanel = l, i.push(() => this.destroyBean(this.primaryColsPanel)), l.init(!0, s, "toolPanelUi"), l.addCss("ag-column-panel-column-select"), this.appendChild(l), o) {
      !s.suppressRowGroups && a && (this.rowGroupDropZonePanel = o.createRowGroupPanel(this, i)), !s.suppressValues && a && (this.valuesDropZonePanel = o.createValuesPanel(this, i)), !s.suppressPivots && r && (this.pivotDropZonePanel = o.createPivotPanel(this, i)), this.setLastVisible();
      const [d] = this.addManagedEventListeners({
        columnPivotModeChanged: () => {
          this.resetChildrenHeight(), this.setLastVisible();
        }
      });
      i.push(() => d());
    }
    this.initialised = !0;
  }
  setPivotModeSectionVisible(e) {
    const t = this.colToolPanelFactory;
    t && (this.pivotModePanel = t.setPanelVisible(
      this.pivotModePanel,
      e,
      t.createPivotModePanel.bind(t, this, this.childDestroyFuncs, !0)
    ), this.setLastVisible());
  }
  setRowGroupsSectionVisible(e) {
    const t = this.colToolPanelFactory;
    t && (this.rowGroupDropZonePanel = t.setPanelVisible(
      this.rowGroupDropZonePanel,
      e,
      t.createRowGroupPanel.bind(t, this, this.childDestroyFuncs)
    ), this.setLastVisible());
  }
  setValuesSectionVisible(e) {
    const t = this.colToolPanelFactory;
    t && (this.valuesDropZonePanel = t.setPanelVisible(
      this.valuesDropZonePanel,
      e,
      t.createValuesPanel.bind(t, this, this.childDestroyFuncs)
    ), this.setLastVisible());
  }
  setPivotSectionVisible(e) {
    var s;
    const t = this.colToolPanelFactory;
    t && (this.pivotDropZonePanel = t.setPanelVisible(
      this.pivotDropZonePanel,
      e,
      t.createPivotPanel.bind(t, this, this.childDestroyFuncs)
    ), (s = this.pivotDropZonePanel) == null || s.setDisplayed(e), this.setLastVisible());
  }
  setResizers() {
    [this.primaryColsPanel, this.rowGroupDropZonePanel, this.valuesDropZonePanel, this.pivotDropZonePanel].forEach(
      (e) => {
        if (!e)
          return;
        const t = e.getGui();
        e.toggleResizable(
          !t.classList.contains("ag-last-column-drop") && !t.classList.contains("ag-hidden")
        );
      }
    );
  }
  setLastVisible() {
    const e = this.getGui();
    Array.prototype.slice.call(e.querySelectorAll(".ag-column-drop")).forEach((o) => o.classList.remove("ag-last-column-drop"));
    const s = e.querySelectorAll(".ag-column-drop:not(.ag-hidden)"), i = Z(s);
    i && i.classList.add("ag-last-column-drop"), this.setResizers();
  }
  resetChildrenHeight() {
    const t = this.getGui().children;
    for (let s = 0; s < t.length; s++) {
      const { style: i } = t[s];
      i.removeProperty("height"), i.removeProperty("flex");
    }
  }
  expandColumnGroups(e) {
    this.primaryColsPanel.expandGroups(e);
  }
  collapseColumnGroups(e) {
    this.primaryColsPanel.collapseGroups(e);
  }
  setColumnLayout(e) {
    this.primaryColsPanel.setColumnLayout(e);
  }
  syncLayoutWithGrid() {
    this.primaryColsPanel.syncLayoutWithGrid();
  }
  destroyChildren() {
    const e = this.childDestroyFuncs;
    e.forEach((t) => t()), e.length = 0, de(this.getGui());
  }
  refresh(e) {
    return this.destroyChildren(), this.init(e), !0;
  }
  getState() {
    return {
      expandedGroupIds: this.primaryColsPanel.getExpandedGroups()
    };
  }
  destroy() {
    this.destroyChildren(), super.destroy();
  }
}, lD = (
  /*css*/
  ".ag-column-drop{align-items:center;display:inline-flex;overflow:auto;position:relative;width:100%}.ag-column-drop-list{align-items:center;display:flex}.ag-column-drop-cell{align-items:center;background-color:var(--ag-column-drop-cell-background-color);border:var(--ag-column-drop-cell-border);border-radius:500px;color:var(--ag-column-drop-cell-text-color);display:flex;padding:calc(var(--ag-spacing)*.25);position:relative;&:focus-visible{box-shadow:var(--ag-focus-shadow)}:where(.ag-drag-handle){color:var(--ag-column-drop-cell-drag-handle-color)}}:where(.ag-ltr) .ag-column-drop-cell{padding-left:calc(var(--ag-spacing)*.75)}:where(.ag-rtl) .ag-column-drop-cell{padding-right:calc(var(--ag-spacing)*.75)}.ag-column-drop-cell-text{flex:1 1 auto;margin:0 var(--ag-spacing);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ag-column-drop-vertical{align-items:stretch;display:flex;flex-direction:column;min-height:75px;overflow:hidden}.ag-column-drop-vertical-title-bar{align-items:center;display:flex;flex:none;padding:var(--ag-widget-container-vertical-padding) calc(var(--ag-spacing)*2) 0}.ag-column-drop-vertical-list{align-items:stretch;flex-direction:column;flex-grow:1;overflow-x:auto;padding-bottom:var(--ag-spacing);padding-left:var(--ag-spacing);padding-right:var(--ag-spacing);position:relative;>*{flex:none}}:where(.ag-column-drop-empty) .ag-column-drop-vertical-list{overflow:hidden}.ag-column-drop-cell-button{cursor:pointer;min-width:0;opacity:.75;&:hover{opacity:1}}.ag-column-drop-wrapper{display:flex}.ag-column-drop-horizontal-half-width{width:50%!important}.ag-column-drop-cell-ghost{opacity:.5}.ag-column-drop-horizontal{background-color:var(--ag-header-background-color);border-bottom:var(--ag-header-row-border);gap:var(--ag-cell-widget-spacing);height:var(--ag-header-height);overflow:hidden;white-space:nowrap}:where(.ag-ltr) .ag-column-drop-horizontal{padding-left:var(--ag-cell-horizontal-padding)}:where(.ag-rtl) .ag-column-drop-horizontal{padding-right:var(--ag-cell-horizontal-padding)}.ag-column-drop-horizontal-list{gap:var(--ag-cell-widget-spacing)}.ag-column-drop-vertical-cell{margin-top:var(--ag-spacing)}:where(.ag-ltr) .ag-column-drop-vertical-icon{margin-right:var(--ag-widget-horizontal-spacing)}:where(.ag-rtl) .ag-column-drop-vertical-icon{margin-left:var(--ag-widget-horizontal-spacing)}.ag-select-agg-func-popup{background:var(--ag-background-color);border:1px solid var(--ag-border-color);border-radius:var(--ag-border-radius);box-shadow:var(--ag-dropdown-shadow);height:calc(var(--ag-spacing)*5*3.5);padding:0;position:absolute}.ag-select-agg-func-virtual-list-item{cursor:default;&:hover{background-color:var(--ag-selected-row-background-color)}}:where(.ag-ltr) .ag-select-agg-func-virtual-list-item{padding-left:calc(var(--ag-spacing)*2)}:where(.ag-rtl) .ag-select-agg-func-virtual-list-item{padding-right:calc(var(--ag-spacing)*2)}:where(.ag-ltr) .ag-column-drop-horizontal-half-width:where(:not(:last-child)){border-right:1px solid var(--ag-border-color)}:where(.ag-rtl) .ag-column-drop-horizontal-half-width:where(:not(:last-child)){border-left:1px solid var(--ag-border-color)}"
);
function Ld(e, t, s) {
  e == null || t == null || e.splice(s, 0, ...t);
}
var dD = { tag: "div", cls: "ag-unselectable", role: "presentation" }, cD = class extends L {
  constructor(e) {
    super(dD), this.horizontal = e, this.state = "notDragging", this.guiDestroyFunctions = [], this.childPillComponents = [], this.resizeEnabled = !1, this.addElementClasses(this.getGui()), this.ePillDropList = _({ tag: "div" }), this.addElementClasses(this.ePillDropList, "list"), this.registerCSS(lD);
  }
  toggleResizable(e) {
    this.positionableFeature.setResizable(e ? { bottom: !0 } : !1), this.resizeEnabled = e;
  }
  isSourceEventFromTarget(e) {
    const { dropZoneTarget: t, dragSource: s } = e;
    return t.contains(s.eElement);
  }
  destroy() {
    this.destroyGui(), super.destroy();
  }
  destroyGui() {
    this.guiDestroyFunctions.forEach((e) => e()), this.guiDestroyFunctions.length = 0, this.childPillComponents.length = 0, de(this.getGui()), de(this.ePillDropList);
  }
  init(e) {
    this.params = e ?? {}, this.createManagedBean(
      new ms(this.getFocusableElement(), {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.onKeyDown.bind(this)
      })
    ), this.setupDropTarget(), this.positionableFeature = new Un(this.getGui()), this.createManagedBean(this.positionableFeature), this.refreshGui(), Ee(this.ePillDropList, this.getAriaLabel());
  }
  onTabKeyDown(e) {
    const t = cs(this.getFocusableElement(), null, !0), s = t.length;
    if (s === 0)
      return;
    const { shiftKey: i } = e, o = te(this.beans), n = o === t[0], r = o === Z(t);
    s === 1 || n && i || r && !i || t[i ? 0 : s - 1].focus();
  }
  onKeyDown(e) {
    const { key: t } = e, s = !this.horizontal;
    let i = t === y.DOWN, o = t === y.UP;
    if (!s) {
      const n = this.gos.get("enableRtl");
      i = !n && t === y.RIGHT || n && t === y.LEFT, o = !n && t === y.LEFT || n && t === y.RIGHT;
    }
    if (!(!i && !o))
      if (e.preventDefault(), e.shiftKey)
        this.moveFocusedItem(o);
      else {
        const n = Be(this.beans, this.getFocusableElement(), !1, o);
        n && n.focus();
      }
  }
  moveFocusedItem(e) {
    const t = this.getFocusedItem();
    if (t === -1)
      return;
    const s = e ? -1 : 1;
    if (!this.normalizeAndUpdateInsertIndex(t, t + s))
      return;
    const o = this.childPillComponents[t];
    if (!o.isMovable())
      return;
    const n = o.getItem();
    this.focusItemAtIndex(this.insertIndex), this.rearrangeItems([n], !0);
  }
  addElementClasses(e, t) {
    t = t ? `-${t}` : "";
    const s = this.horizontal ? "horizontal" : "vertical";
    e.classList.add(`ag-column-drop${t}`, `ag-column-drop-${s}${t}`);
  }
  setupDropTarget() {
    var e;
    this.dropTarget = {
      getContainer: this.getGui.bind(this),
      getIconName: this.getIconName.bind(this),
      onDragging: this.onDragging.bind(this),
      onDragEnter: this.onDragEnter.bind(this),
      onDragLeave: this.onDragLeave.bind(this),
      onDragStop: this.onDragStop.bind(this),
      onDragCancel: this.onDragCancel.bind(this),
      isInterestedIn: this.isInterestedIn.bind(this)
    }, (e = this.beans.dragAndDrop) == null || e.addDropTarget(this.dropTarget);
  }
  minimumAllowedNewInsertIndex() {
    return 0;
  }
  checkInsertIndex(e) {
    const t = this.getNewInsertIndex(e);
    return t < 0 ? !1 : this.normalizeAndUpdateInsertIndex(this.insertIndex, t);
  }
  normalizeAndUpdateInsertIndex(e, t) {
    const s = this.minimumAllowedNewInsertIndex(), i = Math.max(s, t), o = i !== e;
    return o && (this.insertIndex = i), o;
  }
  getNewInsertIndex(e) {
    const t = e.event, s = this.horizontal ? t.clientX : t.clientY, i = this.childPillComponents.map((n) => n.getGui().getBoundingClientRect()), o = i.findIndex(
      (n) => this.horizontal ? n.right > s && n.left < s : n.top < s && n.bottom > s
    );
    if (o === -1) {
      const n = this.gos.get("enableRtl");
      return i.every((l) => s > (this.horizontal ? l.right : l.bottom)) ? n && this.horizontal ? 0 : this.childPillComponents.length : i.every((l) => s < (this.horizontal ? l.left : l.top)) ? n && this.horizontal ? this.childPillComponents.length : 0 : this.insertIndex;
    }
    return this.insertIndex <= o ? o + 1 : o;
  }
  checkDragStartedBySelf(e) {
    this.state === "notDragging" && (this.state = "rearrangeItems", this.potentialDndItems = this.getItems(e.dragSource.getDragItem()), this.refreshGui(), this.checkInsertIndex(e), this.refreshGui());
  }
  onDragging(e) {
    this.checkDragStartedBySelf(e), this.checkInsertIndex(e) && this.refreshGui();
  }
  handleDragEnterEnd(e) {
  }
  onDragEnter(e) {
    const t = this.getItems(e.dragSource.getDragItem());
    this.state = "newItemsIn";
    const s = t.filter((o) => this.isItemDroppable(o, e)), i = s.every(
      (o) => this.childPillComponents.map((n) => n.getItem()).indexOf(o) !== -1
    );
    if (s.length !== 0) {
      if (this.potentialDndItems = s, i) {
        this.state = "notDragging";
        return;
      }
      this.handleDragEnterEnd(e), this.checkInsertIndex(e), this.refreshGui();
    }
  }
  isPotentialDndItems() {
    var e;
    return !!((e = this.potentialDndItems) != null && e.length);
  }
  handleDragLeaveEnd(e) {
  }
  onDragLeave(e) {
    if (this.state === "rearrangeItems") {
      const t = this.getItems(e.dragSource.getDragItem());
      this.removeItems(t);
    }
    this.isPotentialDndItems() && (this.handleDragLeaveEnd(e), this.potentialDndItems = [], this.refreshGui()), this.state = "notDragging";
  }
  onDragCancel(e) {
    this.isPotentialDndItems() && (this.state === "newItemsIn" && this.handleDragLeaveEnd(e), this.potentialDndItems = [], this.refreshGui()), this.state = "notDragging";
  }
  onDragStop() {
    this.isPotentialDndItems() && (this.state === "newItemsIn" ? this.addItems(this.potentialDndItems) : this.rearrangeItems(this.potentialDndItems), this.potentialDndItems = [], this.refreshGui()), this.state = "notDragging";
  }
  removeItems(e) {
    const t = this.getExistingItems().filter((s) => !e.includes(s));
    this.updateItems(t);
  }
  addItems(e) {
    if (!e)
      return;
    const t = this.getExistingItems().slice(), s = e.filter((i) => t.indexOf(i) < 0);
    Ld(t, s, this.insertIndex), this.updateItems(t);
  }
  addItem(e) {
    this.insertIndex = this.getExistingItems().length, this.addItems([e]), this.refreshGui();
  }
  rearrangeItems(e, t) {
    let s;
    return t ? s = this.getExistingItems().filter((i) => e.indexOf(i) === -1) : s = this.getNonGhostItems().slice(), Ld(s, e, this.insertIndex), pt(s, this.getExistingItems()) ? !1 : (this.updateItems(s), !0);
  }
  refreshGui() {
    let e = 0;
    this.horizontal || (e = this.ePillDropList.scrollTop);
    const t = this.resizeEnabled, s = this.getFocusedItem(), { eGridDiv: i } = this.beans, o = Wn();
    let n = null;
    o && (n = Be(this.beans, i) ?? Be(this.beans, i, !1, !0)), this.toggleResizable(!1), this.destroyGui(), this.addIconAndTitleToGui(), this.addEmptyMessageToGui(), this.addItemsToGui(), e !== 0 && (this.ePillDropList.scrollTop = e), t && this.toggleResizable(t), o && this.restoreFocus(s, n);
  }
  getFocusedItem() {
    const e = this.getGui(), t = te(this.beans);
    return e.contains(t) ? Array.from(e.querySelectorAll(".ag-column-drop-cell")).indexOf(t) : -1;
  }
  focusItemAtIndex(e) {
    const t = this.getGui(), i = Array.from(t.querySelectorAll(".ag-column-drop-cell"))[e];
    i && i.focus({ preventScroll: !0 });
  }
  restoreFocus(e, t) {
    const s = this.getGui(), i = Array.from(s.querySelectorAll(".ag-column-drop-cell"));
    if (e === -1)
      return;
    i.length === 0 && t.focus();
    const o = Math.min(i.length - 1, e), n = i[o];
    n && n.focus();
  }
  focusList(e) {
    const t = e ? this.childPillComponents.length - 1 : 0;
    this.restoreFocus(t, this.getFocusableElement());
  }
  getNonGhostItems() {
    const e = this.getExistingItems();
    return this.isPotentialDndItems() ? e.filter((t) => !this.potentialDndItems.includes(t)) : e;
  }
  addItemsToGui() {
    const t = this.getNonGhostItems().map((s) => this.createItemComponent(s, !1));
    if (this.isPotentialDndItems()) {
      const s = this.potentialDndItems.map((i) => this.createItemComponent(i, !0));
      this.insertIndex >= t.length ? t.push(...s) : t.splice(this.insertIndex, 0, ...s);
    }
    this.appendChild(this.ePillDropList), t.forEach((s, i) => {
      i > 0 && this.addArrow(this.ePillDropList), this.ePillDropList.appendChild(s.getGui());
    }), this.addAriaLabelsToComponents();
  }
  addAriaLabelsToComponents() {
    const { childPillComponents: e, ePillDropList: t } = this, s = e.length;
    Ne(t, s === 0 ? "presentation" : "listbox");
    for (let i = 0; i < s; i++) {
      const n = e[i].getGui();
      Da(n, i + 1), Pa(n, s);
    }
  }
  createItemComponent(e, t) {
    const s = this.createPillComponent(e, this.dropTarget, t, this.horizontal);
    return s.addEventListener("columnRemove", this.removeItems.bind(this, [e])), this.createBean(s), this.guiDestroyFunctions.push(() => this.destroyBean(s)), t || this.childPillComponents.push(s), s;
  }
  addIconAndTitleToGui() {
    const { title: e, icon: t } = this.params;
    if (!e || !t)
      return;
    const s = _({ tag: "div" });
    if (Fa(s, !0), this.addElementClasses(s, "title-bar"), this.addElementClasses(t, "icon"), this.toggleCss("ag-column-drop-empty", this.isExistingItemsEmpty()), s.appendChild(t), !this.horizontal) {
      const i = _({ tag: "span" });
      this.addElementClasses(i, "title"), i.textContent = e, s.appendChild(i);
    }
    this.appendChild(s);
  }
  isExistingItemsEmpty() {
    return this.getExistingItems().length === 0;
  }
  addEmptyMessageToGui() {
    const { emptyMessage: e } = this.params;
    if (!e || !this.isExistingItemsEmpty() || this.isPotentialDndItems())
      return;
    const t = _({ tag: "span" });
    t.textContent = e, this.addElementClasses(t, "empty-message"), this.ePillDropList.appendChild(t);
  }
  addArrow(e) {
    if (this.horizontal) {
      const t = this.gos.get("enableRtl"), s = k(t ? "panelDelimiterRtl" : "panelDelimiter", this.beans);
      this.addElementClasses(s, "cell-separator"), e.appendChild(s);
    }
  }
}, uD = {
  tag: "span",
  role: "option",
  children: [
    {
      tag: "span",
      ref: "eDragHandle",
      cls: "ag-drag-handle ag-column-drop-cell-drag-handle",
      role: "presentation"
    },
    { tag: "span", ref: "eText", cls: "ag-column-drop-cell-text", attrs: { "aria-hidden": "true" } },
    { tag: "span", ref: "eButton", cls: "ag-column-drop-cell-button", role: "presentation" }
  ]
}, hD = class extends L {
  constructor(e, t, s, i, o) {
    super(), this.dragSourceDropTarget = e, this.ghost = t, this.horizontal = s, this.template = i, this.agComponents = o, this.eText = x, this.eDragHandle = x, this.eButton = x;
  }
  postConstruct() {
    this.setTemplate(this.template ?? uD, this.agComponents);
    const e = this.getGui(), { beans: t, eDragHandle: s, eText: i, eButton: o } = this;
    this.addElementClasses(e), this.addElementClasses(s, "drag-handle"), this.addElementClasses(i, "text"), this.addElementClasses(o, "button"), s.appendChild(k("columnDrag", t)), o.appendChild(k("cancel", t)), this.tooltipFeature = this.createOptionalManagedBean(
      t.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui()
      })
    ), this.setupComponents(), !this.ghost && this.isDraggable() && this.addDragSource(), this.setupAria(), this.setupTooltip(), this.activateTabIndex(), this.refreshDraggable();
  }
  isDraggable() {
    return !0;
  }
  refreshDraggable() {
    this.eDragHandle.classList.toggle("ag-column-select-column-readonly", !this.isDraggable());
  }
  setupAria() {
    const e = this.getLocaleTextFunc(), t = [this.getAriaDisplayName()];
    this.addAdditionalAriaInstructions(t, e), Ee(this.getGui(), t.join(". "));
  }
  addAdditionalAriaInstructions(e, t) {
    if (this.isRemovable()) {
      const s = t("ariaDropZoneColumnComponentDescription", "Press DELETE to remove");
      e.push(s);
    }
  }
  setupTooltip() {
    const e = () => {
      var t;
      return (t = this.tooltipFeature) == null ? void 0 : t.setTooltipAndRefresh(this.getTooltip());
    };
    e(), this.addManagedEventListeners({ newColumnsLoaded: e });
  }
  getDragSourceId() {
  }
  getDefaultIconName() {
    return "notAllowed";
  }
  addDragSource() {
    const {
      beans: { dragAndDrop: e },
      eDragHandle: t
    } = this, s = this.createGetDragItem(), i = this.getDefaultIconName(), o = {
      type: this.getDragSourceType(),
      sourceId: this.getDragSourceId(),
      eElement: t,
      getDefaultIconName: () => i,
      getDragItem: s,
      dragItemName: this.getDisplayName()
    };
    e == null || e.addDragSource(o, !0), this.addDestroyFunc(() => e == null ? void 0 : e.removeDragSource(o));
  }
  setupComponents() {
    this.eText.textContent = this.getDisplayValue(), this.setupRemove(), this.ghost && this.addCss("ag-column-drop-cell-ghost");
  }
  isRemovable() {
    return !0;
  }
  refreshRemove() {
    G(this.eButton, this.isRemovable());
  }
  setupRemove() {
    this.refreshRemove();
    const e = { type: "columnRemove" };
    this.addGuiEventListener("keydown", (s) => this.onKeyDown(s)), this.addManagedElementListeners(this.eButton, {
      click: (s) => {
        this.dispatchLocalEvent(e), s.stopPropagation();
      }
    });
    const t = new Xt(this.eButton);
    this.addManagedListeners(t, {
      tap: () => this.dispatchLocalEvent(e)
    }), this.addDestroyFunc(t.destroy.bind(t));
  }
  onKeyDown(e) {
    e.key === y.DELETE && this.isRemovable() && (e.preventDefault(), this.dispatchLocalEvent({ type: "columnRemove" }));
  }
  getDisplayValue() {
    return this.getDisplayName();
  }
  addElementClasses(e, t) {
    t = t ? `-${t}` : "";
    const s = this.horizontal ? "horizontal" : "vertical";
    e.classList.add(`ag-column-drop-cell${t}`, `ag-column-drop-${s}-cell${t}`);
  }
  destroy() {
    super.destroy(), this.dragSourceDropTarget = null;
  }
}, gD = class extends hD {
  constructor(e, t, s, i, o) {
    super(t, s, o), this.column = e, this.dropZonePurpose = i, this.eSortIndicator = x, this.popupShowing = !1;
  }
  postConstruct() {
    const { sortSvc: e, colNames: t } = this.beans;
    this.template = {
      tag: "span",
      role: "option",
      children: [
        {
          tag: "span",
          ref: "eDragHandle",
          cls: "ag-drag-handle ag-column-drop-cell-drag-handle",
          role: "presentation"
        },
        { tag: "span", ref: "eText", cls: "ag-column-drop-cell-text", attrs: { "aria-hidden": "true" } },
        e ? { tag: "ag-sort-indicator", ref: "eSortIndicator" } : void 0,
        { tag: "span", ref: "eButton", cls: "ag-column-drop-cell-button", role: "presentation" }
      ]
    }, e && (this.agComponents = [e.getSortIndicatorSelector()]), this.displayName = t.getDisplayNameForColumn(this.column, "columnDrop"), super.postConstruct(), e && (this.setupSort(), this.addManagedEventListeners({
      sortChanged: () => {
        this.setupAria();
      }
    })), this.isGroupingZone() && this.addManagedPropertyListener("groupLockGroupColumns", () => {
      this.refreshRemove(), this.refreshDraggable(), this.setupAria();
    });
  }
  getItem() {
    return this.column;
  }
  getDisplayName() {
    return this.displayName;
  }
  getTooltip() {
    return this.column.getColDef().headerTooltip;
  }
  addAdditionalAriaInstructions(e, t) {
    const s = this.gos.get("rowGroupPanelSuppressSort"), i = this.gos.get("functionsReadOnly");
    if (this.isAggregationZone() && !i) {
      const o = t(
        "ariaDropZoneColumnValueItemDescription",
        "Press ENTER to change the aggregation type"
      );
      e.push(o);
    }
    if (this.isGroupingZone() && this.column.isSortable() && !s) {
      const o = t("ariaDropZoneColumnGroupItemDescription", "Press ENTER to sort");
      e.push(o);
    }
    super.addAdditionalAriaInstructions(e, t);
  }
  isMovable() {
    return this.isDraggable();
  }
  isDraggable() {
    return this.isReadOnly();
  }
  isRemovable() {
    return this.isReadOnly();
  }
  isReadOnly() {
    return !this.isGroupingAndLocked() && !this.gos.get("functionsReadOnly");
  }
  getAriaDisplayName() {
    const e = this.getLocaleTextFunc(), { name: t, aggFuncName: s } = this.getColumnAndAggFuncName(), i = e("ariaDropZoneColumnComponentAggFuncSeparator", " of "), o = {
      asc: e("ariaDropZoneColumnComponentSortAscending", "ascending"),
      desc: e("ariaDropZoneColumnComponentSortDescending", "descending")
    }, n = this.column.getSort(), r = this.gos.get("rowGroupPanelSuppressSort");
    return [
      s && `${s}${i}`,
      t,
      this.isGroupingZone() && !r && n && `, ${o[n]}`
    ].filter((a) => !!a).join("");
  }
  getColumnAndAggFuncName() {
    const e = this.displayName;
    let t = "";
    if (this.isAggregationZone()) {
      const s = this.column.getAggFunc(), i = typeof s == "string" ? s : "agg";
      t = this.getLocaleTextFunc()(i, i);
    }
    return { name: e, aggFuncName: t };
  }
  setupSort() {
    if (!(!this.column.isSortable() || !this.isGroupingZone()) && !this.gos.get("rowGroupPanelSuppressSort")) {
      this.eSortIndicator.setupSort(this.column, !0);
      const e = (t) => {
        t.preventDefault(), this.beans.sortSvc.progressSortFromEvent(this.column, t);
      };
      this.addGuiEventListener("click", e), this.addGuiEventListener("keydown", (t) => {
        t.key === y.ENTER && this.isGroupingZone() && e(t);
      });
    }
  }
  getDefaultIconName() {
    return "hide";
  }
  createGetDragItem() {
    const { column: e } = this;
    return () => {
      const t = {};
      return t[e.getId()] = e.isVisible(), {
        columns: [e],
        visibleState: t
      };
    };
  }
  setupComponents() {
    super.setupComponents(), this.isAggregationZone() && !this.gos.get("functionsReadOnly") && this.addGuiEventListener("click", this.onShowAggFuncSelection.bind(this));
  }
  onKeyDown(e) {
    super.onKeyDown(e), e.key === y.ENTER && this.isAggregationZone() && !this.gos.get("functionsReadOnly") && (e.preventDefault(), this.onShowAggFuncSelection());
  }
  getDisplayValue() {
    const { name: e, aggFuncName: t } = this.getColumnAndAggFuncName();
    return this.isAggregationZone() ? `${t}(${e})` : e;
  }
  onShowAggFuncSelection() {
    if (this.popupShowing)
      return;
    this.popupShowing = !0;
    const { aggFuncSvc: e, popupSvc: t } = this.beans, s = new dg({ cssIdentifier: "select-agg-func" }), i = e.getFuncNames(this.column), o = this.getGui(), n = s.getGui();
    s.setModel({
      getRow: function(h) {
        return i[h];
      },
      getRowCount: function() {
        return i.length;
      }
    }), this.createBean(s);
    const r = _({ tag: "div", cls: "ag-select-agg-func-popup" });
    r.style.top = "0px", r.style.left = "0px", r.appendChild(n), r.style.width = `${o.clientWidth}px`;
    const [a] = this.addManagedElementListeners(r, {
      focusout: (h) => {
        !r.contains(h.relatedTarget) && c && c.hideFunc();
      }
    }), l = (h) => {
      this.destroyBean(s), this.popupShowing = !1, (h == null ? void 0 : h.key) === "Escape" && o.focus(), a && a();
    }, d = this.getLocaleTextFunc(), c = t.addPopup({
      modal: !0,
      eChild: r,
      closeOnEsc: !0,
      closedCallback: l,
      ariaLabel: d("ariaLabelAggregationFunction", "Aggregation Function")
    });
    c && s.setComponentCreator(this.createAggSelect.bind(this, c.hideFunc)), s.addGuiEventListener("keydown", (h) => {
      if (h.key === y.ENTER || h.key === y.SPACE) {
        const g = s.getLastFocusedRow();
        if (g == null)
          return;
        const p = s.getComponentAt(g);
        p && p.selectItem();
      }
    }), t.positionPopupByComponent({
      type: "aggFuncSelect",
      eventSource: o,
      ePopup: r,
      keepWithinBounds: !0,
      column: this.column,
      position: "under"
    }), s.refresh();
    let u = i.findIndex((h) => h === this.column.getAggFunc());
    u === -1 && (u = 0), s.focusRow(u);
  }
  createAggSelect(e, t) {
    const s = () => {
      var a, l;
      e(), this.getGui().focus(), (l = (a = this.beans.valueColsSvc) == null ? void 0 : a.setColumnAggFunc) == null || l.call(a, this.column, t, "toolPanelDragAndDrop");
    }, i = this.getLocaleTextFunc(), o = t.toString(), n = i(o, o);
    return new pD(s, n);
  }
  isGroupingAndLocked() {
    return this.isGroupingZone() && po(this.column, this.beans);
  }
  isAggregationZone() {
    return this.dropZonePurpose === "aggregation";
  }
  isGroupingZone() {
    return this.dropZonePurpose === "rowGroup";
  }
  getDragSourceType() {
    return Vs.ToolPanel;
  }
  destroy() {
    super.destroy(), this.column = null;
  }
}, pD = class extends L {
  constructor(e, t) {
    super({ tag: "div", cls: "ag-select-agg-func-item", children: t }), this.selectItem = e, this.addGuiEventListener("click", this.selectItem);
  }
}, pl = class extends cD {
  constructor(e, t) {
    super(e), this.dropZonePurpose = t, this.addElementClasses(this.getGui(), this.dropZonePurpose.toLowerCase());
  }
  init(e) {
    super.init(e), this.addManagedEventListeners({ newColumnsLoaded: this.refreshGui.bind(this) }), this.addManagedPropertyListeners(
      ["functionsReadOnly", "rowGroupPanelSuppressSort", "groupLockGroupColumns"],
      this.refreshGui.bind(this)
    );
  }
  getItems(e) {
    return e.columns ?? [];
  }
  isInterestedIn(e) {
    return e === Vs.HeaderCell || e === Vs.ToolPanel;
  }
  minimumAllowedNewInsertIndex() {
    const { gos: e, rowGroupColsSvc: t } = this.beans, s = e.get("groupLockGroupColumns"), i = (t == null ? void 0 : t.columns.length) ?? 0;
    return s === -1 ? i : Math.min(s, i);
  }
  showOrHideColumnOnExit(e) {
    return this.isRowGroupPanel() && nu(this.gos, !0) && !e.fromNudge;
  }
  handleDragEnterEnd(e) {
    if (this.showOrHideColumnOnExit(e)) {
      const i = e.dragSource.getDragItem().columns;
      this.setColumnsVisible(i, !1, "uiColumnDragged");
    }
  }
  handleDragLeaveEnd(e) {
    if (this.showOrHideColumnOnExit(e)) {
      const s = e.dragSource.getDragItem();
      this.setColumnsVisible(s.columns, !0, "uiColumnDragged");
    }
  }
  setColumnsVisible(e, t, s) {
    if (e) {
      const i = e.filter((o) => !o.getColDef().lockVisible);
      this.beans.colModel.setColsVisible(i, t, s);
    }
  }
  isRowGroupPanel() {
    return this.dropZonePurpose === "rowGroup";
  }
  createPillComponent(e, t, s, i) {
    return new gD(e, t, s, this.dropZonePurpose, i);
  }
}, fD = class extends pl {
  constructor(e) {
    super(e, "pivot");
  }
  postConstruct() {
    const e = this.getLocaleTextFunc(), t = e("pivotColumnsEmptyMessage", "Drag here to set column labels"), s = e("pivots", "Column Labels");
    super.init({
      icon: k("pivotPanel", this.beans, null),
      emptyMessage: t,
      title: s
    }), this.addManagedEventListeners({
      newColumnsLoaded: this.refresh.bind(this),
      columnPivotChanged: this.refresh.bind(this),
      columnPivotModeChanged: this.checkVisibility.bind(this)
    }), this.refresh();
  }
  getAriaLabel() {
    return this.getLocaleTextFunc()("ariaPivotDropZonePanelLabel", "Column Labels");
  }
  refresh() {
    this.checkVisibility(), this.refreshGui();
  }
  checkVisibility() {
    const e = this.beans.colModel, t = e.isPivotMode();
    if (this.horizontal)
      switch (this.gos.get("pivotPanelShow")) {
        case "always":
          this.setDisplayed(t);
          break;
        case "onlyWhenPivoting": {
          const s = e.isPivotActive();
          this.setDisplayed(t && s);
          break;
        }
        default:
          this.setDisplayed(!1);
          break;
      }
    else
      this.setDisplayed(t);
  }
  isItemDroppable(e, t) {
    return this.gos.get("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowPivot() && (!e.isPivotActive() || this.isSourceEventFromTarget(t));
  }
  updateItems(e) {
    var t;
    (t = this.beans.pivotColsSvc) == null || t.setColumns(e, "toolPanelUi");
  }
  getIconName() {
    return this.isPotentialDndItems() ? "pivot" : "notAllowed";
  }
  getExistingItems() {
    var e;
    return ((e = this.beans.pivotColsSvc) == null ? void 0 : e.columns) ?? [];
  }
}, mD = class extends pl {
  constructor(e) {
    super(e, "rowGroup");
  }
  postConstruct() {
    const e = this.getLocaleTextFunc(), t = e("rowGroupColumnsEmptyMessage", "Drag here to set row groups"), s = e("groups", "Row Groups");
    super.init({
      icon: k("rowGroupPanel", this.beans, null),
      emptyMessage: t,
      title: s
    }), this.addManagedEventListeners({ columnRowGroupChanged: this.refreshGui.bind(this) });
  }
  getAriaLabel() {
    return this.getLocaleTextFunc()("ariaRowGroupDropZonePanelLabel", "Row Groups");
  }
  isItemDroppable(e, t) {
    return this.gos.get("functionsReadOnly") || !e.isPrimary() || e.colDef.showRowGroup ? !1 : e.isAllowRowGroup() && (!e.isRowGroupActive() || this.isSourceEventFromTarget(t));
  }
  updateItems(e) {
    var t;
    (t = this.beans.rowGroupColsSvc) == null || t.setColumns(e, "toolPanelUi");
  }
  getIconName() {
    return this.isPotentialDndItems() ? "group" : "notAllowed";
  }
  getExistingItems() {
    var e;
    return ((e = this.beans.rowGroupColsSvc) == null ? void 0 : e.columns) ?? [];
  }
}, CD = class extends pl {
  constructor(e) {
    super(e, "aggregation");
  }
  postConstruct() {
    const e = this.getLocaleTextFunc(), t = e("valueColumnsEmptyMessage", "Drag here to aggregate"), s = e("values", "Values");
    super.init({
      icon: k("valuePanel", this.beans, null),
      emptyMessage: t,
      title: s
    }), this.addManagedEventListeners({ columnValueChanged: this.refreshGui.bind(this) });
  }
  getAriaLabel() {
    return this.getLocaleTextFunc()("ariaValuesDropZonePanelLabel", "Values");
  }
  getIconName() {
    return this.isPotentialDndItems() ? "aggregate" : "notAllowed";
  }
  isItemDroppable(e, t) {
    return this.gos.get("functionsReadOnly") || !e.isPrimary() ? !1 : e.isAllowValue() && (!e.isValueActive() || this.isSourceEventFromTarget(t));
  }
  updateItems(e) {
    var t;
    (t = this.beans.valueColsSvc) == null || t.setColumns(e, "toolPanelUi");
  }
  getExistingItems() {
    var e;
    return ((e = this.beans.valueColsSvc) == null ? void 0 : e.columns) ?? [];
  }
}, vD = {
  tag: "div",
  cls: "ag-pivot-mode-panel",
  children: [
    {
      tag: "ag-toggle-button",
      ref: "cbPivotMode",
      cls: "ag-pivot-mode-select"
    }
  ]
}, wD = class extends L {
  constructor() {
    super(...arguments), this.cbPivotMode = x;
  }
  postConstruct() {
    this.setTemplate(vD, [Qw]);
    const e = this.cbPivotMode, { colModel: t, ctrlsSvc: s, gos: i } = this.beans;
    e.setValue(t.isPivotMode());
    const o = this.getLocaleTextFunc();
    e.setLabel(o("pivotMode", "Pivot Mode"));
    const n = () => {
      const a = !!e.getValue();
      a !== t.isPivotMode() && (i.updateGridOptions({ options: { pivotMode: a }, source: "toolPanelUi" }), s.getHeaderRowContainerCtrls().forEach((l) => l.refresh()));
    }, r = () => {
      const a = t.isPivotMode();
      e.setValue(a);
    };
    this.addManagedListeners(e, { fieldValueChanged: n }), this.addManagedEventListeners({
      newColumnsLoaded: r,
      columnPivotModeChanged: r
    });
  }
}, bD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colToolPanelFactory";
  }
  setPanelVisible(e, t, s) {
    return e ? e.setDisplayed(t) : t && (e = s()), e;
  }
  createRowGroupPanel(e, t) {
    return this.createPanel(e, t, new mD(!1));
  }
  createValuesPanel(e, t) {
    return this.createPanel(e, t, new CD(!1));
  }
  createPivotPanel(e, t) {
    return this.createPanel(e, t, new fD(!1));
  }
  createPivotModePanel(e, t, s) {
    return this.createPanel(e, t, new wD(), s);
  }
  createPanel(e, t, s, i) {
    return s = e.createBean(s), t.push(() => e.destroyBean(s)), i ? e.prependChild(s) : e.appendChild(s), s;
  }
}, yD = {
  moduleName: "ColumnsToolPanel",
  version: ce,
  beans: [bD],
  userComponents: { agColumnsToolPanel: aD },
  icons: {
    ensureColumnVisible: "column-arrow",
    // column tool panel tab
    columnsToolPanel: "columns",
    // "Group by {column-name}" item in column header menu
    menuAddRowGroup: "group",
    // "Un-Group by {column-name}" item in column header menu
    menuRemoveRowGroup: "group",
    // identifies the pivot drop zone
    pivotPanel: "pivot",
    // "Row groups" drop zone in column tool panel
    rowGroupPanel: "group",
    // columns tool panel Values drop zone
    valuePanel: "aggregation",
    // column tool panel column group contracted (click to expand)
    columnSelectClosed: "tree-closed",
    // column tool panel column group expanded (click to contract)
    columnSelectOpen: "tree-open",
    // column tool panel header expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    columnSelectIndeterminate: "tree-indeterminate"
  },
  dependsOn: [
    Ie,
    hl,
    ol,
    il,
    cl,
    gl
  ]
}, SD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "chartMenuItemMapper";
  }
  getChartItems(e) {
    var d, c;
    const t = this.beans, s = t.chartSvc, i = e === "pivotChart";
    if (!s)
      return null;
    const o = this.getLocaleTextFunc.bind(this), n = i ? new xD(t, s, o) : new RD(t, s, o), r = s.isEnterprise();
    let a = n.getMenuItem();
    if (a && a.subMenu && !r) {
      const u = (h) => {
        var g;
        return {
          ...h,
          subMenu: (g = h.subMenu) == null ? void 0 : g.filter((p) => !p._enterprise).map((p) => u(p))
        };
      };
      a = u(a);
    }
    const l = (c = (d = this.gos.get("chartToolPanelsDef")) == null ? void 0 : d.settingsPanel) == null ? void 0 : c.chartGroupsDef;
    return l && (a = this.filterAndOrderChartMenu(
      a,
      l,
      n.getConfigLookup()
    )), this.cleanInternals(a);
  }
  // Remove our internal _key and _enterprise properties so this does not leak out of the class on the menu items.
  cleanInternals(e) {
    if (!e)
      return e;
    const t = (s) => {
      var i;
      return s == null || delete s._key, s == null || delete s._enterprise, (i = s == null ? void 0 : s.subMenu) == null || i.forEach((o) => t(o)), s;
    };
    return t(e);
  }
  buildLookup(e) {
    const t = {}, s = (i) => {
      t[i._key] = i, i.subMenu && i.subMenu.forEach((o) => s(o));
    };
    return s(e), t;
  }
  /**
   * Make the MenuItem match the charts provided and their ordering on the ChartGroupsDef config object as provided by the user.
   */
  filterAndOrderChartMenu(e, t, s) {
    var n, r, a;
    const i = this.buildLookup(e), o = { ...e, subMenu: [] };
    for (const l of Object.keys(t)) {
      const d = t[l], c = s[l];
      if (c === null)
        continue;
      if (c == null) {
        P(173, { group: l });
        continue;
      }
      const u = i[c._key];
      if (u)
        if (u.subMenu) {
          const h = d.map((g) => {
            const p = c[g];
            if (p == null) {
              P(174, { group: l, chartType: g });
              return;
            }
            return i[p];
          }).filter((g) => g !== void 0);
          h.length > 0 && (u.subMenu = h, (n = o.subMenu) == null || n.push(u));
        } else
          (r = o.subMenu) == null || r.push(u);
    }
    return ((a = o.subMenu) == null ? void 0 : a.length) == 0 ? null : o;
  }
}, xD = class {
  constructor(e, t, s) {
    this.beans = e, this.chartSvc = t, this.getLocaleTextFunc = s;
  }
  getMenuItem() {
    const e = this.getLocaleTextFunc(), t = (s, i, o, n, r = !1) => ({
      // will have a LRM character appended to ensure correct display in RTL languages
      name: e(s, i + "â€Ž"),
      action: () => this.chartSvc.createPivotChart({ chartType: o }),
      _key: n,
      _enterprise: r
    });
    return {
      name: e("pivotChart", "Pivot Chart"),
      _key: "pivotChart",
      subMenu: [
        {
          _key: "pivotColumnChart",
          name: e("columnChart", "Column"),
          subMenu: [
            t("groupedColumn", "Grouped", "groupedColumn", "pivotGroupedColumn"),
            t("stackedColumn", "Stacked", "stackedColumn", "pivotStackedColumn"),
            t("normalizedColumn", "100% Stacked", "normalizedColumn", "pivotNormalizedColumn")
          ]
        },
        {
          _key: "pivotBarChart",
          name: e("barChart", "Bar"),
          subMenu: [
            t("groupedBar", "Grouped", "groupedBar", "pivotGroupedBar"),
            t("stackedBar", "Stacked", "stackedBar", "pivotStackedBar"),
            t("normalizedBar", "100% Stacked", "normalizedBar", "pivotNormalizedBar")
          ]
        },
        {
          _key: "pivotPieChart",
          name: e("pieChart", "Pie"),
          subMenu: [
            t("pie", "Pie", "pie", "pivotPie"),
            t("donut", "Donut", "donut", "pivotDonut")
          ]
        },
        {
          _key: "pivotLineChart",
          name: e("lineChart", "Line"),
          subMenu: [
            t("lineChart", "Line", "line", "pivotLineChart"),
            t("stackedLine", "Stacked", "stackedLine", "pivotStackedLine"),
            t("normalizedLine", "100% Stacked", "normalizedLine", "pivotNormalizedLine")
          ]
        },
        {
          _key: "pivotAreaChart",
          name: e("areaChart", "Area"),
          subMenu: [
            t("areaChart", "Area", "area", "pivotArea"),
            t("stackedArea", "Stacked", "stackedArea", "pivotStackedArea"),
            t("normalizedArea", "100% Stacked", "normalizedArea", "pivotNormalizedArea")
          ]
        },
        {
          _key: "pivotXYChart",
          name: e("xyChart", "X Y (Scatter)"),
          subMenu: [
            t("scatter", "Scatter", "scatter", "pivotScatter"),
            t("bubble", "Bubble", "bubble", "pivotBubble")
          ]
        },
        {
          _key: "pivotStatisticalChart",
          _enterprise: !1,
          // histogram chart is available in both community and enterprise distributions
          name: e("statisticalChart", "Statistical"),
          subMenu: [t("histogramChart", "Histogram", "histogram", "pivotHistogram", !1)]
        },
        {
          _key: "pivotHierarchicalChart",
          _enterprise: !0,
          name: e("hierarchicalChart", "Hierarchical"),
          subMenu: [
            t("treemapChart", "Treemap", "treemap", "pivotTreemap", !0),
            t("sunburstChart", "Sunburst", "sunburst", "pivotSunburst", !0)
          ]
        },
        {
          _key: "pivotFunnel",
          name: e("funnel", "Funnel"),
          subMenu: [
            t("funnel", "Funnel", "funnel", "pivotFunnel"),
            t("coneFunnel", "Cone Funnel", "coneFunnel", "pivotConeFunnel"),
            t("pyramid", "Pyramid", "pyramid", "pivotPyramid")
          ]
        },
        {
          _key: "pivotCombinationChart",
          name: e("combinationChart", "Combination"),
          subMenu: [
            t("columnLineCombo", "Column & Line", "columnLineCombo", "pivotColumnLineCombo"),
            t("AreaColumnCombo", "Area & Column", "areaColumnCombo", "pivotAreaColumnCombo")
          ]
        }
      ],
      icon: k("chart", this.beans, void 0)
    };
  }
  getConfigLookup() {
    return {
      columnGroup: {
        _key: "pivotColumnChart",
        column: "pivotGroupedColumn",
        stackedColumn: "pivotStackedColumn",
        normalizedColumn: "pivotNormalizedColumn"
      },
      barGroup: {
        _key: "pivotBarChart",
        bar: "pivotGroupedBar",
        stackedBar: "pivotStackedBar",
        normalizedBar: "pivotNormalizedBar"
      },
      pieGroup: {
        _key: "pivotPieChart",
        pie: "pivotPie",
        donut: "pivotDonut",
        doughnut: "pivotDonut"
      },
      lineGroup: {
        _key: "pivotLineChart",
        line: "pivotLineChart",
        stackedLine: "pivotStackedLine",
        normalizedLine: "pivotNormalizedLine"
      },
      areaGroup: {
        _key: "pivotAreaChart",
        area: "pivotArea",
        stackedArea: "pivotStackedArea",
        normalizedArea: "pivotNormalizedArea"
      },
      scatterGroup: {
        _key: "pivotXYChart",
        bubble: "pivotBubble",
        scatter: "pivotScatter"
      },
      combinationGroup: {
        _key: "pivotCombinationChart",
        columnLineCombo: "pivotColumnLineCombo",
        areaColumnCombo: "pivotAreaColumnCombo",
        customCombo: null
        // Not currently supported
      },
      hierarchicalGroup: {
        _key: "pivotHierarchicalChart",
        treemap: "pivotTreemap",
        sunburst: "pivotSunburst"
      },
      statisticalGroup: {
        _key: "pivotStatisticalChart",
        histogram: "pivotHistogram",
        // Some statistical charts do not currently support pivot mode
        rangeBar: null,
        rangeArea: null,
        boxPlot: null
      },
      funnelGroup: {
        _key: "pivotFunnel",
        funnel: "pivotFunnel",
        coneFunnel: "pivotConeFunnel",
        pyramid: "pivotPyramid"
      },
      // Polar charts do not support pivot mode
      polarGroup: null,
      // Specialized charts do not currently support pivot mode
      specializedGroup: null
    };
  }
}, RD = class {
  constructor(e, t, s) {
    this.beans = e, this.chartSvc = t, this.getLocaleTextFunc = s;
  }
  getMenuItem() {
    const e = this.getLocaleTextFunc(), t = (s, i, o, n, r = !1) => ({
      name: e(s, i),
      action: () => this.chartSvc.createChartFromCurrentRange(o),
      _key: n,
      _enterprise: r
    });
    return {
      name: e("chartRange", "Chart Range"),
      _key: "chartRange",
      subMenu: [
        {
          name: e("columnChart", "Column"),
          subMenu: [
            t("groupedColumn", "Grouped", "groupedColumn", "rangeGroupedColumn"),
            t("stackedColumn", "Stacked", "stackedColumn", "rangeStackedColumn"),
            t("normalizedColumn", "100% Stacked", "normalizedColumn", "rangeNormalizedColumn")
          ],
          _key: "rangeColumnChart"
        },
        {
          name: e("barChart", "Bar"),
          subMenu: [
            t("groupedBar", "Grouped", "groupedBar", "rangeGroupedBar"),
            t("stackedBar", "Stacked", "stackedBar", "rangeStackedBar"),
            t("normalizedBar", "100% Stacked", "normalizedBar", "rangeNormalizedBar")
          ],
          _key: "rangeBarChart"
        },
        {
          name: e("pieChart", "Pie"),
          subMenu: [
            t("pie", "Pie", "pie", "rangePie"),
            t("donut", "Donut", "donut", "rangeDonut")
          ],
          _key: "rangePieChart"
        },
        {
          name: e("lineChart", "Line"),
          subMenu: [
            t("lineChart", "Line", "line", "rangeLineChart"),
            t("stackedLine", "Stacked", "stackedLine", "rangeStackedLine"),
            t("normalizedLine", "100% Stacked", "normalizedLine", "rangeNormalizedLine")
          ],
          _key: "rangeLineChart"
        },
        {
          name: e("areaChart", "Area"),
          subMenu: [
            t("areaChart", "Area", "area", "rangeArea"),
            t("stackedArea", "Stacked", "stackedArea", "rangeStackedArea"),
            t("normalizedArea", "100% Stacked", "normalizedArea", "rangeNormalizedArea")
          ],
          _key: "rangeAreaChart"
        },
        {
          name: e("xyChart", "X Y (Scatter)"),
          subMenu: [
            t("scatter", "Scatter", "scatter", "rangeScatter"),
            t("bubble", "Bubble", "bubble", "rangeBubble")
          ],
          _key: "rangeXYChart"
        },
        {
          name: e("polarChart", "Polar"),
          subMenu: [
            t("radarLine", "Radar Line", "radarLine", "rangeRadarLine"),
            t("radarArea", "Radar Area", "radarArea", "rangeRadarArea"),
            t("nightingale", "Nightingale", "nightingale", "rangeNightingale"),
            t("radialColumn", "Radial Column", "radialColumn", "rangeRadialColumn"),
            t("radialBar", "Radial Bar", "radialBar", "rangeRadialBar")
          ],
          _key: "rangePolarChart",
          _enterprise: !0
        },
        {
          name: e("statisticalChart", "Statistical"),
          subMenu: [
            t("boxPlot", "Box Plot", "boxPlot", "rangeBoxPlot", !0),
            t("histogramChart", "Histogram", "histogram", "rangeHistogram", !1),
            t("rangeBar", "Range Bar", "rangeBar", "rangeRangeBar", !0),
            t("rangeArea", "Range Area", "rangeArea", "rangeRangeArea", !0)
          ],
          _key: "rangeStatisticalChart",
          _enterprise: !1
          // histogram chart is available in both community and enterprise distributions
        },
        {
          name: e("hierarchicalChart", "Hierarchical"),
          subMenu: [
            t("treemap", "Treemap", "treemap", "rangeTreemap"),
            t("sunburst", "Sunburst", "sunburst", "rangeSunburst")
          ],
          _key: "rangeHierarchicalChart",
          _enterprise: !0
        },
        {
          name: e("specializedChart", "Specialized"),
          subMenu: [
            t("heatmap", "Heatmap", "heatmap", "rangeHeatmap"),
            t("waterfall", "Waterfall", "waterfall", "rangeWaterfall")
          ],
          _key: "rangeSpecializedChart",
          _enterprise: !0
        },
        {
          name: e("funnel", "Funnel"),
          subMenu: [
            t("funnel", "Funnel", "funnel", "rangeFunnel"),
            t("coneFunnel", "Cone Funnel", "coneFunnel", "rangeConeFunnel"),
            t("pyramid", "Pyramid", "pyramid", "rangePyramid")
          ],
          _key: "rangeFunnel",
          _enterprise: !0
        },
        {
          name: e("combinationChart", "Combination"),
          subMenu: [
            t("columnLineCombo", "Column & Line", "columnLineCombo", "rangeColumnLineCombo"),
            t("AreaColumnCombo", "Area & Column", "areaColumnCombo", "rangeAreaColumnCombo")
          ],
          _key: "rangeCombinationChart"
        }
      ],
      icon: k("chart", this.beans, void 0)
    };
  }
  getConfigLookup() {
    return {
      columnGroup: {
        _key: "rangeColumnChart",
        column: "rangeGroupedColumn",
        stackedColumn: "rangeStackedColumn",
        normalizedColumn: "rangeNormalizedColumn"
      },
      barGroup: {
        _key: "rangeBarChart",
        bar: "rangeGroupedBar",
        stackedBar: "rangeStackedBar",
        normalizedBar: "rangeNormalizedBar"
      },
      pieGroup: {
        _key: "rangePieChart",
        pie: "rangePie",
        donut: "rangeDonut",
        doughnut: "rangeDonut"
      },
      lineGroup: {
        _key: "rangeLineChart",
        line: "rangeLineChart",
        stackedLine: "rangeStackedLine",
        normalizedLine: "rangeNormalizedLine"
      },
      areaGroup: {
        _key: "rangeAreaChart",
        area: "rangeArea",
        stackedArea: "rangeStackedArea",
        normalizedArea: "rangeNormalizedArea"
      },
      scatterGroup: {
        _key: "rangeXYChart",
        bubble: "rangeBubble",
        scatter: "rangeScatter"
      },
      polarGroup: {
        _key: "rangePolarChart",
        radarLine: "rangeRadarLine",
        radarArea: "rangeRadarArea",
        nightingale: "rangeNightingale",
        radialColumn: "rangeRadialColumn",
        radialBar: "rangeRadialBar"
      },
      statisticalGroup: {
        _key: "rangeStatisticalChart",
        boxPlot: "rangeBoxPlot",
        histogram: "rangeHistogram",
        rangeBar: "rangeRangeBar",
        rangeArea: "rangeRangeArea"
      },
      hierarchicalGroup: {
        _key: "rangeHierarchicalChart",
        treemap: "rangeTreemap",
        sunburst: "rangeSunburst"
      },
      specializedGroup: {
        _key: "rangeSpecializedChart",
        heatmap: "rangeHeatmap",
        waterfall: "rangeWaterfall"
      },
      funnelGroup: {
        _key: "rangeFunnel",
        funnel: "rangeFunnel",
        coneFunnel: "rangeConeFunnel",
        pyramid: "rangePyramid"
      },
      combinationGroup: {
        _key: "rangeCombinationChart",
        columnLineCombo: "rangeColumnLineCombo",
        areaColumnCombo: "rangeAreaColumnCombo",
        customCombo: null
        // Not currently supported
      }
    };
  }
}, FD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colChooserFactory";
  }
  createColumnSelectPanel(e, t, s, i) {
    const o = e.createManagedBean(new xg()), n = i ?? (t == null ? void 0 : t.getColDef().columnChooserParams) ?? {}, {
      contractColumnSelection: r,
      suppressColumnExpandAll: a,
      suppressColumnFilter: l,
      suppressColumnSelectAll: d,
      suppressSyncLayoutWithGrid: c,
      columnLayout: u
    } = n;
    return o.init(
      !!s,
      N(this.gos, {
        suppressColumnMove: !1,
        suppressValues: !1,
        suppressPivots: !1,
        suppressRowGroups: !1,
        suppressPivotMode: !1,
        contractColumnSelection: !!r,
        suppressColumnExpandAll: !!a,
        suppressColumnFilter: !!l,
        suppressColumnSelectAll: !!d,
        suppressSyncLayoutWithGrid: !!u || !!c,
        onStateUpdated: () => {
        }
      }),
      "columnMenu"
    ), u && o.setColumnLayout(u), o;
  }
  showColumnChooser({
    column: e,
    chooserParams: t,
    eventSource: s,
    headerPosition: i
  }) {
    this.hideActiveColumnChooser();
    const o = this.createColumnSelectPanel(this, e, !0, t), n = this.getLocaleTextFunc(), r = this.beans, { visibleCols: a, focusSvc: l, menuUtils: d } = r, c = a.allCols.indexOf(e), u = e ? l.focusedHeader ?? i ?? null : null;
    this.activeColumnChooserDialog = this.createBean(
      new sP({
        title: n("chooseColumns", "Choose Columns"),
        component: o,
        width: 300,
        height: 300,
        resizable: !0,
        movable: !0,
        centered: !0,
        closable: !0,
        afterGuiAttached: () => {
          var h;
          (h = Be(r, o.getGui())) == null || h.focus({
            preventScroll: !0
          }), this.dispatchVisibleChangedEvent(!0, e);
        },
        closedCallback: (h) => {
          const g = this.activeColumnChooser.getGui();
          this.destroyBean(this.activeColumnChooser), this.activeColumnChooser = void 0, this.activeColumnChooserDialog = void 0, this.dispatchVisibleChangedEvent(!1, e), e && d.restoreFocusOnClose(
            { column: e, headerPosition: u, columnIndex: c, eventSource: s },
            g,
            h,
            !0
          );
        },
        postProcessPopupParams: {
          type: "columnChooser",
          column: e,
          eventSource: s
        }
      })
    ), this.activeColumnChooser = o;
  }
  hideActiveColumnChooser() {
    this.destroyBean(this.activeColumnChooserDialog);
  }
  dispatchVisibleChangedEvent(e, t) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: "columnChooser",
      column: t ?? null
    });
  }
}, PD = {
  pinSubMenu: "PinnedColumn",
  pinLeft: "PinnedColumn",
  pinRight: "PinnedColumn",
  clearPinned: "PinnedColumn",
  pinRowSubMenu: "PinnedRow",
  pinBottom: "PinnedRow",
  pinTop: "PinnedRow",
  unpinRow: "PinnedRow",
  valueAggSubMenu: "SharedAggregation",
  autoSizeThis: "ColumnAutoSize",
  autoSizeAll: "ColumnAutoSize",
  rowGroup: "SharedRowGrouping",
  rowUnGroup: "SharedRowGrouping",
  resetColumns: "CommunityCore",
  expandAll: ["ClientSideRowModelHierarchy", "ServerSideRowModel"],
  contractAll: ["ClientSideRowModelHierarchy", "ServerSideRowModel"],
  copy: "Clipboard",
  copyWithHeaders: "Clipboard",
  copyWithGroupHeaders: "Clipboard",
  cut: "Clipboard",
  paste: "Clipboard",
  export: ["CsvExport", "ExcelExport"],
  csvExport: "CsvExport",
  excelExport: "ExcelExport",
  separator: "CommunityCore",
  pivotChart: "IntegratedCharts",
  chartRange: "IntegratedCharts",
  columnFilter: "ColumnFilter",
  columnChooser: "ColumnMenu",
  sortAscending: "Sort",
  sortDescending: "Sort",
  sortUnSort: "Sort"
};
function DD(e, t) {
  const s = PD[t];
  s && e.assertModuleRegistered(s, `menu item '${t}'`);
}
var ys = "separator";
function Rg(e, t) {
  if (e)
    for (let s = e.length - 2; s >= 0; s--) {
      const i = e[s] === t, o = e[s + 1] === t;
      i && o && e.splice(s + 1, 1);
    }
}
var MD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "menuItemMapper";
  }
  mapWithStockItems(e, t, s, i, o) {
    if (!e)
      return [];
    const n = [], r = this.getLocaleTextFunc(), { beans: a, gos: l } = this, {
      pinnedCols: d,
      colAutosize: c,
      aggFuncSvc: u,
      rowGroupColsSvc: h,
      colNames: g,
      colModel: p,
      clipboardSvc: f,
      expansionSvc: m,
      focusSvc: b,
      csvCreator: w,
      excelCreator: C,
      menuSvc: v,
      colChooserFactory: F,
      sortSvc: R,
      chartMenuItemMapper: D,
      valueColsSvc: M,
      pinnedRowModel: I
    } = a, J = (W, E, oe, j) => {
      var Ce;
      switch (DD(l, W), W) {
        case "pinSubMenu":
          return d && E ? {
            name: r("pinColumn", "Pin Column"),
            icon: k("menuPin", a, null),
            subMenu: ["clearPinned", "pinLeft", "pinRight"]
          } : null;
        case "pinLeft":
          return d && E ? {
            name: r("pinLeft", "Pin Left"),
            action: () => d.setColsPinned([E], "left", j),
            checked: !!E && E.isPinnedLeft()
          } : null;
        case "pinRight":
          return d && E ? {
            name: r("pinRight", "Pin Right"),
            action: () => d.setColsPinned([E], "right", j),
            checked: !!E && E.isPinnedRight()
          } : null;
        case "clearPinned":
          return d && E ? {
            name: r("noPin", "No Pin"),
            action: () => d.setColsPinned([E], null, j),
            checked: !!E && !E.isPinned()
          } : null;
        case "pinRowSubMenu": {
          const z = l.get("enableRowPinning"), se = [], Re = (s == null ? void 0 : s.rowPinned) ?? ((Ce = s == null ? void 0 : s.pinnedSibling) == null ? void 0 : Ce.rowPinned);
          return Re && se.push("unpinRow"), z && z !== "bottom" && Re != "top" && se.push("pinTop"), z && z !== "top" && Re != "bottom" && se.push("pinBottom"), I != null && I.isManual() ? {
            name: r("pinRow", "Pin Row"),
            icon: k("rowPin", a, E),
            subMenu: se
          } : null;
        }
        case "pinTop":
          return I != null && I.isManual() ? {
            name: r("pinTop", "Pin to Top"),
            icon: k("rowPinTop", a, E),
            action: ({ node: z, column: se }) => z && I.pinRow(z, "top", se)
          } : null;
        case "pinBottom":
          return I != null && I.isManual() ? {
            name: r("pinBottom", "Pin to Bottom"),
            icon: k("rowPinBottom", a, E),
            action: ({ node: z, column: se }) => z && I.pinRow(z, "bottom", se)
          } : null;
        case "unpinRow":
          return I != null && I.isManual() ? {
            name: r("unpinRow", "Unpin Row"),
            icon: k("rowUnpin", a, E),
            action: ({ node: z, column: se }) => z && I.pinRow(z, null, se)
          } : null;
        case "valueAggSubMenu":
          return u && M && (E != null && E.isPrimary() || E != null && E.getColDef().pivotValueColumn) ? {
            name: r("valueAggregation", "Value Aggregation"),
            icon: k("menuValue", a, null),
            subMenu: ED(E, u, M, r),
            disabled: l.get("functionsReadOnly")
          } : null;
        case "autoSizeThis":
          return c ? {
            name: r("autosizeThisColumn", "Autosize This Column"),
            action: () => c.autoSizeColumn(E, j, l.get("skipHeaderOnAutoSize"))
          } : null;
        case "autoSizeAll":
          return c ? {
            name: r("autosizeAllColumns", "Autosize All Columns"),
            action: () => c.autoSizeAllColumns(j, l.get("skipHeaderOnAutoSize"))
          } : null;
        case "rowGroup":
          return h ? {
            name: r("groupBy", "Group by") + " " + g.getDisplayNameForColumn(E, "header"),
            disabled: l.get("functionsReadOnly") || (E == null ? void 0 : E.isRowGroupActive()) || !(E != null && E.getColDef().enableRowGroup),
            action: () => h.addColumns([E], j),
            icon: k("menuAddRowGroup", a, null)
          } : null;
        case "rowUnGroup":
          if (h && l.isModuleRegistered("SharedRowGrouping")) {
            const z = E == null ? void 0 : E.getColDef().showRowGroup, se = l.get("groupLockGroupColumns");
            let Re, bt, Ot;
            if (z === !0)
              Re = r("ungroupAll", "Un-Group All"), bt = l.get("functionsReadOnly") || se === -1 || se >= (h.columns.length ?? 0), Ot = () => h.setColumns(h.columns.slice(0, se), j);
            else if (typeof z == "string") {
              const Bt = p.getColDefCol(z), js = Bt != null ? g.getDisplayNameForColumn(Bt, "header") : z;
              Re = r("ungroupBy", "Un-Group by") + " " + js, bt = l.get("functionsReadOnly") || po(Bt, a), Ot = () => {
                h.removeColumns([z], j);
              };
            } else
              Re = r("ungroupBy", "Un-Group by") + " " + g.getDisplayNameForColumn(E, "header"), bt = l.get("functionsReadOnly") || !(E != null && E.isRowGroupActive()) || !(E != null && E.getColDef().enableRowGroup) || po(E, a), Ot = () => h.removeColumns([E], j);
            return {
              name: Re,
              disabled: bt,
              action: Ot,
              icon: k("menuRemoveRowGroup", a, null)
            };
          } else
            return null;
        case "resetColumns":
          return {
            name: r("resetColumns", "Reset Columns"),
            action: () => tC(a, j)
          };
        case "expandAll":
          return m ? {
            name: r("expandAll", "Expand All Row Groups"),
            action: () => m.expandAll(!0)
          } : null;
        case "contractAll":
          return m ? {
            name: r("collapseAll", "Collapse All Row Groups"),
            action: () => m.expandAll(!1)
          } : null;
        case "copy":
          return f ? {
            name: r("copy", "Copy"),
            shortcut: r("ctrlC", "Ctrl+C"),
            icon: k("clipboardCopy", a, null),
            action: () => f.copyToClipboard()
          } : null;
        case "copyWithHeaders":
          return f ? {
            name: r("copyWithHeaders", "Copy with Headers"),
            // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
            icon: k("clipboardCopy", a, null),
            action: () => f.copyToClipboard({ includeHeaders: !0 })
          } : null;
        case "copyWithGroupHeaders":
          return f ? {
            name: r("copyWithGroupHeaders", "Copy with Group Headers"),
            // shortcut: localeTextFunc('ctrlC','Ctrl+C'),
            icon: k("clipboardCopy", a, null),
            action: () => f.copyToClipboard({ includeHeaders: !0, includeGroupHeaders: !0 })
          } : null;
        case "cut":
          if (f) {
            const z = b.getFocusedCell(), se = z ? zn(a, z) : null, Re = se ? z == null ? void 0 : z.column.isCellEditable(se) : !1;
            return {
              name: r("cut", "Cut"),
              shortcut: r("ctrlX", "Ctrl+X"),
              icon: k("clipboardCut", a, null),
              disabled: !Re || l.get("suppressCutToClipboard"),
              action: () => f.cutToClipboard(void 0, "contextMenu")
            };
          } else
            return null;
        case "paste":
          return f ? {
            name: r("paste", "Paste"),
            shortcut: r("ctrlV", "Ctrl+V"),
            disabled: !0,
            icon: k("clipboardPaste", a, null),
            action: () => f.pasteFromClipboard()
          } : null;
        case "export": {
          const z = [];
          return !l.get("suppressCsvExport") && w && z.push("csvExport"), !l.get("suppressExcelExport") && C && z.push("excelExport"), z.length ? {
            name: r("export", "Export"),
            subMenu: z,
            icon: k("save", a, null)
          } : null;
        }
        case "csvExport":
          return w ? {
            name: r("csvExport", "CSV Export"),
            icon: k("csvExport", a, null),
            action: () => w.exportDataAsCsv()
          } : null;
        case "excelExport":
          return C ? {
            name: r("excelExport", "Excel Export"),
            icon: k("excelExport", a, null),
            action: () => C.exportDataAsExcel()
          } : null;
        case "separator":
          return W;
        case "pivotChart":
        case "chartRange":
          return D.getChartItems(W);
        case "columnFilter":
          return v && E ? {
            name: r("columnFilter", "Column Filter"),
            icon: k("filter", a, null),
            action: () => v.showFilterMenu({
              column: E,
              buttonElement: oe(),
              containerType: "columnFilter",
              positionBy: "button"
            })
          } : null;
        case "columnChooser": {
          const z = b.focusedHeader;
          return F ? {
            name: r("columnChooser", "Choose Columns"),
            icon: k("columns", a, null),
            action: () => F.showColumnChooser({
              column: E,
              eventSource: oe(),
              headerPosition: z
            })
          } : null;
        }
        case "sortAscending":
          return R ? {
            name: r("sortAscending", "Sort Ascending"),
            icon: k("sortAscending", a, null),
            action: () => R.setSortForColumn(E, "asc", !1, j)
          } : null;
        case "sortDescending":
          return R ? {
            name: r("sortDescending", "Sort Descending"),
            icon: k("sortDescending", a, null),
            action: () => R.setSortForColumn(E, "desc", !1, j)
          } : null;
        case "sortUnSort":
          return R ? {
            name: r("sortUnSort", "Clear Sort"),
            icon: k("sortUnSort", a, null),
            action: () => R.setSortForColumn(E, null, !1, j)
          } : null;
        default:
          return P(176, { key: W }), null;
      }
    };
    return e.forEach((W) => {
      let E;
      if (typeof W == "string" ? E = J(W, t, i, o) : E = { ...W }, !E)
        return;
      const oe = E, { subMenu: j } = oe;
      j && j instanceof Array && (oe.subMenu = this.mapWithStockItems(
        j,
        t,
        s,
        i,
        o
      )), E != null && n.push(E);
    }), Rg(n, ys), n;
  }
};
function ED(e, t, s, i) {
  let o;
  if (e.isPrimary())
    o = e;
  else {
    const r = e.getColDef().pivotValueColumn;
    o = T(r) ? r : void 0;
  }
  const n = [];
  if (o) {
    const r = o.isValueActive(), a = t.getFuncNames(o);
    n.push({
      name: i("noAggregation", "None"),
      action: () => {
        s.removeColumns([o], "contextMenu"), s.setColumnAggFunc(o, void 0, "contextMenu");
      },
      checked: !r
    }), a.forEach((l) => {
      n.push({
        name: i(l, t.getDefaultFuncLabel(l)),
        action: () => {
          s.setColumnAggFunc(o, l, "contextMenu"), s.addColumns([o], "contextMenu");
        },
        checked: r && o.getAggFunc() === l
      });
    });
  }
  return n;
}
var AD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "colMenuFactory";
  }
  createMenu(e, t, s, i) {
    const o = e.createManagedBean(
      new qn(0, {
        column: s ?? null,
        node: null,
        value: null
      })
    ), n = this.beans.menuItemMapper.mapWithStockItems(
      t,
      s ?? null,
      null,
      i,
      "columnMenu"
    );
    return o.addMenuItems(n), o;
  }
  getMenuItems(e = null, t = null) {
    var n;
    const s = this.getDefaultMenuOptions(e);
    let i;
    const o = (n = (e == null ? void 0 : e.getColDef()) ?? (t == null ? void 0 : t.getColGroupDef())) == null ? void 0 : n.mainMenuItems;
    if (Array.isArray(o))
      i = o;
    else if (typeof o == "function")
      i = o(
        N(this.gos, {
          column: e,
          columnGroup: t,
          defaultItems: s
        })
      );
    else {
      const r = this.gos.getCallback("getMainMenuItems");
      r ? i = r({
        column: e,
        columnGroup: t,
        defaultItems: s
      }) : i = s;
    }
    return Rg(i, ys), i;
  }
  getDefaultMenuOptions(e) {
    const t = [], { beans: s, gos: i } = this, {
      colChooserFactory: o,
      rowGroupColsSvc: n,
      colModel: r,
      expansionSvc: a,
      sortSvc: l,
      menuSvc: d,
      pinnedCols: c,
      aggFuncSvc: u,
      colAutosize: h
    } = s, g = fe(i), p = () => {
      !g && o && t.push("columnChooser"), t.push("resetColumns");
    };
    if (!e)
      return p(), t;
    const { colDef: f } = e, m = c && !f.lockPinned, b = (n == null ? void 0 : n.columns.length) ?? 0, w = b > 0, C = e.isPrimary(), v = u && // if primary, then only allow aggValue if grouping and it's a value columns
    C && w && e.isAllowValue() || // secondary columns can always have aggValue, as it means it's a pivot value column
    !C;
    if (l && !g && e.isSortable()) {
      const F = e.getSort();
      F !== "asc" && t.push("sortAscending"), F !== "desc" && t.push("sortDescending"), F && t.push("sortUnSort"), t.push(ys);
    }
    if (d != null && d.isFilterMenuItemEnabled(e) && (t.push("columnFilter"), t.push(ys)), m && t.push("pinSubMenu"), v && t.push("valueAggSubMenu"), (m || v) && t.push(ys), h && (t.push("autoSizeThis"), t.push("autoSizeAll"), t.push(ys)), n && i.isModuleRegistered("SharedRowGrouping")) {
      const F = t.length;
      f.showRowGroup ? t.push("rowUnGroup") : e.isAllowRowGroup() && C && (e.isRowGroupActive() ? po(e, s) || t.push("rowUnGroup") : t.push("rowGroup")), t.length > F && t.push(ys);
    }
    return p(), a && Ke(i) && (i.get("treeData") || b > (r.isPivotMode() ? 1 : 0)) && (t.push("expandAll"), t.push("contractAll")), t;
  }
}, ID = "ag-menu", kd = "ag-context-menu-open", TD = "ag-context-menu-loading-icon", LD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "contextMenuSvc", this.destroyLoadingSpinner = null, this.lastPromise = 0;
  }
  hideActiveMenu() {
    this.destroyBean(this.activeMenu);
  }
  getMenuItems(e, t, s, i) {
    const o = [], { clipboardSvc: n, chartSvc: r, csvCreator: a, excelCreator: l, colModel: d, rangeSvc: c, gos: u } = this.beans;
    if (T(e) && n && t && (u.get("suppressCutToClipboard") || o.push("cut"), o.push("copy", "copyWithHeaders", "copyWithGroupHeaders", "paste", "separator")), u.get("enableCharts") && r && (d.isPivotMode() && o.push("pivotChart"), c && !c.isEmpty() && o.push("chartRange")), T(e)) {
      const f = u.get("enableRowPinning"), m = u.get("isRowPinnable"), b = u.get("grandTotalRow");
      if (f) {
        const R = e.level > -1 && e.footer, D = e.level === -1 && e.footer;
        (D && !(b === "pinnedBottom" || b === "pinnedTop") || !D && !R) && ((m == null ? void 0 : m(e)) ?? !0) && o.push("pinRowSubMenu");
      }
      const w = u.get("suppressExcelExport") || !l, C = u.get("suppressCsvExport") || !a;
      !As() && (!w || !C) && o.push("export");
    }
    const h = o.length ? o : void 0, g = t == null ? void 0 : t.getColDef().contextMenuItems;
    if (Array.isArray(g))
      return g;
    if (typeof g == "function")
      return g(
        N(u, {
          column: t,
          node: e,
          value: s,
          defaultItems: h,
          event: i
        })
      );
    const p = u.getCallback("getContextMenuItems");
    return (p == null ? void 0 : p({ column: t, node: e, value: s, defaultItems: h, event: i })) ?? o;
  }
  getContextMenuPosition(e, t) {
    const s = this.getRowCtrl(e), i = this.getCellGui(s, t);
    if (!i)
      return { x: 0, y: (s == null ? void 0 : s.getRowYPosition()) ?? 0 };
    const o = i.getBoundingClientRect();
    return {
      x: o.x + o.width / 2,
      y: o.y + o.height / 2
    };
  }
  showContextMenu(e) {
    const t = e.rowNode ?? null, s = e.column ?? null;
    let { anchorToElement: i, value: o, source: n } = e;
    t && s && o == null && (o = this.beans.valueSvc.getValueForDisplay(s, t).value), i == null && (i = this.getContextMenuAnchorElement(t, s)), this.beans.menuUtils.onContextMenu({
      mouseEvent: e.mouseEvent ?? null,
      touchEvent: e.touchEvent ?? null,
      showMenuCallback: (r) => this.showMenu(t, s, o, r, i),
      source: n
    });
  }
  handleContextMenuMouseEvent(e, t, s, i) {
    var u;
    const o = (i == null ? void 0 : i.rowNode) ?? (s == null ? void 0 : s.rowNode) ?? null, n = (i == null ? void 0 : i.column) ?? ((u = s == null ? void 0 : s.findFullWidthInfoForEvent(e || t)) == null ? void 0 : u.column) ?? null, { valueSvc: r, ctrlsSvc: a } = this.beans, l = n ? r.getValue(n, o) : null, d = a.getGridBodyCtrl(), c = i ? i.eGui : d.eGridBody;
    this.showContextMenu({
      mouseEvent: e,
      touchEvent: t,
      rowNode: o,
      column: n,
      value: l,
      anchorToElement: c,
      source: "ui"
    });
  }
  showMenu(e, t, s, i, o) {
    const n = this.getMenuItems(e, t, s, i);
    if (lC(n)) {
      const r = this.lastPromise + 1;
      return this.lastPromise = r, this.destroyLoadingSpinner || this.createLoadingIcon(i), n.then((a) => {
        var u, h;
        if (this.lastPromise !== r)
          return;
        const { target: l } = i, d = !l;
        // check if there are actual menu items to be displayed
        a && a.length && // check if the element that triggered the context menu was removed from the DOM
        (d || He(l)) && // overlay was displayed
        !((u = this.beans.overlays) != null && u.isExclusive()) && this.createContextMenu({ menuItems: a, node: e, column: t, value: s, mouseEvent: i, anchorToElement: o }), (h = this.destroyLoadingSpinner) == null || h.call(this);
      }), !0;
    }
    return n === void 0 || !(n != null && n.length) ? !1 : (this.createContextMenu({ menuItems: n, node: e, column: t, value: s, mouseEvent: i, anchorToElement: o }), !0);
  }
  createLoadingIcon(e) {
    var l;
    const { beans: t } = this, s = this.getLocaleTextFunc(), i = k("loadingMenuItems", t), o = _({ tag: "div", cls: TD });
    o.appendChild(i);
    const n = Ns(t), r = Hn(t);
    if (!r) {
      P(54);
      return;
    }
    r.appendChild(o), (l = t.ariaAnnounce) == null || l.announceValue(
      s("ariaLabelLoadingContextMenu", "Loading Context Menu"),
      "contextmenu"
    ), t.environment.applyThemeClasses(o), $r(o, e, t);
    const a = (d) => {
      $r(o, d, t);
    };
    n.addEventListener("mousemove", a), this.destroyLoadingSpinner = () => {
      n.removeEventListener("mousemove", a), r.removeChild(o), this.destroyLoadingSpinner = null;
    };
  }
  createContextMenu(e) {
    const { menuItems: t, node: s, column: i, value: o, mouseEvent: n, anchorToElement: r } = e, { ctrlsSvc: a, focusSvc: l, popupSvc: d } = this.beans, c = a.getGridBodyCtrl().eGridBody, u = new kD(t, i, s, o);
    this.createBean(u);
    const h = u.getGui();
    i || l.clearFocusedCell();
    const g = {
      column: i,
      rowNode: s,
      type: "contextMenu",
      mouseEvent: n,
      ePopup: h,
      // move one pixel away so that accidentally double clicking
      // won't show the browser's contextmenu
      nudgeY: 1
    }, p = this.getLocaleTextFunc(), f = d == null ? void 0 : d.addPopup({
      modal: !0,
      eChild: h,
      closeOnEsc: !0,
      closedCallback: (b) => {
        Bn(this.beans, () => {
          c.classList.remove(kd), this.destroyBean(u), this.dispatchVisibleChangedEvent(!1, b === void 0 ? "api" : "ui");
        });
      },
      click: n,
      positionCallback: () => {
        const b = this.gos.get("enableRtl");
        d == null || d.positionPopupUnderMouseEvent({
          ...g,
          nudgeX: b ? (h.offsetWidth + 1) * -1 : 1
        });
      },
      // so when browser is scrolled down, or grid is scrolled, context menu stays with cell
      anchorToElement: r,
      ariaLabel: p("ariaLabelContextMenu", "Context Menu")
    });
    f && (c.classList.add(kd), u.afterGuiAttached({ container: "contextMenu", hidePopup: f.hideFunc })), this.activeMenu && this.hideActiveMenu(), this.activeMenu = u, u.addEventListener("destroyed", () => {
      this.activeMenu === u && (this.activeMenu = null);
    }), f && u.addEventListener(
      "closeMenu",
      (b) => f.hideFunc({
        mouseEvent: b.mouseEvent ?? void 0,
        keyboardEvent: b.keyboardEvent ?? void 0,
        forceHide: !0
      })
    );
    const m = n && n instanceof MouseEvent && n.type === "mousedown";
    this.dispatchVisibleChangedEvent(!0, m ? "api" : "ui");
  }
  dispatchVisibleChangedEvent(e, t = "ui") {
    this.eventSvc.dispatchEvent({
      type: "contextMenuVisibleChanged",
      visible: e,
      source: t
    });
  }
  getRowCtrl(e) {
    const { rowIndex: t, rowPinned: s } = e || {};
    if (t != null)
      return this.beans.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: s }) || void 0;
  }
  getCellGui(e, t) {
    if (!e || !t)
      return;
    const s = e.getCellCtrl(t);
    return (s == null ? void 0 : s.eGui) || void 0;
  }
  getContextMenuAnchorElement(e, t) {
    const s = this.beans.ctrlsSvc.getGridBodyCtrl().eGridBody, i = this.getRowCtrl(e);
    if (!i)
      return s;
    const o = this.getCellGui(i, t);
    return o || (i.isFullWidth() ? i.getFullWidthElement() : s);
  }
  destroy() {
    var e;
    (e = this.destroyLoadingSpinner) == null || e.call(this), super.destroy();
  }
}, kD = class extends L {
  constructor(e, t, s, i) {
    super({ tag: "div", cls: ID, role: "presentation" }), this.menuItems = e, this.column = t, this.node = s, this.value = i, this.menuList = null, this.focusedCell = null;
  }
  postConstruct() {
    const e = this.createManagedBean(
      new qn(0, {
        column: this.column,
        node: this.node,
        value: this.value
      })
    ), t = this.beans.menuItemMapper.mapWithStockItems(
      this.menuItems,
      this.column,
      this.node,
      () => this.getGui(),
      "contextMenu"
    );
    e.addMenuItems(t), this.appendChild(e), this.menuList = e, e.addEventListener("closeMenu", (s) => this.dispatchLocalEvent(s));
  }
  afterGuiAttached({ hidePopup: e }) {
    e && this.addDestroyFunc(e), this.focusedCell = this.beans.focusSvc.getFocusedCell();
    const t = this.menuList;
    t && Bn(this.beans, () => Ve(t.getGui()));
  }
  restoreFocusedCell() {
    const { beans: e, focusedCell: t } = this, s = e.focusSvc, i = s.getFocusedCell();
    if (i && t && Yu(i, t)) {
      const { rowIndex: o, rowPinned: n, column: r } = t;
      yi(e) && s.setFocusedCell({
        rowIndex: o,
        column: r,
        rowPinned: n,
        forceBrowserFocus: !0,
        preventScrollOnBrowserFocus: !Wn()
      });
    }
  }
  destroy() {
    super.destroy(), this.restoreFocusedCell();
  }
};
function GD(e) {
  return {
    tag: "div",
    cls: `ag-tabs ${e}`,
    children: [
      { tag: "div", ref: "eHeader" },
      {
        tag: "div",
        ref: "eBody",
        role: "presentation",
        cls: `ag-tabs-body ${e ? `${e}-body` : ""}`
      }
    ]
  };
}
var OD = class extends Ti {
  constructor(e) {
    super(GD(e.cssClass)), this.eHeader = x, this.eBody = x, this.items = [], this.tabbedItemScrollMap = /* @__PURE__ */ new Map(), this.params = e;
  }
  postConstruct() {
    this.setupHeader(), this.params.items && this.params.items.forEach((e) => this.addItem(e)), this.initialiseTabGuard({
      onTabKeyDown: this.onTabKeyDown.bind(this),
      handleKeyDown: this.handleKeyDown.bind(this),
      focusInnerElement: this.focusInnerElement.bind(this),
      focusTrapActive: !0
    }), this.addDestroyFunc(() => {
      var e, t, s;
      return (s = (t = (e = this.activeItem) == null ? void 0 : e.tabbedItem) == null ? void 0 : t.afterDetachedCallback) == null ? void 0 : s.call(t);
    });
  }
  setupHeader() {
    const { enableCloseButton: e, cssClass: t } = this.params, s = (i, o) => {
      i.classList.add(`ag-tabs-${o}`), t && i.classList.add(`${t}-${o}`);
    };
    e ? (this.setupCloseButton(s), this.eTabHeader = _({ tag: "div", role: "presentation" }), s(this.eHeader, "header-wrapper"), this.eHeader.appendChild(this.eTabHeader)) : this.eTabHeader = this.eHeader, Ne(this.eTabHeader, "tablist"), s(this.eTabHeader, "header");
  }
  setupCloseButton(e) {
    const t = _({ tag: "button" });
    e(t, "close-button");
    const s = k("close", this.beans);
    Ee(t, this.params.closeButtonAriaLabel), t.appendChild(s), this.addManagedElementListeners(t, { click: () => {
      var o, n;
      return (n = (o = this.params).onCloseClicked) == null ? void 0 : n.call(o);
    } });
    const i = _({ tag: "div", role: "presentation" });
    e(i, "close-button-wrapper"), i.appendChild(t), this.eHeader.appendChild(i), this.eCloseButton = t;
  }
  handleKeyDown(e) {
    switch (e.key) {
      case y.RIGHT:
      case y.LEFT: {
        if (!this.eTabHeader.contains(te(this.beans)))
          return;
        const t = e.key === y.RIGHT, s = this.gos.get("enableRtl"), i = this.items.indexOf(this.activeItem), o = t !== s ? Math.min(i + 1, this.items.length - 1) : Math.max(i - 1, 0);
        if (i === o)
          return;
        e.preventDefault();
        const n = this.items[o];
        this.showItemWrapper(n), n.eHeaderButton.focus();
        break;
      }
      case y.UP:
      case y.DOWN:
        e.stopPropagation();
        break;
    }
  }
  onTabKeyDown(e) {
    var h, g, p, f;
    if (e.defaultPrevented)
      return;
    const { beans: t, eHeader: s, eBody: i, activeItem: o, params: n } = this, { suppressTrapFocus: r, enableCloseButton: a } = n, l = te(t), d = e.target, c = e.shiftKey;
    if (s.contains(l)) {
      e.preventDefault(), a && c && !((h = this.eCloseButton) != null && h.contains(l)) ? (g = this.eCloseButton) == null || g.focus() : r && c ? (p = oa(pe(t).body, d)) == null || p.focus() : this.focusBody(e.shiftKey);
      return;
    }
    let u = null;
    if (cg(i, d) && (c && (u = oa(i, d)), !u && !r && (u = o.eHeaderButton)), !u && i.contains(l) && (u = Be(t, i, !1, c), !u)) {
      r && !c ? this.forceFocusOutOfContainer(c) : a && !c ? (e.preventDefault(), (f = this.eCloseButton) == null || f.focus()) : (e.preventDefault(), this.focusHeader());
      return;
    }
    u && (e.preventDefault(), u.focus());
  }
  focusInnerElement(e) {
    return e ? this.focusBody(!0) : (this.focusHeader(), !0);
  }
  focusHeader(e) {
    this.activeItem.eHeaderButton.focus({ preventScroll: e });
  }
  focusBody(e) {
    return Ve(this.eBody, e);
  }
  setAfterAttachedParams(e) {
    this.afterAttachedParams = e;
  }
  showFirstItem() {
    this.items.length > 0 && this.showItemWrapper(this.items[0]);
  }
  addItem(e) {
    const t = _({
      tag: "span",
      cls: "ag-tab",
      role: "tab",
      attrs: { tabindex: "-1" }
    });
    t.appendChild(e.title), this.eTabHeader.appendChild(t), Ee(t, e.titleLabel);
    const s = {
      tabbedItem: e,
      eHeaderButton: t
    };
    this.items.push(s), t.addEventListener("click", this.showItemWrapper.bind(this, s));
  }
  showItem(e) {
    const t = this.items.find((s) => s.tabbedItem === e);
    t && this.showItemWrapper(t);
  }
  showItemWrapper(e) {
    var i, o, n, r, a, l;
    const { tabbedItem: t, eHeaderButton: s } = e;
    if ((o = (i = this.params).onItemClicked) == null || o.call(i, { item: t }), this.activeItem === e) {
      (r = (n = this.params).onActiveItemClicked) == null || r.call(n);
      return;
    }
    this.lastScrollListener && (this.lastScrollListener = this.lastScrollListener()), de(this.eBody), t.bodyPromise.then((d) => {
      this.eBody.appendChild(d);
      const c = !Wn();
      if (this.params.suppressFocusBodyOnOpen || Ve(this.eBody, !1, c), t.afterAttachedCallback && t.afterAttachedCallback(this.afterAttachedParams), this.params.keepScrollPosition) {
        const u = t.getScrollableContainer && t.getScrollableContainer() || d;
        [this.lastScrollListener] = this.addManagedElementListeners(u, {
          scroll: () => {
            this.tabbedItemScrollMap.set(t.name, u.scrollTop);
          }
        });
        const h = this.tabbedItemScrollMap.get(t.name);
        h !== void 0 && setTimeout(() => {
          u.scrollTop = h;
        }, 0);
      }
    }), this.activeItem && (this.activeItem.eHeaderButton.classList.remove("ag-tab-selected"), (l = (a = this.activeItem.tabbedItem).afterDetachedCallback) == null || l.call(a)), s.classList.add("ag-tab-selected"), this.activeItem = e;
  }
}, ts = "filterMenuTab", ss = "generalMenuTab", Ss = "columnsMenuTab", Xo = [ss, ts, Ss], BD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "enterpriseMenuFactory";
  }
  hideActiveMenu() {
    this.destroyBean(this.activeMenu);
  }
  showMenuAfterMouseEvent(e, t, s, i, o) {
    const { column: n, columnGroup: r } = this.splitColumnOrGroup(e), a = o ? "filterMenuTab" : void 0;
    this.showMenu(
      n,
      r,
      (l) => {
        var c;
        const d = l.getGui();
        this.beans.popupSvc.positionPopupUnderMouseEvent({
          type: s,
          column: n,
          mouseEvent: t,
          ePopup: d
        }), a && ((c = l.showTab) == null || c.call(l, a)), this.dispatchVisibleChangedEvent(!0, !1, n, r, a);
      },
      s,
      a,
      void 0,
      t.target,
      i
    );
  }
  splitColumnOrGroup(e) {
    const t = e && wt(e);
    return { column: t ? e : void 0, columnGroup: t ? void 0 : e };
  }
  showMenuAfterButtonClick(e, t, s, i, o) {
    let n = -1, r = "left";
    this.gos.get("enableRtl") && (n = 1, r = "right");
    const a = o ? "filterMenuTab" : void 0, l = a ? [a] : void 0, d = fe(this.gos), c = (d ? 9 : 4) * n, u = d ? -23 : 4, { column: h, columnGroup: g } = this.splitColumnOrGroup(e);
    this.showMenu(
      h,
      g,
      (p) => {
        var m;
        const f = p.getGui();
        this.beans.popupSvc.positionPopupByComponent({
          type: s,
          column: h,
          eventSource: t,
          ePopup: f,
          alignSide: r,
          nudgeX: c,
          nudgeY: u,
          position: "under",
          keepWithinBounds: !0
        }), a && ((m = p.showTab) == null || m.call(p, a)), this.dispatchVisibleChangedEvent(!0, !1, h, g, a);
      },
      s,
      a,
      l,
      t,
      i
    );
  }
  showMenu(e, t, s, i, o, n, r, a) {
    var b;
    const l = this.getMenuParams(e, t, n, r);
    if (!l)
      return;
    const { menu: d, eMenuGui: c, anchorToElement: u, restoreFocusParams: h } = l, g = [], { menuUtils: p, popupSvc: f } = this.beans;
    g.push((w) => {
      const C = d.getGui();
      this.destroyBean(d), e && (Dn(e, !1, "contextMenu"), p.restoreFocusOnClose(h, C, w)), a == null || a();
    });
    const m = this.getLocaleTextFunc();
    if (f.addPopup({
      modal: !0,
      eChild: c,
      closeOnEsc: !0,
      closedCallback: (w) => {
        g.forEach((C) => C(w)), this.dispatchVisibleChangedEvent(!1, !1, e, t, o);
      },
      afterGuiAttached: (w) => d.afterGuiAttached(Object.assign({}, { container: i }, w)),
      // if defaultTab is not present, positionCallback will be called
      // after `showTabBasedOnPreviousSelection` is called.
      positionCallback: o ? () => s(d) : void 0,
      ariaLabel: m("ariaLabelColumnMenu", "Column Menu")
    }), o || ((b = d.showTabBasedOnPreviousSelection) == null || b.call(d), s(d)), cu(this.gos)) {
      const w = f.setPopupPositionRelatedToElement(c, u);
      w && e && this.addStopAnchoring(w, e, g);
    }
    d.addEventListener("tabSelected", (w) => {
      this.dispatchVisibleChangedEvent(!1, !0, e), this.lastSelectedTab = w.key, this.dispatchVisibleChangedEvent(!0, !0, e);
    }), e && Dn(e, !0, "contextMenu"), this.activeMenu = d, d.addEventListener("destroyed", () => {
      this.activeMenu === d && (this.activeMenu = null);
    });
  }
  addStopAnchoring(e, t, s) {
    e.then((i) => {
      t.__addEventListener("leftChanged", i), t.__addEventListener("visibleChanged", i), s.push(() => {
        t.__removeEventListener("leftChanged", i), t.__removeEventListener("visibleChanged", i);
      });
    });
  }
  getMenuParams(e, t, s, i) {
    const { focusSvc: o, visibleCols: n, ctrlsSvc: r } = this.beans, a = {
      column: e,
      headerPosition: o.focusedHeader,
      columnIndex: n.allCols.indexOf(e),
      eventSource: i
    }, l = this.createMenu(e, t, a, s, i);
    return l ? {
      menu: l,
      eMenuGui: l.getGui(),
      anchorToElement: i || r.getGridBodyCtrl().eGridBody,
      restoreFocusParams: a
    } : void 0;
  }
  createMenu(e, t, s, i, o) {
    if (fe(this.gos))
      return this.createBean(
        new ND(e, s, this.lastSelectedTab, i, o)
      );
    {
      const n = this.beans.colMenuFactory.getMenuItems(e, t);
      return n.length ? this.createBean(new HD(n, e, s, o)) : void 0;
    }
  }
  dispatchVisibleChangedEvent(e, t, s, i, o) {
    this.eventSvc.dispatchEvent({
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: t,
      key: this.lastSelectedTab ?? o ?? (fe(this.gos) ? ss : "columnMenu"),
      column: s ?? null,
      columnGroup: i ?? null
    });
  }
  isMenuEnabled(e) {
    var o;
    if (!fe(this.gos))
      return !0;
    const t = !((o = this.beans.filterManager) != null && o.isFilterAllowed(e)), s = e.getColDef().menuTabs ?? Xo;
    return (t && s.includes(ts) ? s.length - 1 : s.length) > 0;
  }
  showMenuAfterContextMenuEvent(e, t, s) {
    this.beans.menuUtils.onContextMenu({
      mouseEvent: t,
      touchEvent: s,
      source: "ui",
      showMenuCallback: (i) => (this.showMenuAfterMouseEvent(e, i, "columnMenu"), !0)
    });
  }
}, ND = class extends S {
  constructor(e, t, s, i, o) {
    super(), this.column = e, this.restoreFocusParams = t, this.initialSelection = s, this.restrictTo = i, this.sourceElement = o, this.tabFactories = {}, this.includeChecks = {};
    const { tabFactories: n, includeChecks: r } = this;
    n[ss] = this.createMainPanel.bind(this), n[ts] = this.createFilterPanel.bind(this), n[Ss] = this.createColumnsPanel.bind(this), r[ss] = () => !0, r[ts] = () => {
      var a;
      return e ? !!((a = this.beans.filterManager) != null && a.isFilterAllowed(e)) : !1;
    }, r[Ss] = () => !0;
  }
  postConstruct() {
    var s;
    const e = this.getTabsToCreate().map((i) => this.createTab(i)), t = new OD({
      items: e,
      cssClass: "ag-menu",
      onActiveItemClicked: this.onHidePopup.bind(this),
      onItemClicked: this.onTabItemClicked.bind(this)
    });
    this.tabbedLayout = this.createBean(t), (s = this.mainMenuList) == null || s.setParentComponent(t), this.addDestroyFunc(() => this.destroyBean(t));
  }
  getTabsToCreate() {
    var e;
    return this.restrictTo ? this.restrictTo : (((e = this.column) == null ? void 0 : e.getColDef().menuTabs) ?? Xo).filter(
      (t) => this.isValidMenuTabItem(t) && this.isNotSuppressed(t)
    );
  }
  isValidMenuTabItem(e) {
    let t = !0, s = Xo;
    return this.restrictTo != null && (t = this.restrictTo.indexOf(e) > -1, s = this.restrictTo), t = t && Xo.indexOf(e) > -1, t || P(175, { menuTabName: e, itemsToConsider: s }), t;
  }
  isNotSuppressed(e) {
    return this.includeChecks[e]();
  }
  createTab(e) {
    return this.tabFactories[e]();
  }
  showTabBasedOnPreviousSelection() {
    this.showTab(this.initialSelection);
  }
  showTab(e) {
    const { tabItemColumns: t, tabbedLayout: s, tabItemFilter: i, tabItemGeneral: o } = this;
    t && e === Ss ? s.showItem(t) : i && e === ts ? s.showItem(i) : o && e === ss ? s.showItem(o) : s.showFirstItem();
  }
  onTabItemClicked(e) {
    let t = null;
    switch (e.item) {
      case this.tabItemColumns:
        t = Ss;
        break;
      case this.tabItemFilter:
        t = ts;
        break;
      case this.tabItemGeneral:
        t = ss;
        break;
    }
    t && this.activateTab(t);
  }
  activateTab(e) {
    const t = {
      type: "tabSelected",
      key: e
    };
    this.dispatchLocalEvent(t);
  }
  createMainPanel() {
    const { beans: e, column: t } = this, s = e.colMenuFactory, i = s.createMenu(
      this,
      s.getMenuItems(t),
      this.column,
      () => this.sourceElement ?? this.getGui()
    );
    this.mainMenuList = i, i.addEventListener("closeMenu", this.onHidePopup.bind(this));
    const o = {
      title: k("legacyMenu", e, t),
      titleLabel: ss.replace("MenuTab", ""),
      bodyPromise: q.resolve(i.getGui()),
      name: ss
    };
    return this.tabItemGeneral = o, o;
  }
  onHidePopup(e) {
    this.beans.menuUtils.closePopupAndRestoreFocusOnSelect(
      this.hidePopupFunc,
      this.restoreFocusParams,
      e
    );
  }
  createFilterPanel() {
    const e = this.column ? this.createBean(new $a(this.column, "COLUMN_MENU")) : null;
    this.filterComp = e, e != null && e.hasFilter() || K(119);
    const t = (i) => e == null ? void 0 : e.afterGuiAttached(i), s = () => e == null ? void 0 : e.afterGuiDetached();
    return this.tabItemFilter = {
      title: k("filterTab", this.beans, this.column),
      titleLabel: ts.replace("MenuTab", ""),
      bodyPromise: q.resolve(e == null ? void 0 : e.getGui()),
      afterAttachedCallback: t,
      afterDetachedCallback: s,
      name: ts
    }, this.tabItemFilter;
  }
  createColumnsPanel() {
    const e = _({ tag: "div", cls: "ag-menu-column-select-wrapper" }), { beans: t, column: s } = this, o = t.colChooserFactory.createColumnSelectPanel(
      this,
      s
    ).getGui();
    o.classList.add("ag-menu-column-select"), e.appendChild(o);
    const n = {
      title: k("columns", t, s),
      //createColumnsIcon(),
      titleLabel: Ss.replace("MenuTab", ""),
      bodyPromise: q.resolve(e),
      name: Ss
    };
    return this.tabItemColumns = n, n;
  }
  afterGuiAttached(e) {
    const { container: t, hidePopup: s } = e;
    this.tabbedLayout.setAfterAttachedParams({ container: t, hidePopup: s }), s && (this.hidePopupFunc = s, this.addDestroyFunc(s));
  }
  getGui() {
    return this.tabbedLayout.getGui();
  }
  destroy() {
    super.destroy(), this.destroyBean(this.filterComp);
  }
}, HD = class extends L {
  constructor(e, t, s, i) {
    super({ tag: "div", ref: "eColumnMenu", cls: "ag-menu ag-column-menu", role: "presentation" }), this.menuItems = e, this.column = t, this.restoreFocusParams = s, this.sourceElement = i, this.eColumnMenu = x;
  }
  postConstruct() {
    const e = this.beans.colMenuFactory.createMenu(
      this,
      this.menuItems,
      this.column,
      () => this.sourceElement ?? this.getGui()
    );
    this.mainMenuList = e, e.addEventListener("closeMenu", this.onHidePopup.bind(this)), this.eColumnMenu.appendChild(e.getGui());
  }
  onHidePopup(e) {
    this.beans.menuUtils.closePopupAndRestoreFocusOnSelect(
      this.hidePopupFunc,
      this.restoreFocusParams,
      e
    );
  }
  afterGuiAttached({ hidePopup: e }) {
    e && (this.hidePopupFunc = e, this.addDestroyFunc(e)), Ve(this.mainMenuList.getGui());
  }
};
function VD(e, t) {
  const { contextMenuSvc: s } = e;
  if (!s)
    return;
  const { rowNode: i, column: o, value: n, x: r, y: a } = t || {};
  let { x: l, y: d } = s.getContextMenuPosition(i, o);
  r != null && (l = r), a != null && (d = a), s.showContextMenu({
    mouseEvent: new MouseEvent("mousedown", { clientX: l, clientY: d }),
    rowNode: i,
    column: o,
    value: n,
    source: "api"
  });
}
function _D(e, t) {
  var s;
  (s = e.colChooserFactory) == null || s.showColumnChooser({ chooserParams: t });
}
function WD(e) {
  var t;
  (t = e.colChooserFactory) == null || t.hideActiveColumnChooser();
}
var zD = class extends S {
  constructor() {
    super(...arguments), this.beanName = "menuUtils";
  }
  restoreFocusOnClose(e, t, s, i) {
    const { eventSource: o } = e, n = s instanceof KeyboardEvent;
    if (!i && !n || !o)
      return;
    const r = te(this.beans);
    // focus is outside of comp
    !t.contains(r) && // something else has focus
    !yi(this.beans) || this.focusHeaderCell(e);
  }
  closePopupAndRestoreFocusOnSelect(e, t, s) {
    let i;
    s && s.keyboardEvent && (i = s.keyboardEvent), e(i && { keyboardEvent: i });
    const o = this.beans, n = o.focusSvc, r = n.getFocusedCell();
    if (yi(o))
      if (r) {
        const { rowIndex: a, rowPinned: l, column: d } = r;
        n.setFocusedCell({
          rowIndex: a,
          column: d,
          rowPinned: l,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      } else
        this.focusHeaderCell(t);
  }
  onContextMenu(e) {
    const { mouseEvent: t, touchEvent: s, showMenuCallback: i, source: o } = e;
    if (!this.gos.get("allowContextMenuWithControlKey") && t && (t.ctrlKey || t.metaKey) || (t && this.blockMiddleClickScrollsIfNeeded(t), o === "ui" && this.gos.get("suppressContextMenu")))
      return;
    const n = t ?? s.touches[0];
    if (i(n)) {
      const r = t ?? s;
      r && r.cancelable && r.preventDefault();
    }
  }
  // make this async for react
  async focusHeaderCell(e) {
    const { column: t, columnIndex: s, headerPosition: i, eventSource: o } = e, { visibleCols: n, headerNavigation: r, focusSvc: a } = this.beans, l = await n.allCols.some((d) => d === t);
    if (this.isAlive()) {
      if (t != null && t.isAlive() && l && o && He(o)) {
        const d = Ua(o);
        d && (r == null || r.scrollToColumn(t), d.focus());
      } else if (i && s !== -1) {
        const d = n.allCols, c = d[s] || Z(d);
        c && a.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: i.headerRowIndex,
            column: c
          }
        });
      }
    }
  }
  blockMiddleClickScrollsIfNeeded(e) {
    this.gos.get("suppressMiddleClickScrolls") && e.which === 2 && e.preventDefault();
  }
}, Fg = {
  moduleName: "MenuCore",
  version: ce,
  beans: [MD, SD, zD],
  icons: {
    // context menu chart item
    chart: "chart",
    // columns in menu (column chooser / columns tab)
    columns: "columns",
    // loading async menu items
    loadingMenuItems: "loading",
    // "Pin column" item in column header menu
    menuPin: "pin",
    // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
    menuValue: "aggregation",
    // "Group by {column-name}" item in column header menu
    menuAddRowGroup: "group",
    // "Un-Group by {column-name}" item in column header menu
    menuRemoveRowGroup: "group",
    // context menu copy item
    clipboardCopy: "copy",
    // context menu cut item
    clipboardCut: "cut",
    // context menu paste item
    clipboardPaste: "paste",
    // context menu export item
    save: "save",
    // csv export
    csvExport: "csv",
    // excel export,
    excelExport: "excel",
    // show on column header when column is sorted ascending
    sortAscending: "asc",
    // show on column header when column is sorted descending
    sortDescending: "desc",
    // show on column header when column has no sort, only when enabled with colDef.unSortIcon=true
    sortUnSort: "none"
  },
  dependsOn: [Ie, cl, sg, gl]
}, UD = {
  moduleName: "ColumnMenu",
  version: ce,
  beans: [BD, AD, FD],
  icons: {
    ensureColumnVisible: "column-arrow",
    // menu tab icon in legacy tabbed enterprise column menu
    legacyMenu: "menu",
    // filter tab icon in legacy tabbed enterprise column menu
    filterTab: "filter",
    // column tool panel column group contracted (click to expand)
    columnSelectClosed: "tree-closed",
    // column tool panel column group expanded (click to contract)
    columnSelectOpen: "tree-open",
    // column tool panel header expand/collapse all button, shown when some children are expanded and
    //     others are collapsed
    columnSelectIndeterminate: "tree-indeterminate"
  },
  apiFunctions: {
    showColumnChooser: _D,
    hideColumnChooser: WD
  },
  dependsOn: [Fg, il, ol]
}, jD = {
  moduleName: "ContextMenu",
  version: ce,
  beans: [LD],
  apiFunctions: {
    showContextMenu: VD
  },
  dependsOn: [Fg]
}, $D = {
  moduleName: "Menu",
  version: ce,
  dependsOn: [UD, jD]
}, KD = (
  /*css*/
  ".ag-status-bar{border-top:var(--ag-footer-row-border);display:flex;justify-content:space-between;line-height:1.5;overflow:hidden;padding-left:calc(var(--ag-spacing)*4);padding-right:calc(var(--ag-spacing)*4)}.ag-status-panel,:where(.ag-status-panel.ag-status-panel-aggregations .ag-status-name-value){display:inline-flex}.ag-status-name-value{color:var(--ag-status-bar-label-color);font-weight:var(--ag-status-bar-label-font-weight);margin-left:var(--ag-spacing);margin-right:var(--ag-spacing);padding-bottom:var(--ag-widget-container-vertical-padding);padding-top:var(--ag-widget-container-vertical-padding);white-space:nowrap}.ag-status-name-value-value{color:var(--ag-status-bar-value-color);font-weight:var(--ag-status-bar-value-font-weight)}.ag-status-bar-left{display:inline-flex}.ag-status-bar-center{display:inline-flex;text-align:center}.ag-status-bar-right{display:inline-flex}"
);
function qD(e, t, s) {
  return e.getCompDetails(t, YD, void 0, s, !0);
}
var YD = {
  name: "statusPanel",
  optionalMethods: ["refresh"]
}, ZD = {
  tag: "div",
  cls: "ag-status-bar",
  children: [
    {
      tag: "div",
      ref: "eStatusBarLeft",
      cls: "ag-status-bar-left",
      role: "status"
    },
    {
      tag: "div",
      ref: "eStatusBarCenter",
      cls: "ag-status-bar-center",
      role: "status"
    },
    {
      tag: "div",
      ref: "eStatusBarRight",
      cls: "ag-status-bar-right",
      role: "status"
    }
  ]
}, QD = class extends L {
  constructor() {
    super(ZD), this.updateQueued = !1, this.panelsPromise = q.resolve(), this.eStatusBarLeft = x, this.eStatusBarCenter = x, this.eStatusBarRight = x, this.compDestroyFunctions = {}, this.registerCSS(KD);
  }
  wireBeans(e) {
    this.userCompFactory = e.userCompFactory, this.statusBarSvc = e.statusBarSvc;
  }
  postConstruct() {
    this.processStatusPanels(/* @__PURE__ */ new Map()), this.addManagedPropertyListeners(["statusBar"], this.handleStatusBarChanged.bind(this));
  }
  processStatusPanels(e) {
    var s;
    const t = (s = this.gos.get("statusBar")) == null ? void 0 : s.statusPanels;
    if (t) {
      const i = t.filter(
        (r) => r.align === "left"
      ), o = t.filter(
        (r) => r.align === "center"
      ), n = t.filter(
        (r) => !r.align || r.align === "right"
      );
      this.panelsPromise = q.all([
        this.createAndRenderComponents(
          i,
          this.eStatusBarLeft,
          e
        ),
        this.createAndRenderComponents(
          o,
          this.eStatusBarCenter,
          e
        ),
        this.createAndRenderComponents(
          n,
          this.eStatusBarRight,
          e
        )
      ]);
    } else
      this.setDisplayed(!1);
  }
  handleStatusBarChanged() {
    this.updateQueued || (this.updateQueued = !0, this.panelsPromise.then(() => {
      this.updateStatusBar(), this.updateQueued = !1;
    }));
  }
  updateStatusBar() {
    var i;
    const e = (i = this.gos.get("statusBar")) == null ? void 0 : i.statusPanels, t = Array.isArray(e) && e.length > 0;
    this.setDisplayed(t);
    const s = /* @__PURE__ */ new Map();
    t && e.forEach((o) => {
      const n = o.key ?? o.statusPanel, r = this.statusBarSvc.getStatusPanel(n);
      if (r != null && r.refresh) {
        const a = N(this.gos, {
          ...o.statusPanelParams ?? {},
          key: n
        });
        r.refresh(a) && (s.set(n, r), delete this.compDestroyFunctions[n], De(r.getGui()));
      }
    }), this.resetStatusBar(), t && this.processStatusPanels(s);
  }
  resetStatusBar() {
    de(this.eStatusBarLeft), de(this.eStatusBarCenter), de(this.eStatusBarRight), this.destroyComponents(), this.statusBarSvc.unregisterAllComponents();
  }
  destroy() {
    this.destroyComponents(), super.destroy();
  }
  destroyComponents() {
    Object.values(this.compDestroyFunctions).forEach((e) => e()), this.compDestroyFunctions = {};
  }
  createAndRenderComponents(e, t, s) {
    const i = [];
    return e.forEach((o) => {
      const n = o.key || o.statusPanel, r = s.get(n);
      let a;
      if (r)
        a = q.resolve(r);
      else {
        const l = qD(
          this.userCompFactory,
          o,
          N(this.gos, { key: n })
        );
        if (l == null)
          return;
        a = l.newAgStackInstance();
      }
      i.push({
        key: n,
        promise: a
      });
    }), q.all(i.map((o) => o.promise)).then(() => {
      i.forEach((o) => {
        o.promise.then((n) => {
          const r = () => {
            this.destroyBean(n);
          };
          this.isAlive() ? (this.statusBarSvc.registerStatusPanel(o.key, n), t.appendChild(n.getGui()), this.compDestroyFunctions[o.key] = r) : r();
        });
      });
    });
  }
}, XD = {
  selector: "AG-STATUS-BAR",
  component: QD
}, JD = {
  tag: "div",
  cls: "ag-status-name-value",
  children: [
    { tag: "span", ref: "eLabel" },
    ":Â ",
    { tag: "span", ref: "eValue", cls: "ag-status-name-value-value" }
  ]
}, Ro = class extends L {
  constructor() {
    super(JD), this.eLabel = x, this.eValue = x;
  }
  setLabel(e, t) {
    this.setDisplayed(!1), this.eLabel.textContent = this.getLocaleTextFunc()(e, t);
  }
  setValue(e, t) {
    this.eValue.textContent = this.valueFormatter(
      N(this.gos, { value: e, totalRows: t, key: this.key })
    );
  }
}, e0 = {
  selector: "AG-NAME-VALUE",
  component: Ro
}, Pg = (e) => {
  let t = 0;
  return e.forEachNodeAfterFilter((s) => {
    s.data && t++;
  }), t;
}, Fo = (e) => {
  let t = 0;
  return e.forEachNode((s) => {
    s.data && t++;
  }), t;
};
function t0(e, t) {
  return typeof e != "number" ? "" : Di(Math.round(e * 100) / 100, t);
}
var s0 = {
  tag: "div",
  cls: "ag-status-panel ag-status-panel-aggregations",
  children: [
    {
      tag: "ag-name-value",
      ref: "avgAggregationComp"
    },
    {
      tag: "ag-name-value",
      ref: "countAggregationComp"
    },
    {
      tag: "ag-name-value",
      ref: "minAggregationComp"
    },
    {
      tag: "ag-name-value",
      ref: "maxAggregationComp"
    },
    {
      tag: "ag-name-value",
      ref: "sumAggregationComp"
    }
  ]
}, i0 = class extends L {
  constructor() {
    super(s0, [e0]), this.sumAggregationComp = x, this.countAggregationComp = x, this.minAggregationComp = x, this.maxAggregationComp = x, this.avgAggregationComp = x;
  }
  postConstruct() {
    if (!Ke(this.gos) && !nt(this.gos)) {
      P(221);
      return;
    }
    this.avgAggregationComp.setLabel("avg", "Average"), this.countAggregationComp.setLabel("count", "Count"), this.minAggregationComp.setLabel("min", "Min"), this.maxAggregationComp.setLabel("max", "Max"), this.sumAggregationComp.setLabel("sum", "Sum"), this.addManagedEventListeners({
      cellSelectionChanged: this.onCellSelectionChanged.bind(this),
      modelUpdated: this.onCellSelectionChanged.bind(this)
    });
  }
  init(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.params = e;
    const t = e.valueFormatter ?? (({ value: i }) => t0(i, this.getLocaleTextFunc.bind(this))), s = ["avg", "count", "min", "max", "sum"];
    for (const i of s) {
      const o = this.getAllowedAggregationValueComponent(i);
      o && (o.key = i, o.valueFormatter = t.bind(this));
    }
    return this.onCellSelectionChanged(), !0;
  }
  setAggregationComponentValue(e, t, s) {
    var n;
    const i = this.getAllowedAggregationValueComponent(e), o = Fo(this.beans.rowModel);
    T(i) && i ? (i.setValue(t, o), i.setDisplayed(s)) : (n = this.getAggregationValueComponent(e)) == null || n.setDisplayed(!1);
  }
  getAllowedAggregationValueComponent(e) {
    const { aggFuncs: t } = this.params;
    return !t || t.includes(e) ? this.getAggregationValueComponent(e) : null;
  }
  getAggregationValueComponent(e) {
    const t = `${e}AggregationComp`;
    return this[t];
  }
  onCellSelectionChanged() {
    const e = this.beans, { rangeSvc: t, valueSvc: s } = e, i = t == null ? void 0 : t.getCellRanges();
    let o = 0, n = 0, r = 0, a = null, l = null;
    const d = {};
    if (i != null && i.length && t)
      for (let h = 0; h < i.length; h++) {
        const g = i[h];
        let p = t.getRangeStartRow(g);
        const f = t.getRangeEndRow(g);
        for (; !(ie(p) || !p || Zu(f, p) || !p || !g.columns); )
          g.columns.forEach((b) => {
            if (p === null)
              return;
            const w = yv({
              rowPinned: p.rowPinned,
              column: b,
              rowIndex: p.rowIndex
            });
            if (d[w])
              return;
            d[w] = !0;
            const C = zn(e, p);
            if (ie(C))
              return;
            let v = s.getValue(b, C);
            ie(v) || v === "" || (n++, !(typeof v == "object" && "value" in v && (v = v.value, v === "")) && (typeof v == "string" && (v = Number(v)), typeof v == "number" && !isNaN(v) && (o += v, (l === null || v > l) && (l = v), (a === null || v < a) && (a = v), r++)));
          }), p = Jr(e, p);
      }
    const c = n > 1, u = r > 1;
    this.setAggregationComponentValue("count", n, c), this.setAggregationComponentValue("sum", o, u), this.setAggregationComponentValue("min", a, u), this.setAggregationComponentValue("max", l, u), this.setAggregationComponentValue("avg", o / r, u);
  }
}, o0 = class extends Ro {
  postConstruct() {
    if (this.setLabel("filteredRows", "Filtered"), !Ke(this.gos)) {
      P(222);
      return;
    }
    this.addCss("ag-status-panel"), this.addCss("ag-status-panel-filtered-row-count"), this.setDisplayed(!0);
    const e = this.onDataChanged.bind(this);
    this.addManagedEventListeners({ modelUpdated: e });
  }
  onDataChanged() {
    const { rowModel: e } = this.beans, t = Fo(e), s = Pg(e);
    this.setValue(s, t), this.setDisplayed(t !== s);
  }
  init(e) {
    this.refresh(e), this.onDataChanged();
  }
  updateValueFormatter(e) {
    this.valueFormatter = e ?? (({ value: t }) => Di(t, this.getLocaleTextFunc.bind(this)));
  }
  refresh(e) {
    const { key: t, valueFormatter: s } = e;
    return this.key = t, this.updateValueFormatter(s), !0;
  }
}, n0 = class extends Ro {
  postConstruct() {
    const e = this.gos;
    if (!Ke(e) && !nt(e)) {
      P(223);
      return;
    }
    this.setLabel("selectedRows", "Selected"), this.addCss("ag-status-panel"), this.addCss("ag-status-panel-selected-row-count");
    const t = this.onRowSelectionChanged.bind(this);
    this.addManagedEventListeners({ modelUpdated: t, selectionChanged: t });
  }
  onRowSelectionChanged() {
    const { selectionSvc: e, rowModel: t } = this.beans, s = (e == null ? void 0 : e.getSelectionCount()) ?? 0, i = Fo(t);
    if (this.setValue(s, i), s < 0) {
      this.setDisplayed(!0);
      return;
    }
    this.setDisplayed(s > 0);
  }
  init(e) {
    this.refresh(e), this.onRowSelectionChanged();
  }
  updateValueFormatter(e) {
    this.valueFormatter = e ?? (({ value: t }) => t == null || t >= 0 ? Di(t, this.getLocaleTextFunc.bind(this)) : this.getLocaleTextFunc()("statusBarLastRowUnknown", "?"));
  }
  refresh(e) {
    const { key: t, valueFormatter: s } = e;
    return this.key = t, this.updateValueFormatter(s), !0;
  }
}, r0 = class extends Ro {
  postConstruct() {
    if (!Ke(this.gos)) {
      P(224);
      return;
    }
    this.setLabel("totalAndFilteredRows", "Rows"), this.addCss("ag-status-panel"), this.addCss("ag-status-panel-total-and-filtered-row-count"), this.setDisplayed(!0), this.addManagedEventListeners({ modelUpdated: this.onDataChanged.bind(this) });
  }
  onDataChanged() {
    const { rowModel: e } = this.beans, t = Pg(e), s = Fo(e);
    this.setValue(t, s);
  }
  init(e) {
    this.refresh(e), this.onDataChanged();
  }
  updateValueFormatter(e) {
    this.valueFormatter = e ?? (({ value: t, totalRows: s }) => {
      const i = this.getLocaleTextFunc.bind(this), o = Di(t, i), n = Di(s ?? t, i);
      if (t === s)
        return o;
      const r = i();
      return `${o} ${r("of", "of")} ${n}`;
    });
  }
  refresh(e) {
    const { key: t, valueFormatter: s } = e;
    return this.key = t, this.updateValueFormatter(s), !0;
  }
}, a0 = class extends Ro {
  postConstruct() {
    if (this.setLabel("totalRows", "Total Rows"), !Ke(this.gos)) {
      P(225);
      return;
    }
    this.addCss("ag-status-panel"), this.addCss("ag-status-panel-total-row-count"), this.setDisplayed(!0), this.addManagedEventListeners({ modelUpdated: this.onDataChanged.bind(this) });
  }
  onDataChanged() {
    const e = Fo(this.beans.rowModel);
    this.setValue(e, e);
  }
  init(e) {
    this.refresh(e), this.onDataChanged();
  }
  updateValueFormatter(e) {
    this.valueFormatter = e ?? (({ value: t }) => Di(t, this.getLocaleTextFunc.bind(this)));
  }
  refresh(e) {
    const { key: t, valueFormatter: s } = e;
    return this.key = t, this.updateValueFormatter(s), !0;
  }
};
function l0(e, t) {
  var i;
  const s = (i = e.statusBarSvc) == null ? void 0 : i.getStatusPanel(t);
  return vn(s);
}
var d0 = class extends S {
  // tslint:disable-next-line
  constructor() {
    super(), this.beanName = "statusBarSvc", this.comps = /* @__PURE__ */ new Map();
  }
  registerStatusPanel(e, t) {
    this.comps.set(e, t);
  }
  unregisterStatusPanel(e) {
    this.comps.delete(e);
  }
  unregisterAllComponents() {
    this.comps.clear();
  }
  getStatusPanel(e) {
    return this.comps.get(e);
  }
  destroy() {
    this.unregisterAllComponents(), super.destroy();
  }
}, c0 = {
  moduleName: "StatusBar",
  version: ce,
  beans: [d0],
  userComponents: {
    agAggregationComponent: i0,
    agTotalRowCountComponent: a0,
    agFilteredRowCountComponent: o0,
    agTotalAndFilteredRowCountComponent: r0,
    agSelectedRowCountComponent: n0
  },
  selectors: [XD],
  apiFunctions: {
    getStatusPanel: l0
  },
  dependsOn: [Ie, Yh]
};
function u0(e) {
  const t = e.cssIdentifier || "default", s = e.direction || "vertical";
  return {
    tag: "div",
    cls: `ag-group ag-${t}-group`,
    role: "presentation",
    children: [
      {
        tag: "div",
        ref: "eToolbar",
        cls: `ag-group-toolbar ag-${t}-group-toolbar`,
        children: [{ tag: "ag-checkbox", ref: "cbGroupEnabled" }]
      },
      {
        tag: "div",
        ref: "eContainer",
        cls: `ag-group-container ag-group-container-${s} ag-${t}-group-container`
      }
    ]
  };
}
var Dg = class extends L {
  constructor(e = {}) {
    super(u0(e), [Ii]), this.params = e, this.suppressEnabledCheckbox = !0, this.suppressToggleExpandOnEnableChange = !1, this.eToolbar = x, this.cbGroupEnabled = x, this.eContainer = x;
    const {
      enabled: t,
      items: s,
      suppressEnabledCheckbox: i,
      expanded: o,
      suppressToggleExpandOnEnableChange: n,
      useToggle: r
    } = e;
    this.cssIdentifier = e.cssIdentifier || "default", this.enabled = t ?? !0, this.items = s || [], this.useToggle = r ?? !1, this.alignItems = e.alignItems || "center", this.expanded = o ?? !0, i != null && (this.suppressEnabledCheckbox = i), n != null && (this.suppressToggleExpandOnEnableChange = n);
  }
  postConstruct() {
    if (this.setupTitleBar(), this.items.length) {
      const o = this.items;
      this.items = [], this.addItems(o);
    }
    const e = this.getLocaleTextFunc();
    this.cbGroupEnabled.setLabel(e("enabled", "Enabled")), this.enabled && this.setEnabled(this.enabled, void 0, !0), this.setAlignItems(this.alignItems);
    const { onEnableChange: t, onExpandedChange: s, suppressOpenCloseIcons: i } = this.params;
    this.hideEnabledCheckbox(this.suppressEnabledCheckbox), this.hideOpenCloseIcons(i ?? !1), this.refreshChildDisplay(), G(this.eContainer, this.expanded), this.cbGroupEnabled.onValueChange((o) => {
      this.setEnabled(o, !0, this.suppressToggleExpandOnEnableChange), this.dispatchEnableChangeEvent(o);
    }), t != null && this.onEnableChange(t), s != null && this.onExpandedChange(s);
  }
  refreshChildDisplay() {
    var e;
    G(this.eToolbar, this.expanded && !this.suppressEnabledCheckbox), (e = this.eTitleBar) == null || e.refreshOnExpand(this.expanded);
  }
  isExpanded() {
    return this.expanded;
  }
  setAlignItems(e) {
    this.alignItems !== e && this.removeCss(`ag-group-item-alignment-${this.alignItems}`), this.alignItems = e;
    const t = `ag-group-item-alignment-${this.alignItems}`;
    return this.addCss(t), this;
  }
  toggleGroupExpand(e, t) {
    var s;
    if ((s = this.eTitleBar) != null && s.isSuppressCollapse() && !this.useToggle)
      e = !0, t = !0;
    else if (e = e ?? !this.expanded, this.expanded === e)
      return this;
    return this.expanded = e, this.refreshChildDisplay(), G(this.eContainer, e), t || this.dispatchLocalEvent({
      type: e ? "expanded" : "collapsed"
    }), this;
  }
  addItems(e) {
    e.forEach((t) => this.addItem(t));
  }
  prependItem(e) {
    this.insertItem(e, !0);
  }
  addItem(e) {
    this.insertItem(e, !1);
  }
  insertItem(e, t) {
    const s = this.eContainer, i = e instanceof L ? e.getGui() : e;
    i.classList.add("ag-group-item", `ag-${this.cssIdentifier}-group-item`), t ? (s.insertAdjacentElement("afterbegin", i), this.items.unshift(i)) : (s.appendChild(i), this.items.push(i));
  }
  hideItem(e, t) {
    const s = this.items[t];
    G(s, !e);
  }
  getItemIndex(e) {
    const t = e instanceof L ? e.getGui() : e;
    return this.items.indexOf(t);
  }
  setTitle(e) {
    var t;
    return (t = this.eTitleBar) == null || t.setTitle(e), this;
  }
  addTitleBarWidget(e) {
    var t;
    return (t = this.eTitleBar) == null || t.addWidget(e), this;
  }
  addCssClassToTitleBar(e) {
    var t;
    (t = this.eTitleBar) == null || t.addCss(e);
  }
  dispatchEnableChangeEvent(e) {
    const t = {
      type: "enableChange",
      enabled: e
    };
    this.dispatchLocalEvent(t);
  }
  setEnabled(e, t, s) {
    var i;
    return this.enabled = e, this.refreshDisabledStyles(), s || this.toggleGroupExpand(e), t || (this.cbGroupEnabled.setValue(e), (i = this.eToggle) == null || i.setValue(e)), this;
  }
  isEnabled() {
    return this.enabled;
  }
  onEnableChange(e) {
    return this.addManagedListeners(this, { enableChange: (t) => e(t.enabled) }), this;
  }
  onExpandedChange(e) {
    return this.addManagedListeners(this, {
      expanded: () => e(!0),
      collapsed: () => e(!1)
    }), this;
  }
  hideEnabledCheckbox(e) {
    return this.suppressEnabledCheckbox = e, this.refreshChildDisplay(), this.refreshDisabledStyles(), this;
  }
  hideOpenCloseIcons(e) {
    var t;
    return (t = this.eTitleBar) == null || t.hideOpenCloseIcons(e), this;
  }
  refreshDisabledStyles() {
    var t;
    const e = !this.enabled;
    this.eContainer.classList.toggle("ag-disabled", e), (t = this.eTitleBar) == null || t.refreshDisabledStyles(this.suppressEnabledCheckbox && e), this.eContainer.classList.toggle("ag-disabled-group-container", e);
  }
  setupTitleBar() {
    const e = this.useToggle ? this.createToggleTitleBar() : this.createDefaultTitleBar();
    this.eToolbar.insertAdjacentElement("beforebegin", e.getGui());
  }
  createDefaultTitleBar() {
    const e = this.createManagedBean(new g0(this.params));
    return this.eTitleBar = e, e.refreshOnExpand(this.expanded), this.addManagedListeners(e, {
      expandedChanged: (t) => this.toggleGroupExpand(t.expanded)
    }), e;
  }
  createToggleTitleBar() {
    const e = this.createManagedBean(
      new bh({
        value: this.enabled,
        label: this.params.title,
        labelAlignment: "left",
        labelWidth: "flex",
        onValueChange: (t) => {
          this.setEnabled(t, !0), this.dispatchEnableChangeEvent(t);
        }
      })
    );
    return e.addCss("ag-group-title-bar"), e.addCss(`ag-${this.params.cssIdentifier ?? "default"}-group-title-bar ag-unselectable`), this.eToggle = e, this.toggleGroupExpand(this.enabled), e;
  }
}, Mr = "ag-disabled-group-title-bar";
function h0(e) {
  const t = e.cssIdentifier ?? "default";
  return {
    tag: "div",
    cls: `ag-group-title-bar ag-${t}-group-title-bar ag-unselectable`,
    role: e.suppressKeyboardNavigation ? "presentation" : "role",
    children: [
      {
        tag: "span",
        ref: "eGroupOpenedIcon",
        cls: `ag-group-title-bar-icon ag-${t}-group-title-bar-icon`,
        role: "presentation"
      },
      {
        tag: "span",
        ref: "eGroupClosedIcon",
        cls: `ag-group-title-bar-icon ag-${t}-group-title-bar-icon`,
        role: "presentation"
      },
      { tag: "span", ref: "eTitle", cls: `ag-group-title ag-${t}-group-title` }
    ]
  };
}
var g0 = class extends L {
  constructor(e = {}) {
    super(h0(e)), this.suppressOpenCloseIcons = !1, this.suppressKeyboardNavigation = !1, this.eGroupOpenedIcon = x, this.eGroupClosedIcon = x, this.eTitle = x;
    const { title: t, suppressOpenCloseIcons: s, suppressKeyboardNavigation: i } = e;
    t && t.length > 0 && (this.title = t), s != null && (this.suppressOpenCloseIcons = s), this.suppressKeyboardNavigation = i ?? !1;
  }
  postConstruct() {
    this.setTitle(this.title), this.hideOpenCloseIcons(this.suppressOpenCloseIcons), this.setupExpandContract();
  }
  setupExpandContract() {
    this.eGroupClosedIcon.appendChild(ho("accordionClosed", this.beans, null)), this.eGroupOpenedIcon.appendChild(ho("accordionOpen", this.beans, null)), this.addManagedElementListeners(this.getGui(), {
      click: () => this.dispatchExpandChanged(),
      keydown: (e) => {
        switch (e.key) {
          case y.ENTER:
          case y.SPACE:
            e.preventDefault(), this.dispatchExpandChanged();
            break;
          case y.RIGHT:
          case y.LEFT:
            e.preventDefault(), this.dispatchExpandChanged(e.key === y.RIGHT);
            break;
        }
      }
    });
  }
  refreshOnExpand(e) {
    this.refreshAriaStatus(e), this.refreshOpenCloseIcons(e);
  }
  refreshAriaStatus(e) {
    this.suppressOpenCloseIcons || ot(this.getGui(), e);
  }
  refreshOpenCloseIcons(e) {
    const t = !this.suppressOpenCloseIcons;
    G(this.eGroupOpenedIcon, t && e), G(this.eGroupClosedIcon, t && !e);
  }
  isSuppressCollapse() {
    return this.suppressOpenCloseIcons;
  }
  dispatchExpandChanged(e) {
    const t = {
      type: "expandedChanged",
      expanded: e
    };
    this.dispatchLocalEvent(t);
  }
  setTitle(e) {
    const t = this.getGui(), s = !!e && e.length > 0;
    e = s ? e : void 0, this.eTitle.textContent = e ?? "", G(t, s), e !== this.title && (this.title = e);
    const i = t.classList.contains(Mr);
    return this.refreshDisabledStyles(i), this;
  }
  addWidget(e) {
    return this.getGui().appendChild(e), this;
  }
  hideOpenCloseIcons(e) {
    return this.suppressOpenCloseIcons = e, e && this.dispatchExpandChanged(!0), this;
  }
  refreshDisabledStyles(e) {
    const t = this.getGui();
    e ? (t.classList.add(Mr), t.removeAttribute("tabindex")) : (t.classList.remove(Mr), typeof this.title == "string" && !this.suppressKeyboardNavigation ? t.setAttribute("tabindex", "0") : t.removeAttribute("tabindex"));
  }
}, p0 = {
  selector: "AG-GROUP-COMPONENT",
  component: Dg
};
function Mg(e) {
  const { filters: t } = e;
  return t && t.length > 0 ? t : [{ filter: "agTextColumnFilter" }, { filter: "agSetColumnFilter" }];
}
function Gd(e, t) {
  if (e != null)
    for (let s = e.length - 1; s >= 0; s--)
      t(e[s], s);
}
function f0(e, t) {
  return t.title != null ? t.title : e instanceof Ka ? e.getFilterTitle() : "Filter";
}
var Eg = class extends Ti {
  constructor() {
    super({ tag: "div", cls: "ag-multi-filter ag-menu-list-compact" }), this.filterType = "multi", this.filterDefs = [], this.filters = [], this.guiDestroyFuncs = [], this.filterGuis = [], this.activeFilterIndices = [], this.lastActivatedMenuItem = null, this.afterFiltersReadyFuncs = [];
  }
  postConstruct() {
    this.initialiseTabGuard({
      onFocusIn: (e) => this.onFocusIn(e)
    });
  }
  init(e) {
    this.params = e, this.filterDefs = Mg(e);
    const { column: t, filterChangedCallback: s } = e;
    this.column = t, this.filterChangedCallback = s;
    const i = [];
    return this.filterDefs.forEach((o, n) => {
      const r = this.createFilter(o, n);
      r != null && i.push(r);
    }), new q((o) => {
      q.all(i).then((n) => {
        this.filters = n, this.refreshGui("columnMenu").then(() => {
          o();
        });
      });
    }).then(() => {
      this.afterFiltersReadyFuncs.forEach((o) => o()), this.afterFiltersReadyFuncs.length = 0;
    });
  }
  refreshGui(e) {
    return e === this.lastOpenedInContainer ? q.resolve() : (this.tabGuardFeature.removeAllChildrenExceptTabGuards(), this.destroyChildren(), q.all(
      this.filters.map((t, s) => {
        const i = this.filterDefs[s], o = f0(t, i);
        let n;
        if (i.display === "subMenu" && e !== "toolPanel")
          n = this.insertFilterMenu(t, o).then(
            (r) => r.getGui()
          );
        else if (i.display === "subMenu" || i.display === "accordion") {
          const r = this.insertFilterGroup(t, o);
          n = q.resolve(r.getGui());
        } else
          n = q.resolve(t.getGui());
        return n;
      })
    ).then((t) => {
      t.forEach((s, i) => {
        i > 0 && this.appendChild(_({ tag: "div", cls: "ag-filter-separator" })), this.appendChild(s);
      }), this.filterGuis = t, this.lastOpenedInContainer = e;
    }));
  }
  destroyChildren() {
    this.guiDestroyFuncs.forEach((e) => e()), this.guiDestroyFuncs.length = 0, this.filterGuis.length = 0;
  }
  insertFilterMenu(e, t) {
    const s = this.createBean(new ra());
    return s.init({
      menuItemDef: {
        name: t,
        subMenu: [],
        subMenuRole: "dialog",
        cssClasses: ["ag-multi-filter-menu-item"],
        menuItem: gg,
        menuItemParams: {
          cssClassPrefix: "ag-compact-menu-option",
          isCompact: !0
        }
      },
      level: 0,
      isAnotherSubMenuOpen: () => !1,
      childComponent: e,
      contextParams: {
        column: null,
        node: null,
        value: null
      }
    }).then(() => {
      s.setParentComponent(this), this.guiDestroyFuncs.push(() => this.destroyBean(s)), this.addManagedListeners(s, {
        menuItemActivated: (o) => {
          this.lastActivatedMenuItem && this.lastActivatedMenuItem !== o.menuItem && this.lastActivatedMenuItem.deactivate(), this.lastActivatedMenuItem = o.menuItem;
        }
      });
      const i = s.getGui();
      return s.addManagedElementListeners(i, {
        // `AgMenuList` normally handles keyboard navigation, so need to do here
        keydown: (o) => {
          const { key: n } = o;
          switch (n) {
            case y.UP:
            case y.RIGHT:
            case y.DOWN:
            case y.LEFT:
              o.preventDefault(), n === y.RIGHT && s.openSubMenu(!0);
              break;
          }
        },
        focusin: () => s.activate(),
        focusout: () => {
          !s.isSubMenuOpen() && !s.isSubMenuOpening() && s.deactivate();
        }
      }), s;
    });
  }
  insertFilterGroup(e, t) {
    const s = this.createBean(
      new Dg({
        title: t,
        cssIdentifier: "multi-filter"
      })
    );
    return this.guiDestroyFuncs.push(() => this.destroyBean(s)), s.addItem(e.getGui()), s.toggleGroupExpand(!1), e.afterGuiAttached && s.addManagedListeners(s, {
      expanded: () => e.afterGuiAttached({
        container: this.lastOpenedInContainer,
        suppressFocus: !0,
        hidePopup: this.hidePopup
      })
    }), s;
  }
  isFilterActive() {
    return this.filters.some((e) => e.isFilterActive());
  }
  getLastActiveFilterIndex() {
    const e = this.activeFilterIndices;
    return e.length > 0 ? e[e.length - 1] : null;
  }
  doesFilterPass(e, t) {
    let s = !0;
    return this.filters.forEach((i) => {
      !s || i === t || !i.isFilterActive() || (s = i.doesFilterPass(e));
    }), s;
  }
  getModelFromUi() {
    return {
      filterType: this.filterType,
      filterModels: this.filters.map((t) => {
        const s = t;
        return typeof s.getModelFromUi == "function" ? s.getModelFromUi() : null;
      })
    };
  }
  getModel() {
    return this.isFilterActive() ? {
      filterType: this.filterType,
      filterModels: this.filters.map((t) => t.isFilterActive() ? t.getModel() : null)
    } : null;
  }
  setModel(e) {
    const t = (i, o) => new q((n) => {
      const r = i.setModel(o);
      r ? r.then(() => n()) : n();
    });
    let s = [];
    return e == null ? s = this.filters.map((i, o) => t(i, null).then(() => {
      this.updateActiveList(o);
    })) : this.filters.forEach((i, o) => {
      const n = e.filterModels.length > o ? e.filterModels[o] : null, r = t(i, n).then(() => {
        this.updateActiveList(o);
      });
      s.push(r);
    }), q.all(s).then(() => {
    });
  }
  applyModel(e = "api") {
    let t = !1;
    return this.filters.forEach((s) => {
      s instanceof Ka && (t = s.applyModel(e) || t);
    }), t;
  }
  getChildFilterInstance(e) {
    return this.filters[e];
  }
  afterGuiAttached(e) {
    let t;
    e ? (this.hidePopup = e.hidePopup, t = this.refreshGui(e.container)) : (this.hidePopup = void 0, t = q.resolve());
    const s = e == null ? void 0 : e.suppressFocus;
    t.then(() => {
      const { filterDefs: i, filters: o, filterGuis: n, beans: r } = this;
      let a = !!s;
      i && Gd(i, (d, c) => {
        const u = c === 0, h = d.display && d.display !== "inline", g = s || !u || h, p = { ...e ?? {}, suppressFocus: g }, f = o == null ? void 0 : o[c];
        if (f && (this.executeFunctionIfExistsOnFilter(f, "afterGuiAttached", p), u && !g && (a = !0)), !s && u && h) {
          const m = n[c];
          m && (Ve(m) || m.focus({ preventScroll: !0 }), a = !0);
        }
      });
      const l = te(r);
      !a && (yi(r) || this.getGui().contains(l)) && this.forceFocusOutOfContainer(!0);
    });
  }
  afterGuiDetached() {
    this.executeFunctionIfExists("afterGuiDetached");
  }
  onAnyFilterChanged() {
    this.executeFunctionIfExists("onAnyFilterChanged");
  }
  onNewRowsLoaded() {
    this.executeFunctionIfExists("onNewRowsLoaded");
  }
  destroy() {
    this.filters.forEach((e) => this.destroyBean(e)), this.filters.length = 0, this.destroyChildren(), this.hidePopup = void 0, super.destroy();
  }
  executeFunctionIfExists(e, ...t) {
    Gd(this.filters, (s) => {
      this.executeFunctionIfExistsOnFilter(s, e, t);
    });
  }
  executeFunctionIfExistsOnFilter(e, t, ...s) {
    const i = e[t];
    typeof i == "function" && i.apply(e, s);
  }
  createFilter(e, t) {
    const { filterModifiedCallback: s, doesRowPassOtherFilter: i } = this.params, { filterManager: o, userCompFactory: n } = this.beans;
    let r;
    const a = {
      ...o.createFilterParams(this.column, this.column.getColDef()),
      filterModifiedCallback: s,
      filterChangedCallback: (c) => {
        this.executeWhenAllFiltersReady(() => this.filterChanged(t, c));
      },
      doesRowPassOtherFilter: (c) => i(c) && this.doesFilterPass({ node: c, data: c.data }, r)
    }, l = Bu(n, e, a, "agTextColumnFilter");
    if (!l)
      return null;
    const d = l.newAgStackInstance();
    return d.then((c) => {
      if (c && (r = c, e.display === "subMenu")) {
        const u = c.getGui();
        Ne(u, "dialog");
      }
    }), d;
  }
  executeWhenAllFiltersReady(e) {
    var t;
    (((t = this.filters) == null ? void 0 : t.length) ?? 0) > 0 ? e() : this.afterFiltersReadyFuncs.push(e);
  }
  updateActiveList(e) {
    const { filters: t, activeFilterIndices: s } = this, i = t[e];
    Ae(s, e), i.isFilterActive() && s.push(e);
  }
  filterChanged(e, t) {
    this.updateActiveList(e), this.filterChangedCallback(t);
    const s = this.filters[e];
    this.filters.forEach((i) => {
      i !== s && typeof i.onAnyFilterChanged == "function" && i.onAnyFilterChanged();
    });
  }
  onFocusIn(e) {
    const t = this.lastActivatedMenuItem;
    t != null && !t.getGui().contains(e.target) && (t.deactivate(), this.lastActivatedMenuItem = null);
  }
  getModelAsString(e) {
    var i, o;
    if (!this.filters || !((i = e == null ? void 0 : e.filterModels) != null && i.length))
      return "";
    const t = this.getLastActiveFilterIndex() ?? 0, s = this.filters[t];
    return ((o = s.getModelAsString) == null ? void 0 : o.call(s, e.filterModels[t])) ?? "";
  }
}, m0 = {
  tag: "div",
  cls: "ag-multi-floating-filter ag-floating-filter-input"
}, C0 = class extends L {
  constructor() {
    super(m0), this.floatingFilters = [], this.compDetailsList = [];
  }
  init(e) {
    this.params = e;
    const { compDetailsList: t } = this.getCompDetailsList(e);
    return this.setParams(t);
  }
  setParams(e) {
    const t = [];
    return e.forEach((s) => {
      const i = s == null ? void 0 : s.newAgStackInstance();
      i != null && (this.compDetailsList.push(s), t.push(i));
    }), q.all(t).then((s) => {
      s.forEach((i, o) => {
        this.floatingFilters.push(i);
        const n = i.getGui();
        this.appendChild(n), o > 0 && G(n, !1);
      });
    });
  }
  refresh(e) {
    this.params = e;
    const { compDetailsList: t, floatingFilterParamsList: s } = this.getCompDetailsList(e);
    t.length === this.compDetailsList.length && t.every(
      (o, n) => {
        var r;
        return !((r = this.beans.filterManager) != null && r.areFilterCompsDifferent(this.compDetailsList[n], o));
      }
    ) ? s.forEach((o, n) => {
      var a;
      const r = this.floatingFilters[n];
      (a = r.refresh) == null || a.call(r, o);
    }) : (de(this.getGui()), this.destroyBeans(this.floatingFilters), this.floatingFilters = [], this.compDetailsList = [], this.setParams(t));
  }
  getCompDetailsList(e) {
    const t = [], s = [], i = e.filterParams, o = e.currentParentModel;
    return Mg(i).forEach((n, r) => {
      const a = {
        ...e,
        // set the parent filter instance for each floating filter to the relevant child filter instance
        parentFilterInstance: (d) => {
          this.parentMultiFilterInstance((c) => {
            const u = c.getChildFilterInstance(r);
            u != null && d(u);
          });
        },
        // return the parent model for the specific filter
        currentParentModel: () => {
          var d, c;
          return ((c = (d = o()) == null ? void 0 : d.filterModels) == null ? void 0 : c[r]) ?? null;
        }
      };
      me(a.filterParams, n.filterParams);
      const l = this.getCompDetails(n, a);
      l && (t.push(l), s.push(a));
    }), { compDetailsList: t, floatingFilterParamsList: s };
  }
  onParentModelChanged(e, t) {
    t && t.afterFloatingFilter || this.parentMultiFilterInstance((s) => {
      if (e == null)
        this.floatingFilters.forEach((i, o) => {
          i.onParentModelChanged(null, t), G(i.getGui(), o === 0);
        });
      else {
        const i = s.getLastActiveFilterIndex();
        this.floatingFilters.forEach((o, n) => {
          const r = e.filterModels.length > n ? e.filterModels[n] : null;
          o.onParentModelChanged(r, t);
          const a = i == null ? n === 0 : n === i;
          G(o.getGui(), a);
        });
      }
    });
  }
  destroy() {
    this.destroyBeans(this.floatingFilters), this.floatingFilters.length = 0, super.destroy();
  }
  getCompDetails(e, t) {
    const { filterManager: s, frameworkOverrides: i, userCompFactory: o } = this.beans, n = ah(
      i,
      e,
      () => s.getDefaultFloatingFilter(this.params.column)
    ) ?? "agReadOnlyFloatingFilter";
    return Nu(o, e, t, n);
  }
  parentMultiFilterInstance(e) {
    this.params.parentFilterInstance((t) => {
      t instanceof Eg || K(120), e(t);
    });
  }
}, v0 = {
  moduleName: "MultiFilter",
  version: ce,
  userComponents: { agMultiColumnFilter: Eg, agMultiColumnFloatingFilter: C0 },
  dependsOn: [Ie, ul, gl]
}, w0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "aggColNameSvc";
  }
  getHeaderName(e, t) {
    if (this.gos.get("suppressAggFuncInHeader"))
      return t;
    const { valueColsSvc: s, colModel: i, rowGroupColsSvc: o } = this.beans, n = e.getColDef().pivotValueColumn, r = T(n);
    let a = null, l;
    if (r) {
      const d = (s == null ? void 0 : s.columns) ?? [], c = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && d.length === 1, u = e.getColDef().pivotTotalColumnIds !== void 0;
      if (c && !u)
        return t;
      a = n ? n.getAggFunc() : null, l = !0;
    } else {
      const d = e.isValueActive(), c = i.isPivotMode() || (o == null ? void 0 : o.columns.length) !== 0;
      d && c ? (a = e.getAggFunc(), l = !0) : l = !1;
    }
    if (l) {
      const d = typeof a == "string" ? a : "func";
      return `${this.getLocaleTextFunc()(d, d)}(${t})`;
    }
    return t;
  }
}, b0 = {
  sum: "Sum",
  first: "First",
  last: "Last",
  min: "Min",
  max: "Max",
  count: "Count",
  avg: "Average"
}, y0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "aggFuncSvc", this.aggFuncsMap = {}, this.initialised = !1;
  }
  postConstruct() {
    this.init();
  }
  init() {
    this.initialised || (this.initialiseWithDefaultAggregations(), this.addAggFuncs(this.gos.get("aggFuncs")));
  }
  initialiseWithDefaultAggregations() {
    const e = this.aggFuncsMap;
    e.sum = S0, e.first = x0, e.last = R0, e.min = F0, e.max = P0, e.count = D0, e.avg = M0, this.initialised = !0;
  }
  isAggFuncPossible(e, t) {
    const i = this.getFuncNames(e).includes(t), o = T(this.aggFuncsMap[t]);
    return i && o;
  }
  getDefaultFuncLabel(e) {
    return b0[e] ?? e;
  }
  getDefaultAggFunc(e) {
    const t = e.getColDef().defaultAggFunc;
    if (T(t) && this.isAggFuncPossible(e, t))
      return t;
    if (this.isAggFuncPossible(e, "sum"))
      return "sum";
    const s = this.getFuncNames(e);
    return s != null && s.length ? s[0] : null;
  }
  addAggFuncs(e) {
    if (this.init(), !!e)
      for (const t of Object.keys(e))
        this.aggFuncsMap[t] = e[t];
  }
  getAggFunc(e) {
    return this.init(), this.aggFuncsMap[e];
  }
  getFuncNames(e) {
    const t = e.getColDef().allowedAggFuncs;
    return t ?? Object.keys(this.aggFuncsMap).sort();
  }
  clear() {
    this.aggFuncsMap = {};
  }
};
function S0(e) {
  const { values: t } = e;
  let s = null;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    typeof o == "number" ? s === null ? s = o : s += typeof s == "number" ? o : BigInt(o) : typeof o == "bigint" && (s === null ? s = o : s = (typeof s == "bigint" ? s : BigInt(s)) + o);
  }
  return s;
}
function x0(e) {
  return e.values.length > 0 ? e.values[0] : null;
}
function R0(e) {
  return e.values.length > 0 ? Z(e.values) : null;
}
function F0(e) {
  const { values: t } = e;
  let s = null;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    (typeof o == "number" || typeof o == "bigint") && (s === null || s > o) && (s = o);
  }
  return s;
}
function P0(e) {
  const { values: t } = e;
  let s = null;
  for (let i = 0; i < t.length; i++) {
    const o = t[i];
    (typeof o == "number" || typeof o == "bigint") && (s === null || s < o) && (s = o);
  }
  return s;
}
function D0(e) {
  var o, n;
  const { values: t } = e;
  let s = 0;
  for (let r = 0; r < t.length; r++) {
    const a = t[r];
    s += a != null && typeof a.value == "number" ? a.value : 1;
  }
  const i = (n = (o = e.rowNode) == null ? void 0 : o.aggData) == null ? void 0 : n[e.column.getColId()];
  return i && i.value === s ? i : {
    value: s,
    toString: function() {
      return this.value.toString();
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}
function M0(e) {
  var r, a, l;
  const { values: t } = e;
  let s = 0, i = 0;
  for (let d = 0; d < t.length; d++) {
    const c = t[d];
    let u = null;
    typeof c == "number" || typeof c == "bigint" ? (u = c, i++) : c != null && (typeof c.value == "number" || typeof c.value == "bigint") && typeof c.count == "number" && (u = c.value * (typeof c.value == "number" ? c.count : BigInt(c.count)), i += c.count), typeof u == "number" ? s += typeof s == "number" ? u : BigInt(u) : typeof u == "bigint" && (s = (typeof s == "bigint" ? s : BigInt(s)) + u);
  }
  let o = null;
  i > 0 && (o = s / (typeof s == "number" ? i : BigInt(i)));
  const n = (l = (r = e.rowNode) == null ? void 0 : r.aggData) == null ? void 0 : l[(a = e.column) == null ? void 0 : a.getColId()];
  return n && n.count === i && n.value === o ? n : {
    count: i,
    value: o,
    // the grid by default uses toString to render values for an object, so this
    // is a trick to get the default cellRenderer to display the avg value
    toString: function() {
      return typeof this.value == "number" || typeof this.value == "bigint" ? this.value.toString() : "";
    },
    // used for sorting
    toNumber: function() {
      return this.value;
    }
  };
}
function E0(e, t) {
  e.aggFuncSvc && e.aggFuncSvc.addAggFuncs(t);
}
function A0(e) {
  e.aggFuncSvc && e.aggFuncSvc.clear();
}
function I0(e, t, s) {
  var i, o;
  (o = (i = e.valueColsSvc) == null ? void 0 : i.setColumnAggFunc) == null || o.call(i, t, s, "api");
}
function Er(e, t, s, i, o, n) {
  const r = typeof s == "string" ? e.aggFuncSvc.getAggFunc(s) : s;
  if (typeof r != "function")
    return K(109, { aggFuncOrString: s }), null;
  const a = N(e.gos, {
    values: t,
    column: i,
    colDef: i.colDef,
    pivotResultColumn: n,
    rowNode: o,
    // this is typed incorrectly. Within CSRM, this will always be defined. When called from integrated charts, this will never be defined.
    data: o == null ? void 0 : o.data
  });
  return r(a);
}
var T0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "aggStage", this.refreshProps = /* @__PURE__ */ new Set([
      "getGroupRowAgg",
      "alwaysAggregateAtRootLevel",
      "suppressAggFilteredOnly",
      "grandTotalRow"
    ]), this.step = "aggregate";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.pivotColsSvc = e.pivotColsSvc, this.valueColsSvc = e.valueColsSvc, this.pivotResultCols = e.pivotResultCols, this.valueSvc = e.valueSvc;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  execute(e) {
    var o, n, r;
    const t = !((n = (o = this.valueColsSvc) == null ? void 0 : o.columns) != null && n.length), s = !this.gos.getCallback("getGroupRowAgg");
    if (t && s && ((r = e.changedPath) != null && r.active))
      return;
    const i = this.createAggDetails(e);
    this.recursivelyCreateAggData(i);
  }
  createAggDetails(e) {
    var n;
    const t = this.colModel.isPivotActive(), s = (n = this.valueColsSvc) == null ? void 0 : n.columns, i = t && this.pivotColsSvc ? this.pivotColsSvc.columns : [];
    return {
      alwaysAggregateAtRootLevel: this.gos.get("alwaysAggregateAtRootLevel"),
      groupIncludeTotalFooter: !!Ga(this.gos),
      changedPath: e.changedPath,
      valueColumns: s ?? [],
      pivotColumns: i,
      filteredOnly: !this.isSuppressAggFilteredOnly(),
      userAggFunc: this.gos.getCallback("getGroupRowAgg")
    };
  }
  isSuppressAggFilteredOnly() {
    return no(this.gos) !== void 0 || this.gos.get("suppressAggFilteredOnly");
  }
  recursivelyCreateAggData(e) {
    const t = (s) => {
      if (!s.hasChildren()) {
        s.aggData && this.setAggData(s, null);
        return;
      }
      if (s.level === -1 && !e.groupIncludeTotalFooter) {
        const n = !this.colModel.isPivotMode();
        if (!e.alwaysAggregateAtRootLevel && n) {
          this.setAggData(s, null);
          return;
        }
      }
      this.aggregateRowNode(s, e);
    };
    e.changedPath.forEachChangedNodeDepthFirst(t, !0);
  }
  aggregateRowNode(e, t) {
    const s = t.valueColumns.length === 0, i = t.pivotColumns.length === 0;
    let o;
    t.userAggFunc ? o = t.userAggFunc({ nodes: e.childrenAfterFilter }) : s ? o = null : i ? o = this.aggregateRowNodeUsingValuesOnly(e, t) : o = this.aggregateRowNodeUsingValuesAndPivot(e), this.setAggData(e, o), e.sibling && this.setAggData(e.sibling, o);
  }
  aggregateRowNodeUsingValuesAndPivot(e) {
    var n, r;
    const t = {}, s = ((r = (n = this.pivotResultCols) == null ? void 0 : n.getPivotResultCols()) == null ? void 0 : r.list) ?? [];
    let i = !0;
    const o = this.beans;
    for (let a = 0; a < s.length; a++) {
      const l = s[a], d = l.getColDef();
      if (d.pivotTotalColumnIds != null) {
        i = !1;
        continue;
      }
      const c = d.pivotKeys ?? [];
      let u;
      e.leafGroup ? u = this.getValuesFromMappedSet(e.childrenMapped, c, d.pivotValueColumn) : u = this.getValuesPivotNonLeaf(e, d.colId), t[d.colId] = Er(
        o,
        u,
        d.pivotValueColumn.getAggFunc(),
        d.pivotValueColumn,
        e,
        l
      );
    }
    if (!i)
      for (let a = 0; a < s.length; a++) {
        const l = s[a], d = l.getColDef();
        if (d.pivotTotalColumnIds == null || !d.pivotTotalColumnIds.length)
          continue;
        const c = d.pivotTotalColumnIds.map(
          (u) => t[u]
        );
        t[d.colId] = Er(
          o,
          c,
          d.pivotValueColumn.getAggFunc(),
          d.pivotValueColumn,
          e,
          l
        );
      }
    return t;
  }
  aggregateRowNodeUsingValuesOnly(e, t) {
    const s = {}, { changedPath: i, valueColumns: o, filteredOnly: n } = t, r = i.active ? i.getValueColumnsForNode(e, o) : o, a = i.active ? i.getNotValueColumnsForNode(e, o) : null, l = this.getValuesNormal(e, r, n), d = e.aggData, c = this.beans;
    return r.forEach((u, h) => {
      s[u.getId()] = Er(
        c,
        l[h],
        u.getAggFunc(),
        u,
        e
      );
    }), a && d && a.forEach((u) => {
      s[u.getId()] = d[u.getId()];
    }), s;
  }
  getValuesPivotNonLeaf(e, t) {
    return e.childrenAfterFilter.map((s) => s.aggData[t]);
  }
  getValuesFromMappedSet(e, t, s) {
    let i = e;
    for (let o = 0; o < t.length; o++) {
      const n = t[o];
      i = i ? i[n] : null;
    }
    return i ? i.map((o) => this.valueSvc.getValue(s, o)) : [];
  }
  getValuesNormal(e, t, s) {
    const i = [];
    t.forEach(() => i.push([]));
    const o = t.length, n = s ? e.childrenAfterFilter : e.childrenAfterGroup, r = n.length;
    for (let a = 0; a < r; a++) {
      const l = n[a];
      for (let d = 0; d < o; d++) {
        const c = t[d], u = this.valueSvc.getValue(c, l);
        i[d].push(u);
      }
    }
    return i;
  }
  setAggData(e, t) {
    const s = e.aggData;
    if (e.aggData = t, e.__localEventService) {
      const i = (o) => {
        const n = e.aggData ? e.aggData[o] : void 0, r = s ? s[o] : void 0;
        if (n === r)
          return;
        const a = this.colModel.getColById(o);
        a && e.dispatchCellChangedEvent(a, n, r);
      };
      if (s)
        for (const o of Object.keys(s))
          i(o);
      if (t)
        for (const o of Object.keys(t))
          (!s || !(o in s)) && i(o);
    }
  }
}, L0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "filterAggStage", this.refreshProps = /* @__PURE__ */ new Set([]), this.step = "filter_aggregates";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    var d, c;
    const t = this.beans.colModel.isPivotMode(), s = ((d = this.filterManager) == null ? void 0 : d.isAggregateFilterPresent()) || ((c = this.filterManager) == null ? void 0 : c.isAggregateQuickFilterPresent()), i = (u) => !u.node.group, o = (u) => u.node.leafGroup, n = no(this.gos) || (t ? o : i), { changedPath: r } = e, a = (u, h = !1) => {
      u.childrenAfterFilter && (u.childrenAfterAggFilter = u.childrenAfterFilter, h && u.childrenAfterAggFilter.forEach((g) => a(g, h)), this.setAllChildrenCount(u)), u.sibling && (u.sibling.childrenAfterAggFilter = u.childrenAfterAggFilter);
    }, l = (u) => {
      var h;
      u.childrenAfterAggFilter = ((h = u.childrenAfterFilter) == null ? void 0 : h.filter((g) => {
        var m;
        return n({ node: g }) && this.filterManager.doesRowPassAggregateFilters({ rowNode: g }) ? (a(g, !0), !0) : (m = g.childrenAfterAggFilter) == null ? void 0 : m.length;
      })) || null, this.setAllChildrenCount(u), u.sibling && (u.sibling.childrenAfterAggFilter = u.childrenAfterAggFilter);
    };
    r.forEachChangedNodeDepthFirst(s ? l : a, !0);
  }
  /** for tree data, we include all children, groups and leafs */
  setAllChildrenCountTreeData(e) {
    const t = e.childrenAfterAggFilter;
    let s = 0;
    if (t) {
      const i = t.length;
      s = i;
      for (let o = 0; o < i; ++o)
        s += t[o].allChildrenCount ?? 0;
    }
    e.setAllChildrenCount(
      // Maintain the historical behaviour:
      // - allChildrenCount is 0 in the root if there are no children
      // - allChildrenCount is null in any non-root row if there are no children
      s === 0 && e.level >= 0 ? null : s
    );
  }
  /* for grid data, we only count the leafs */
  setAllChildrenCountGridGrouping(e) {
    let t = 0;
    e.childrenAfterAggFilter.forEach((s) => {
      s.group ? t += s.allChildrenCount : t++;
    }), e.setAllChildrenCount(t);
  }
  setAllChildrenCount(e) {
    if (!e.hasChildren()) {
      e.setAllChildrenCount(null);
      return;
    }
    this.gos.get("treeData") ? this.setAllChildrenCountTreeData(e) : this.setAllChildrenCountGridGrouping(e);
  }
};
function Vt(e, t) {
  if (e.sibling)
    return;
  const s = Av(e, t);
  s.footer = !0, s.setRowTop(null), s.setRowIndex(null), s.oldRowTop = null, s.id = "rowGroupFooter_" + e.id, s.sibling = e, e.sibling = s;
}
function fl(e) {
  e.sibling && (e.sibling.setRowTop(null), e.sibling.setRowIndex(null), e.sibling = void 0);
}
var k0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "footerSvc";
  }
  addTotalRows(e, t, s, i, o, n) {
    let r = e;
    if (o) {
      const d = i && Ga(this.gos);
      return G0(n, d) && (Vt(t, this.beans), s(t.sibling, r++)), r;
    }
    const a = Si(this.gos);
    return (i && a({ node: t })) === n && (Vt(t, this.beans), s(t.sibling, r++)), r;
  }
  getTopDisplayIndex(e, t, s, i) {
    let o = t;
    if (e[0].footer) {
      if (t === 0)
        return 0;
      o -= 1;
    }
    const n = e[e.length - 1], r = o >= s.length;
    return n.footer && r ? n.rowIndex : i(o);
  }
  doesCellShowTotalPrefix(e, t) {
    var s;
    return !e.footer || !(t != null && t.getColDef().showRowGroup) ? !1 : this.gos.get("treeData") ? !0 : e.level === -1 ? ((s = this.beans.showRowGroupCols) == null ? void 0 : s.getShowRowGroupCols()[0]) === t : !!e.rowGroupColumn && t && t.isRowGroupDisplayed(e.rowGroupColumn.getId());
  }
  applyTotalPrefix(e, t, s, i) {
    var n, r;
    const o = (n = i.getColDef().cellRendererParams) == null ? void 0 : n.totalValueGetter;
    if (o) {
      const a = N(this.gos, { column: i, node: s, value: e, formattedValue: t });
      if (typeof o === "function")
        return o(a);
      if (typeof o == "string")
        return (r = this.beans.expressionSvc) == null ? void 0 : r.evaluate(o, a);
      P(179);
    }
    return s.level === -1 ? this.getLocaleTextFunc()("footerTotal", "Total") + " " : this.getTotalValue(t ?? e) ?? "";
  }
  getTotalValue(e) {
    return this.getLocaleTextFunc()("footerTotal", "Total") + " " + (e ?? "");
  }
};
function G0(e, t) {
  switch (t) {
    case "top":
    case "pinnedTop":
      return e === "top";
    case "bottom":
    case "pinnedBottom":
      return e === "bottom";
    default:
      return !1;
  }
}
var Ag = class extends Va {
  constructor() {
    super(...arguments), this.beanName = "valueColsSvc", this.eventName = "columnValueChanged", this.columnProcessors = {
      set: (e, t, s) => this.setValueActive(t, e, s),
      add: (e, t, s) => this.setValueActive(!0, e, s),
      remove: (e, t, s) => this.setValueActive(!1, e, s)
    }, this.columnExtractors = {
      setFlagFunc: (e, t, s) => this.setColValueActive(e, t, s),
      getIndexFunc: () => {
      },
      getInitialIndexFunc: () => {
      },
      getValueFunc: (e) => {
        const t = e.aggFunc;
        if (t === null || t === "")
          return null;
        if (t !== void 0)
          return !!t;
      },
      getInitialValueFunc: (e) => e.initialAggFunc != null && e.initialAggFunc != ""
    }, this.modifyColumnsNoEventsCallbacks = {
      addCol: (e) => this.columns.push(e),
      removeCol: (e) => Ae(this.columns, e)
    };
  }
  extractCols(e, t) {
    return this.columns = super.extractCols(e, t), this.columns.forEach((s) => {
      const i = s.getColDef();
      i.aggFunc != null && i.aggFunc != "" ? this.setColAggFunc(s, i.aggFunc) : s.getAggFunc() || this.setColAggFunc(s, i.initialAggFunc);
    }), this.columns;
  }
  setColumnAggFunc(e, t, s) {
    if (!e)
      return;
    const i = this.colModel.getColDefCol(e);
    i && (this.setColAggFunc(i, t), this.dispatchColumnChangedEvent(this.eventSvc, this.eventName, [i], s));
  }
  syncColumnWithState(e, t, s) {
    const i = s("aggFunc").value1;
    i !== void 0 && (typeof i == "string" ? (this.setColAggFunc(e, i), e.isValueActive() || (this.setColValueActive(e, !0, t), this.modifyColumnsNoEventsCallbacks.addCol(e))) : (T(i) && P(33), e.isValueActive() && (this.setColValueActive(e, !1, t), this.modifyColumnsNoEventsCallbacks.removeCol(e))));
  }
  setValueActive(e, t, s) {
    if (e !== t.isValueActive() && (this.setColValueActive(t, e, s), e && !t.getAggFunc() && this.aggFuncSvc)) {
      const i = this.aggFuncSvc.getDefaultAggFunc(t);
      this.setColAggFunc(t, i);
    }
  }
  setColAggFunc(e, t) {
    e.aggFunc = t, e.dispatchStateUpdatedEvent("aggFunc");
  }
  setColValueActive(e, t, s) {
    e.aggregationActive !== t && (e.aggregationActive = t, e.dispatchColEvent("columnValueChanged", s));
  }
}, ml = {
  moduleName: "SharedAggregation",
  version: ce,
  beans: [y0, w0, k0, Ag],
  apiFunctions: {
    addAggFuncs: E0,
    clearAggFuncs: A0,
    setColumnAggFunc: I0
  },
  dependsOn: [Ie]
}, O0 = {
  moduleName: "Aggregation",
  version: ce,
  beans: [T0, L0],
  rowModels: ["clientSide"],
  dependsOn: [ml]
}, Ig = class extends Va {
  constructor() {
    super(...arguments), this.beanName = "pivotColsSvc", this.eventName = "columnPivotChanged", this.columnProcessors = {
      set: (e, t, s) => this.setColPivotActive(e, t, s),
      add: (e, t, s) => this.setColPivotActive(e, !0, s),
      remove: (e, t, s) => this.setColPivotActive(e, !1, s)
    }, this.columnOrdering = {
      enableProp: "pivot",
      initialEnableProp: "initialPivot",
      indexProp: "pivotIndex",
      initialIndexProp: "initialPivotIndex"
    }, this.columnExtractors = {
      setFlagFunc: (e, t, s) => this.setColPivotActive(e, t, s),
      getIndexFunc: (e) => e.pivotIndex,
      getInitialIndexFunc: (e) => e.initialPivotIndex,
      getValueFunc: (e) => e.pivot,
      getInitialValueFunc: (e) => e.initialPivot
    }, this.modifyColumnsNoEventsCallbacks = {
      addCol: (e) => this.columns.push(e),
      removeCol: (e) => Ae(this.columns, e)
    };
  }
  syncColumnWithState(e, t, s, i) {
    const { value1: o, value2: n } = s("pivot", "pivotIndex");
    (o !== void 0 || n !== void 0) && (typeof n == "number" || o ? (e.isPivotActive() || (this.setColPivotActive(e, !0, t), this.modifyColumnsNoEventsCallbacks.addCol(e)), i && typeof n == "number" && (i[e.getId()] = n)) : e.isPivotActive() && (this.setColPivotActive(e, !1, t), this.modifyColumnsNoEventsCallbacks.removeCol(e)));
  }
  setColPivotActive(e, t, s) {
    e.pivotActive !== t && (e.pivotActive = t, e.dispatchColEvent("columnPivotChanged", s)), e.dispatchStateUpdatedEvent("pivot");
  }
}, B0 = class extends Va {
  constructor() {
    super(...arguments), this.beanName = "rowGroupColsSvc", this.eventName = "columnRowGroupChanged", this.columnProcessors = {
      set: (e, t, s) => this.setActive(t, e, s),
      add: (e, t, s) => this.setActive(!0, e, s),
      remove: (e, t, s) => this.setActive(!1, e, s)
    }, this.columnOrdering = {
      enableProp: "rowGroup",
      initialEnableProp: "initialRowGroup",
      indexProp: "rowGroupIndex",
      initialIndexProp: "initialRowGroupIndex"
    }, this.columnExtractors = {
      setFlagFunc: (e, t, s) => this.setColRowGroupActive(e, t, s),
      getIndexFunc: (e) => e.rowGroupIndex,
      getInitialIndexFunc: (e) => e.initialRowGroupIndex,
      getValueFunc: (e) => e.rowGroup,
      getInitialValueFunc: (e) => e.initialRowGroup
    }, this.modifyColumnsNoEventsCallbacks = {
      addCol: (e) => this.columns.push(e),
      removeCol: (e) => Ae(this.columns, e)
    };
  }
  moveColumn(e, t, s) {
    if (this.columns.length === 0)
      return;
    const i = this.columns[e], o = this.columns.slice(e, t);
    this.columns.splice(e, 1), this.columns.splice(t, 0, i), this.updateIndexMap(), this.eventSvc.dispatchEvent({
      type: this.eventName,
      columns: o,
      column: o.length === 1 ? o[0] : null,
      source: s
    });
  }
  syncColumnWithState(e, t, s, i) {
    const { value1: o, value2: n } = s("rowGroup", "rowGroupIndex");
    (o !== void 0 || n !== void 0) && (typeof n == "number" || o ? (e.isRowGroupActive() || (this.setColRowGroupActive(e, !0, t), this.modifyColumnsNoEventsCallbacks.addCol(e)), i && typeof n == "number" && (i[e.getId()] = n)) : e.isRowGroupActive() && (this.setColRowGroupActive(e, !1, t), this.modifyColumnsNoEventsCallbacks.removeCol(e)));
  }
  setActive(e, t, s) {
    e !== t.isRowGroupActive() && (this.setColRowGroupActive(t, e, s), nu(this.gos, e) && this.colModel.setColsVisible([t], !e, s));
  }
  setColRowGroupActive(e, t, s) {
    e.rowGroupActive !== t && (e.rowGroupActive = t, e.dispatchColEvent("columnRowGroupChanged", s)), e.dispatchStateUpdatedEvent("rowGroup");
  }
}, N0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "autoColSvc";
  }
  postConstruct() {
    this.addManagedPropertyListener("autoGroupColumnDef", this.updateColumns.bind(this));
  }
  addColumns(e) {
    this.columns != null && (e.list = this.columns.list.concat(e.list), e.tree = this.columns.tree.concat(e.tree), yu(e));
  }
  createColumns(e, t) {
    var R;
    const s = this.beans, { colModel: i, gos: o, rowGroupColsSvc: n, colGroupSvc: r } = s, a = i.isPivotMode(), l = Oa(o, a), d = a ? o.get("pivotSuppressAutoColumn") : this.isSuppressAutoCol(), c = n == null ? void 0 : n.columns, h = !(c && c.length > 0 || o.get("treeData")) || d || l, g = () => {
      this.columns && (gs(s, this.columns.tree), this.columns = null);
    };
    if (h) {
      g();
      return;
    }
    const p = this.generateAutoCols(c), f = bu(p, ((R = this.columns) == null ? void 0 : R.list) || null), m = e.treeDepth, w = (this.columns ? this.columns.treeDepth : -1) == m;
    if (f && w)
      return;
    g();
    const C = (r == null ? void 0 : r.findDepth(e.tree)) ?? 0, v = (r == null ? void 0 : r.balanceTreeForAutoCols(p, C)) ?? [];
    this.columns = {
      list: p,
      tree: v,
      treeDepth: C,
      map: {}
    }, t((D) => {
      if (!D)
        return null;
      const M = D.filter((I) => !Na(I));
      return [...p, ...M];
    });
  }
  updateColumns(e) {
    var s;
    const t = Ls(e.source);
    (s = this.columns) == null || s.list.forEach((i, o) => this.updateOneAutoCol(i, o, t));
  }
  getColumn(e) {
    var t;
    return ((t = this.columns) == null ? void 0 : t.list.find((s) => Ha(s, e))) ?? null;
  }
  getColumns() {
    var e;
    return ((e = this.columns) == null ? void 0 : e.list) ?? null;
  }
  generateAutoCols(e = []) {
    const t = [], s = this.gos.get("treeData");
    let i = ou(this.gos);
    return s && i && (P(182), i = !1), i ? e.forEach((o, n) => {
      t.push(this.createOneAutoCol(o, n));
    }) : t.push(this.createOneAutoCol()), t;
  }
  isSuppressAutoCol() {
    const e = this.gos;
    return e.get("groupDisplayType") === "custom" ? !0 : e.get("treeDataDisplayType") === "custom";
  }
  // rowGroupCol and index are missing if groupDisplayType != "multipleColumns"
  createOneAutoCol(e, t) {
    let s;
    e ? s = `${Ri}-${e.getId()}` : s = Ri;
    const i = this.createAutoColDef(s, e, t);
    i.colId = s;
    const o = new Ai(i, null, s, !0);
    return this.createBean(o), o;
  }
  /**
   * Refreshes an auto group col to load changes from defaultColDef or autoGroupColDef
   */
  updateOneAutoCol(e, t, s) {
    const i = e.getColDef(), o = typeof i.showRowGroup == "string" ? i.showRowGroup : void 0, n = this.beans, r = o != null ? n.colModel.getColDefCol(o) : void 0, a = e.getId(), l = this.createAutoColDef(a, r ?? void 0, t);
    e.setColDef(l, null, s), Wt(n, { state: [{ colId: a, ...l }] }, s);
  }
  createAutoColDef(e, t, s) {
    let i = this.createBaseColDef(t);
    const o = this.gos.get("autoGroupColumnDef");
    me(i, o), i = Fi(this.beans, i, e, !0), this.gos.get("treeData") || ie(i.field) && ie(i.valueGetter) && ie(i.filterValueGetter) && i.filter !== "agGroupColumnFilter" && (i.filter = !1), s && s > 0 && (i.headerCheckboxSelection = !1);
    const n = dt(this.gos), r = i.valueGetter || i.field != null;
    return n && !r && (i.sortIndex = void 0, i.initialSort = void 0), i;
  }
  createBaseColDef(e) {
    const t = this.gos.get("autoGroupColumnDef"), i = {
      headerName: this.getLocaleTextFunc()("group", "Group"),
      showRowGroup: (e == null ? void 0 : e.getColId()) ?? !0
    };
    return t && (t.cellRenderer || t.cellRendererSelector) || (i.cellRenderer = "agGroupCellRenderer"), e && (i.headerName = this.beans.colNames.getDisplayNameForColumn(e, "header") ?? void 0, i.headerValueGetter = e.colDef.headerValueGetter), i;
  }
  destroy() {
    var e;
    gs(this.beans, (e = this.columns) == null ? void 0 : e.tree), super.destroy();
  }
}, Tg = class extends S {
  addExpandedCss(e, t) {
    t.isExpandable() && (e.push("ag-row-group"), e.push(t.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted"));
  }
  getRowExpandedListeners(e) {
    const { rowNode: t } = e, s = this.updateExpandedCss.bind(this, e, t);
    return {
      expandedChanged: s,
      hasChildrenChanged: s
    };
  }
  setExpanded(e, t, s, i) {
    if (e.expanded === t)
      return;
    e.expanded = t, e.dispatchRowEvent("expandedChanged");
    const o = { ...sh(e, this.gos, "rowGroupOpened"), expanded: t, event: s || null };
    this.dispatchExpandedEvent(o, i);
  }
  isExpandable(e) {
    return e.footer ? !1 : this.beans.colModel.isPivotMode() ? e.hasChildren() && !e.leafGroup : e.hasChildren() || e.master;
  }
  updateExpandedCss(e, t) {
    const s = t.isExpandable(), i = t.expanded == !0;
    e.forEachGui(void 0, (o) => {
      const n = o.rowComp;
      n.toggleCss("ag-row-group", s), n.toggleCss("ag-row-group-expanded", s && i), n.toggleCss("ag-row-group-contracted", s && !i), ot(o.element, s && i);
    });
  }
}, H0 = class extends Tg {
  constructor() {
    super(...arguments), this.beanName = "expansionSvc", this.events = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  expandRows(e) {
    const t = new Set(e);
    this.rowModel.forEachNode((s) => {
      s.id && t.has(s.id) && (s.expanded = !0);
    }), this.onGroupExpandedOrCollapsed();
  }
  expandAll(e) {
    const { gos: t, colModel: s, eventSvc: i } = this.beans, o = this.rowModel, n = t.get("treeData"), r = s.isPivotActive(), a = (d) => {
      d && d.forEach((c) => {
        const u = () => {
          c.expanded = e, a(c.childrenAfterGroup);
        };
        if (n) {
          T(c.childrenAfterGroup) && u();
          return;
        }
        if (r) {
          !c.leafGroup && u();
          return;
        }
        c.group && u();
      });
    }, l = o.rootNode;
    l && a(l.childrenAfterGroup), o.refreshModel({ step: "map" }), i.dispatchEvent({
      type: "expandOrCollapseAll",
      source: e ? "expandAll" : "collapseAll"
    });
  }
  onGroupExpandedOrCollapsed() {
    this.rowModel.refreshModel({ step: "map" });
  }
  // because the user can call rowNode.setExpanded() many times in one VM turn,
  // we throttle the calls to ClientSideRowModel using animationFrameSvc. this means for 100
  // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
  // CSRM has updated.
  //
  // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
  // to re-render 100+ times, which would be a performance lag.
  //
  // we use animationFrameService
  // rather than debounce() so this will get done if anyone flushes the animationFrameService
  // (eg user calls api.ensureRowVisible(), which in turn flushes ).
  dispatchExpandedEvent(e, t) {
    this.events.push(e);
    const s = () => {
      this.rowModel.onRowGroupOpened(), this.events.forEach((o) => this.eventSvc.dispatchEvent(o));
      const i = this.events.map((o) => o.node);
      this.beans.rowRenderer.refreshCells({ rowNodes: i }), this.events = [];
    };
    t ? s() : (this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.debounce(s)), this.dispatchExpandedDebounced());
  }
  // the advantage over normal debounce is the client can call flushAllFrames()
  // to make sure all rendering is complete. we don't wait any milliseconds,
  // as this is intended to batch calls in one VM turn.
  debounce(e) {
    const t = this.beans.animationFrameSvc;
    if (!t)
      return () => window.setTimeout(e, 0);
    let s = !1;
    return () => {
      if (!t.active) {
        window.setTimeout(e, 0);
        return;
      }
      s || (s = !0, t.addDestroyTask(() => {
        s = !1, e();
      }));
    };
  }
};
function V0(e) {
  let t = e.get("groupHideParentOfSingleChild");
  return t || (t = e.get("groupRemoveSingleChildren"), !t && e.get("groupRemoveLowestSingleChildren") && (t = "leafGroupsOnly")), {
    groupHideParentOfSingleChild: t,
    isGroupMultiAutoColumn: ou(e),
    hideOpenParents: e.get("groupHideOpenParents"),
    grandTotalRow: Ga(e),
    groupTotalRow: Si(e)
  };
}
function _0(e, t, s) {
  return e.groupHideParentOfSingleChild === !0 && s && t.childrenAfterGroup.length === 1;
}
function W0(e, t, s) {
  return e.groupHideParentOfSingleChild === "leafGroupsOnly" && s && t.leafGroup && t.childrenAfterGroup.length === 1;
}
function z0(e, t, s, i, o, n) {
  const r = i && !s, a = i && t.leafGroup, l = e.hideOpenParents && t.expanded && !t.master && !a;
  return !r && !l && !o && !n;
}
var U0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "flattenStage", this.refreshProps = /* @__PURE__ */ new Set([
      "groupHideParentOfSingleChild",
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "groupTotalRow",
      "masterDetail"
    ]), this.step = "map";
  }
  execute(e) {
    var c;
    const t = e.rowNode, s = [], i = this.beans.colModel.isPivotMode(), o = i && t.leafGroup && t.aggData, n = o ? [t] : t.childrenAfterSort, r = V0(this.gos);
    this.recursivelyAddToRowsToDisplay(r, n, s, i, 0);
    const a = s.length > 0, l = r.grandTotalRow;
    if (!o && // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)
    a && l)
      if (Vt(t, this.beans), l === "pinnedBottom" || l === "pinnedTop")
        (c = this.beans.pinnedRowModel) == null || c.setGrandTotalPinned(l === "pinnedBottom" ? "bottom" : "top");
      else {
        const u = l === "top";
        this.addRowNodeToRowsToDisplay(r, t.sibling, s, 0, u);
      }
    return s;
  }
  recursivelyAddToRowsToDisplay(e, t, s, i, o) {
    var n;
    if (t != null && t.length)
      for (let r = 0; r < t.length; r++) {
        const a = t[r], l = a.hasChildren(), d = _0(e, a, l), c = W0(e, a, l);
        if (z0(
          e,
          a,
          l,
          i,
          d,
          c
        ) && this.addRowNodeToRowsToDisplay(e, a, s, o), !(i && a.leafGroup))
          if (l) {
            const h = d || c;
            if (a.expanded || h) {
              const g = e.groupTotalRow({ node: a });
              g || fl(a);
              const p = h ? o : o + 1;
              g === "top" && (Vt(a, this.beans), this.addRowNodeToRowsToDisplay(e, a.sibling, s, p)), this.recursivelyAddToRowsToDisplay(
                e,
                a.childrenAfterSort,
                s,
                i,
                p
              ), g === "bottom" && (Vt(a, this.beans), this.addRowNodeToRowsToDisplay(e, a.sibling, s, p));
            }
          } else {
            const h = (n = this.beans.masterDetailSvc) == null ? void 0 : n.getDetail(a);
            h && this.addRowNodeToRowsToDisplay(e, h, s, o);
          }
      }
  }
  // duplicated method, it's also in floatingRowModel
  addRowNodeToRowsToDisplay(e, t, s, i, o) {
    o ? s.unshift(t) : s.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : i);
  }
}, j0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "groupStage", this.refreshProps = /* @__PURE__ */ new Set([
      "groupDefaultExpanded",
      "groupAllowUnbalanced",
      "initialGroupOrderComparator",
      "groupHideOpenParents",
      "groupDisplayType",
      "treeData",
      "treeDataChildrenField",
      "treeDataParentIdField"
    ]), this.step = "group", this.approach = null, this.strategy = void 0;
  }
  destroy() {
    super.destroy(), this.strategy = void 0, this.approach = null;
  }
  createStrategy() {
    const { beans: e, approach: t } = this;
    let s;
    switch (t) {
      case "treeSelfRef":
        s = "treeParentIdStrategy";
        break;
      case "group":
        s = "groupStrategy";
        break;
    }
    if (s) {
      const i = e.registry.createDynamicBean(s, !1);
      return this.createOptionalManagedBean(i), i;
    }
  }
  execute(e) {
    let t = this.strategy;
    const s = hu(this.gos);
    return this.approach !== s && (this.approach = s, this.destroyBean(t), t && this.approach !== "treeNested" && this.approach !== "treePath" && $0(e.rowNode), t = this.createStrategy(), this.strategy = t), t == null || t.execute(e), !!t;
  }
}, $0 = (e) => {
  const t = e.allLeafChildren, s = e.sibling;
  e.treeNodeFlags = 0, e.childrenAfterGroup = t, e.childrenMapped = null, e.groupData = null, s && (s.childrenAfterGroup = e.childrenAfterGroup, s.childrenAfterAggFilter = e.childrenAfterAggFilter, s.childrenAfterFilter = e.childrenAfterFilter, s.childrenAfterSort = e.childrenAfterSort, s.childrenMapped = null, s.groupData = null);
  for (const i of t) {
    const o = i.sibling;
    Od(i), o && Od(o), i.parent = e, i.level = 0, i.key = null, i.treeNodeFlags = 0, (i.group || i.hasChildren()) && (i.group = !1, i.updateHasChildren());
  }
  e.updateHasChildren();
}, Od = (e) => {
  e.allLeafChildren = null, e.childrenAfterGroup = null, e.childrenAfterAggFilter = null, e.childrenAfterFilter = null, e.childrenAfterSort = null, e.childrenMapped = null, e.groupData && (e.groupData = null);
};
function Bd(e, t, s) {
  var r;
  let i = e;
  const o = i.level - t.level;
  if (o <= 0 || !s.get("groupHideOpenParents"))
    return !1;
  for (let a = 0; a < o; a++) {
    if (!(((r = i.parent) == null ? void 0 : r.getFirstChild()) === i))
      return !1;
    i = i.parent;
  }
  return i === t;
}
var Lg = class extends S {
  constructor() {
    super(...arguments), this.indentClass = null;
  }
  init(e, t, s, i, o, n, r) {
    var c;
    this.params = r, this.eGui = t, this.eCheckbox = s, this.eExpanded = i, this.eContracted = o, this.comp = e, this.compClass = n;
    const { node: a, column: l } = r;
    if (this.node = a, this.displayedNode = a, !this.isEmbeddedRowMismatch()) {
      if (a.footer) {
        this.initFooterCell();
        return;
      }
      if (!l) {
        this.initFullWidthCell();
        return;
      }
      this.displayedNode = ((c = this.beans.showRowGroupColValueSvc) == null ? void 0 : c.getDisplayedNode(a, l)) ?? this.node, this.setupExpand(), this.setupCheckbox(), this.addGroupValue(), this.setupIndent();
    }
  }
  initFooterCell() {
    const { node: e } = this.params;
    this.addGroupValue(), this.setupIndent(), e.level === -1 || this.comp.toggleCss("ag-row-group-leaf-indent", !0);
  }
  initFullWidthCell() {
    const e = () => {
      const { rowDragSvc: t } = this.beans;
      if (!this.params.rowDrag || !t)
        return;
      const s = t.createRowDragComp(() => this.params.value, this.params.node);
      this.createManagedBean(s), this.eGui.insertAdjacentElement("afterbegin", s.getGui());
    };
    this.setupExpand(), e(), this.setupCheckbox(), this.addGroupValue(), this.setupIndent();
  }
  /**
   * Returns an aria "role" to place on full width group cells, or the parent wrapper.
   * @returns the aria role to place on the parent wrapper
   */
  getCellAriaRole() {
    var s, i;
    const e = (s = this.params.colDef) == null ? void 0 : s.cellAriaRole, t = (i = this.params.column) == null ? void 0 : i.getColDef().cellAriaRole;
    return e || t || "gridcell";
  }
  /**
   * Determines if this cell should be rendered, as when using embeddedFullWidthRows
   * only one group cell should be rendered.
   *
   * if [enableRTL] all but pinned right cells should be skipped if available
   * otherwise prioritise pinned left cell if available
   * otherwise center viewport.
   *
   * @returns whether the cell should be skipped due to embedded full width rows
   */
  isEmbeddedRowMismatch() {
    if (!this.params.fullWidth || !this.gos.get("embedFullWidthRows"))
      return !1;
    const { visibleCols: e } = this.beans, t = this.params.pinned === "left", s = this.params.pinned === "right", i = !t && !s;
    return this.gos.get("enableRtl") ? e.isPinningLeft() ? !s : !i : e.isPinningLeft() ? !t : !i;
  }
  /**
   * Displays the group value for the displayed node
   */
  addGroupValue() {
    const {
      params: { value: e, valueFormatted: t }
    } = this, s = this.getInnerCompDetails();
    this.comp.setInnerRenderer(s, t ?? e ?? null);
  }
  /**
   * Sets up expand/collapse:
   * Chevron
   * Aria-expanded
   * Child count
   */
  setupExpand() {
    const { colModel: e } = this.beans, { eGridCell: t, column: s, suppressDoubleClickExpand: i } = this.params, o = (d, c) => {
      const u = k(d, this.beans, null);
      u && (c.appendChild(u), this.addDestroyFunc(() => c.removeChild(u)));
    };
    o("groupExpanded", this.eExpanded), o("groupContracted", this.eContracted);
    const n = this.comp, r = () => {
      if (!this.isExpandable())
        return;
      const c = this.displayedNode.expanded;
      n.setExpandedDisplayed(c), n.setContractedDisplayed(!c), ot(t, !!this.displayedNode.expanded);
    }, a = () => {
      const d = this.isExpandable();
      n.toggleCss("ag-cell-expandable", d), n.toggleCss("ag-row-group", d);
      const c = !d && e.isPivotMode();
      n.toggleCss("ag-pivot-leaf-group", c);
      const u = !e.isPivotMode() && (!this.displayedNode.footer || this.displayedNode.level !== -1);
      n.toggleCss("ag-row-group-leaf-indent", !d && u);
      const h = this.getChildCount(), g = h > 0 ? `(${h})` : "";
      n.setChildCount(g), d ? r() : (n.setExpandedDisplayed(!1), n.setContractedDisplayed(!1), Xf(t));
    };
    (() => {
      !((s == null ? void 0 : s.isCellEditable(this.displayedNode)) && this.gos.get("enableGroupEdit")) && !i && this.addManagedListeners(t, { dblclick: this.onCellDblClicked.bind(this) }), this.addManagedListeners(this.eExpanded, { click: this.onExpandClicked.bind(this) }), this.addManagedListeners(this.eContracted, { click: this.onExpandClicked.bind(this) }), this.addManagedListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedListeners(this.displayedNode, {
        // Expandable state has changed
        allChildrenCountChanged: a,
        masterChanged: a,
        groupChanged: a,
        hasChildrenChanged: a,
        // Node expanded changed
        expandedChanged: r
      });
    })(), a();
  }
  /**
   * Return the inner renderer details for the cell
   *
   * Prioritises:
   * 1. Group row renderer for group rows
   * 2. agFindCellRenderer for find results in group rows
   * 3. Provided innerRenderer (i.e, cellRendererParams.innerRenderer)
   * 4. Cell renderer of the grouped column
   * 5. Inner renderer of the grouped column
   * 6. agFindCellRenderer for find results
   */
  getInnerCompDetails() {
    var l, d;
    const { userCompFactory: e, findSvc: t } = this.beans, s = this.params;
    if (s.fullWidth) {
      const c = this.gos.get("groupRowRendererParams"), u = Io(
        e,
        c,
        s
      );
      return u || (t != null && t.isMatch(s.node, null) ? Io(
        e,
        { ...c, innerRenderer: "agFindCellRenderer" },
        s
      ) : void 0);
    }
    const i = (c) => c && c.componentClass == this.compClass, o = Io(e, s, s);
    if (o && !i(o))
      return o;
    const {
      displayedNode: { rowGroupColumn: n }
    } = this, r = n == null ? void 0 : n.colDef, a = n && ((l = s.column) == null ? void 0 : l.isRowGroupDisplayed(n.getId()));
    if (r && a) {
      const c = Cn(e, r, s);
      if (c)
        if (i(c)) {
          if ((d = r == null ? void 0 : r.cellRendererParams) != null && d.innerRenderer)
            return Io(
              e,
              r.cellRendererParams,
              s
            );
        } else
          return c;
    }
    if (t != null && t.isMatch(s.node, s.column))
      return Cn(
        e,
        { ...r ?? s.colDef, cellRenderer: "agFindCellRenderer" },
        s
      );
  }
  /**
   * Get the allChildCount of a given node
   * @param node the node to return the count for
   * @returns 0 if the count should not be displayed, otherwise the count
   */
  getChildCount() {
    const { column: e, suppressCount: t } = this.params;
    if (t)
      return 0;
    const { allChildrenCount: s, rowGroupColumn: i } = this.displayedNode;
    return !((s ?? 0) > 0 && (!i || !e || (e == null ? void 0 : e.isRowGroupDisplayed(i.getId())))) || this.gos.get("showOpenedGroup") && this.displayedNode !== this.node && !Bd(this.node, this.displayedNode, this.gos) ? 0 : s ?? 0;
  }
  /**
   * Checks whether the current cell is expandable, either due to [groupHideOpenParent] control or otherwise.
   * @returns whether this cell is expandable
   */
  isExpandable() {
    const { node: e, column: t, colDef: s } = this.params;
    if (!this.displayedNode.isExpandable() || e.rowPinned)
      return !1;
    if (!t)
      return !0;
    if (e.hasChildren() && s) {
      const { showRowGroup: n } = s;
      if (!n)
        return !1;
      if (n === !0)
        return !0;
    }
    return e === this.displayedNode ? e.rowGroupColumn && (t == null ? void 0 : t.isRowGroupDisplayed(e.rowGroupColumn.getId())) ? !0 : e.master ? (s == null ? void 0 : s.showRowGroup) === !0 || (s == null ? void 0 : s.showRowGroup) == null : !1 : Bd(this.node, this.displayedNode, this.gos);
  }
  /**
   * For full width group cells & single group column, indents child groups based on uiLevel
   */
  setupIndent() {
    const { suppressPadding: e, node: t, colDef: s } = this.params;
    if (e)
      return;
    const i = () => {
      let o = 0;
      s && s.showRowGroup !== !0 ? o = 0 : o = t.uiLevel;
      const n = "ag-row-group-indent-" + o;
      n !== this.indentClass && (this.indentClass && this.comp.toggleCss(this.indentClass, !1), this.indentClass = n, this.comp.toggleCss(n, !0), this.eGui.style.setProperty("--ag-indentation-level", String(o)));
    };
    this.addManagedListeners(t, { uiLevelChanged: i.bind(this) }), i();
  }
  /**
   * Selection checkboxes
   */
  setupCheckbox() {
    const { node: e } = this.params;
    !e.footer && !e.rowPinned && !e.detail && (this.addManagedPropertyListener("rowSelection", ({ currentValue: s, previousValue: i }) => {
      const o = typeof s == "object" ? s : void 0, n = typeof i == "object" ? i : void 0;
      (o == null ? void 0 : o.checkboxLocation) !== (n == null ? void 0 : n.checkboxLocation) && (this.destroyCheckbox(), this.addCheckbox());
    }), this.addCheckbox());
  }
  addCheckbox() {
    const { selectionSvc: e } = this.beans;
    if (!e || !Dt(this.gos))
      return;
    const { node: t, column: s } = this.params, i = this.gos.get("rowSelection"), o = ao(i);
    if (o === "selectionColumn")
      return;
    if (o === "autoGroupColumn") {
      const d = (s == null ? void 0 : s.getColDef().showRowGroup) != null, c = !s && t.group;
      if (!(d || c))
        return;
    }
    const n = typeof i == "object" ? Ts(i) : this.params.checkbox;
    if (!(typeof n == "function" || n === !0))
      return;
    if (typeof (s == null ? void 0 : s.getColDef().showRowGroup) == "string" && !this.isExpandable()) {
      this.comp.setCheckboxSpacing(!0);
      return;
    }
    const l = e.createCheckboxSelectionComponent();
    this.cbComp = l, this.createBean(l), l.init({
      rowNode: t,
      // when groupHideOpenParents = true and group expanded, we want the checkbox to refer to leaf node state (not group node state)
      column: s,
      overrides: {
        isVisible: n,
        callbackParams: this.params,
        removeHidden: !0
      }
    }), this.eCheckbox.appendChild(l.getGui()), this.comp.setCheckboxVisible(!0);
  }
  destroyCheckbox() {
    this.comp.setCheckboxSpacing(!1), this.comp.setCheckboxVisible(!1), this.cbComp && this.eCheckbox.removeChild(this.cbComp.getGui()), this.cbComp = this.destroyBean(this.cbComp);
  }
  /**
   * Called when the expand / contract icon is clicked.
   */
  onExpandClicked(e) {
    gt(e) || (vt(e), this.onExpandOrContract(e));
  }
  /**
   * Called on cell key press - only handles 'Enter' key for expand/collapse
   */
  onKeyDown(e) {
    !(e.key === y.ENTER) || this.params.suppressEnterExpand || this.params.column && this.params.column.isCellEditable(this.params.node) || this.onExpandOrContract(e);
  }
  /**
   * Called on cell double click - only expands/collapses if the event is not on the expand / contract icon
   */
  onCellDblClicked(e) {
    if (gt(e))
      return;
    qr(this.eExpanded, e) || qr(this.eContracted, e) || this.onExpandOrContract(e);
  }
  /**
   * Called when expand or contract is attempted, to scroll the row and update the node state
   * @param e originating event
   */
  onExpandOrContract(e) {
    if (!this.isExpandable())
      return;
    const t = this.displayedNode, s = !t.expanded;
    !s && t.sticky && this.beans.ctrlsSvc.getScrollFeature().setVerticalScrollPosition(t.rowTop - t.stickyRowTop), t.setExpanded(s, e);
  }
  destroy() {
    super.destroy(), this.destroyCheckbox();
  }
}, K0 = {
  tag: "span",
  cls: "ag-cell-wrapper",
  children: [
    { tag: "span", ref: "eExpanded", cls: "ag-group-expanded ag-hidden" },
    { tag: "span", ref: "eContracted", cls: "ag-group-contracted ag-hidden" },
    { tag: "span", ref: "eCheckbox", cls: "ag-group-checkbox ag-invisible" },
    { tag: "span", ref: "eValue", cls: "ag-group-value" },
    { tag: "span", ref: "eChildCount", cls: "ag-group-child-count" }
  ]
}, Nd = class extends L {
  constructor() {
    super(K0), this.eExpanded = x, this.eContracted = x, this.eCheckbox = x, this.eValue = x, this.eChildCount = x;
  }
  init(e) {
    const t = {
      setInnerRenderer: (n, r) => this.setRenderDetails(n, r),
      setChildCount: (n) => this.eChildCount.textContent = n,
      toggleCss: (n, r) => this.toggleCss(n, r),
      setContractedDisplayed: (n) => G(this.eContracted, n),
      setExpandedDisplayed: (n) => G(this.eExpanded, n),
      setCheckboxVisible: (n) => this.eCheckbox.classList.toggle("ag-invisible", !n),
      setCheckboxSpacing: (n) => this.eCheckbox.classList.toggle("ag-group-checkbox-spacing", n)
    }, s = this.createManagedBean(new Lg()), i = !e.colDef, o = this.getGui();
    s.init(t, o, this.eCheckbox, this.eExpanded, this.eContracted, this.constructor, e), i && Ne(o, s.getCellAriaRole());
  }
  setRenderDetails(e, t) {
    e ? e.newAgStackInstance().then((s) => {
      if (!s)
        return;
      const i = () => this.destroyBean(s);
      this.isAlive() ? (this.eValue.appendChild(s.getGui()), this.addDestroyFunc(i)) : i();
    }) : this.eValue.innerText = t;
  }
  destroy() {
    this.destroyBean(this.innerCellRenderer), super.destroy();
  }
  refresh() {
    return !1;
  }
}, q0 = (
  /*css*/
  ".ag-group-checkbox-spacing{width:var(--ag-icon-size)}:where(.ag-ltr) .ag-group-checkbox-spacing{margin-right:var(--ag-cell-widget-spacing)}:where(.ag-rtl) .ag-group-checkbox-spacing{margin-left:var(--ag-cell-widget-spacing)}"
), Y0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "showRowGroupColValueSvc";
  }
  /**
   * Get the value for format in the group column, also returns the displayedNode from which the value was
   * taken in cases of groupHideOpenParents and showOpenedGroup.
   */
  getGroupValue(e, t) {
    var n;
    if (!t)
      return e.group ? { displayedNode: e, value: e.groupValue } : null;
    const s = this.beans.valueSvc, i = t.colDef.showRowGroup;
    if (!i)
      return null;
    if (e.level === -1 && e.footer)
      return { displayedNode: e, value: null };
    if (typeof i == "string") {
      if ((((n = this.beans.rowGroupColsSvc) == null ? void 0 : n.getColumnIndex(i)) ?? -1) > e.level)
        return null;
      const a = this.getDisplayedNode(e, t, !0);
      if (a)
        return {
          displayedNode: a,
          value: s.getValue(t, a)
        };
    }
    const o = s.getValue(t, e);
    if (o == null) {
      const r = this.getDisplayedNode(e, t);
      if (r)
        return {
          displayedNode: r,
          value: s.getValue(t, r)
        };
    }
    return {
      displayedNode: e,
      value: o
    };
  }
  /**
   * Formats a group col value, and prefixes it with the "Total" prefix if applicable
   */
  formatAndPrefixGroupColValue(e, t, s = !1) {
    const i = this.formatGroupColValue(e, t, s), { value: o, displayedNode: n } = e, r = this.beans.footerSvc;
    return r != null && r.doesCellShowTotalPrefix(n, t) ? r.applyTotalPrefix(o, i, n, t) : n.footer && n.level === -1 ? null : i;
  }
  /**
   * Formats the group col value using the underlying column's value formatter
   */
  formatGroupColValue(e, t, s = !1) {
    const i = this.beans.valueSvc, { displayedNode: o, value: n } = e, r = o.rowGroupColumn, a = o.group && !t;
    if (r && (a || (t == null ? void 0 : t.isRowGroupDisplayed(r.colId)))) {
      if (s && r.colDef.useValueFormatterForExport === !1)
        return null;
      const d = i.formatValue(r, o, n);
      return d == null && o.key === "" ? this.getLocaleTextFunc()("blanks", "(Blanks)") : d;
    }
    return !t || o.group || s && t.colDef.useValueFormatterForExport === !1 ? null : i.formatValue(t, o, n);
  }
  /**
   * Checks if the node has a value to inherit from the parent node for display in the given column
   *
   * This is used when [groupHideOpenParents] or [showOpenedGroup] are enabled
   *
   * @param node node to check for preferential nodes to display
   * @param column column to get the displayed node for
   * @returns a parent node of node to display the value from, or undefined if no value will be inherited
   */
  getDisplayedNode(e, t, s = !1) {
    var l, d;
    const i = this.gos, o = i.get("groupHideOpenParents"), n = i.get("showOpenedGroup") && !s;
    if (!o && !n)
      return;
    const r = t.colDef.showRowGroup;
    if (r === !0)
      return e.group ? void 0 : e.parent ?? void 0;
    let a = e;
    for (; a && ((l = a.rowGroupColumn) == null ? void 0 : l.getId()) != r; ) {
      const c = a === ((d = a.parent) == null ? void 0 : d.getFirstChild());
      if (!n && !c)
        return;
      a = a.parent;
    }
    if (a !== e)
      return a ?? void 0;
  }
}, Z0 = class extends S {
  constructor() {
    super(...arguments), this.beanName = "showRowGroupCols";
  }
  refresh() {
    this.showRowGroupCols = [], this.showRowGroupColsMap = {};
    const { colModel: e, rowGroupColsSvc: t } = this.beans;
    e.getCols().forEach((s) => {
      const o = s.getColDef().showRowGroup, n = typeof o == "string";
      !n && !(o === !0) || (this.showRowGroupCols.push(s), n ? this.showRowGroupColsMap[o] = s : t && t.columns.forEach((a) => {
        this.showRowGroupColsMap[a.getId()] = s;
      }));
    });
  }
  getShowRowGroupCols() {
    return this.showRowGroupCols;
  }
  getShowRowGroupCol(e) {
    return this.showRowGroupColsMap[e];
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t)
      return null;
    const { rowGroupColsSvc: s, colModel: i } = this.beans;
    if (t === !0 && s)
      return s.columns.slice(0);
    const o = i.getColDefCol(t);
    return o ? [o] : null;
  }
  isRowGroupDisplayed(e, t) {
    const { colDef: s } = e;
    if ((s == null ? void 0 : s.showRowGroup) == null)
      return !1;
    const i = s.showRowGroup === !0, o = s.showRowGroup === t;
    return i || o;
  }
}, Q0 = class extends S {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.extraTopHeight = 0, this.extraBottomHeight = 0;
  }
  postConstruct() {
    this.isClientSide = Ke(this.gos), this.beans.ctrlsSvc.whenReady(this, (e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    }), this.resetStickyContainers();
  }
  setOffsetTop(e) {
    this.extraTopHeight !== e && (this.extraTopHeight = e, this.eventSvc.dispatchEvent({
      type: "stickyTopOffsetChanged",
      offset: e
    }));
  }
  setOffsetBottom(e) {
    this.extraBottomHeight !== e && (this.extraBottomHeight = e);
  }
  resetOffsets() {
    this.setOffsetBottom(0), this.setOffsetTop(0);
  }
  /**
   * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
   */
  getLastPixelOfGroup(e) {
    return this.isClientSide ? J0(e) : X0(e);
  }
  /**
   * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
   */
  getFirstPixelOfGroup(e) {
    return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0;
  }
  updateStickyRows(e) {
    const t = e === "top";
    let s = 0;
    if (!this.canRowsBeSticky())
      return this.refreshNodesAndContainerHeight(e, /* @__PURE__ */ new Set(), s);
    const { rowModel: i, rowRenderer: o, pinnedRowModel: n } = this.beans, r = t ? o.firstVisibleVPixel - this.extraTopHeight : o.lastVisibleVPixel - this.extraTopHeight, a = /* @__PURE__ */ new Set(), l = (h) => {
      if (a.add(h), t) {
        const g = this.getLastPixelOfGroup(h), p = r + s + h.rowHeight;
        g < p ? h.stickyRowTop = s + (g - p) : h.stickyRowTop = s;
      } else {
        const g = this.getFirstPixelOfGroup(h), p = r - (s + h.rowHeight);
        g > p ? h.stickyRowTop = s - (g - p) : h.stickyRowTop = s;
      }
      s = 0, a.forEach((g) => {
        const p = g.stickyRowTop + g.rowHeight;
        s < p && (s = p);
      });
    }, d = this.areFooterRowsStickySuppressed(), c = this.gos.get("suppressGroupRowsSticky"), u = (h) => {
      if (!h.displayed)
        return !1;
      if (h.footer) {
        if (d === !0 || d === "grand" && h.level === -1 || d === "group" && h.level > -1)
          return !1;
        const g = h.sibling.rowIndex ? h.sibling.rowIndex + 1 === h.rowIndex : !1;
        return e === "bottom" && g || h.level === -1 && (n != null && n.getGrandTotalPinned()) ? !1 : !a.has(h);
      }
      return h.isExpandable() ? c === !0 || e === "bottom" ? !1 : !a.has(h) && h.expanded : !1;
    };
    for (let h = 0; h < 100; h++) {
      let g = r + s;
      t || (g = r - s);
      const p = i.getRowIndexAtPixel(g), f = i.getRow(p);
      if (f == null)
        break;
      const b = this.getStickyAncestors(f).find(
        (C) => (t ? C.rowIndex < p : C.rowIndex > p) && u(C)
      );
      if (b) {
        l(b);
        continue;
      }
      if ((t ? f.rowTop < g : f.rowTop + f.rowHeight > g) && u(f)) {
        l(f);
        continue;
      }
      break;
    }
    return t || a.forEach((h) => {
      h.stickyRowTop = s - (h.stickyRowTop + h.rowHeight);
    }), this.refreshNodesAndContainerHeight(e, a, s);
  }
  areFooterRowsStickySuppressed() {
    const e = this.gos.get("suppressStickyTotalRow");
    if (e === !0)
      return !0;
    const t = e === "group", s = e === "grand";
    return t && s ? !0 : s ? "grand" : t ? "group" : !1;
  }
  canRowsBeSticky() {
    const e = Vn(this.gos), t = this.areFooterRowsStickySuppressed(), s = this.gos.get("suppressGroupRowsSticky");
    return e && (!t || !s);
  }
  getStickyAncestors(e) {
    const t = [];
    let s = e.footer ? e.sibling : e.parent;
    for (; s; )
      s.sibling && t.push(s.sibling), t.push(s), s = s.parent;
    return t.reverse();
  }
  checkStickyRows() {
    const e = this.updateStickyRows("top"), t = this.updateStickyRows("bottom");
    return e || t;
  }
  destroyStickyCtrls() {
    this.resetStickyContainers();
  }
  resetStickyContainers() {
    this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0), this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
  }
  refreshStickyNode(e) {
    const t = /* @__PURE__ */ new Set();
    if (this.stickyTopRowCtrls.some((s) => s.rowNode === e)) {
      for (let s = 0; s < this.stickyTopRowCtrls.length; s++) {
        const i = this.stickyTopRowCtrls[s].rowNode;
        i !== e && t.add(i);
      }
      this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows();
      return;
    }
    for (let s = 0; s < this.stickyBottomRowCtrls.length; s++) {
      const i = this.stickyBottomRowCtrls[s].rowNode;
      i !== e && t.add(i);
    }
    this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows();
  }
  /**
   * Destroy old ctrls and create new ctrls where necessary.
   */
  refreshNodesAndContainerHeight(e, t, s) {
    const i = e === "top", o = i ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls, n = {}, r = [];
    for (let g = 0; g < o.length; g++) {
      const p = o[g].rowNode;
      if (!t.has(p)) {
        n[p.id] = o[g], p.sticky = !1;
        continue;
      }
      r.push(o[g]);
    }
    const a = /* @__PURE__ */ new Set();
    for (let g = 0; g < r.length; g++)
      a.add(r[g].rowNode);
    const l = [];
    t.forEach((g) => {
      a.has(g) || (g.sticky = !0, l.push(this.createRowCon(g, !1, !1)));
    });
    let d = !!l.length || r.length !== o.length;
    i ? this.topContainerHeight !== s && (this.topContainerHeight = s, this.gridBodyCtrl.setStickyTopHeight(s), d = !0) : this.bottomContainerHeight !== s && (this.bottomContainerHeight = s, this.gridBodyCtrl.setStickyBottomHeight(s), d = !0), this.destroyRowCtrls(n, !1);
    const c = [...r, ...l];
    c.sort((g, p) => p.rowNode.rowIndex - g.rowNode.rowIndex), i || c.reverse(), c.forEach((g) => g.setRowTop(g.rowNode.stickyRowTop));
    const u = this.beans.pageBounds;
    let h = 0;
    return i ? (t.forEach((g) => {
      g.rowIndex < u.getFirstRow() && (h += g.rowHeight);
    }), h > this.topContainerHeight && (h = this.topContainerHeight), this.setOffsetTop(h)) : (t.forEach((g) => {
      g.rowIndex > u.getLastRow() && (h += g.rowHeight);
    }), h > this.bottomContainerHeight && (h = this.bottomContainerHeight), this.setOffsetBottom(h)), d ? (i ? this.stickyTopRowCtrls = c : this.stickyBottomRowCtrls = c, !0) : !1;
  }
  ensureRowHeightsValid() {
    let e = !1;
    const t = (s) => {
      const i = s.rowNode;
      if (i.rowHeightEstimated) {
        const o = Je(this.beans, i);
        i.setRowHeight(o.height), e = !0;
      }
    };
    return this.stickyTopRowCtrls.forEach(t), this.stickyBottomRowCtrls.forEach(t), e;
  }
};
function X0(e) {
  var t, s;
  if (e.isExpandable() || e.footer) {
    if (e.master && e.detailNode)
      return e.detailNode.rowTop + e.detailNode.rowHeight;
    if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
      let o = (t = e.childStore) == null ? void 0 : t.getStoreBounds();
      return e.footer && (o = (s = e.sibling.childStore) == null ? void 0 : s.getStoreBounds()), ((o == null ? void 0 : o.heightPx) ?? 0) + ((o == null ? void 0 : o.topPx) ?? 0);
    }
    return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
  }
  return Number.MAX_SAFE_INTEGER;
}
function J0(e) {
  if (e.isExpandable() || e.footer) {
    if (e.footer && e.rowIndex === 0)
      return Number.MAX_SAFE_INTEGER;
    if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
      let i = e.footer ? e.sibling : e;
      for (; i.isExpandable() && i.expanded; )
        if (i.master && i.detailNode)
          i = i.detailNode;
        else if (i.childrenAfterSort) {
          if (i.childrenAfterSort.length === 0)
            break;
          i = Z(i.childrenAfterSort);
        }
      return i.rowTop + i.rowHeight;
    }
    return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
  }
  return Number.MAX_SAFE_INTEGER;
}
var eM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "stickyRowSvc";
  }
  createStickyRowFeature(e, t, s) {
    const i = this.gos;
    if (Vn(i) && Ke(i) || nt(i))
      return e.createManagedBean(new Q0(t, s));
  }
}, tM = {
  moduleName: "GroupCellRenderer",
  version: ce,
  userComponents: {
    agGroupRowRenderer: Nd,
    agGroupCellRenderer: Nd
  },
  dynamicBeans: { groupCellRendererCtrl: Lg },
  icons: {
    // shown on row group when contracted (click to expand)
    groupContracted: "tree-closed",
    // shown on row group when expanded (click to contract)
    groupExpanded: "tree-open"
  },
  css: [q0],
  dependsOn: [Ie]
}, kg = {
  moduleName: "GroupColumn",
  version: ce,
  beans: [
    N0,
    Z0,
    Y0,
    B0,
    Ig,
    Ag
  ],
  dependsOn: [Ie, tM]
}, sM = {
  moduleName: "ClientSideRowModelHierarchy",
  version: ce,
  rowModels: ["clientSide"],
  beans: [j0, U0, H0],
  dependsOn: [Ie]
}, Gg = {
  moduleName: "StickyRow",
  version: ce,
  beans: [eM]
}, Ar = class {
  constructor() {
    this.allSets = /* @__PURE__ */ new Map();
  }
  removeFromChildrenAfterGroup(e, t) {
    const s = this.getSet(e);
    (s.fromChildrenAfterGroup ?? (s.fromChildrenAfterGroup = /* @__PURE__ */ new Set())).add(t);
  }
  isRemoveFromAllLeafChildren(e, t) {
    var s, i;
    return !!((i = (s = this.allSets.get(e)) == null ? void 0 : s.fromAllLeafChildren) != null && i.has(t));
  }
  preventRemoveFromAllLeafChildren(e, t) {
    var s, i;
    (i = (s = this.allSets.get(e)) == null ? void 0 : s.fromAllLeafChildren) == null || i.delete(t);
  }
  removeFromAllLeafChildren(e, t) {
    const s = this.getSet(e);
    (s.fromAllLeafChildren ?? (s.fromAllLeafChildren = /* @__PURE__ */ new Set())).add(t);
  }
  getSet(e) {
    let t = this.allSets.get(e);
    return t || (t = {
      fromChildrenAfterGroup: null,
      fromAllLeafChildren: null
    }, this.allSets.set(e, t)), t;
  }
  getAllParents() {
    return Array.from(this.allSets.keys());
  }
  flush() {
    const e = this.allSets;
    for (const t of e.keys()) {
      const s = e.get(t);
      if (s) {
        const { fromChildrenAfterGroup: i, fromAllLeafChildren: o } = s, { childrenAfterGroup: n, allLeafChildren: r } = t;
        n && i && (Hd(n, i), t.updateHasChildren()), r && o && Hd(r, o);
      }
    }
    e.clear();
  }
};
function Hd(e, t) {
  let s = 0;
  for (let i = 0, o = e.length; i < o; ++i) {
    const n = e[i];
    t.has(n) || (e[s++] = n);
  }
  e.length = s;
}
function iM(e) {
  if (!e)
    return !1;
  const t = e.length;
  if (t < 2)
    return !1;
  let s = !1;
  for (let i = 1; i < t; i++)
    if (Vd(e[i - 1], e[i]) > 0) {
      s = !0;
      break;
    }
  return s ? (e.sort(Vd), !0) : !1;
}
function Vd(e, t) {
  const s = e.sourceRowIndex, i = t.sourceRowIndex, o = s >= 0, n = i >= 0, r = o && n, a = !o && !n;
  return r ? s - i : a ? e.__objectId - t.__objectId : o ? 1 : -1;
}
var oM = class extends S {
  wireBeans(e) {
    this.colModel = e.colModel, this.rowGroupColsSvc = e.rowGroupColsSvc, this.valueSvc = e.valueSvc, this.selectionSvc = e.selectionSvc, this.showRowGroupCols = e.showRowGroupCols;
  }
  execute(e) {
    var o;
    const t = this.createGroupingDetails(e), s = e.changedRowNodes;
    s ? this.handleDeltaUpdate(t, s) : this.shotgunResetEverything(t, !!e.afterColumnsChanged);
    const i = e.changedPath;
    this.positionLeafsAndGroups(i), this.orderGroups(t), (o = this.selectionSvc) == null || o.updateSelectableAfterGrouping(i);
  }
  positionLeafsAndGroups(e) {
    e.forEachChangedNodeDepthFirst((t) => {
      if (t.childrenAfterGroup) {
        const s = [], i = [];
        let o;
        t.childrenAfterGroup.forEach((n) => {
          var r;
          (r = n.childrenAfterGroup) != null && r.length ? n.key === "" && !o ? o = n : i.push(n) : s.push(n);
        }), o && i.push(o), t.childrenAfterGroup = [...s, ...i];
      }
    }, !1);
  }
  createGroupingDetails(e) {
    var r;
    const { rowNode: t, changedPath: s, rowNodesOrderChanged: i } = e, o = (r = this.rowGroupColsSvc) == null ? void 0 : r.columns;
    return {
      expandByDefault: this.gos.get("groupDefaultExpanded"),
      groupedCols: o,
      rootNode: t,
      pivotMode: this.colModel.isPivotMode(),
      groupedColCount: (o == null ? void 0 : o.length) ?? 0,
      rowNodesOrderChanged: !!i,
      // if no transaction and not immutable row data set, then it's shotgun, changed path would be 'not active' at this point anyway
      changedPath: s,
      groupAllowUnbalanced: this.gos.get("groupAllowUnbalanced"),
      isGroupOpenByDefault: this.gos.getCallback("isGroupOpenByDefault"),
      initialGroupOrderComparator: this.gos.getCallback("initialGroupOrderComparator"),
      keyCreators: (o == null ? void 0 : o.map((a) => a.getColDef().keyCreator)) ?? []
    };
  }
  handleDeltaUpdate(e, { removals: t, updates: s, adds: i }) {
    const o = new Ar();
    t.size && this.removeNodes(t, e, o);
    for (const a of s)
      this.moveNodeInWrongPath(a, e, o);
    const n = e.changedPath;
    for (const a of i)
      this.insertOneNode(a, e), n.active && n.addParentNode(a.parent);
    const r = o.getAllParents();
    o.flush(), this.removeEmptyGroups(r, e), e.rowNodesOrderChanged && this.sortChildren(e);
  }
  // this is used when doing delta updates, eg Redux, keeps nodes in right order
  sortChildren(e) {
    e.changedPath.forEachChangedNodeDepthFirst(
      (t) => {
        iM(t.childrenAfterGroup) && e.changedPath.addParentNode(t);
      },
      !1,
      !0
    );
  }
  orderGroups(e) {
    const t = e.initialGroupOrderComparator;
    T(t) && s(e.rootNode);
    function s(i) {
      T(i.childrenAfterGroup) && // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)
      !i.leafGroup && (i.childrenAfterGroup.sort((n, r) => t({ nodeA: n, nodeB: r })), i.childrenAfterGroup.forEach((n) => s(n)));
    }
  }
  getExistingPathForNode(e, t) {
    const s = [];
    let i = e.parent;
    for (; i && i !== t.rootNode; )
      s.push({
        key: i.key,
        rowGroupColumn: i.rowGroupColumn,
        field: i.field
      }), i = i.parent;
    return s.reverse(), s;
  }
  moveNodeInWrongPath(e, t, s) {
    t.changedPath.active && t.changedPath.addParentNode(e.parent);
    const i = (a) => a.key, o = this.getExistingPathForNode(e, t).map(i), n = this.getGroupInfo(e, t).map(i);
    pt(o, n) || this.moveNode(e, t, s);
  }
  moveNode(e, t, s) {
    if (this.removeNodesFromParents([e], t, s), this.insertOneNode(e, t, s), e.setData(e.data), t.changedPath.active) {
      const i = e.parent;
      t.changedPath.addParentNode(i);
    }
  }
  removeNodes(e, t, s) {
    if (this.removeNodesFromParents(e, t, s), t.changedPath.active)
      for (const i of e)
        t.changedPath.addParentNode(i.parent);
  }
  forEachParentGroup(e, t, s) {
    let i = t;
    for (; i && i !== e.rootNode; )
      s(i), i = i.parent;
  }
  removeNodesFromParents(e, t, s) {
    const i = s == null, o = s || new Ar();
    for (const n of e)
      this.removeFromParent(n, o), this.forEachParentGroup(t, n.parent, (r) => {
        o.removeFromAllLeafChildren(r, n);
      });
    i && o.flush();
  }
  removeEmptyGroups(e, t) {
    let s = !0;
    const i = (o) => {
      var l;
      const n = this.getChildrenMappedKey(o.key, o.rowGroupColumn), r = o.parent;
      return (r != null && r.childrenMapped ? !r.childrenMapped[n] : !0) ? !1 : !!o.group && (((l = o.childrenAfterGroup) == null ? void 0 : l.length) ?? 0) === 0;
    };
    for (; s; ) {
      s = !1;
      const o = new Ar();
      e.forEach((n) => {
        this.forEachParentGroup(t, n, (r) => {
          var a;
          i(r) && (s = !0, this.removeFromParent(r, o), (a = this.selectionSvc) == null || a.setNodesSelected({
            nodes: [r],
            newValue: !1,
            source: "rowGroupChanged"
          }));
        });
      }), o.flush();
    }
  }
  // removes the node from the parent by:
  // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)
  // b) removing from childrenMapped (immediately)
  // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed
  // d) setRowIndex(null) - as the rowNode will no longer be displayed.
  removeFromParent(e, t) {
    var i;
    e.parent && (t ? t.removeFromChildrenAfterGroup(e.parent, e) : (Ae(e.parent.childrenAfterGroup, e), e.parent.updateHasChildren()));
    const s = this.getChildrenMappedKey(e.key, e.rowGroupColumn);
    (i = e.parent) != null && i.childrenMapped && delete e.parent.childrenMapped[s], e.setRowTop(null), e.setRowIndex(null);
  }
  /**
   * This is idempotent, but relies on the `key` field being the same throughout a RowNode's lifetime
   */
  addToParent(e, t) {
    const s = this.getChildrenMappedKey(e.key, e.rowGroupColumn);
    t != null && t.childrenMapped && t.childrenMapped[s] !== e && (t.childrenMapped[s] = e, t.childrenAfterGroup.push(e), UP(t, this.beans, !0));
  }
  areGroupColsEqual(e, t) {
    return e == null || t == null || e.pivotMode !== t.pivotMode ? !1 : pt(e.groupedCols, t.groupedCols) && pt(e.keyCreators, t.keyCreators);
  }
  checkAllGroupDataAfterColsChanged(e) {
    const t = (s) => {
      s && s.forEach((i) => {
        var r;
        if (!i.group)
          return;
        const n = {
          field: i.field,
          key: i.key,
          rowGroupColumn: i.rowGroupColumn,
          leafNode: (r = i.allLeafChildren) == null ? void 0 : r[0]
        };
        this.setGroupData(i, n), t(i.childrenAfterGroup);
      });
    };
    t(e.rootNode.childrenAfterGroup);
  }
  shotgunResetEverything(e, t) {
    var n, r;
    if (this.noChangeInGroupingColumns(e, t))
      return;
    (r = (n = this.selectionSvc) == null ? void 0 : n.filterFromSelection) == null || r.call(n, (a) => !a.group);
    const { groupedCols: s } = e, i = e.rootNode;
    i.leafGroup = s.length === 0, i.childrenAfterGroup = [], i.childrenMapped = {}, i.updateHasChildren();
    const o = i.sibling;
    o && (o.childrenAfterGroup = i.childrenAfterGroup, o.childrenMapped = i.childrenMapped), this.insertNodes(i.allLeafChildren, e);
  }
  noChangeInGroupingColumns(e, t) {
    let s = !1;
    const i = this.showRowGroupCols.getShowRowGroupCols(), o = i ? i.map((n) => n.getId()).join("-") : "";
    return t && (s = this.areGroupColsEqual(e, this.oldGroupingDetails), this.oldGroupDisplayColIds !== o && this.checkAllGroupDataAfterColsChanged(e)), this.oldGroupingDetails = e, this.oldGroupDisplayColIds = o, s;
  }
  insertNodes(e, t) {
    e.forEach((s) => {
      this.insertOneNode(s, t), t.changedPath.active && t.changedPath.addParentNode(s.parent);
    });
  }
  insertOneNode(e, t, s) {
    const i = this.getGroupInfo(e, t), o = this.findParentForNode(e, i, t, s);
    o.group || P(184, { parentGroupData: o.data, childNodeData: e.data }), e.parent = o, e.level = i.length, o.childrenAfterGroup.push(e), o.updateHasChildren();
  }
  findParentForNode(e, t, s, i) {
    let o = s.rootNode;
    return t.forEach((n, r) => {
      o = this.getOrCreateNextNode(o, n, r, s), i != null && i.isRemoveFromAllLeafChildren(o, e) ? i == null || i.preventRemoveFromAllLeafChildren(o, e) : o.allLeafChildren.push(e);
    }), o;
  }
  getOrCreateNextNode(e, t, s, i) {
    var r;
    const o = this.getChildrenMappedKey(t.key, t.rowGroupColumn);
    let n = (r = e == null ? void 0 : e.childrenMapped) == null ? void 0 : r[o];
    return n || (n = this.createGroup(t, e, s, i), this.addToParent(n, e)), n;
  }
  createGroup(e, t, s, i) {
    const o = new Us(this.beans);
    return o.group = !0, o.field = e.field, o.rowGroupColumn = e.rowGroupColumn, this.setGroupData(o, e), o.key = e.key, o.id = this.createGroupId(o, t, s), o.level = s, o.leafGroup = s === i.groupedColCount - 1, o.allLeafChildren = [], o.setAllChildrenCount(0), o.rowGroupIndex = s, o.childrenAfterGroup = [], o.childrenMapped = {}, o.updateHasChildren(), o.parent = t, this.setExpandedInitialValue(i, o), o;
  }
  createGroupId(e, t, s) {
    const i = (o, n) => {
      if (!o.rowGroupColumn)
        return null;
      const r = n ? i(n, n.parent) : null;
      return `${r == null ? "" : r + "-"}${o.rowGroupColumn.getColId()}-${o.key}`;
    };
    return Rn + i(e, t);
  }
  setGroupData(e, t) {
    const s = t.rowGroupColumn;
    s && t.leafNode && (e.groupValue = this.valueSvc.getValue(s, t.leafNode)), e.groupData = {}, this.showRowGroupCols.getShowRowGroupCols().forEach((o) => {
      const n = e.rowGroupColumn;
      n !== null && o.isRowGroupDisplayed(n.getId()) && (e.groupData[o.getColId()] = this.valueSvc.getValue(n, t.leafNode));
    });
  }
  getChildrenMappedKey(e, t) {
    return t ? t.getId() + "-" + e : e;
  }
  setExpandedInitialValue(e, t) {
    if (e.pivotMode && t.leafGroup) {
      t.expanded = !1;
      return;
    }
    const s = e.isGroupOpenByDefault;
    if (s) {
      const i = {
        rowNode: t,
        field: t.field,
        key: t.key,
        level: t.level,
        rowGroupColumn: t.rowGroupColumn
      };
      t.expanded = s(i) == !0;
      return;
    }
    if (e.expandByDefault === -1) {
      t.expanded = !0;
      return;
    }
    t.expanded = t.level < e.expandByDefault;
  }
  getGroupInfo(e, t) {
    const s = [];
    return t.groupedCols.forEach((i) => {
      let o = this.valueSvc.getKeyForNode(i, e), n = o != null && o !== "";
      if ((t.pivotMode || !t.groupAllowUnbalanced) && !n && (o = "", n = !0), n) {
        const a = {
          key: o,
          field: i.getColDef().field,
          rowGroupColumn: i,
          leafNode: e
        };
        s.push(a);
      }
    }), s;
  }
};
function nM(e, t) {
  var s;
  (s = e.rowGroupColsSvc) == null || s.setColumns(t, "api");
}
function rM(e, t) {
  var s;
  (s = e.rowGroupColsSvc) == null || s.removeColumns(t, "api");
}
function aM(e, t) {
  var s;
  (s = e.rowGroupColsSvc) == null || s.addColumns(t, "api");
}
function lM(e, t, s) {
  var i, o;
  (o = (i = e.rowGroupColsSvc) == null ? void 0 : i.moveColumn) == null || o.call(i, t, s, "api");
}
function dM(e) {
  var t;
  return ((t = e.rowGroupColsSvc) == null ? void 0 : t.columns) ?? [];
}
var Og = {
  moduleName: "SharedRowGrouping",
  version: ce,
  apiFunctions: {
    setRowGroupColumns: nM,
    removeRowGroupColumns: rM,
    addRowGroupColumns: aM,
    getRowGroupColumns: dM,
    moveRowGroupColumn: lM
  },
  dependsOn: [Ie, ml, kg, Gg]
}, cM = {
  moduleName: "RowGrouping",
  version: ce,
  dynamicBeans: { groupStrategy: oM },
  rowModels: ["clientSide"],
  dependsOn: [Og, O0, sM]
}, uM = {
  tag: "div",
  cls: "ag-filter-toolpanel-search",
  role: "presentation",
  children: [
    {
      tag: "div",
      ref: "eExpand",
      cls: "ag-filter-toolpanel-expand"
    },
    {
      tag: "ag-input-text-field",
      ref: "eFilterTextField",
      cls: "ag-filter-toolpanel-search-input"
    }
  ]
}, hM = class extends L {
  constructor() {
    super(...arguments), this.eExpand = x, this.eFilterTextField = x;
  }
  postConstruct() {
    this.setTemplate(uM, [yh]);
    const e = this.getLocaleTextFunc();
    this.eFilterTextField.setAutoComplete(!1).setInputAriaLabel(e("ariaFilterColumnsInput", "Filter Columns Input")).onValueChange(this.onSearchTextChanged.bind(this)), this.createExpandIcons(), this.setExpandState(
      0
      /* EXPANDED */
    ), this.addManagedElementListeners(this.eExpand, { click: this.onExpandClicked.bind(this) }), this.addManagedEventListeners({ newColumnsLoaded: this.showOrHideOptions.bind(this) });
  }
  init(e) {
    this.params = e, this.beans.colModel.ready && this.showOrHideOptions();
  }
  createExpandIcons() {
    const { eExpand: e, beans: t } = this;
    e.appendChild(this.eExpandChecked = k("accordionOpen", t)), e.appendChild(this.eExpandUnchecked = k("accordionClosed", t)), e.appendChild(this.eExpandIndeterminate = k("accordionIndeterminate", t));
  }
  // we only show expand / collapse if we are showing filters
  showOrHideOptions() {
    const { params: e, eFilterTextField: t } = this, s = !e.suppressFilterSearch, i = !e.suppressExpandAll, o = this.getLocaleTextFunc();
    t.setInputPlaceholder(o("searchOoo", "Search..."));
    const n = (a) => a.getOriginalParent() && a.isFilterAllowed(), r = this.beans.colModel.getCols().some(n);
    G(t.getGui(), s), G(this.eExpand, i && r);
  }
  onSearchTextChanged() {
    this.onSearchTextChangedDebounced || (this.onSearchTextChangedDebounced = ct(
      this,
      () => this.dispatchLocalEvent({ type: "searchChanged", searchText: this.eFilterTextField.getValue() }),
      300
    )), this.onSearchTextChangedDebounced();
  }
  onExpandClicked() {
    const e = this.currentExpandState === 0 ? { type: "collapseAll" } : { type: "expandAll" };
    this.dispatchLocalEvent(e);
  }
  setExpandState(e) {
    this.currentExpandState = e, G(
      this.eExpandChecked,
      e === 0
      /* EXPANDED */
    ), G(
      this.eExpandUnchecked,
      e === 1
      /* COLLAPSED */
    ), G(
      this.eExpandIndeterminate,
      e === 2
      /* INDETERMINATE */
    );
  }
}, gM = {
  selector: "AG-FILTERS-TOOL-PANEL-HEADER",
  component: hM
}, pM = {
  tag: "div",
  cls: "ag-filter-toolpanel-instance",
  children: [
    {
      tag: "div",
      ref: "eFilterToolPanelHeader",
      cls: "ag-filter-toolpanel-header ag-filter-toolpanel-instance-header",
      role: "button",
      attrs: { "aria-expanded": "false" },
      children: [
        { tag: "div", ref: "eExpand", cls: "ag-filter-toolpanel-expand" },
        { tag: "span", ref: "eFilterName", cls: "ag-header-cell-text" },
        {
          tag: "span",
          ref: "eFilterIcon",
          cls: "ag-header-icon ag-filter-icon ag-filter-toolpanel-instance-header-icon",
          attrs: { "aria-hidden": "true" }
        }
      ]
    },
    { tag: "div", ref: "agFilterToolPanelBody", cls: "ag-filter-toolpanel-instance-body ag-filter" }
  ]
}, Bg = class extends L {
  constructor(e, t) {
    super(pM), this.hideHeader = e, this.expandedCallback = t, this.eFilterToolPanelHeader = x, this.eFilterName = x, this.agFilterToolPanelBody = x, this.eFilterIcon = x, this.eExpand = x, this.expanded = !1;
  }
  postConstruct() {
    const { beans: e, eExpand: t } = this, s = k("accordionOpen", e);
    this.eExpandChecked = s;
    const i = k("accordionClosed", e);
    this.eExpandUnchecked = i, t.appendChild(s), t.appendChild(i);
  }
  setColumn(e) {
    this.column = e;
    const { beans: t, eFilterToolPanelHeader: s, eFilterIcon: i, eExpandChecked: o, hideHeader: n } = this;
    this.eFilterName.innerText = t.colNames.getDisplayNameForColumn(e, "filterToolPanel", !1) || "", this.addManagedListeners(s, {
      click: this.toggleExpanded.bind(this),
      keydown: this.onKeyDown.bind(this)
    }), this.addManagedEventListeners({ filterOpened: this.onFilterOpened.bind(this) }), this.addInIcon("filterActive", i, e), G(i, this.isFilterActive(), { skipAriaHidden: !0 }), G(o, !1), n ? (G(s, !1), s.removeAttribute("tabindex")) : s.setAttribute("tabindex", "0"), this.addManagedListeners(e, { filterChanged: this.onFilterChanged.bind(this) });
  }
  onKeyDown(e) {
    const { key: t } = e, { ENTER: s, SPACE: i, LEFT: o, RIGHT: n } = y;
    t !== s && t !== i && t !== o && t !== n || (e.preventDefault(), t === s || t === i ? this.toggleExpanded() : t === y.LEFT ? this.collapse() : this.expand());
  }
  getColumn() {
    return this.column;
  }
  getColumnFilterName() {
    return this.beans.colNames.getDisplayNameForColumn(this.column, "filterToolPanel", !1);
  }
  addCssClassToTitleBar(e) {
    this.eFilterToolPanelHeader.classList.add(e);
  }
  addInIcon(e, t, s) {
    if (t == null)
      return;
    const i = k(e, this.beans, s);
    t.appendChild(i);
  }
  isFilterActive() {
    var e;
    return !!((e = this.beans.filterManager) != null && e.isFilterActive(this.column));
  }
  onFilterChanged() {
    G(this.eFilterIcon, this.isFilterActive(), { skipAriaHidden: !0 }), this.dispatchLocalEvent({ type: "filterChanged" });
  }
  toggleExpanded() {
    this.expanded ? this.collapse() : this.expand();
  }
  expand() {
    this.expanded || (this.expanded = !0, ot(this.eFilterToolPanelHeader, !0), G(this.eExpandChecked, !0), G(this.eExpandUnchecked, !1), this.addFilterElement(), this.expandedCallback());
  }
  addFilterElement(e) {
    var i;
    const t = _({ tag: "div", cls: "ag-filter-toolpanel-instance-filter" }), s = this.createManagedBean(new $a(this.column, "TOOLBAR"));
    this.filterWrapperComp = s, s.hasFilter() && ((i = s.getFilter()) == null || i.then((o) => {
      this.underlyingFilter = o, o && (t.appendChild(s.getGui()), this.agFilterToolPanelBody.appendChild(t), s.afterGuiAttached({ container: "toolPanel", suppressFocus: e }));
    }));
  }
  collapse() {
    if (!this.expanded)
      return;
    this.expanded = !1, ot(this.eFilterToolPanelHeader, !1), this.removeFilterElement(), G(this.eExpandChecked, !1), G(this.eExpandUnchecked, !0);
    const e = this.filterWrapperComp;
    e == null || e.afterGuiDetached(), this.destroyBean(e), this.expandedCallback();
  }
  removeFilterElement() {
    de(this.agFilterToolPanelBody);
  }
  isExpanded() {
    return this.expanded;
  }
  refreshFilter(e) {
    var s;
    if (!this.expanded)
      return;
    const t = this.underlyingFilter;
    t && (e ? typeof t.refreshVirtualList == "function" && t.refreshVirtualList() : (s = t.afterGuiDetached) == null || s.call(t));
  }
  onFilterOpened(e) {
    e.source === "COLUMN_MENU" && e.column === this.column && this.expanded && this.collapse();
  }
}, Qt = class Ng extends L {
  constructor(t, s, i, o, n) {
    super(), this.columnGroup = t, this.childFilterComps = s, this.expandedCallback = i, this.depth = o, this.showingColumn = n, this.filterGroupComp = x;
  }
  postConstruct() {
    const t = {
      cssIdentifier: "filter-toolpanel",
      direction: "vertical"
    };
    this.setTemplate(
      {
        tag: "div",
        cls: "ag-filter-toolpanel-group-wrapper",
        children: [{ tag: "ag-group-component", ref: "filterGroupComp" }]
      },
      [p0],
      { filterGroupComp: t }
    ), this.setGroupTitle();
    const { filterGroupComp: s, depth: i, childFilterComps: o, gos: n } = this;
    s.setAlignItems("stretch"), s.addCss(`ag-filter-toolpanel-group-level-${i}`), s.getGui().style.setProperty("--ag-indentation-level", String(i)), s.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${i}-header`), o.forEach((r) => {
      s.addItem(r), r.addCssClassToTitleBar(`ag-filter-toolpanel-group-level-${i + 1}-header`), r.getGui().style.setProperty("--ag-indentation-level", String(i + 1));
    }), this.tooltipFeature = this.createOptionalManagedBean(
      this.beans.registry.createDynamicBean("tooltipFeature", !1, {
        getGui: () => this.getGui(),
        getLocation: () => "filterToolPanelColumnGroup",
        shouldDisplayTooltip: sl(
          n,
          () => s.getGui().querySelector(".ag-group-title")
        )
      })
    ), this.refreshFilterClass(), this.addExpandCollapseListeners(), this.addFilterChangedListeners(), this.setupTooltip(), this.addInIcon("filterActive");
  }
  setupTooltip() {
    if (!this.showingColumn)
      return;
    const t = () => {
      var s;
      (s = this.tooltipFeature) == null || s.setTooltipAndRefresh(this.columnGroup.getColDef().headerTooltip);
    };
    t(), this.addManagedEventListeners({ newColumnsLoaded: t });
  }
  addCssClassToTitleBar(t) {
    this.filterGroupComp.addCssClassToTitleBar(t);
  }
  refreshFilters(t) {
    this.childFilterComps.forEach((s) => {
      s instanceof Ng ? s.refreshFilters(t) : s.refreshFilter(t);
    });
  }
  isColumnGroup() {
    return ae(this.columnGroup);
  }
  isExpanded() {
    return this.filterGroupComp.isExpanded();
  }
  getChildren() {
    return this.childFilterComps;
  }
  getFilterGroupName() {
    return this.filterGroupName ?? "";
  }
  getFilterGroupId() {
    return this.columnGroup.getId();
  }
  hideGroupItem(t, s) {
    this.filterGroupComp.hideItem(t, s);
  }
  hideGroup(t) {
    this.setDisplayed(!t);
  }
  addInIcon(t) {
    const s = k(t, this.beans);
    s && s.classList.add("ag-filter-toolpanel-group-instance-header-icon"), this.filterGroupComp.addTitleBarWidget(s);
  }
  forEachToolPanelFilterChild(t) {
    this.childFilterComps.forEach((s) => {
      s instanceof Bg && t(s);
    });
  }
  addExpandCollapseListeners() {
    const t = this.isColumnGroup() ? () => this.expandedCallback() : () => this.forEachToolPanelFilterChild((i) => i.expand()), s = this.isColumnGroup() ? () => this.expandedCallback() : () => this.forEachToolPanelFilterChild((i) => i.collapse());
    this.addManagedListeners(this.filterGroupComp, {
      expanded: t,
      collapsed: s
    });
  }
  getColumns() {
    return ae(this.columnGroup) ? this.columnGroup.getLeafColumns() : [this.columnGroup];
  }
  addFilterChangedListeners() {
    this.getColumns().forEach((t) => {
      this.addManagedListeners(t, { filterChanged: () => this.refreshFilterClass() });
    }), ae(this.columnGroup) || this.addManagedEventListeners({ filterOpened: this.onFilterOpened.bind(this) });
  }
  refreshFilterClass() {
    const t = this.getColumns(), s = () => t.some((i) => i.isFilterActive());
    this.filterGroupComp.toggleCss("ag-has-filter", s());
  }
  onFilterOpened(t) {
    t.source === "COLUMN_MENU" && t.column === this.columnGroup && this.isExpanded() && this.collapse();
  }
  expand() {
    this.filterGroupComp.toggleGroupExpand(!0);
  }
  collapse() {
    this.filterGroupComp.toggleGroupExpand(!1);
  }
  setGroupTitle() {
    const t = this.columnGroup, s = ae(t) ? this.getColumnGroupName(t) : this.getColumnName(t);
    this.filterGroupName = s, this.filterGroupComp.setTitle(s || "");
  }
  getColumnGroupName(t) {
    return this.beans.colNames.getDisplayNameForProvidedColumnGroup(null, t, "filterToolPanel");
  }
  getColumnName(t) {
    return this.beans.colNames.getDisplayNameForColumn(t, "filterToolPanel", !1);
  }
  destroyFilters() {
    this.childFilterComps = this.destroyBeans(this.childFilterComps), de(this.getGui());
  }
  destroy() {
    this.destroyFilters(), super.destroy();
  }
}, fM = class extends L {
  constructor() {
    super({ tag: "div", cls: "ag-filter-list-panel" }), this.initialised = !1, this.hasLoadedInitialState = !1, this.isInitialState = !1, this.filterGroupComps = [], this.suppressOnColumnsChanged = !1, this.onColumnsChangedPending = !1;
  }
  wireBeans(e) {
    this.colModel = e.colModel;
  }
  init(e) {
    this.initialised = !0;
    const t = N(this.gos, {
      suppressExpandAll: !1,
      suppressFilterSearch: !1,
      suppressSyncLayoutWithGrid: !1
    });
    me(t, e), this.params = t, t.suppressSyncLayoutWithGrid || this.addManagedEventListeners({ columnMoved: () => this.onColumnsChanged() }), this.addManagedEventListeners({
      newColumnsLoaded: () => this.onColumnsChanged(),
      toolPanelVisibleChanged: (s) => {
        s.key === "filters" && this.refreshFilters(s.visible);
      },
      dragStarted: () => {
        this.suppressOnColumnsChanged = !0;
      },
      dragStopped: () => {
        this.suppressOnColumnsChanged = !1, this.onColumnsChangedPending && (this.onColumnsChangedPending = !1, this.onColumnsChanged());
      }
    }), this.colModel.ready && this.onColumnsChanged();
  }
  onColumnsChanged() {
    if (this.suppressOnColumnsChanged) {
      this.onColumnsChangedPending = !0;
      return;
    }
    const e = this.colModel.isPivotMode();
    !this.params.suppressSyncLayoutWithGrid && !e ? this.syncFilterLayout() : this.buildTreeFromProvidedColumnDefs(), this.refreshAriaLabel();
  }
  syncFilterLayout() {
    mg(this.colModel, this.setFiltersLayout.bind(this)), this.refreshAriaLabel();
  }
  buildTreeFromProvidedColumnDefs() {
    const e = this.colModel.getColDefColTree();
    this.recreateFilters(e);
  }
  setFiltersLayout(e) {
    const t = fg(this.colModel, e);
    this.recreateFilters(t);
  }
  recreateFilters(e) {
    const t = te(this.beans);
    this.hasLoadedInitialState || (this.hasLoadedInitialState = !0, this.isInitialState = !!this.params.initialState);
    const s = this.getExpansionState();
    this.destroyFilters();
    const i = this.recursivelyAddComps(e, 0, s);
    this.filterGroupComps = i;
    const o = i.length;
    o && (i.forEach((r) => this.appendChild(r)), this.setFirstAndLastVisible(0, o - 1));
    const n = this.searchFilterText;
    T(n) && this.searchFilters(n), this.fireExpandedEvent(), this.getGui().contains(t) && t.focus(), this.isInitialState = !1, this.refreshAriaLabel();
  }
  recursivelyAddComps(e, t, s) {
    return e.map((i) => {
      var l;
      if (ae(i))
        return ((l = this.recursivelyAddFilterGroupComps(i, t, s)) == null ? void 0 : l.flatMap((d) => d)) ?? [];
      const o = i;
      if (!this.shouldDisplayFilter(o))
        return [];
      const n = t === 0, r = new Bg(n, () => this.onFilterExpanded());
      if (this.createBean(r), r.setColumn(o), s.get(o.getId()) && r.expand(), t > 0)
        return r;
      const a = this.createBean(
        new Qt(o, [r], this.onGroupExpanded.bind(this), t, !0)
      );
      return a.addCssClassToTitleBar("ag-filter-toolpanel-header"), s.get(a.getFilterGroupId()) || a.collapse(), a;
    }).flatMap((i) => i);
  }
  refreshAriaLabel() {
    const e = this.getLocaleTextFunc(), t = e("ariaFilterPanelList", "Filter List"), s = e("filters", "Filters"), l = this.getGui().querySelectorAll(".ag-filter-toolpanel-group-item:not(.ag-filter-toolpanel-group-wrapper, .ag-hidden)").length;
    Ee(this.getAriaElement(), `${t} ${l} ${s}`);
  }
  recursivelyAddFilterGroupComps(e, t, s) {
    if (!this.filtersExistInChildren(e.getChildren()))
      return;
    const i = e.getColGroupDef();
    if (i && i.suppressFiltersToolPanel)
      return [];
    const o = e.isPadding() ? t : t + 1, n = this.recursivelyAddComps(e.getChildren(), o, s).flatMap(
      (l) => l
    );
    if (e.isPadding())
      return n;
    const r = new Qt(
      e,
      n,
      this.onGroupExpanded.bind(this),
      t,
      !1
    );
    this.createBean(r), r.addCssClassToTitleBar("ag-filter-toolpanel-header");
    const a = s.get(r.getFilterGroupId());
    return (this.isInitialState && !a || a === !1) && r.collapse(), [r];
  }
  filtersExistInChildren(e) {
    return e.some((t) => ae(t) ? this.filtersExistInChildren(t.getChildren()) : this.shouldDisplayFilter(t));
  }
  shouldDisplayFilter(e) {
    const t = e.getColDef() && e.getColDef().suppressFiltersToolPanel;
    return e.isFilterAllowed() && !t;
  }
  getExpansionState() {
    const e = /* @__PURE__ */ new Map();
    if (this.isInitialState) {
      const { expandedColIds: s, expandedGroupIds: i } = this.params.initialState;
      return s.forEach((o) => e.set(o, !0)), i.forEach((o) => e.set(o, !0)), e;
    }
    const t = (s) => {
      e.set(s.getFilterGroupId(), s.isExpanded()), s.getChildren().forEach((i) => {
        i instanceof Qt ? t(i) : e.set(i.getColumn().getId(), i.isExpanded());
      });
    };
    return this.filterGroupComps.forEach(t), e;
  }
  // we don't support refreshing, but must implement because it's on the tool panel interface
  refresh() {
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  expandFilterGroups(e, t) {
    const s = [], i = (o) => {
      const n = o.getFilterGroupId();
      (!t || t.includes(n)) && (e && o.isColumnGroup() ? o.expand() : o.collapse(), s.push(n)), o.getChildren().forEach((a) => {
        a instanceof Qt && i(a);
      });
    };
    if (this.filterGroupComps.forEach(i), this.onGroupExpanded(), t) {
      const o = t.filter((n) => s.indexOf(n) < 0);
      o.length > 0 && P(166, { unrecognisedGroupIds: o });
    }
  }
  expandFilters(e, t) {
    const s = [], i = (o) => {
      if (o instanceof Qt) {
        let a = !1;
        return o.getChildren().forEach((l) => {
          i(l) && (e ? (o.expand(), a = !0) : o.isColumnGroup() || o.collapse());
        }), a;
      }
      const n = o.getColumn().getColId(), r = !t || t.includes(n);
      return r && (e ? o.expand() : o.collapse(), s.push(n)), r;
    };
    if (this.filterGroupComps.forEach(i), this.onGroupExpanded(), t) {
      const o = t.filter((n) => s.indexOf(n) < 0);
      o.length > 0 && P(167, { unrecognisedColIds: o });
    }
  }
  onGroupExpanded() {
    this.fireExpandedEvent();
  }
  onFilterExpanded() {
    this.dispatchLocalEvent({ type: "filterExpanded" });
  }
  fireExpandedEvent() {
    let e = 0, t = 0;
    const s = (o) => {
      o.isColumnGroup() && (o.isExpanded() ? e++ : t++, o.getChildren().forEach((n) => {
        n instanceof Qt && s(n);
      }));
    };
    this.filterGroupComps.forEach(s);
    let i;
    e > 0 && t > 0 ? i = 2 : t > 0 ? i = 1 : i = 0, this.dispatchLocalEvent({ type: "groupExpanded", state: i });
  }
  performFilterSearch(e) {
    this.searchFilterText = T(e) ? e.toLowerCase() : null, this.searchFilters(this.searchFilterText);
  }
  searchFilters(e) {
    const t = (n) => !T(e) || n.toLowerCase().indexOf(e) !== -1, s = (n, r) => {
      if (!(n instanceof Qt))
        return t(n.getColumnFilterName() || "");
      const a = n.getChildren(), l = t(n.getFilterGroupName()), d = r || l;
      if (d) {
        n.hideGroup(!1);
        for (let u = 0; u < a.length; u++)
          s(a[u], d), n.hideGroupItem(!1, u);
        return !0;
      }
      let c = !1;
      return a.forEach((u, h) => {
        const g = s(u, r);
        n.hideGroupItem(!g, h), g && (c = !0);
      }), n.hideGroup(!c), c;
    };
    let i, o;
    this.filterGroupComps.forEach((n, r) => {
      var l;
      s(n, !1);
      const a = (l = n.getGui()) == null ? void 0 : l.classList.contains("ag-hidden");
      i === void 0 ? a || (i = r, o = r) : !a && o !== r && (o = r);
    }), this.setFirstAndLastVisible(i, o), this.refreshAriaLabel();
  }
  setFirstAndLastVisible(e, t) {
    this.filterGroupComps.forEach((s, i) => {
      s.removeCss("ag-first-group-visible"), s.removeCss("ag-last-group-visible"), i === e && s.addCss("ag-first-group-visible"), i === t && s.addCss("ag-last-group-visible");
    });
  }
  refreshFilters(e) {
    this.filterGroupComps.forEach((t) => t.refreshFilters(e));
  }
  getExpandedFiltersAndGroups() {
    const e = [], t = /* @__PURE__ */ new Set(), s = (i) => {
      if (i instanceof Qt) {
        i.getChildren().forEach((n) => s(n));
        const o = i.getFilterGroupId();
        i.isExpanded() && !t.has(o) && e.push(o);
      } else
        i.isExpanded() && t.add(i.getColumn().getColId());
    };
    return this.filterGroupComps.forEach(s), { expandedGroupIds: e, expandedColIds: Array.from(t) };
  }
  destroyFilters() {
    this.filterGroupComps = this.destroyBeans(this.filterGroupComps), de(this.getGui());
  }
  destroy() {
    this.destroyFilters(), super.destroy();
  }
}, mM = {
  selector: "AG-FILTERS-TOOL-PANEL-LIST",
  component: fM
}, CM = (
  /*css*/
  ".ag-filter-toolpanel{flex:1 1 0px;min-width:0}.ag-filter-toolpanel-header,.ag-filter-toolpanel-search{align-items:center;color:var(--ag-header-text-color);display:flex;font-weight:var(--ag-header-font-weight);padding:0 var(--ag-spacing);>*{align-items:center;display:flex}}.ag-filter-toolpanel-header{padding-bottom:var(--ag-spacing);padding-top:var(--ag-spacing);position:relative;&:focus-visible{border-radius:var(--ag-border-radius);box-shadow:inset var(--ag-focus-shadow)}}:where(.ag-ltr) .ag-filter-toolpanel-group-instance-header-icon,:where(.ag-ltr) .ag-filter-toolpanel-instance-header-icon{margin-left:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-group-instance-header-icon,:where(.ag-rtl) .ag-filter-toolpanel-instance-header-icon{margin-right:var(--ag-spacing)}.ag-filter-toolpanel-search{min-height:var(--ag-header-height);padding-bottom:var(--ag-spacing);padding-top:var(--ag-widget-container-vertical-padding)}:where(.ag-filter-toolpanel-group:not(.ag-has-filter)>.ag-group-title-bar) .ag-filter-toolpanel-group-instance-header-icon{display:none}.ag-filter-toolpanel-search-input{flex-grow:1;height:calc(var(--ag-spacing)*4)}:where(.ag-ltr) .ag-filter-toolpanel-group-title-bar-icon{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-group-title-bar-icon{margin-left:var(--ag-spacing)}.ag-filter-toolpanel-expand{cursor:pointer}:where(.ag-ltr) .ag-filter-toolpanel-expand{margin-right:var(--ag-spacing)}:where(.ag-rtl) .ag-filter-toolpanel-expand{margin-left:var(--ag-spacing)}:where(.ag-ltr) .ag-filter-toolpanel-group-title-bar,:where(.ag-ltr) .ag-filter-toolpanel-instance-header{padding-left:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}:where(.ag-rtl) .ag-filter-toolpanel-group-title-bar,:where(.ag-rtl) .ag-filter-toolpanel-instance-header{padding-right:calc(var(--ag-spacing) + var(--ag-filter-tool-panel-group-indent)*var(--ag-indentation-level))}:where(.ag-ltr) .ag-filter-toolpanel-instance-body{margin-left:var(--ag-filter-tool-panel-group-indent)}:where(.ag-rtl) .ag-filter-toolpanel-instance-body{margin-right:var(--ag-filter-tool-panel-group-indent)}.ag-filter-toolpanel-instance-filter{background-color:var(--ag-chrome-background-color)}.ag-filter-toolpanel-group-level-0{border-top:none}"
), vM = {
  tag: "div",
  cls: "ag-filter-toolpanel",
  children: [
    { tag: "ag-filters-tool-panel-header", ref: "filtersToolPanelHeaderPanel" },
    { tag: "ag-filters-tool-panel-list", ref: "filtersToolPanelListPanel" }
  ]
}, wM = class extends L {
  constructor() {
    super(vM, [gM, mM]), this.filtersToolPanelHeaderPanel = x, this.filtersToolPanelListPanel = x, this.initialised = !1, this.listenerDestroyFuncs = [], this.registerCSS(CM);
  }
  init(e) {
    this.initialised && (this.listenerDestroyFuncs.forEach((a) => a()), this.listenerDestroyFuncs = []), this.initialised = !0;
    const s = {
      ...N(this.gos, {
        suppressExpandAll: !1,
        suppressFilterSearch: !1,
        suppressSyncLayoutWithGrid: !1
      }),
      ...e
    };
    this.params = s;
    const { filtersToolPanelHeaderPanel: i, filtersToolPanelListPanel: o } = this;
    i.init(s), o.init(s);
    const n = s.suppressExpandAll, r = s.suppressFilterSearch;
    n && r && i.setDisplayed(!1), this.listenerDestroyFuncs.push(
      ...this.addManagedListeners(i, {
        expandAll: () => o.expandFilterGroups(!0),
        collapseAll: () => o.expandFilterGroups(!1),
        searchChanged: (a) => o.performFilterSearch(a.searchText)
      }),
      ...this.addManagedListeners(o, {
        filterExpanded: s.onStateUpdated,
        groupExpanded: (a) => {
          i.setExpandState(a.state), s.onStateUpdated();
        }
      })
    );
  }
  // lazy initialise the panel
  setVisible(e) {
    super.setDisplayed(e), e && !this.initialised && this.init(this.params);
  }
  setFilterLayout(e) {
    this.filtersToolPanelListPanel.setFiltersLayout(e);
  }
  expandFilterGroups(e) {
    this.filtersToolPanelListPanel.expandFilterGroups(!0, e);
  }
  collapseFilterGroups(e) {
    this.filtersToolPanelListPanel.expandFilterGroups(!1, e);
  }
  expandFilters(e) {
    this.filtersToolPanelListPanel.expandFilters(!0, e);
  }
  collapseFilters(e) {
    this.filtersToolPanelListPanel.expandFilters(!1, e);
  }
  syncLayoutWithGrid() {
    this.filtersToolPanelListPanel.syncFilterLayout();
  }
  refresh(e) {
    return this.init(e), !0;
  }
  getState() {
    return this.filtersToolPanelListPanel.getExpandedFiltersAndGroups();
  }
}, bM = {
  moduleName: "FiltersToolPanel",
  version: ce,
  userComponents: { agFiltersToolPanel: wM },
  icons: {
    // filter tool panel tab
    filtersToolPanel: "filter"
  },
  dependsOn: [hl, Ie, ul]
}, yM = {
  tag: "div",
  cls: "ag-loading",
  children: [
    { tag: "span", ref: "eLoadingIcon", cls: "ag-loading-icon" },
    { tag: "span", ref: "eLoadingText", cls: "ag-loading-text" }
  ]
}, SM = class extends L {
  constructor() {
    super(yM), this.eLoadingIcon = x, this.eLoadingText = x;
  }
  init(e) {
    e.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    this.eLoadingText.textContent = this.getLocaleTextFunc()("loadingError", "ERR");
  }
  setupLoading() {
    const e = k("groupLoading", this.beans, null);
    e && this.eLoadingIcon.appendChild(e), this.eLoadingText.textContent = this.getLocaleTextFunc()("loadingOoo", "Loading");
  }
  refresh(e) {
    return !1;
  }
}, xM = { tag: "div", cls: "ag-skeleton-container" }, RM = class extends L {
  constructor() {
    super(xM);
  }
  init(e) {
    const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", t), this.addDestroyFunc(() => to(e.eParentOfValue)), to(e.eParentOfValue, t), e.node.failedLoad ? this.setupFailed() : this.setupLoading(e);
  }
  setupFailed() {
    const e = this.getLocaleTextFunc();
    this.getGui().textContent = e("loadingError", "ERR");
    const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
    Ee(this.getGui(), t);
  }
  setupLoading(e) {
    const t = _({
      tag: "div",
      cls: "ag-skeleton-effect"
    }), s = e.node.rowIndex;
    if (s != null) {
      const n = 75 + 25 * (s % 2 === 0 ? Math.sin(s) : Math.cos(s));
      t.style.width = `${n}%`;
    }
    this.getGui().appendChild(t);
    const o = this.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
    Ee(this.getGui(), o);
  }
  refresh(e) {
    return !1;
  }
}, FM = {
  moduleName: "LoadingCellRenderer",
  version: ce,
  userComponents: {
    agLoadingCellRenderer: SM
  },
  icons: {
    // rotating spinner shown by the loading cell renderer
    groupLoading: "loading"
  },
  dependsOn: [Ie]
}, PM = {
  moduleName: "SkeletonCellRenderer",
  version: ce,
  userComponents: {
    agSkeletonCellRenderer: RM
  },
  dependsOn: [Ie]
};
function DM(e) {
  return e.colModel.isPivotMode();
}
function MM(e, t, s) {
  var i;
  return ((i = e.pivotResultCols) == null ? void 0 : i.lookupPivotResultCol(t, s)) ?? null;
}
function EM(e, t) {
  var s;
  (s = e.valueColsSvc) == null || s.setColumns(t, "api");
}
function AM(e) {
  var t;
  return ((t = e.valueColsSvc) == null ? void 0 : t.columns) ?? [];
}
function IM(e, t) {
  var s;
  (s = e.valueColsSvc) == null || s.removeColumns(t, "api");
}
function TM(e, t) {
  var s;
  (s = e.valueColsSvc) == null || s.addColumns(t, "api");
}
function LM(e, t) {
  var s;
  (s = e.pivotColsSvc) == null || s.setColumns(t, "api");
}
function kM(e, t) {
  var s;
  (s = e.pivotColsSvc) == null || s.removeColumns(t, "api");
}
function GM(e, t) {
  var s;
  (s = e.pivotColsSvc) == null || s.addColumns(t, "api");
}
function OM(e) {
  var t;
  return ((t = e.pivotColsSvc) == null ? void 0 : t.columns) ?? [];
}
function BM(e, t) {
  var s;
  (s = e.pivotResultCols) == null || s.setPivotResultCols(t, "api");
}
function NM(e) {
  var s;
  const t = (s = e.pivotResultCols) == null ? void 0 : s.getPivotResultCols();
  return t ? t.list : null;
}
var _d = "PivotRowTotal_", HM = ({ headerName: e }, { headerName: t }) => e && !t ? 1 : !e && t ? -1 : !e && !t ? 0 : e < t ? -1 : e > t ? 1 : 0, VM = (e) => (t, s) => e(t.headerName, s.headerName), _M = class extends S {
  constructor() {
    super(...arguments), this.beanName = "pivotColDefSvc";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.pivotColsSvc = e.pivotColsSvc, this.valueColsSvc = e.valueColsSvc, this.colNames = e.colNames;
  }
  postConstruct() {
    const e = () => this.gos.get("serverSidePivotResultFieldSeparator") ?? "_";
    this.fieldSeparator = e(), this.addManagedPropertyListener("serverSidePivotResultFieldSeparator", () => {
      this.fieldSeparator = e();
    });
    const t = () => this.gos.get("pivotDefaultExpanded");
    this.pivotDefaultExpanded = t(), this.addManagedPropertyListener("pivotDefaultExpanded", () => {
      this.pivotDefaultExpanded = t();
    });
  }
  createPivotColumnDefs(e) {
    const t = this.createPivotColumnsFromUniqueValues(e);
    function s(n, r = []) {
      return n.forEach((a) => {
        a.children !== void 0 ? s(a.children, r) : r.push(a);
      }), r;
    }
    const i = s(t);
    this.addRowGroupTotals(t, i), this.addExpandablePivotGroups(t, i), this.addPivotTotalsToGroups(t, i);
    const o = i.map((n) => ({ ...n }));
    return {
      pivotColumnGroupDefs: t,
      pivotColumnDefs: o
    };
  }
  createPivotColumnsFromUniqueValues(e) {
    var o;
    const t = ((o = this.pivotColsSvc) == null ? void 0 : o.columns) ?? [], s = t.length;
    return this.recursivelyBuildGroup(
      0,
      e,
      [],
      s,
      t
    );
  }
  recursivelyBuildGroup(e, t, s, i, o) {
    var d;
    if (e >= i)
      return this.buildMeasureCols(s);
    const { pivotComparator: n } = o[e].getColDef(), r = n ? VM(n) : HM, a = (d = this.valueColsSvc) == null ? void 0 : d.columns;
    if ((a == null ? void 0 : a.length) === 1 && this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && e === i - 1) {
      const c = [];
      for (const u of t.keys()) {
        const h = [...s, u], g = this.createColDef(a[0], u, h);
        g.columnGroupShow = "open", c.push(g);
      }
      return c.sort(r), c;
    }
    const l = [];
    for (const c of t.keys()) {
      const u = this.pivotDefaultExpanded === -1 || e < this.pivotDefaultExpanded, h = [...s, c];
      l.push({
        children: this.recursivelyBuildGroup(
          e + 1,
          t.get(c),
          h,
          i,
          o
        ),
        headerName: c,
        pivotKeys: h,
        columnGroupShow: "open",
        openByDefault: u,
        groupId: this.generateColumnGroupId(h)
      });
    }
    return l.sort(r), l;
  }
  buildMeasureCols(e) {
    var s;
    const t = ((s = this.valueColsSvc) == null ? void 0 : s.columns) ?? [];
    return t.length === 0 ? [this.createColDef(null, "-", e)] : t.map((i) => {
      const o = this.colNames.getDisplayNameForColumn(i, "header");
      return {
        ...this.createColDef(i, o, e),
        columnGroupShow: "open"
      };
    });
  }
  addExpandablePivotGroups(e, t) {
    const s = this.gos.get("suppressExpandablePivotGroups");
    if (s || this.gos.get("pivotColumnGroupTotals"))
      return;
    const i = (o, n, r) => {
      if ("children" in o) {
        const { valueColsSvc: d } = this, { columns: c = [] } = d ?? {}, u = /* @__PURE__ */ new Map();
        o.children.forEach((p) => {
          i(p, n, u);
        });
        const h = !o.children.some((p) => p.children), g = h && c.length === 1 && this.gos.get("removePivotHeaderRowWhenSingleValueColumn");
        c.forEach((p) => {
          const f = this.colNames.getDisplayNameForColumn(p, "header"), m = this.createColDef(p, f, o.pivotKeys);
          m.pivotTotalColumnIds = u.get(p.getColId()), m.columnGroupShow = s ? "open" : "closed", m.aggFunc = p.getAggFunc(), (!h || g) && (o.children.push(m), n.push(m));
        }), this.merge(r, u);
        return;
      }
      if (!o.pivotValueColumn)
        return;
      const a = o.pivotValueColumn.getColId();
      r.has(a) ? r.get(a).push(o.colId) : r.set(a, [o.colId]);
    };
    e.forEach((o) => {
      i(o, t, /* @__PURE__ */ new Map());
    });
  }
  addPivotTotalsToGroups(e, t) {
    var n;
    if (!this.gos.get("pivotColumnGroupTotals"))
      return;
    const s = this.gos.get("pivotColumnGroupTotals") === "after", i = (n = this.valueColsSvc) == null ? void 0 : n.columns, o = i == null ? void 0 : i.map((r) => r.getAggFunc());
    if (!(!o || o.length < 1 || !this.sameAggFuncs(o)) && i) {
      const r = i[0];
      e.forEach((a) => {
        this.recursivelyAddPivotTotal(a, t, r, s);
      });
    }
  }
  recursivelyAddPivotTotal(e, t, s, i) {
    const o = e;
    if (!o.children) {
      const r = e;
      return r.colId ? [r.colId] : null;
    }
    let n = [];
    if (o.children.forEach((r) => {
      const a = this.recursivelyAddPivotTotal(r, t, s, i);
      a && (n = n.concat(a));
    }), o.children.length > 1) {
      const a = this.getLocaleTextFunc()("pivotColumnGroupTotals", "Total"), l = this.createColDef(s, a, e.pivotKeys, !0);
      l.pivotTotalColumnIds = n, l.aggFunc = s.getAggFunc(), l.columnGroupShow = this.gos.get("suppressExpandablePivotGroups") ? "open" : void 0;
      const d = e.children;
      i ? d.push(l) : d.unshift(l), t.push(l);
    }
    return n;
  }
  addRowGroupTotals(e, t) {
    var r;
    if (!this.gos.get("pivotRowTotals"))
      return;
    const s = this.gos.get("pivotRowTotals") === "after", o = (((r = this.valueColsSvc) == null ? void 0 : r.columns) ?? []).slice();
    s || o.reverse();
    const n = o.length > 1 || !this.gos.get("removePivotHeaderRowWhenSingleValueColumn");
    for (let a = 0; a < o.length; a++) {
      const l = o[a], d = this.colNames.getDisplayNameForColumn(l, "header"), c = this.createColDef(l, d, []), u = [];
      for (let g = 0; g < t.length; g++) {
        const p = t[g];
        p.pivotValueColumn === l && u.push(p.colId);
      }
      c.pivotTotalColumnIds = u, c.colId = _d + c.colId;
      const h = n ? {
        children: [c],
        pivotKeys: [],
        groupId: `${_d}_pivotGroup_${l.getColId()}`
      } : c;
      t.push(c), s ? e.push(h) : e.unshift(h);
    }
  }
  createColDef(e, t, s, i = !1) {
    const o = {};
    if (e) {
      const n = e.getColDef();
      Object.assign(o, n), o.hide = !1;
    }
    return o.headerName = t, o.colId = this.generateColumnId(
      s || [],
      e && !i ? e.getColId() : ""
    ), o.field = o.colId, o.valueGetter = (n) => {
      var r;
      return (r = n.data) == null ? void 0 : r[n.colDef.field];
    }, o.pivotKeys = s, o.pivotValueColumn = e, o.filter === !0 && (o.filter = "agNumberColumnFilter"), o;
  }
  sameAggFuncs(e) {
    if (e.length == 1)
      return !0;
    for (let t = 1; t < e.length; t++)
      if (e[t] !== e[0])
        return !1;
    return !0;
  }
  merge(e, t) {
    t.forEach((s, i) => {
      const n = [...e.has(i) ? e.get(i) : [], ...s];
      e.set(i, n);
    });
  }
  generateColumnGroupId(e) {
    var s;
    return `pivotGroup_${(((s = this.pivotColsSvc) == null ? void 0 : s.columns) ?? []).map((i) => i.getColId()).join("-")}_${e.join("-")}`;
  }
  generateColumnId(e, t) {
    var i;
    return `pivot_${(((i = this.pivotColsSvc) == null ? void 0 : i.columns) ?? []).map((o) => o.getColId()).join("-")}_${e.join("-")}_${t}`;
  }
  /**
   * Used by the SSRM to create secondary columns from provided fields
   * @param fields
   */
  createColDefsFromFields(e) {
    const t = /* @__PURE__ */ new Map();
    for (let o = 0; o < e.length; o++) {
      const r = e[o].split(this.fieldSeparator);
      let a = t;
      for (let l = 0; l < r.length; l++) {
        const d = r[l];
        let c = a.get(d);
        c || (c = /* @__PURE__ */ new Map(), a.set(d, c)), a = c;
      }
    }
    const s = (o, n, r, a) => {
      const l = [];
      for (const [u, h] of r) {
        const g = s(`${o}${this.fieldSeparator}${u}`, u, h, a + 1);
        l.push(g);
      }
      if (l.length === 0) {
        const u = this.colModel.getColDefCol(n);
        if (u) {
          const g = this.colNames.getDisplayNameForColumn(u, "header") ?? n, p = this.createColDef(u, g, void 0, !1);
          return p.colId = o, p.aggFunc = u.getAggFunc(), p.valueGetter = (f) => {
            var m;
            return (m = f.data) == null ? void 0 : m[o];
          }, p;
        }
        return {
          colId: o,
          headerName: n,
          // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId
          // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects
          valueGetter: (g) => {
            var p;
            return (p = g.data) == null ? void 0 : p[o];
          }
        };
      }
      return this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && l.length === 1 && "colId" in l[0] ? (l[0].headerName = n, l[0]) : {
        openByDefault: this.pivotDefaultExpanded === -1 || a < this.pivotDefaultExpanded,
        groupId: o,
        headerName: n,
        children: l
      };
    }, i = [];
    for (const [o, n] of t) {
      const r = s(o, o, n, 0);
      i.push(r);
    }
    return i;
  }
}, WM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "pivotResultCols";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.visibleCols = e.visibleCols;
  }
  destroy() {
    var e;
    gs(this.beans, (e = this.pivotResultCols) == null ? void 0 : e.tree), super.destroy();
  }
  isPivotResultColsPresent() {
    return this.pivotResultCols != null;
  }
  lookupPivotResultCol(e, t) {
    if (this.pivotResultCols == null)
      return null;
    const s = this.colModel.getColDefCol(t);
    let i = null;
    return this.pivotResultCols.list.forEach((o) => {
      const n = o.getColDef().pivotKeys, r = o.getColDef().pivotValueColumn;
      pt(n, e) && r === s && (i = o);
    }), i;
  }
  getPivotResultCols() {
    return this.pivotResultCols;
  }
  getPivotResultCol(e) {
    return this.pivotResultCols ? this.colModel.getColFromCollection(e, this.pivotResultCols) : null;
  }
  setPivotResultCols(e, t) {
    var s, i;
    if (this.colModel.ready && !(e == null && this.pivotResultCols == null)) {
      if (e) {
        this.processPivotResultColDef(e);
        const n = (t === "api" ? Su : Ym)(
          this.beans,
          e,
          !1,
          ((s = this.pivotResultCols) == null ? void 0 : s.tree) || this.previousPivotResultCols || void 0,
          t
        );
        gs(this.beans, (i = this.pivotResultCols) == null ? void 0 : i.tree, n.columnTree);
        const r = n.columnTree, a = n.treeDepth, l = Ba(r), d = {};
        this.pivotResultCols = { tree: r, treeDepth: a, list: l, map: d }, this.pivotResultCols.list.forEach((u) => this.pivotResultCols.map[u.getId()] = u);
        const c = !!this.previousPivotResultCols;
        this.previousPivotResultCols = null, this.colModel.refreshCols(!c);
      } else
        this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null, this.pivotResultCols = null, this.colModel.refreshCols(!1);
      this.visibleCols.refresh(t);
    }
  }
  processPivotResultColDef(e) {
    const t = this.gos.get("processPivotResultColDef"), s = this.gos.get("processPivotResultColGroupDef");
    if (!t && !s)
      return;
    const i = (o) => {
      o.forEach((n) => {
        if (T(n.children)) {
          const a = n;
          s && s(a), i(a.children);
        } else
          t && t(n);
      });
    };
    e && i(e);
  }
}, zM = {
  moduleName: "SharedPivot",
  version: ce,
  beans: [WM, _M, Ig],
  apiFunctions: {
    isPivotMode: DM,
    getPivotResultColumn: MM,
    setValueColumns: EM,
    getValueColumns: AM,
    removeValueColumns: IM,
    addValueColumns: TM,
    setPivotColumns: LM,
    removePivotColumns: kM,
    addPivotColumns: GM,
    getPivotColumns: OM,
    setPivotResultColumns: BM,
    getPivotResultColumns: NM
  },
  dependsOn: [Og, Ah]
};
Zr.values();
var UM = {
  moduleName: "SharedTreeData",
  version: ce,
  dependsOn: [Ie, ml, kg, Gg]
}, jM = "ag-Grid-MissingKey", $M = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmBlockUtils";
  }
  wireBeans(e) {
    this.valueSvc = e.valueSvc, this.showRowGroupCols = e.showRowGroupCols, this.nodeManager = e.ssrmNodeManager, this.expansionSvc = e.expansionSvc, this.serverSideRowModel = e.rowModel, this.storeFactory = e.ssrmStoreFactory;
  }
  createRowNode(e) {
    const t = new Us(this.beans), s = e.rowHeight != null ? e.rowHeight : Bs(this.beans);
    return t.setRowHeight(s), t.group = e.group, t.leafGroup = e.leafGroup, t.level = e.level, t.uiLevel = e.level, t.parent = e.parent, t.stub = !0, t.__needsRefreshWhenVisible = !1, t.group && (t.expanded = !1, t.field = e.field, t.rowGroupColumn = e.rowGroupColumn, t.rowGroupIndex = e.level), t;
  }
  destroyRowNode(e, t = !1) {
    e.childStore && !t && (this.destroyBean(e.childStore), e.childStore = null), e.sibling && !e.footer && this.destroyRowNode(e.sibling, !1), e.clearRowTopAndRowIndex(), e.id != null && this.nodeManager.removeNode(e);
  }
  setTreeGroupInfo(e) {
    e.updateHasChildren();
    const t = this.gos.get("getServerSideGroupKey"), s = e.hasChildren();
    s && t != null && (e.key = t(e.data)), !s && e.childStore != null && (this.destroyBean(e.childStore), e.childStore = null, e.expanded = !1);
  }
  setRowGroupInfo(e) {
    if (e.key = this.valueSvc.getValue(e.rowGroupColumn, e), (e.key === null || e.key === void 0) && Nn(() => {
      var o;
      P(190, { rowGroupId: (o = e.rowGroupColumn) == null ? void 0 : o.getId(), data: e.data });
    }, "SSBlock-BadKey"), this.gos.get("groupAllowUnbalanced") && e.key === "") {
      const o = this.serverSideRowModel.getParams();
      e.childStore = this.createBean(this.storeFactory.createStore(o, e));
    }
    Si(this.beans.gos)({ node: e }) && (Vt(e, this.beans), e.sibling && (e.sibling.uiLevel = e.uiLevel + 1));
  }
  setMasterDetailInfo(e) {
    const t = this.gos.get("isRowMaster");
    t != null ? e.master = t(e.data) : e.master = !0;
  }
  updateDataIntoRowNode(e, t) {
    e.updateData(t), this.gos.get("treeData") ? (this.setTreeGroupInfo(e), this.setChildCountIntoRowNode(e), this.updateRowFooter(e)) : e.group ? (this.setChildCountIntoRowNode(e), this.updateRowFooter(e)) : this.gos.get("masterDetail");
  }
  updateRowFooter(e) {
    if (!e.footer) {
      if (e.group && Si(this.beans.gos)({ node: e }) && !e.sibling) {
        Vt(e, this.beans);
        return;
      }
      e.sibling && fl(e);
    }
  }
  setDataIntoRowNode(e, t, s, i) {
    var n;
    e.stub = !1;
    const o = this.gos.get("treeData");
    e.setDataAndId(t, s), o ? this.setTreeGroupInfo(e) : e.group ? this.setRowGroupInfo(e) : this.gos.get("masterDetail") && this.setMasterDetailInfo(e), (o || e.group) && (this.setGroupDataIntoRowNode(e), this.setChildCountIntoRowNode(e)), T(t) && (e.setRowHeight(Je(this.beans, e, !1, i).height), (n = e.sibling) == null || n.setRowHeight(
      Je(this.beans, e.sibling, !1, i).height
    ));
  }
  setChildCountIntoRowNode(e) {
    const t = this.gos.get("getChildCount");
    t && e.setAllChildrenCount(t(e.data));
  }
  setGroupDataIntoRowNode(e) {
    var i;
    e.groupValue = e.key;
    const t = ((i = this.showRowGroupCols) == null ? void 0 : i.getShowRowGroupCols()) ?? [], s = this.gos.get("treeData");
    t.forEach((o) => {
      if (e.groupData == null && (e.groupData = {}), s)
        e.groupData[o.getColId()] = e.key;
      else if (o.isRowGroupDisplayed(e.rowGroupColumn.getId())) {
        const n = this.valueSvc.getValue(e.rowGroupColumn, e);
        e.groupData[o.getColId()] = n;
      }
    });
  }
  clearDisplayIndex(e) {
    var i, o;
    e.clearRowTopAndRowIndex(), e.hasChildren() && !!e.childStore && ((i = e.childStore) == null || i.clearDisplayIndexes()), e.master && e.detailNode && ((o = e.detailNode) == null || o.clearRowTopAndRowIndex());
  }
  setDisplayIndex(e, t, s, i) {
    const o = this.gos.get("groupAllowUnbalanced") && e.group && e.key === "";
    if (this.gos.get("groupHideOpenParents") && e.group && e.expanded || o ? (e.setRowIndex(null), e.setRowTop(null)) : (e.setRowIndex(t.value++), e.setRowTop(s.value), s.value += e.rowHeight), e.setUiLevel(i), e.footer)
      return;
    if (e.master && (e.expanded && e.detailNode ? (e.detailNode.setRowIndex(t.value++), e.detailNode.setRowTop(s.value), s.value += e.detailNode.rowHeight) : e.detailNode && e.detailNode.clearRowTopAndRowIndex()), e.hasChildren() && !!e.childStore) {
      const l = e.childStore;
      e.expanded || o ? l.setDisplayIndexes(t, s, o ? i : i + 1) : l.clearDisplayIndexes();
    }
  }
  extractRowBounds(e, t) {
    const s = (i) => ({
      rowHeight: i.rowHeight,
      rowTop: i.rowTop
    });
    if (e.rowIndex === t)
      return s(e);
    if (e.hasChildren() && e.expanded && e.childStore) {
      const i = e.childStore;
      if (i.isDisplayIndexInStore(t))
        return i.getRowBounds(t);
    } else if (e.master && e.expanded && e.detailNode && e.detailNode.rowIndex === t)
      return s(e.detailNode);
  }
  isPixelInNodeRange(e, t) {
    return !T(e.rowTop) || !T(e.rowHeight) ? !1 : t >= e.rowTop && t < e.rowTop + e.rowHeight;
  }
  getIndexAtPixel(e, t) {
    if (this.isPixelInNodeRange(e, t))
      return e.rowIndex;
    const s = e.master && e.expanded, i = e.detailNode;
    if (s && i && this.isPixelInNodeRange(i, t))
      return i.rowIndex;
    if (e.hasChildren() && e.expanded && e.childStore) {
      const o = e.childStore;
      if (o.isPixelInRange(t))
        return o.getRowIndexAtPixel(t);
    }
    return null;
  }
  createNodeIdPrefix(e) {
    const t = [];
    let s = e;
    for (; s && s.level >= 0; )
      s.key === "" ? t.push(jM) : t.push(s.key), s = s.parent;
    if (t.length > 0)
      return t.reverse().join("-");
  }
  checkOpenByDefault(e) {
    var t;
    return (t = this.expansionSvc) == null ? void 0 : t.checkOpenByDefault(e);
  }
}, KM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmExpandListener";
  }
  wireBeans(e) {
    this.serverSideRowModel = e.rowModel, this.storeFactory = e.ssrmStoreFactory;
  }
  postConstruct() {
    nt(this.gos) && this.addManagedEventListeners({ rowGroupOpened: this.onRowGroupOpened.bind(this) });
  }
  onRowGroupOpened(e) {
    const t = e.node;
    if (t.expanded) {
      if (t.master)
        this.createDetailNode(t);
      else if (ie(t.childStore)) {
        const s = this.serverSideRowModel.getParams();
        t.childStore = this.createBean(this.storeFactory.createStore(s, t));
      }
    } else this.gos.get("purgeClosedRowNodes") && T(t.childStore) && (t.childStore = this.destroyBean(t.childStore));
    this.eventSvc.dispatchEvent({ type: "storeUpdated" });
  }
  createDetailNode(e) {
    if (T(e.detailNode))
      return e.detailNode;
    const t = new Us(this.beans);
    t.detail = !0, t.selectable = !1, t.parent = e, T(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1;
    const s = 200, i = Je(this.beans, t).height;
    return t.rowHeight = i || s, e.detailNode = t, t;
  }
}, qM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmFilterListener";
  }
  wireBeans(e) {
    this.serverSideRowModel = e.rowModel, this.filterManager = e.filterManager, this.listenerUtils = e.ssrmListenerUtils;
  }
  postConstruct() {
    nt(this.gos) && this.addManagedEventListeners({
      advancedFilterEnabledChanged: () => this.onFilterChanged(!0),
      filterChanged: () => this.onFilterChanged()
    });
  }
  onFilterChanged(e) {
    var l, d;
    const t = this.serverSideRowModel.getParams();
    if (!t)
      return;
    const s = t.filterModel;
    let i, o;
    if ((l = this.filterManager) != null && l.isAdvFilterEnabled()) {
      i = this.filterManager.getAdvFilterModel();
      const c = e ? Object.keys(s ?? {}) : this.getAdvancedFilterColumns(s), u = this.getAdvancedFilterColumns(i);
      c.forEach((h) => u.add(h)), o = Array.from(u);
    } else if (i = ((d = this.filterManager) == null ? void 0 : d.getFilterModel()) ?? {}, e) {
      const c = this.getAdvancedFilterColumns(s);
      Object.keys(i).forEach((u) => c.add(u)), o = Array.from(c);
    } else
      o = this.findChangedColumns(s, i);
    const n = this.listenerUtils.isSortingWithValueColumn(o), r = this.listenerUtils.isSortingWithSecondaryColumn(o), a = {
      valueColChanged: n,
      secondaryColChanged: r,
      changedColumns: o
    };
    this.serverSideRowModel.refreshAfterFilter(i, a);
  }
  findChangedColumns(e, t) {
    const s = {};
    Object.keys(e).forEach((o) => s[o] = !0), Object.keys(t).forEach((o) => s[o] = !0);
    const i = [];
    return Object.keys(s).forEach((o) => {
      const n = JSON.stringify(e[o]), r = JSON.stringify(t[o]);
      n != r && i.push(o);
    }), i;
  }
  getAdvancedFilterColumns(e) {
    const t = /* @__PURE__ */ new Set();
    if (!e)
      return t;
    const s = (i) => {
      i.filterType === "join" ? i.conditions.forEach((o) => s(o)) : t.add(i.colId);
    };
    return s(e), t;
  }
}, YM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmListenerUtils";
  }
  wireBeans(e) {
    this.pivotResultCols = e.pivotResultCols, this.valueColsSvc = e.valueColsSvc;
  }
  isSortingWithValueColumn(e) {
    var s;
    const t = (((s = this.valueColsSvc) == null ? void 0 : s.columns) ?? []).map((i) => i.getColId());
    for (let i = 0; i < e.length; i++)
      if (t.indexOf(e[i]) > -1)
        return !0;
    return !1;
  }
  isSortingWithSecondaryColumn(e) {
    var i;
    const t = (i = this.pivotResultCols) == null ? void 0 : i.getPivotResultCols();
    if (!t)
      return !1;
    const s = t.list.map((o) => o.getColId());
    for (let o = 0; o < e.length; o++)
      if (s.indexOf(e[o]) > -1)
        return !0;
    return !1;
  }
}, ZM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmSortSvc";
  }
  wireBeans(e) {
    this.sortSvc = e.sortSvc, this.serverSideRowModel = e.rowModel, this.listenerUtils = e.ssrmListenerUtils;
  }
  postConstruct() {
    nt(this.gos) && this.addManagedEventListeners({ sortChanged: this.onSortChanged.bind(this) });
  }
  onSortChanged() {
    const e = this.serverSideRowModel.getParams();
    if (!e)
      return;
    const t = this.sortSvc.getSortModel(), s = e.sortModel, i = this.findChangedColumnsInSort(t, s), o = this.listenerUtils.isSortingWithValueColumn(i), n = this.listenerUtils.isSortingWithSecondaryColumn(i), r = {
      valueColChanged: o,
      secondaryColChanged: n,
      changedColumns: i
    };
    this.serverSideRowModel.refreshAfterSort(t, r);
  }
  // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,
  // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache
  // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache
  // was previously sorted by A and then the A sort now needs to be cleared.
  findChangedColumnsInSort(e, t) {
    let s = [];
    [e, t].forEach((n) => {
      if (n) {
        const r = n.map((a) => a.colId);
        s = s.concat(r);
      }
    });
    const i = (n, r) => {
      const a = n ? n.sort : null, l = r ? r.sort : null;
      return a !== l;
    }, o = (n, r) => {
      const a = n ? t.indexOf(n) : -1, l = r ? e.indexOf(r) : -1;
      return a !== l;
    };
    return s.filter((n) => {
      const r = t.find((l) => l.colId === n), a = e.find((l) => l.colId === n);
      return i(r, a) || o(r, a);
    });
  }
}, QM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmNodeManager", this.rowNodes = /* @__PURE__ */ new Map();
  }
  addRowNode(e) {
    const t = e.id;
    this.rowNodes.has(t) && P(187, {
      rowId: t,
      firstData: this.rowNodes.get(t).data,
      secondData: e.data
    }), this.rowNodes.set(t, e);
  }
  removeNode(e) {
    const t = e.id;
    this.rowNodes.delete(t);
  }
  destroy() {
    this.clear(), super.destroy();
  }
  clear() {
    this.rowNodes.clear(), super.destroy();
  }
}, XM = class extends S {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.pauseStoreUpdateListening = !1, this.started = !1, this.managingPivotResultColumns = !1, this.onRowHeightChanged_debounced = ct(this, this.onRowHeightChanged.bind(this), 100);
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.colNames = e.colNames, this.pivotResultCols = e.pivotResultCols, this.rowGroupColsSvc = e.rowGroupColsSvc, this.pivotColsSvc = e.pivotColsSvc, this.valueColsSvc = e.valueColsSvc, this.filterManager = e.filterManager, this.sortSvc = e.sortSvc, this.rowRenderer = e.rowRenderer, this.nodeManager = e.ssrmNodeManager, this.storeFactory = e.ssrmStoreFactory, this.pivotColDefSvc = e.pivotColDefSvc;
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  start() {
    this.started = !0, this.updateDatasource();
  }
  destroyDatasource() {
    this.datasource && (this.datasource.destroy && this.datasource.destroy(), this.rowRenderer.datasourceChanged(), this.datasource = void 0);
  }
  postConstruct() {
    const e = this.resetRootStore.bind(this);
    this.addManagedEventListeners({
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.onStoreUpdated.bind(this),
      columnValueChanged: e,
      columnPivotChanged: e,
      columnRowGroupChanged: e,
      columnPivotModeChanged: e
    }), this.addManagedPropertyListeners(
      [
        /**
         * Following properties omitted as they are likely to come with undesired  side effects.
         * 'getRowId', 'isRowMaster', 'getRowHeight', 'isServerSideGroup', 'getServerSideGroupKey',
         * */
        "masterDetail",
        "treeData",
        "removePivotHeaderRowWhenSingleValueColumn",
        "cacheBlockSize"
      ],
      e
    ), this.addManagedPropertyListeners(["groupAllowUnbalanced", "groupTotalRow"], () => this.onStoreUpdated()), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights()), this.verifyProps(), this.addManagedPropertyListener("serverSideDatasource", () => this.updateDatasource());
  }
  updateDatasource() {
    const e = this.gos.get("serverSideDatasource");
    e && this.setDatasource(e);
  }
  verifyProps() {
    Dt(this.gos) && !this.gos.exists("getRowId") && P(188);
  }
  setDatasource(e) {
    this.started && (this.destroyDatasource(), this.datasource = e, this.resetRootStore());
  }
  applyRowData(e, t, s) {
    const i = this.getRootStore();
    if (!i)
      return;
    const o = i.getChildStore(s);
    o && o.applyRowData(e, t, e.rowData.length);
  }
  isLastRowIndexKnown() {
    const e = this.getRootStore();
    return e ? e.isLastRowIndexKnown() : !1;
  }
  onColumnEverything() {
    var d, c, u, h;
    if (!this.storeParams) {
      this.resetRootStore();
      return;
    }
    const e = this.columnsToValueObjects((d = this.rowGroupColsSvc) == null ? void 0 : d.columns), t = this.columnsToValueObjects((c = this.valueColsSvc) == null ? void 0 : c.columns), s = this.columnsToValueObjects((u = this.pivotColsSvc) == null ? void 0 : u.columns), i = (g) => {
      const p = {};
      g.oldCols.forEach((b) => p[b.id] = b);
      const f = g.newCols.every((b) => {
        const w = p[b.id];
        return w && delete p[b.id], w && w.field === b.field && w.aggFunc === b.aggFunc;
      }), m = !g.allowRemovedColumns && !!Object.values(p).length;
      return f && !m;
    }, o = !Ta(this.storeParams.sortModel, ((h = this.sortSvc) == null ? void 0 : h.getSortModel()) ?? []), n = !i({
      oldCols: this.storeParams.rowGroupCols,
      newCols: e
    }), r = !i({
      oldCols: this.storeParams.pivotCols,
      newCols: s
    }), a = !!(e != null && e.length) && !i({
      oldCols: this.storeParams.valueCols,
      newCols: t,
      allowRemovedColumns: !0
    });
    if (o || n || r || a)
      this.resetRootStore();
    else {
      const g = this.createStoreParams();
      this.storeParams.rowGroupCols = g.rowGroupCols, this.storeParams.pivotCols = g.pivotCols, this.storeParams.valueCols = g.valueCols;
    }
  }
  destroyRootStore() {
    !this.rootNode || !this.rootNode.childStore || (this.rootNode.childStore = this.destroyBean(this.rootNode.childStore), this.nodeManager.clear());
  }
  refreshAfterSort(e, t) {
    this.storeParams && (this.storeParams.sortModel = e);
    const s = this.getRootStore();
    s && (s.refreshAfterSort(t), this.onStoreUpdated());
  }
  generateSecondaryColumns(e) {
    var s;
    if (!this.pivotColDefSvc) {
      this.gos.assertModuleRegistered("SharedPivot", 2);
      return;
    }
    const t = this.pivotColDefSvc.createColDefsFromFields(e);
    this.managingPivotResultColumns = !0, (s = this.pivotResultCols) == null || s.setPivotResultCols(t, "rowModelUpdated");
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes(), t = Je(this.beans, this.rootNode);
    if (this.rootNode.setRowHeight(t.height, t.estimated), this.rootNode.sibling) {
      const s = Je(this.beans, this.rootNode.sibling);
      this.rootNode.sibling.setRowHeight(s.height, s.estimated);
    }
    e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      const s = Je(this.beans, t);
      t.setRowHeight(s.height, s.estimated);
      const i = t.detailNode;
      if (i) {
        const o = Je(this.beans, i);
        i.setRowHeight(o.height, o.estimated);
      }
      if (t.sibling) {
        const o = Je(this.beans, t.sibling);
        i == null || i.setRowHeight(o.height, o.estimated);
      }
      e = !0;
    }), e;
  }
  resetRootStore() {
    var e;
    this.destroyRootStore(), this.rootNode = new Us(this.beans), this.rootNode.group = !0, this.rootNode.level = -1, this.datasource && (this.storeParams = this.createStoreParams(), this.rootNode.childStore = this.createBean(this.storeFactory.createStore(this.storeParams, this.rootNode)), this.updateRowIndexesAndBounds()), this.managingPivotResultColumns && ((e = this.pivotResultCols) == null || e.setPivotResultCols(null, "api"), this.managingPivotResultColumns = !1), this.dispatchModelUpdated(!0);
  }
  columnsToValueObjects(e = []) {
    return e.map(
      (t) => ({
        id: t.getId(),
        aggFunc: t.getAggFunc(),
        displayName: this.colNames.getDisplayNameForColumn(t, "model"),
        field: t.getColDef().field
      })
    );
  }
  createStoreParams() {
    var n, r, a, l, d, c, u;
    const e = this.columnsToValueObjects((n = this.rowGroupColsSvc) == null ? void 0 : n.columns), t = this.columnsToValueObjects((r = this.valueColsSvc) == null ? void 0 : r.columns), s = this.columnsToValueObjects((a = this.pivotColsSvc) == null ? void 0 : a.columns), i = ka(this.gos);
    return {
      // the columns the user has grouped and aggregated by
      valueCols: t,
      rowGroupCols: e,
      pivotCols: s,
      pivotMode: this.colModel.isPivotMode(),
      // sort and filter model
      filterModel: (l = this.filterManager) != null && l.isAdvFilterEnabled() ? (d = this.filterManager) == null ? void 0 : d.getAdvFilterModel() : ((c = this.filterManager) == null ? void 0 : c.getFilterModel()) ?? {},
      sortModel: ((u = this.sortSvc) == null ? void 0 : u.getSortModel()) ?? [],
      datasource: this.datasource,
      lastAccessedSequence: { value: 0 },
      // blockSize: blockSize == null ? 100 : blockSize,
      dynamicRowHeight: i
    };
  }
  getParams() {
    return this.storeParams;
  }
  dispatchModelUpdated(e = !1) {
    this.eventSvc.dispatchEvent({
      type: "modelUpdated",
      animate: !e,
      keepRenderedRows: !e,
      newPage: !1,
      newData: !1
    });
  }
  onStoreUpdated() {
    this.pauseStoreUpdateListening || (this.updateRowIndexesAndBounds(), this.dispatchModelUpdated());
  }
  onRowHeightChanged() {
    this.updateRowIndexesAndBounds(), this.dispatchModelUpdated();
  }
  updateRowIndexesAndBounds() {
    const e = this.getRootStore();
    e && e.setDisplayIndexes({ value: 0 }, { value: 0 }, 0);
  }
  retryLoads() {
    const e = this.getRootStore();
    e && (e.retryLoads(), this.onStoreUpdated());
  }
  getRow(e) {
    const t = this.getRootStore();
    if (t)
      return t.getRowUsingDisplayIndex(e);
  }
  /**
   * Pauses the store, to prevent it updating the UI. This is used when doing batch updates to the store.
   */
  setPaused(e) {
    this.pauseStoreUpdateListening = e;
  }
  expandAll(e) {
    this.pauseStoreUpdateListening = !0, this.forEachNode((t) => {
      t.stub || t.hasChildren() && t.setExpanded(e);
    }), this.pauseStoreUpdateListening = !1, this.onStoreUpdated();
  }
  refreshAfterFilter(e, t) {
    this.storeParams && (this.storeParams.filterModel = e);
    const s = this.getRootStore();
    s && (s.refreshAfterFilter(t), this.onStoreUpdated());
  }
  getRootStore() {
    var e;
    return (e = this.rootNode) == null ? void 0 : e.childStore;
  }
  getRowCount() {
    const e = this.getRootStore();
    return e ? e.getDisplayIndexEnd() : 0;
  }
  getTopLevelRowCount() {
    const e = this.getRootStore();
    return e ? e.getRowCount() : 1;
  }
  getTopLevelRowDisplayedIndex(e) {
    const t = this.getRootStore();
    return t ? t.getTopLevelRowDisplayedIndex(e) : e;
  }
  getRowBounds(e) {
    const t = this.getRootStore();
    return t ? t.getRowBounds(e) : {
      rowTop: 0,
      rowHeight: Bs(this.beans)
    };
  }
  getBlockStates() {
    const e = this.getRootStore();
    if (!e)
      return;
    const t = {};
    return e.forEachStoreDeep((s) => {
      const i = s.getBlockStates();
      for (const o of Object.keys(i))
        t[o] = i[o];
    }), t;
  }
  getRowIndexAtPixel(e) {
    const t = this.getRootStore();
    return e <= 0 || !t ? 0 : t.getRowIndexAtPixel(e);
  }
  isEmpty() {
    return !1;
  }
  isRowsToRender() {
    return this.getRootStore() != null && this.getRowCount() > 0;
  }
  getType() {
    return "serverSide";
  }
  forEachNode(e) {
    const t = this.getRootStore();
    t && t.forEachNodeDeep(e);
  }
  forEachDisplayedNode(e) {
    const t = (s, i) => {
      s.stub || !s.displayed || e(s, i);
    };
    this.forEachNode(t);
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    const s = this.getRootStore();
    s && s.forEachNodeDeepAfterFilterAndSort(e, void 0, t);
  }
  /** @return false if store hasn't started */
  executeOnStore(e, t) {
    if (!this.started)
      return !1;
    const s = this.getRootStore();
    if (!s)
      return !0;
    const i = s.getChildStore(e);
    return i && t(i), !0;
  }
  refreshStore(e = {}) {
    const t = e.route ? e.route : [];
    this.executeOnStore(t, (s) => s.refreshStore(e.purge == !0));
  }
  getStoreState() {
    const e = [], t = this.getRootStore();
    return t && t.addStoreStates(e), e;
  }
  getNodesInRangeForSelection(e, t) {
    const s = e.rowIndex, i = t.rowIndex;
    if (s === null && i === null)
      return [];
    if (i === null)
      return e ? [e] : [];
    if (s === null)
      return [t];
    const o = [], [n, r] = [s, i].sort((a, l) => a - l);
    return this.forEachNode((a) => {
      const l = a.rowIndex;
      l == null || a.stub || l >= n && l <= r && o.push(a);
    }), o.length !== r - n + 1 ? null : o;
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((s) => {
      s.id === e && (t = s), s.detailNode && s.detailNode.id === e && (t = s.detailNode);
    }), t;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  setRowCount(e, t) {
    const s = this.getRootStore();
    s && s.setRowCount(e, t);
  }
  destroy() {
    this.destroyDatasource(), this.destroyRootStore(), super.destroy();
  }
  /**
   * @deprecated v33.1
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
}, JM = class extends Tg {
  constructor() {
    super(...arguments), this.beanName = "expansionSvc", this.queuedRowIds = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.serverSideRowModel = e.rowModel;
  }
  postConstruct() {
    this.addManagedEventListeners({
      columnRowGroupChanged: () => {
        this.queuedRowIds.clear();
      }
    });
  }
  checkOpenByDefault(e) {
    if (!e.isExpandable())
      return;
    if (this.queuedRowIds.has(e.id)) {
      this.queuedRowIds.delete(e.id), e.setExpanded(!0);
      return;
    }
    const t = this.gos.getCallback("isServerSideGroupOpenByDefault");
    if (!t)
      return;
    const s = {
      data: e.data,
      rowNode: e
    };
    t(s) && e.setExpanded(!0);
  }
  expandRows(e) {
    e.forEach((t) => {
      const s = this.serverSideRowModel.getRowNode(t);
      s ? s.setExpanded(!0) : this.queuedRowIds.add(t);
    });
  }
  expandAll(e) {
    this.serverSideRowModel.expandAll(e);
  }
  onGroupExpandedOrCollapsed() {
  }
  dispatchExpandedEvent(e) {
    this.eventSvc.dispatchEvent(e), this.beans.rowRenderer.refreshCells({ rowNodes: [e.node] });
  }
}, Ir = class extends S {
  constructor(e) {
    super(), this.selectionCtx = e, this.selectedState = { selectAll: !1, toggledNodes: /* @__PURE__ */ new Set() }, this.selectAllUsed = !1, this.selectedNodes = {};
  }
  getSelectedState() {
    return {
      selectAll: this.selectedState.selectAll,
      toggledNodes: [...this.selectedState.toggledNodes]
    };
  }
  setSelectedState(e) {
    if (typeof e != "object") {
      K(116);
      return;
    }
    if (!("selectAll" in e)) {
      K(116);
      return;
    }
    if (typeof e.selectAll != "boolean") {
      K(117);
      return;
    }
    if (!("toggledNodes" in e) || !Array.isArray(e.toggledNodes))
      return P(197);
    const t = {
      selectAll: e.selectAll,
      toggledNodes: /* @__PURE__ */ new Set()
    };
    e.toggledNodes.forEach((i) => {
      typeof i == "string" ? t.toggledNodes.add(i) : P(196, { key: i });
    });
    const s = t.selectAll || t.toggledNodes.size > 1;
    if (ru(this.gos) && !Hs(this.gos) && s) {
      P(130);
      return;
    }
    this.selectedState = t;
  }
  deleteSelectionStateFromParent(e, t) {
    if (this.selectedState.toggledNodes.size === 0)
      return !1;
    let s = !1;
    return t.forEach((i) => {
      this.selectedState.toggledNodes.delete(i) && (s = !0);
    }), s;
  }
  setNodesSelected(e) {
    const { nodes: t, clearSelection: s, newValue: i, source: o } = e;
    if (t.length === 0)
      return 0;
    const n = s && i;
    if (!Hs(this.gos) || n) {
      if (t.length > 1)
        return K(130), 0;
      const a = t[0], l = a.footer ? a.sibling : a;
      return i && l.selectable ? (this.selectedNodes = { [l.id]: l }, this.selectedState = {
        selectAll: !1,
        toggledNodes: /* @__PURE__ */ new Set([l.id])
      }) : (this.selectedNodes = {}, this.selectedState = {
        selectAll: !1,
        toggledNodes: /* @__PURE__ */ new Set()
      }), 1;
    }
    const r = (a, l = i) => {
      const d = a.footer ? a.sibling : a;
      l && d.selectable ? this.selectedNodes[d.id] = d : delete this.selectedNodes[d.id], l === this.selectedState.selectAll || !d.selectable ? this.selectedState.toggledNodes.delete(d.id) : this.selectedState.toggledNodes.add(d.id);
    };
    return t.forEach((a) => r(a)), t.length === 1 && o === "api" && this.selectionCtx.setRoot(t[0].footer ? t[0].sibling : t[0]), 1;
  }
  processNewRow(e) {
    this.selectedNodes[e.id] && (this.selectedNodes[e.id] = e);
  }
  isNodeSelected(e) {
    const t = this.selectedState.toggledNodes.has(e.id);
    return this.selectedState.selectAll ? !t : t;
  }
  getSelectedNodes(e = !1, t = !0) {
    const {
      selectedState: { selectAll: s },
      selectedNodes: i,
      selectAllUsed: o
    } = this;
    return t && o && P(199), e && s ? null : Object.values(i);
  }
  getSelectedRows() {
    return (this.getSelectedNodes() ?? []).map((e) => e.data);
  }
  getSelectionCount() {
    return this.selectedState.selectAll ? -1 : this.selectedState.toggledNodes.size;
  }
  isEmpty() {
    var e;
    return !this.selectedState.selectAll && !((e = this.selectedState.toggledNodes) != null && e.size);
  }
  selectAllRowNodes() {
    this.reset(!0);
  }
  deselectAllRowNodes() {
    this.reset(!1);
  }
  reset(e) {
    this.selectedState = { selectAll: e, toggledNodes: /* @__PURE__ */ new Set() }, this.selectedNodes = {}, this.selectAllUsed || (this.selectAllUsed = e);
  }
  getSelectAllState() {
    return this.selectedState.selectAll ? this.selectedState.toggledNodes.size > 0 ? null : !0 : this.selectedState.toggledNodes.size > 0 ? null : !1;
  }
}, Wo = class extends S {
  constructor(e) {
    super(), this.selectionCtx = e, this.selectedState = { selectAllChildren: !1, toggledNodes: /* @__PURE__ */ new Map() };
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowGroupColsSvc = e.rowGroupColsSvc, this.filterManager = e.filterManager, this.selectionSvc = e.selectionSvc;
  }
  postConstruct() {
    this.addManagedEventListeners({
      // if model has updated, a store may now be fully loaded to clean up indeterminate states
      modelUpdated: () => this.removeRedundantState(),
      // when the grouping changes, the state no longer makes sense, so reset the state.
      columnRowGroupChanged: () => this.selectionSvc.reset("rowGroupChanged")
    });
  }
  getSelectedState() {
    const { gos: e, rowGroupColsSvc: t, selectedState: s } = this, i = e.get("treeData"), o = (n, r, a) => {
      const l = {
        nodeId: a
      };
      if ((i || t && r <= t.columns.length) && (l.selectAllChildren = n.selectAllChildren), n.toggledNodes.size) {
        const d = [];
        n.toggledNodes.forEach((c, u) => {
          const h = o(c, r + 1, u);
          d.push(h);
        }), l.toggledNodes = d;
      }
      return l;
    };
    return o(s, 0);
  }
  setSelectedState(e) {
    if ("selectAll" in e) {
      K(111);
      return;
    }
    const t = (s, i) => {
      var a;
      if (typeof s != "object")
        throw K(243), new Error();
      if ("selectAllChildren" in s && typeof s.selectAllChildren != "boolean")
        throw K(244), new Error();
      if ("toggledNodes" in s) {
        if (!Array.isArray(s.toggledNodes))
          throw K(245), new Error();
        if (!s.toggledNodes.every(
          (d) => typeof d == "object" && "nodeId" in d && typeof d.nodeId == "string"
        ))
          throw K(246), new Error();
      }
      const o = s.selectAllChildren ?? !i, n = (a = s.toggledNodes) == null ? void 0 : a.map((l) => [
        l.nodeId,
        t(l, o)
      ]);
      if (n == null ? void 0 : n.some(
        ([, l]) => o === l.selectAllChildren && l.toggledNodes.size === 0
      ))
        throw K(247), new Error();
      return {
        selectAllChildren: o,
        toggledNodes: new Map(n)
      };
    };
    try {
      this.selectedState = t(e, !!e.selectAllChildren);
    } catch {
    }
  }
  deleteSelectionStateFromParent(e, t) {
    let s = this.selectedState;
    const i = [...e];
    for (; s && i.length; )
      s = s.toggledNodes.get(i.pop());
    if (!s)
      return !1;
    let o = !1;
    return t.forEach((n) => {
      s != null && s.toggledNodes.delete(n) && (o = !0);
    }), o && this.removeRedundantState(), o;
  }
  setNodesSelected({ nodes: e, newValue: t, clearSelection: s, source: i }) {
    if (e.length === 0)
      return 0;
    const o = s && t;
    if (!Hs(this.gos) || o) {
      if (e.length > 1)
        return K(130), 0;
      this.deselectAllRowNodes();
    }
    return e.forEach((n) => {
      const r = n.footer ? n.sibling : n, a = this.getRouteToNode(r);
      this.recursivelySelectNode(a, this.selectedState, t);
    }), this.removeRedundantState(), e.length === 1 && i === "api" && this.selectionCtx.setRoot(e[0].footer ? e[0].sibling : e[0]), 1;
  }
  isNodeSelected(e) {
    const t = this.getRouteToNode(e);
    return this.isNodePathSelected(t, this.selectedState);
  }
  isNodePathSelected([e, ...t], s) {
    if (t.length === 0) {
      const i = s.toggledNodes.has(e.id);
      if (e.hasChildren()) {
        const o = s.toggledNodes.get(e.id);
        if (o && o.toggledNodes.size)
          return;
      }
      return s.selectAllChildren ? !i : i;
    }
    if (s.toggledNodes.has(e.id)) {
      const i = s.toggledNodes.get(e.id);
      if (i)
        return this.isNodePathSelected(t, i);
    }
    return s.selectAllChildren;
  }
  getRouteToNode(e) {
    const t = [];
    let s = e;
    for (; s.parent; )
      t.push(s), s = s.parent;
    return t.reverse();
  }
  removeRedundantState() {
    var t;
    if ((t = this.filterManager) != null && t.isAnyFilterPresent())
      return;
    const e = (s = this.selectedState, i, o) => {
      if (s.toggledNodes.forEach((a, l) => {
        e(a, l, s);
      }), i) {
        const a = this.rowModel.getRowNode(i), l = a == null ? void 0 : a.childStore;
        if ((l == null ? void 0 : l.isLastRowIndexKnown()) && s.toggledNodes.size >= l.getRowCount()) {
          for (const u of s.toggledNodes.entries()) {
            const [h, g] = u;
            if (g.toggledNodes.size > 0 || !this.rowModel.getRowNode(h))
              return;
          }
          s.selectAllChildren = !s.selectAllChildren, s.toggledNodes.clear();
        }
      }
      const n = s.toggledNodes.size === 0, r = (o == null ? void 0 : o.selectAllChildren) === s.selectAllChildren;
      n && r && (o == null || o.toggledNodes.delete(i));
    };
    e();
  }
  recursivelySelectNode([e, ...t], s, i) {
    if (!e)
      return;
    if (!t.length) {
      const a = e.selectable;
      if (s.selectAllChildren === i || !a) {
        s.toggledNodes.delete(e.id);
        return;
      }
      const d = {
        selectAllChildren: i,
        toggledNodes: /* @__PURE__ */ new Map()
      };
      s.toggledNodes.set(e.id, d);
      return;
    }
    const n = s.toggledNodes.has(e.id), r = s.toggledNodes.get(e.id) ?? {
      selectAllChildren: s.selectAllChildren,
      toggledNodes: /* @__PURE__ */ new Map()
    };
    n || s.toggledNodes.set(e.id, r), this.recursivelySelectNode(t, r, i), s.selectAllChildren === r.selectAllChildren && r.toggledNodes.size === 0 && s.toggledNodes.delete(e.id);
  }
  getSelectedNodes(e = !1) {
    if (P(202), this.selectedState.selectAllChildren && e)
      return null;
    const t = [];
    return this.rowModel.forEachNode((s) => {
      s.isSelected() && t.push(s);
    }), t;
  }
  processNewRow() {
  }
  getSelectedRows() {
    var e;
    return ((e = this.getSelectedNodes()) == null ? void 0 : e.map((t) => t.data)) ?? [];
  }
  getSelectionCount() {
    return -1;
  }
  isEmpty() {
    var e;
    return !this.selectedState.selectAllChildren && !((e = this.selectedState.toggledNodes) != null && e.size);
  }
  selectAllRowNodes() {
    this.reset(!0);
  }
  deselectAllRowNodes() {
    this.reset(!1);
  }
  reset(e) {
    this.selectedState = { selectAllChildren: e, toggledNodes: /* @__PURE__ */ new Map() };
  }
  getSelectAllState() {
    return this.selectedState.selectAllChildren ? this.selectedState.toggledNodes.size > 0 ? null : !0 : this.selectedState.toggledNodes.size > 0 ? null : !1;
  }
}, eE = class extends qw {
  constructor() {
    super(...arguments), this.beanName = "selectionSvc";
  }
  postConstruct() {
    super.postConstruct(), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
      const s = lo(this.gos), i = s && this.selectionStrategy instanceof Ir ? Wo : !s && this.selectionStrategy instanceof Wo ? Ir : void 0;
      i && (this.destroyBean(this.selectionStrategy), this.selectionStrategy = this.createManagedBean(new i(this.selectionCtx)), this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged("api"));
    }), this.addManagedPropertyListeners(["rowSelection"], () => {
      const s = pn(this.gos);
      s !== this.selectionMode && (this.selectionMode = s, this.deselectAllRowNodes({ source: "api" }));
    }), this.selectionMode = pn(this.gos);
    const t = lo(this.gos) ? Wo : Ir;
    this.selectionStrategy = this.createManagedBean(new t(this.selectionCtx));
  }
  handleSelectionEvent(e, t, s) {
    if (this.isRowSelectionBlocked(t))
      return 0;
    let i = 0;
    const o = this.inferNodeSelections(t, e.shiftKey, e.metaKey || e.ctrlKey, s);
    return o == null ? 0 : (this.selectionCtx.selectAll = !1, "select" in o ? (o.reset ? this.selectionStrategy.deselectAllRowNodes({ source: "api" }) : this.selectionStrategy.setNodesSelected({ nodes: o.deselect, newValue: !1, source: s }), i = this.selectionStrategy.setNodesSelected({ nodes: o.select, newValue: !0, source: s })) : i = this.selectionStrategy.setNodesSelected({
      nodes: [o.node],
      newValue: o.newValue,
      clearSelection: o.clearSelection,
      event: e,
      source: s
    }), this.shotgunResetNodeSelectionState(s), this.dispatchSelectionChanged(s), i);
  }
  getSelectionState() {
    return this.selectionStrategy.getSelectedState();
  }
  setSelectionState(e, t) {
    if (!Dt(this.gos)) {
      P(132);
      return;
    }
    Array.isArray(e) || (this.selectionStrategy.setSelectedState(e), this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged(t));
  }
  setNodesSelected(e) {
    if (!Dt(this.gos) && e.newValue)
      return P(132), 0;
    const { nodes: t, ...s } = e;
    if (t.length > 1 && this.selectionMode !== "multiRow")
      return P(130), 0;
    const i = {
      nodes: t.filter((n) => n.selectable),
      ...s
    };
    if (!i.nodes.length)
      return 0;
    const o = this.selectionStrategy.setNodesSelected(i);
    return this.shotgunResetNodeSelectionState(i.source), this.dispatchSelectionChanged(i.source), o;
  }
  /**
   * Deletes the selection state for a set of nodes, for use after deleting nodes via
   * transaction. As this is designed for transactions, all nodes should belong to the same group.
   */
  deleteSelectionStateFromParent(e, t) {
    this.selectionStrategy.deleteSelectionStateFromParent(e, t) && (this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged("api"));
  }
  shotgunResetNodeSelectionState(e) {
    this.beans.rowModel.forEachNode((t) => {
      if (t.stub)
        return;
      const s = this.selectionStrategy.isNodeSelected(t);
      s !== t.isSelected() && this.selectRowNode(t, s, void 0, e);
    });
  }
  getSelectedNodes() {
    return this.selectionStrategy.getSelectedNodes() ?? [];
  }
  getSelectedRows() {
    return this.selectionStrategy.getSelectedRows();
  }
  getSelectionCount() {
    return this.selectionStrategy.getSelectionCount();
  }
  syncInRowNode(e) {
    this.selectionStrategy.processNewRow(e);
    const t = this.selectionStrategy.isNodeSelected(e);
    if (t != !1 && !e.selectable) {
      this.selectionStrategy.setNodesSelected({
        nodes: [e],
        newValue: !1,
        source: "api"
      }), this.shotgunResetNodeSelectionState(), this.dispatchSelectionChanged("api");
      return;
    }
    e.__selected = t;
  }
  reset() {
    this.selectionStrategy.deselectAllRowNodes({ source: "api" }), this.selectionCtx.reset();
  }
  isEmpty() {
    return this.selectionStrategy.isEmpty();
  }
  hasNodesToSelect() {
    return !0;
  }
  selectAllRowNodes(e) {
    if (!Dt(this.gos)) {
      P(132);
      return;
    }
    if (Wd(e), ru(this.gos) && !Hs(this.gos))
      return P(130);
    this.selectionStrategy.selectAllRowNodes(e), this.selectionCtx.selectAll = !0, this.beans.rowModel.forEachNode((t) => {
      t.stub || this.selectRowNode(t, !0, void 0, e.source);
    }), this.dispatchSelectionChanged(e.source);
  }
  deselectAllRowNodes(e) {
    Wd(e), this.selectionStrategy.deselectAllRowNodes(e), this.selectionCtx.selectAll = !1, this.beans.rowModel.forEachNode((t) => {
      t.stub || this.selectRowNode(t, !1, void 0, e.source);
    }), this.dispatchSelectionChanged(e.source);
  }
  getSelectAllState(e) {
    return this.selectionStrategy.getSelectAllState(e);
  }
  // used by CSRM
  getBestCostNodeSelection() {
    return P(194, { method: "getBestCostNodeSelection" });
  }
  /**
   * Updates the selectable state for a node by invoking isRowSelectable callback.
   * If the node is not selectable, it will be deselected.
   *
   * Callers:
   *  - property isRowSelectable changed
   *  - after grouping / treeData
   */
  updateSelectable() {
    if (!Dt(this.gos))
      return;
    const e = [];
    this.beans.rowModel.forEachNode((t) => {
      !this.updateRowSelectable(t, !0) && t.isSelected() && e.push(t);
    }), e.length && this.setNodesSelected({
      nodes: e,
      newValue: !1,
      source: "selectableChanged"
    });
  }
  dispatchSelectionChanged(e) {
    this.eventSvc.dispatchEvent({
      type: "selectionChanged",
      source: e,
      selectedNodes: this.selectionStrategy instanceof Wo ? null : this.selectionStrategy.getSelectedNodes(!0, !1),
      serverSideState: this.getSelectionState()
    });
  }
  updateSelectableAfterGrouping() {
    return K(194, { method: "updateSelectableAfterGrouping" });
  }
  refreshMasterNodeState() {
  }
  setDetailSelectionState() {
  }
};
function Wd({ selectAll: e }) {
  (e === "filtered" || e === "currentPage") && P(195, { justCurrentPage: e === "currentPage" });
}
var tE = class extends S {
  constructor() {
    super(...arguments), this.beanName = "rowChildrenSvc";
  }
  getHasChildrenValue(e) {
    const t = this.gos.get("treeData"), s = this.gos.get("isServerSideGroup");
    return !e.stub && !e.footer && (t ? !!s && s(e.data) : !!e.group);
  }
}, sE = class extends S {
  constructor() {
    super(...arguments), this.beanName = "lazyBlockLoadingSvc", this.outboundRequests = 0, this.cacheLoadingNodesMap = /* @__PURE__ */ new Map(), this.isCheckQueued = !1, this.nextBlockToLoad = void 0;
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.maxOutboundRequests = Am(this.gos);
  }
  subscribe(e) {
    this.cacheLoadingNodesMap.set(e, /* @__PURE__ */ new Set());
  }
  unsubscribe(e) {
    this.cacheLoadingNodesMap.delete(e);
  }
  /**
   * Queues a microtask to check if any blocks need to be loaded.
   */
  queueLoadCheck() {
    this.isCheckQueued || (this.isCheckQueued = !0, setTimeout(() => {
      this.queueLoadAction(), this.isCheckQueued = !1;
    }));
  }
  onLoadComplete() {
    this.outboundRequests -= 1, this.queueLoadCheck();
  }
  hasAvailableLoadBandwidth() {
    return this.maxOutboundRequests === void 0 ? !0 : this.outboundRequests < this.maxOutboundRequests;
  }
  queueLoadAction() {
    const e = this.getBlockToLoad();
    if (!e)
      return;
    const t = this.nextBlockToLoad && this.nextBlockToLoad.cache === e.cache && this.nextBlockToLoad.index === e.index;
    if (!t && (!this.nextBlockToLoad || !t)) {
      this.nextBlockToLoad = e, window.clearTimeout(this.loaderTimeout);
      const s = Number(this.nextBlockToLoad.index), i = this.nextBlockToLoad.cache, o = e.index + e.cache.getBlockSize();
      this.loaderTimeout = window.setTimeout(() => {
        i.isAlive() && (this.loaderTimeout = void 0, this.attemptLoad(i, s, o), this.nextBlockToLoad = void 0);
      }, this.gos.get("blockLoadDebounceMillis"));
    }
  }
  attemptLoad(e, t, s) {
    this.hasAvailableLoadBandwidth() && (this.executeLoad(e, t, s), this.queueLoadCheck());
  }
  executeLoad(e, t, s) {
    var u;
    const i = e.getSsrmParams(), o = {
      startRow: t,
      endRow: s,
      rowGroupCols: i.rowGroupCols,
      valueCols: i.valueCols,
      pivotCols: i.pivotCols,
      pivotMode: i.pivotMode,
      groupKeys: e.store.getParentNode().getRoute() ?? [],
      filterModel: i.filterModel,
      sortModel: i.sortModel
    }, n = this.cacheLoadingNodesMap.get(e), r = () => {
      for (let h = 0; h < s - t; h++)
        n.delete(t + h);
    }, a = () => {
      for (let h = 0; h < s - t; h++)
        n.add(t + h);
    }, l = (h) => {
      this.onLoadComplete(), e.onLoadSuccess(t, s - t, h), r();
    }, d = () => {
      this.onLoadComplete(), e.onLoadFailed(t, s - t), r();
    }, c = N(this.gos, {
      request: o,
      success: l,
      fail: d,
      parentNode: e.store.getParentNode()
    });
    a(), this.outboundRequests += 1, (u = e.getSsrmParams().datasource) == null || u.getRows(c);
  }
  getBlockToLoad() {
    var a, l;
    const e = this.rowRenderer.firstRenderedRow, t = this.rowRenderer.lastRenderedRow;
    for (let d = e; d <= t; d++) {
      const c = this.rowModel.getRow(d);
      if (!c)
        continue;
      const u = (a = c.parent) == null ? void 0 : a.childStore;
      if (!u)
        continue;
      const h = u.getCache(), g = h.getNodes().getBy("node", c);
      if (!g)
        continue;
      const p = this.cacheLoadingNodesMap.get(h);
      if (!(p != null && p.has(g.index)) && (c.__needsRefreshWhenVisible || c.stub && !c.failedLoad))
        return {
          cache: h,
          index: h.getBlockStartIndex(g.index)
        };
    }
    let s = null, i = null, o = Number.MAX_SAFE_INTEGER;
    for (const d of this.cacheLoadingNodesMap.keys())
      d.getNodesToRefresh().forEach((u) => {
        if (u.rowIndex == null) {
          i = u, s = d;
          return;
        }
        const h = d.getNodes().getBy("node", u);
        if (!h)
          return;
        const g = this.cacheLoadingNodesMap.get(d);
        if (g != null && g.has(h.index))
          return;
        const p = Math.abs(e - u.rowIndex), f = Math.abs(u.rowIndex - t);
        p < o && (i = u, o = p, s = d), f < o && (i = u, o = f, s = d);
      });
    if (!s)
      return;
    const n = s, r = (l = n.getNodes().getBy("node", i)) == null ? void 0 : l.index;
    return r == null ? void 0 : {
      cache: n,
      index: n.getBlockStartIndex(r)
    };
  }
  isRowLoading(e, t) {
    var s;
    return ((s = this.cacheLoadingNodesMap.get(e)) == null ? void 0 : s.has(t)) ?? !1;
  }
}, iE = class {
  constructor(...e) {
    this.indexes = e, this.maps = new Map(this.indexes.map((t) => [t, /* @__PURE__ */ new Map()]));
  }
  getSize() {
    return this.maps.get(this.indexes[0]).size;
  }
  getBy(e, t) {
    return this.maps.get(e).get(t);
  }
  set(e) {
    this.indexes.forEach((t) => {
      this.maps.get(t).set(e[t], e);
    });
  }
  delete(e) {
    this.indexes.forEach((t) => {
      this.maps.get(t).delete(e[t]);
    });
  }
  clear() {
    this.maps.forEach((e) => e.clear());
  }
  getIterator(e) {
    return this.maps.get(e).values();
  }
  forEach(e) {
    const t = this.getIterator(this.indexes[0]);
    let s;
    for (; (s = t.next()) && !s.done; )
      e(s.value);
  }
  find(e) {
    const t = this.getIterator(this.indexes[0]);
    let s;
    for (; (s = t.next()) && !s.done; )
      if (e(s.value))
        return s.value;
  }
  filter(e) {
    const t = this.getIterator(this.indexes[0]);
    let s;
    const i = [];
    for (; (s = t.next()) && !s.done; )
      e(s.value) && i.push(s.value);
    return i;
  }
}, oE = 100, Tr = class extends S {
  constructor(e, t, s, i) {
    super(), this.live = !0, this.removedNodeCache = /* @__PURE__ */ new Map(), this.store = e, this.numberOfRows = t, this.isLastRowKnown = s, this.storeParams = i;
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.blockUtils = e.ssrmBlockUtils, this.focusSvc = e.focusSvc, this.nodeManager = e.ssrmNodeManager, this.serverSideRowModel = e.rowModel, this.rowNodeSorter = e.rowNodeSorter, this.sortSvc = e.sortSvc, this.lazyBlockLoadingSvc = e.lazyBlockLoadingSvc, this.colModel = e.colModel;
  }
  postConstruct() {
    this.lazyBlockLoadingSvc.subscribe(this), this.nodeMap = new iE("index", "id", "node"), this.nodeDisplayIndexMap = /* @__PURE__ */ new Map(), this.nodesToRefresh = /* @__PURE__ */ new Set(), this.defaultNodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode()), this.getRowIdFunc = ro(this.gos), this.isMasterDetail = this.gos.get("masterDetail");
  }
  destroy() {
    this.lazyBlockLoadingSvc.unsubscribe(this), this.numberOfRows = 0, this.nodeMap.forEach((e) => this.blockUtils.destroyRowNode(e.node)), this.nodeMap.clear(), this.nodeDisplayIndexMap.clear(), this.nodesToRefresh.clear(), this.live = !1, super.destroy();
  }
  /**
   * Get the row node for a specific display index from this store
   * @param displayIndex the display index of the node to find
   * @returns undefined if the node is not in the store bounds, otherwise will always return a node
   */
  getRowByDisplayIndex(e) {
    var l, d, c, u, h;
    if (!this.store.isDisplayIndexInStore(e))
      return;
    const t = this.nodeDisplayIndexMap.get(e);
    if (t)
      return (t.stub || t.__needsRefreshWhenVisible) && this.lazyBlockLoadingSvc.queueLoadCheck(), t;
    if (this.gos.get("groupHideOpenParents") || this.gos.get("groupAllowUnbalanced")) {
      const g = this.nodeMap.find(
        (p) => {
          var f;
          return !!((f = p.node.childStore) != null && f.isDisplayIndexInStore(e));
        }
      );
      if (g)
        return (l = g.node.childStore) == null ? void 0 : l.getRowUsingDisplayIndex(e);
    }
    if (e === this.store.getDisplayIndexStart())
      return this.createStubNode(0, e);
    const i = this.nodeDisplayIndexMap.get(e - 1);
    if (i) {
      if (this.isMasterDetail && i.master && i.expanded)
        return i.detailNode;
      if (i.expanded && ((d = i.childStore) != null && d.isDisplayIndexInStore(e)))
        return (c = i.childStore) == null ? void 0 : c.getRowUsingDisplayIndex(
          e
        );
      const g = this.nodeMap.getBy("node", i);
      return this.createStubNode(g.index + 1, e);
    }
    const o = this.getSurroundingNodesByDisplayIndex(e);
    if (o == null) {
      const g = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - e);
      return this.createStubNode(g, e);
    }
    const { previousNode: n, nextNode: r } = o;
    if (n && n.node.expanded && ((u = n.node.childStore) != null && u.isDisplayIndexInStore(e)))
      return (h = n.node.childStore) == null ? void 0 : h.getRowUsingDisplayIndex(e);
    if (r) {
      const g = r.node.rowIndex - e, p = r.index - g;
      return this.createStubNode(p, e);
    }
    const a = this.store.getRowCount() - (this.store.getDisplayIndexEnd() - e);
    return this.createStubNode(a, e);
  }
  /**
   * Used for creating and positioning a stub node without firing a store updated event
   */
  createStubNode(e, t) {
    const s = this.store.getRowBounds(t), i = this.createRowAtIndex(e, null, (o) => {
      o.setRowIndex(t), o.setRowTop(s.rowTop), this.nodeDisplayIndexMap.set(t, o);
    });
    if (e === 0 && this.gos.get("groupHideOpenParents")) {
      const o = this.store.getParentNode().groupData;
      if (o)
        for (const n of Object.keys(o))
          Ad(i, this.colModel, n, o[n]);
    }
    return this.lazyBlockLoadingSvc.queueLoadCheck(), i;
  }
  /**
   * @param index The row index relative to this store
   * @returns A rowNode at the given store index
   */
  getRowByStoreIndex(e) {
    var t;
    return (t = this.nodeMap.getBy("index", e)) == null ? void 0 : t.node;
  }
  /**
   * Given a number of rows, skips through the given sequence & row top reference (using default row height)
   * @param numberOfRowsToSkip number of rows to skip over in the given sequence
   * @param displayIndexSeq the sequence in which to skip
   * @param nextRowTop the row top reference in which to skip
   */
  skipDisplayIndexes(e, t, s) {
    if (e === 0)
      return;
    const i = Bs(this.beans);
    t.value += e, s.value += e * i;
  }
  /**
   * @param displayIndexSeq the number sequence for generating the display index of each row
   * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
   */
  setDisplayIndexes(e, t, s) {
    this.nodeDisplayIndexMap.clear();
    const i = {};
    this.nodeMap.forEach((r) => {
      i[r.index] = r.node;
    });
    let o = -1;
    for (const r of Object.keys(i)) {
      const a = i[r], l = Number(r), d = l - 1 - o;
      this.skipDisplayIndexes(d, e, t);
      const c = l === 0;
      if (a.setFirstChild(c), c && this.gos.get("groupHideOpenParents")) {
        const u = this.store.getParentNode().groupData;
        if (u)
          for (const h of Object.keys(u))
            Ad(a, this.colModel, h, c ? u[h] : void 0);
      }
      this.blockUtils.setDisplayIndex(a, e, t, s), a.rowIndex != null && this.nodeDisplayIndexMap.set(a.rowIndex, a), o = l;
    }
    const n = this.numberOfRows - 1 - o;
    this.skipDisplayIndexes(n, e, t), this.purgeExcessRows();
  }
  getRowCount() {
    return this.numberOfRows;
  }
  setRowCount(e, t) {
    this.numberOfRows = e, t != null && (this.isLastRowKnown = t, t === !1 && (this.numberOfRows += 1)), this.fireStoreUpdatedEvent();
  }
  getNodes() {
    return this.nodeMap;
  }
  getNodeCachedByDisplayIndex(e) {
    return this.nodeDisplayIndexMap.get(e) ?? null;
  }
  getNodesToRefresh() {
    return this.nodesToRefresh;
  }
  /**
   * @returns the previous and next loaded row nodes surrounding the given display index
   */
  getSurroundingNodesByDisplayIndex(e) {
    let t, s;
    return this.nodeMap.forEach((i) => {
      if (e > i.node.rowIndex) {
        (s == null || s.node.rowIndex < i.node.rowIndex) && (s = i);
        return;
      }
      if (t == null || t.node.rowIndex > i.node.rowIndex) {
        t = i;
        return;
      }
    }), !s && !t ? null : { previousNode: s, nextNode: t };
  }
  /**
   * Get or calculate the display index for a given store index
   * @param storeIndex the rows index within this store
   * @returns the rows visible display index relative to the grid
   */
  getDisplayIndexFromStoreIndex(e) {
    var r;
    const t = this.nodeMap.getBy("index", e);
    if (t)
      return t.node.rowIndex;
    let s, i;
    if (this.nodeMap.forEach((a) => {
      if (e > a.index) {
        (i == null || i.index < a.index) && (i = a);
        return;
      }
      if (s == null || s.index > a.index) {
        s = a;
        return;
      }
    }), !s)
      return this.store.getDisplayIndexEnd() - (this.numberOfRows - e);
    if (!i)
      return this.store.getDisplayIndexStart() + e;
    const o = e - i.index;
    return (((r = i.node.childStore) == null ? void 0 : r.getDisplayIndexEnd()) ?? i.node.rowIndex) + o;
  }
  /**
   * Creates a new row and inserts it at the given index
   * @param atStoreIndex the node index relative to this store
   * @param data the data object to populate the node with
   * @returns the new row node
   */
  createRowAtIndex(e, t, s) {
    var n, r;
    const i = this.nodeMap.getBy("index", e);
    if (i) {
      const { node: a } = i;
      if (a.__needsRefreshWhenVisible = !1, this.doesNodeMatch(t, a))
        return this.blockUtils.updateDataIntoRowNode(a, t), this.nodesToRefresh.delete(a), a;
      if (this.getRowIdFunc == null && a.hasChildren() && a.expanded)
        return this.nodesToRefresh.delete(a), a;
      this.destroyRowAtIndex(e);
    }
    if (t && this.getRowIdFunc != null) {
      const a = this.getRowId(t), l = a && ((n = this.removedNodeCache) == null ? void 0 : n.get(a));
      if (l)
        return (r = this.removedNodeCache) == null || r.delete(a), this.blockUtils.updateDataIntoRowNode(l, t), this.nodeMap.set({
          id: l.id,
          node: l,
          index: e
        }), this.nodesToRefresh.delete(l), l.__needsRefreshWhenVisible = !1, l;
      const d = this.nodeMap.getBy("id", a);
      if (d) {
        this.nodeMap.delete(d);
        const { node: c, index: u } = d;
        return this.blockUtils.updateDataIntoRowNode(c, t), this.nodeMap.set({
          id: c.id,
          node: c,
          index: e
        }), this.nodesToRefresh.delete(c), c.__needsRefreshWhenVisible = !1, this.getBlockStartIndex(u) === this.getBlockStartIndex(e) || this.markBlockForVerify(u), c;
      }
    }
    const o = this.blockUtils.createRowNode(this.store.getRowDetails());
    if (t != null) {
      const a = this.getPrefixedId(this.store.getIdSequence().value++);
      this.blockUtils.setDataIntoRowNode(o, t, a, void 0), this.serverSideRowModel.setPaused(!0), this.blockUtils.checkOpenByDefault(o), this.serverSideRowModel.setPaused(!1), this.nodeManager.addRowNode(o);
    }
    return this.nodeMap.set({
      id: o.id,
      node: o,
      index: e
    }), s && s(o), o;
  }
  getBlockStates() {
    const e = {}, t = {};
    this.nodeMap.forEach(({ node: n, index: r }) => {
      const a = this.getBlockStartIndex(r);
      !n.stub && !n.failedLoad && (e[a] = (e[a] ?? 0) + 1);
      let l = "loaded";
      n.failedLoad ? l = "failed" : this.lazyBlockLoadingSvc.isRowLoading(this, a) ? l = "loading" : (this.nodesToRefresh.has(n) || n.stub) && (l = "needsLoading"), t[a] || (t[a] = /* @__PURE__ */ new Set()), t[a].add(l);
    });
    const s = {
      loading: 4,
      failed: 3,
      needsLoading: 2,
      loaded: 1
    }, i = this.blockUtils.createNodeIdPrefix(this.store.getParentNode()), o = {};
    for (const n of Object.keys(t)) {
      const a = [...t[n]].sort(
        (c, u) => (s[c] ?? 0) - (s[u] ?? 0)
      )[0], l = Number(n) / this.getBlockSize(), d = i ? `${i}-${l}` : String(l);
      o[d] = {
        blockNumber: l,
        startRow: Number(n),
        endRow: Number(n) + this.getBlockSize(),
        pageStatus: a,
        loadedRowCount: e[n] ?? 0
      };
    }
    return o;
  }
  destroyRowAtIndex(e) {
    const t = this.nodeMap.getBy("index", e);
    t && (this.nodeMap.delete(t), this.nodeDisplayIndexMap.delete(t.node.rowIndex), this.nodesToRefresh.size > 0 ? this.removedNodeCache.set(t.node.id, t.node) : this.blockUtils.destroyRowNode(t.node), this.nodesToRefresh.delete(t.node));
  }
  getSsrmParams() {
    return this.store.getSsrmParams();
  }
  /**
   * @param id the base id to be prefixed
   * @returns a node id with prefix if required
   */
  getPrefixedId(e) {
    return this.defaultNodeIdPrefix ? this.defaultNodeIdPrefix + "-" + e : e.toString();
  }
  markBlockForVerify(e) {
    const [t, s] = this.getBlockBounds(e);
    this.nodeMap.filter((o) => o.index >= t && o.index < s).forEach(({ node: o }) => {
      o.__needsRefreshWhenVisible = !0;
    });
  }
  doesNodeMatch(e, t) {
    if (t.stub)
      return !1;
    const s = this.getRowId(e);
    return s === null ? t.data === e : t.id === s;
  }
  /**
   * Deletes any stub nodes not within the given range
   */
  purgeStubsOutsideOfViewport() {
    const { firstRenderedRow: e, lastRenderedRow: t } = this.rowRenderer, s = this.getBlockStartIndex(e), [, i] = this.getBlockBounds(t);
    this.nodeMap.forEach((o) => {
      this.lazyBlockLoadingSvc.isRowLoading(this, o.index) || o.node.failedLoad || o.node.stub && (o.index < s || o.index > i) && this.destroyRowAtIndex(o.index);
    });
  }
  getBlocksDistanceFromRow(e, t) {
    const s = {};
    return e.forEach(({ node: i, index: o }) => {
      const [n, r] = this.getBlockBounds(o);
      if (n in s)
        return;
      const a = Math.abs(i.rowIndex - t);
      let l;
      const d = this.nodeMap.getBy("index", [r - 1]);
      d && (l = Math.abs(d.node.rowIndex - t));
      const c = l == null || a < l ? a : l;
      s[n] = c;
    }), Object.entries(s);
  }
  purgeExcessRows() {
    if (this.purgeStubsOutsideOfViewport(), this.store.getDisplayIndexEnd() == null || this.storeParams.maxBlocksInCache == null)
      return;
    const { firstRenderedRow: e, lastRenderedRow: t } = this.rowRenderer, s = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    this.nodeMap.forEach(({ index: g, node: p }) => {
      const f = this.getBlockStartIndex(g);
      s.add(f), p.rowIndex >= e && p.rowIndex <= t && i.add(f);
    });
    const o = Math.max(i.size, this.storeParams.maxBlocksInCache ?? 0), r = s.size - o;
    if (r <= 0)
      return;
    let a = Number.MAX_SAFE_INTEGER, l = Number.MIN_SAFE_INTEGER;
    i.forEach((g) => {
      a > g && (a = g), l < g && (l = g);
    });
    const d = this.nodeMap.filter(({ node: g, index: p }) => {
      const f = this.getBlockStartIndex(p);
      return !(f >= a && f <= l) && !this.isNodeCached(g);
    });
    if (d.length === 0)
      return;
    const c = e + (t - e) / 2, u = this.getBlocksDistanceFromRow(d, c), h = this.getBlockSize();
    u.sort((g, p) => Math.sign(p[1] - g[1]));
    for (let g = 0; g < Math.min(r, u.length); g++) {
      const p = Number(u[g][0]);
      for (let f = p; f < p + h; f++) {
        const m = this.nodeMap.getBy("index", f);
        !m || this.isNodeCached(m.node) || this.destroyRowAtIndex(f);
      }
    }
  }
  isNodeFocused(e) {
    const t = this.focusSvc.getFocusCellToUseAfterRefresh();
    return !t || t.rowPinned != null ? !1 : t.rowIndex === e.rowIndex;
  }
  isNodeCached(e) {
    const t = this.gos.get("groupAllowUnbalanced") && e.key === "";
    return e.isExpandable() && e.expanded || this.isNodeFocused(e) || t;
  }
  extractDuplicateIds(e) {
    if (this.getRowIdFunc == null)
      return [];
    const t = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set();
    return e.forEach((i) => {
      const o = this.getRowId(i);
      if (t.has(o)) {
        s.add(o);
        return;
      }
      t.add(o);
    }), [...s];
  }
  onLoadSuccess(e, t, s) {
    if (!this.live)
      return;
    const i = s.groupLevelInfo;
    if (this.store.setStoreInfo(i), this.getRowIdFunc != null) {
      const r = this.extractDuplicateIds(s.rowData);
      if (r.length > 0) {
        const a = r.join(", ");
        P(205, { duplicateIdText: a }), this.onLoadFailed(e, t);
        return;
      }
    }
    s.pivotResultFields && this.serverSideRowModel.generateSecondaryColumns(s.pivotResultFields);
    const o = this.nodesToRefresh.size > 0;
    if (s.rowData.forEach((r, a) => {
      var c;
      const l = e + a, d = this.nodeMap.getBy("index", l);
      if ((c = d == null ? void 0 : d.node) != null && c.stub) {
        this.createRowAtIndex(l, r);
        return;
      }
      if (d && this.doesNodeMatch(r, d.node)) {
        this.blockUtils.updateDataIntoRowNode(d.node, r), this.nodesToRefresh.delete(d.node), d.node.__needsRefreshWhenVisible = !1;
        return;
      }
      this.createRowAtIndex(l, r);
    }), s.rowCount != null && s.rowCount !== -1)
      this.numberOfRows = s.rowCount, this.isLastRowKnown = !0;
    else if (t > s.rowData.length)
      this.numberOfRows = e + s.rowData.length, this.isLastRowKnown = !0;
    else if (!this.isLastRowKnown) {
      const r = e + s.rowData.length + 1;
      r > this.numberOfRows && (this.numberOfRows = r);
    }
    this.isLastRowKnown && this.nodeMap.filter((a) => a.index >= this.numberOfRows).forEach((a) => this.destroyRowAtIndex(a.index)), this.fireStoreUpdatedEvent();
    const n = this.nodesToRefresh.size === 0;
    o && n && this.fireRefreshFinishedEvent();
  }
  fireRefreshFinishedEvent() {
    this.nodesToRefresh.size === 0 && (this.removedNodeCache.forEach((t) => {
      this.blockUtils.destroyRowNode(t);
    }), this.removedNodeCache = /* @__PURE__ */ new Map(), this.store.fireRefreshFinishedEvent());
  }
  /**
   * @returns true if all rows are loaded
   */
  isStoreFullyLoaded() {
    const e = this.isLastRowKnown, t = this.nodeMap.getSize() === this.numberOfRows;
    if (!e || !t || this.nodesToRefresh.size > 0)
      return;
    let s = -1;
    return this.nodeMap.find((o) => (s += 1, !!(o.index !== s || o.node.__needsRefreshWhenVisible || o.node.stub))) == null;
  }
  isLastRowIndexKnown() {
    return this.isLastRowKnown;
  }
  onLoadFailed(e, t) {
    if (!this.live)
      return;
    const s = this.nodesToRefresh.size > 0;
    for (let o = e; o < e + t && o < this.getRowCount(); o++) {
      let { node: n } = this.nodeMap.getBy("index", o) ?? {};
      n && this.nodesToRefresh.delete(n), (!n || !n.stub) && (n && !n.stub && this.destroyRowAtIndex(o), n = this.createRowAtIndex(o)), n.__needsRefreshWhenVisible = !1, n.failedLoad = !0;
    }
    const i = this.nodesToRefresh.size === 0;
    s && i && this.fireRefreshFinishedEvent(), this.fireStoreUpdatedEvent();
  }
  markNodesForRefresh() {
    this.nodeMap.forEach((e) => {
      e.node.stub && !e.node.failedLoad || this.nodesToRefresh.add(e.node);
    }), this.lazyBlockLoadingSvc.queueLoadCheck(), this.isLastRowKnown && this.numberOfRows === 0 && (this.numberOfRows = 1, this.isLastRowKnown = !1, this.fireStoreUpdatedEvent());
  }
  isNodeInCache(e) {
    return !!this.nodeMap.getBy("id", e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  fireStoreUpdatedEvent() {
    this.live && this.store.fireStoreUpdatedEvent();
  }
  getRowId(e) {
    if (this.getRowIdFunc == null)
      return null;
    const { level: t } = this.store.getRowDetails(), s = this.store.getParentNode().getRoute() ?? [];
    return this.getRowIdFunc({
      data: e,
      parentKeys: s.length > 0 ? s : void 0,
      level: t
    });
  }
  getOrderedNodeMap() {
    const e = {};
    return this.nodeMap.forEach((t) => e[t.index] = t), e;
  }
  clearDisplayIndexes() {
    this.nodeDisplayIndexMap.clear();
  }
  /**
   * Client side sorting
   */
  clientSideSortRows() {
    var o;
    const e = ((o = this.sortSvc) == null ? void 0 : o.getSortOptions()) ?? [];
    if (!e.some((n) => n.sort != null) || !this.rowNodeSorter)
      return;
    const s = new Array(this.nodeMap.getSize());
    this.nodeMap.forEach((n) => s[n.index] = n.node), this.nodeMap.clear(), this.rowNodeSorter.doFullSort(s, e).forEach((n, r) => {
      this.nodeMap.set({
        id: n.id,
        node: n,
        index: r
      });
    });
  }
  /**
   * Transaction Support here
   */
  updateRowNodes(e) {
    const t = [];
    return e.forEach((s) => {
      const i = this.getRowId(s), o = this.nodeMap.getBy("id", i);
      o && (this.blockUtils.updateDataIntoRowNode(o.node, s), t.push(o.node));
    }), t;
  }
  insertRowNodes(e, t) {
    const s = this.store.getRowCount() - (this.store.getParentNode().sibling ? 1 : 0), i = t == null && this.isLastRowKnown ? s : t;
    if (i == null || s < i)
      return [];
    const o = {};
    e.forEach((l) => {
      const d = this.getRowId(l);
      d && this.isNodeInCache(d) || (o[d] = l);
    });
    const n = Object.values(o), r = n.length;
    if (r === 0)
      return [];
    const a = this.nodeMap.filter((l) => l.index >= i);
    return a.forEach((l) => this.nodeMap.delete(l)), a.forEach((l) => {
      this.nodeMap.set({
        node: l.node,
        index: l.index + r,
        id: l.id
      });
    }), this.numberOfRows += r, n.map(
      (l, d) => this.createRowAtIndex(i + d, l)
    );
  }
  removeRowNodes(e) {
    const t = [], s = [];
    let i = 0;
    const o = [...e], n = this.getOrderedNodeMap();
    let r = -1;
    for (const a of Object.keys(n)) {
      r += 1;
      const l = n[a], d = o.findIndex((u) => u === l.id);
      if (d !== -1) {
        o.splice(d, 1), this.destroyRowAtIndex(Number(a)), t.push(l.node), i += 1;
        continue;
      }
      if (i === 0)
        continue;
      const c = Number(a);
      r !== c && s.push(l.node), this.nodeMap.delete(l), this.nodeMap.set({
        id: l.id,
        node: l.node,
        index: c - i
      });
    }
    return this.numberOfRows -= this.isLastRowIndexKnown() ? e.length : i, o.length > 0 && s.length > 0 && (s.forEach((a) => a.__needsRefreshWhenVisible = !0), this.lazyBlockLoadingSvc.queueLoadCheck()), t;
  }
  /**
   * Return the block size configured for this cache
   */
  getBlockSize() {
    return this.storeParams.cacheBlockSize || oE;
  }
  /**
   * Get the start index of the loading block for a given index
   */
  getBlockStartIndex(e) {
    const t = this.getBlockSize();
    return e - e % t;
  }
  /**
   * Get the start and end index of a block, given a row store index
   */
  getBlockBounds(e) {
    const t = this.getBlockStartIndex(e), s = this.getBlockSize();
    return [t, t + s];
  }
}, nE = class extends S {
  constructor(e, t, s) {
    super(), this.idSequence = { value: 0 }, this.ssrmParams = e, this.parentRowNode = s, this.storeParams = t, this.level = s.level + 1, this.group = e.rowGroupCols ? this.level < e.rowGroupCols.length : !1, this.leafGroup = e.rowGroupCols ? this.level === e.rowGroupCols.length - 1 : !1, this.info = {};
  }
  wireBeans(e) {
    this.blockUtils = e.ssrmBlockUtils, this.storeUtils = e.ssrmStoreUtils, this.selectionSvc = e.selectionSvc, this.rowGroupColsSvc = e.rowGroupColsSvc;
  }
  postConstruct() {
    let e = 1;
    if (this.level === 0 && (e = this.storeUtils.getServerSideInitialRowCount() ?? 1, this.eventSvc.dispatchEventOnce({
      type: "rowCountReady"
    })), this.cache = this.createManagedBean(new Tr(this, e, !1, this.storeParams)), !this.gos.get("treeData") && this.group && this.rowGroupColsSvc) {
      const s = this.ssrmParams.rowGroupCols[this.level];
      this.groupField = s.field, this.rowGroupColumn = this.rowGroupColsSvc.columns[this.level];
    }
  }
  destroy() {
    this.displayIndexStart = void 0, this.displayIndexEnd = void 0, this.destroyBean(this.cache), super.destroy();
  }
  /**
   * Given a server response, ingest the rows outside of the data source lifecycle.
   *
   * @param rowDataParams the server response containing the rows to ingest
   * @param startRow the index to start ingesting rows
   * @param expectedRows the expected number of rows in the response (used to determine if the last row index is known)
   */
  applyRowData(e, t, s) {
    this.cache.onLoadSuccess(t, s, e);
  }
  /**
   * Applies a given transaction to the data set within this store
   *
   * @param transaction an object containing delta instructions determining the changes to apply to this store
   * @returns an object determining the status of this transaction and effected nodes
   */
  applyTransaction(e) {
    var c, u, h;
    const t = ro(this.gos);
    if (!t)
      return P(206), {
        status: Ft.Cancelled
      };
    const s = this.gos.getCallback("isApplyServerSideTransaction");
    if (s) {
      const g = {
        transaction: e,
        parentNode: this.parentRowNode,
        groupLevelInfo: this.info
      };
      if (!s(g))
        return { status: Ft.Cancelled };
    }
    const i = this.cache.isStoreFullyLoaded();
    let o;
    (c = e.update) != null && c.length && (o = this.cache.updateRowNodes(e.update));
    let n;
    if ((u = e.add) != null && u.length) {
      let g = e.addIndex;
      g != null && g < 0 && (g = void 0), n = this.cache.insertRowNodes(e.add, g);
    }
    let r;
    if ((h = e.remove) != null && h.length) {
      const g = e.remove.map(
        (f) => t({ level: this.level, parentKeys: this.parentRowNode.getRoute() ?? [], data: f })
      ), p = [...new Set(g)];
      r = this.cache.removeRowNodes(p);
    }
    const a = this.gos.get("serverSideEnableClientSideSort"), l = (o == null ? void 0 : o.length) || (n == null ? void 0 : n.length);
    return i && a && l && this.cache.clientSideSortRows(), this.updateSelectionAfterTransaction(o, r), {
      status: Ft.Applied,
      update: o,
      add: n,
      remove: r
    };
  }
  updateSelectionAfterTransaction(e, t) {
    if (!this.selectionSvc)
      return;
    const s = [];
    e == null || e.forEach((i) => {
      i.isSelected() && !i.selectable && s.push(i);
    }), t == null || t.forEach((i) => {
      i.isSelected() && s.push(i);
    }), s.length && this.selectionSvc.setNodesSelected({
      newValue: !1,
      clearSelection: !1,
      nodes: s,
      source: "rowDataChanged"
    });
  }
  /**
   * Clear the display indexes, used for fading rows out when stores are not being destroyed
   */
  clearDisplayIndexes() {
    this.displayIndexStart = void 0, this.displayIndexEnd = void 0, this.cache.getNodes().forEach((e) => this.blockUtils.clearDisplayIndex(e.node)), this.parentRowNode.sibling && this.blockUtils.clearDisplayIndex(this.parentRowNode.sibling), this.cache.clearDisplayIndexes();
  }
  /**
   * @returns an index representing the last sequentially displayed row in the grid for this store
   */
  getDisplayIndexStart() {
    return this.displayIndexStart;
  }
  /**
   * @returns the index representing one after the last sequentially displayed row in the grid for this store
   */
  getDisplayIndexEnd() {
    return this.displayIndexEnd;
  }
  /**
   * @returns the virtual size of this store
   */
  getRowCount() {
    return this.parentRowNode.sibling ? this.cache.getRowCount() + 1 : this.cache.getRowCount();
  }
  /**
   * Sets the current row count of the store, and whether the last row index is known
   */
  setRowCount(e, t) {
    this.cache.setRowCount(e, t);
  }
  /**
   * Given a display index, returns whether that row is within this store or a child store of this store
   *
   * @param displayIndex the visible index of a row
   * @returns whether or not the row exists within this store
   */
  isDisplayIndexInStore(e) {
    return this.cache.getRowCount() === 0 ? !1 : this.displayIndexStart <= e && e < this.getDisplayIndexEnd();
  }
  /**
   * Recursively sets up the display indexes and top position of every node belonging to this store.
   *
   * Called after a row height changes, or a store updated event.
   *
   * @param displayIndexSeq the number sequence for generating the display index of each row
   * @param nextRowTop an object containing the next row top value intended to be modified by ref per row
   */
  setDisplayIndexes(e, t, s) {
    this.displayIndexStart = e.value, this.topPx = t.value;
    const i = this.parentRowNode.level > -1 && Si(this.gos)({ node: this.parentRowNode });
    i || fl(this.parentRowNode), i === "top" && (Vt(this.parentRowNode, this.beans), this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, e, t, s)), this.cache.setDisplayIndexes(e, t, s), i === "bottom" && (Vt(this.parentRowNode, this.beans), this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, e, t, s)), this.displayIndexEnd = e.value, this.heightPx = t.value - this.topPx;
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
   */
  forEachStoreDeep(e, t = { value: 0 }) {
    e(this, t.value++), this.cache.getNodes().forEach((s) => {
      const i = s.node.childStore;
      i && i.forEachStoreDeep(e, t);
    });
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort
   */
  forEachNodeDeep(e, t = { value: 0 }) {
    this.cache.getNodes().forEach((s) => {
      e(s.node, t.value++);
      const i = s.node.childStore;
      i && i.forEachNodeDeep(e, t);
    });
  }
  /**
   * Recursively applies a provided function to every node
   *
   * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeep
   */
  forEachNodeDeepAfterFilterAndSort(e, t = { value: 0 }, s = !1) {
    const i = this.parentRowNode.level > -1 && Si(this.gos)({ node: this.parentRowNode });
    i === "top" && e(this.parentRowNode.sibling, t.value++);
    const o = this.cache.getOrderedNodeMap();
    for (const n of Object.values(o)) {
      e(n.node, t.value++);
      const r = n.node.childStore;
      r && r.forEachNodeDeepAfterFilterAndSort(e, t, s);
    }
    i === "bottom" && e(this.parentRowNode.sibling, t.value++);
  }
  /**
   * Removes the failed status from all nodes, and marks them as stub to encourage reloading
   */
  retryLoads() {
    this.cache.getNodes().forEach(({ node: e }) => {
      e.failedLoad && (e.failedLoad = !1, e.__needsRefreshWhenVisible = !0, e.stub = !0);
    }), this.forEachChildStoreShallow((e) => e.retryLoads()), this.fireStoreUpdatedEvent();
  }
  /**
   * Given a display index, returns the row at that location.
   *
   * @param displayRowIndex the displayed index within the grid to search for
   * @returns the row node if the display index falls within the store, if it didn't exist this will create a new stub to return
   */
  getRowUsingDisplayIndex(e) {
    return this.parentRowNode.sibling && e === this.parentRowNode.sibling.rowIndex ? this.parentRowNode.sibling : this.cache.getRowByDisplayIndex(e);
  }
  /**
   * Given a display index, returns the row top and height for the row at that index.
   *
   * @param displayIndex the display index of the node
   * @returns an object containing the rowTop and rowHeight of the node at the given displayIndex
   */
  getRowBounds(e) {
    if (!this.isDisplayIndexInStore(e))
      return null;
    const t = this.cache.getNodeCachedByDisplayIndex(e);
    if (t) {
      const a = this.blockUtils.extractRowBounds(t, e);
      if (a)
        return a;
    }
    const { previousNode: s, nextNode: i } = this.cache.getSurroundingNodesByDisplayIndex(e) ?? {};
    if (s) {
      const a = this.blockUtils.extractRowBounds(s.node, e);
      if (a != null)
        return a;
    }
    const o = Bs(this.beans);
    if (i) {
      const a = (i.node.rowIndex - e) * o;
      return {
        rowTop: i.node.rowTop - a,
        rowHeight: o
      };
    }
    const n = this.topPx + this.heightPx, r = (this.getDisplayIndexEnd() - e) * o;
    return {
      rowTop: n - r,
      rowHeight: o
    };
  }
  /**
   * Given a vertical pixel, determines whether this store contains a row at that pixel
   *
   * @param pixel a vertical pixel position from the grid
   * @returns whether that pixel points to a virtual space belonging to this store
   */
  isPixelInRange(e) {
    return e >= this.topPx && e < this.topPx + this.heightPx;
  }
  /**
   * Given a vertical pixel, returns the row existing at that pixel location
   *
   * @param pixel a vertical pixel position from the grid
   * @returns the display index at the given pixel location
   */
  getRowIndexAtPixel(e) {
    if (e < this.topPx)
      return this.getDisplayIndexStart();
    if (e >= this.topPx + this.heightPx)
      return this.getDisplayIndexEnd() - 1;
    if (this.parentRowNode.sibling && e > this.parentRowNode.sibling.rowTop && e < this.parentRowNode.sibling.rowTop + this.parentRowNode.sibling.rowHeight)
      return this.parentRowNode.sibling.rowIndex;
    let t = Number.MAX_SAFE_INTEGER, s = null, i = Number.MAX_SAFE_INTEGER, o = null;
    if (this.cache.getNodes().forEach(({ node: l }) => {
      const d = Math.abs(e - l.rowTop);
      if (l.rowTop < e) {
        d < t && (t = d, s = l);
        return;
      }
      d < i && (i = d, o = l);
    }), s = s, o = o, s) {
      const l = this.blockUtils.getIndexAtPixel(s, e);
      if (l != null)
        return l;
    }
    const n = Bs(this.beans);
    if (o) {
      const l = o.rowTop, d = Math.ceil((l - e) / n);
      return o.rowIndex - d;
    }
    const r = this.topPx + this.heightPx, a = Math.floor((r - e) / n);
    return this.getDisplayIndexEnd() - a;
  }
  /**
   * Given a path of group keys, returns the child store for that group.
   *
   * @param keys the grouping path to the desired store
   * @returns the child store for the given keys, or null if not found
   */
  getChildStore(e) {
    return this.storeUtils.getChildStore(e, this, (t) => {
      const s = this.cache.getNodes().find((i) => i.node.key == t);
      return s ? s.node : null;
    });
  }
  /**
   * Executes a provided callback on each child store belonging to this store
   *
   * @param cb the callback to execute
   */
  forEachChildStoreShallow(e) {
    this.cache.getNodes().forEach(({ node: t }) => {
      t.childStore && e(t.childStore);
    });
  }
  /**
   * Executes after a change to sorting, determines recursively whether this store or a child requires refreshed.
   *
   * If a purge refresh occurs, the row count is preserved.
   *
   * @param params a set of properties pertaining to the sort changes
   */
  refreshAfterSort(e) {
    if (this.storeUtils.isServerSideSortAllLevels() || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e)) {
      const s = this.cache.isStoreFullyLoaded(), i = this.gos.get("serverSideEnableClientSideSort");
      if (!(s && i)) {
        const n = this.cache.getRowCount(), r = this.cache.isLastRowIndexKnown();
        this.destroyBean(this.cache), this.cache = this.createManagedBean(new Tr(this, n, r, this.storeParams));
        return;
      }
      this.cache.clientSideSortRows();
    }
    this.forEachChildStoreShallow((s) => s.refreshAfterSort(e));
  }
  /**
   * Executes after a change to filtering, determines recursively whether this store or a child requires refreshed.
   *
   * If a refresh occurs, the row count is reset.
   *
   * @param params a set of properties pertaining to the filter changes
   */
  refreshAfterFilter(e) {
    if (!this.storeUtils.isServerSideOnlyRefreshFilteredGroups() || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, e)) {
      this.refreshStore(!0);
      return;
    }
    this.forEachChildStoreShallow((s) => s.refreshAfterFilter(e));
  }
  /**
   * Marks all existing nodes as requiring reloaded, and triggers a load check
   *
   * @param purge whether to remove all nodes and data in favour of stub nodes
   */
  refreshStore(e) {
    if (e) {
      this.destroyBean(this.cache), this.cache = this.createManagedBean(new Tr(this, 1, !1, this.storeParams)), this.fireStoreUpdatedEvent();
      return;
    }
    this.cache.markNodesForRefresh();
  }
  /**
   * Used for pagination, given a local/store index, returns the display index of that row
   *
   * @param topLevelIndex the store index of a row
   * @returns the display index for the given store index
   */
  getTopLevelRowDisplayedIndex(e) {
    return this.cache.getDisplayIndexFromStoreIndex(e) ?? e;
  }
  /**
   * Used for pagination to determine if the last page is known, and for aria to determine if the last grid row is known
   *
   * @returns whether the last index of this store is known, or if lazy loading still required
   */
  isLastRowIndexKnown() {
    return this.cache.isLastRowIndexKnown();
  }
  /**
   * Used by the selection service to select a range of nodes
   *
   * @param firstInRange the first node in the range to find
   * @param lastInRange the last node in the range to find
   * @returns a range of nodes between firstInRange and lastInRange inclusive
   */
  getRowNodesInRange(e, t) {
    return this.cache.getNodes().filter(({ node: s }) => s.rowIndex >= e.rowIndex && s.rowIndex <= t.rowIndex).map(({ node: s }) => s);
  }
  /**
   * Mutates a given array to add this stores state, and recursively add all the children store states.
   *
   * @param result a mutable results array
   */
  addStoreStates(e) {
    e.push({
      route: this.parentRowNode.getRoute() ?? [],
      rowCount: this.getRowCount(),
      lastRowIndexKnown: this.isLastRowIndexKnown(),
      info: this.info,
      maxBlocksInCache: this.storeParams.maxBlocksInCache,
      cacheBlockSize: this.storeParams.cacheBlockSize
    }), this.forEachChildStoreShallow((t) => t.addStoreStates(e));
  }
  getIdSequence() {
    return this.idSequence;
  }
  getParentNode() {
    return this.parentRowNode;
  }
  getRowDetails() {
    return {
      field: this.groupField,
      group: this.group,
      leafGroup: this.leafGroup,
      level: this.level,
      parent: this.parentRowNode,
      rowGroupColumn: this.rowGroupColumn
    };
  }
  getSsrmParams() {
    return this.ssrmParams;
  }
  setStoreInfo(e) {
    e && Object.assign(this.info, e);
  }
  // gets called 1) row count changed 2) cache purged
  fireStoreUpdatedEvent() {
    this.eventSvc.dispatchEvent({
      type: "storeUpdated"
    });
  }
  // gets called when row data updated, and no more refreshing needed
  fireRefreshFinishedEvent() {
    this.eventSvc.dispatchEvent({
      type: "storeRefreshed",
      route: this.parentRowNode.getRoute()
    });
  }
  getBlockStates() {
    return this.cache.getBlockStates();
  }
  getStoreBounds() {
    return {
      topPx: this.topPx,
      heightPx: this.heightPx
    };
  }
  getCache() {
    return this.cache;
  }
  getFirstNode() {
    const e = this.cache.getNodes().getBy("index", 0);
    return (e == null ? void 0 : e.node) ?? null;
  }
}, rE = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmStoreFactory";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.rowGroupColsSvc = e.rowGroupColsSvc, this.pivotColsSvc = e.pivotColsSvc, this.rowAutoHeight = e.rowAutoHeight;
  }
  createStore(e, t) {
    const s = this.getStoreParams(e, t);
    return new nE(e, s, t);
  }
  getStoreParams(e, t) {
    const s = this.getLevelSpecificParams(t), i = this.getBlockSize(s), o = this.getMaxBlocksInCache(e, s);
    return {
      cacheBlockSize: i,
      maxBlocksInCache: o
    };
  }
  getMaxBlocksInCache(e, t) {
    var o;
    const s = t && t.maxBlocksInCache != null ? t.maxBlocksInCache : this.gos.get("maxBlocksInCache");
    if (s != null && s >= 0) {
      if (e.dynamicRowHeight) {
        P(203);
        return;
      }
      if ((o = this.rowAutoHeight) != null && o.active) {
        P(204);
        return;
      }
      return s;
    }
  }
  getBlockSize(e) {
    const t = e && e.cacheBlockSize != null ? e.cacheBlockSize : this.gos.get("cacheBlockSize");
    return t != null && t > 0 ? t : 100;
  }
  getLevelSpecificParams(e) {
    var o, n;
    const t = this.gos.getCallback("getServerSideGroupLevelParams");
    if (!t)
      return;
    const s = {
      level: e.level + 1,
      parentRowNode: e.level >= 0 ? e : void 0,
      rowGroupColumns: ((o = this.rowGroupColsSvc) == null ? void 0 : o.columns) ?? [],
      pivotColumns: ((n = this.pivotColsSvc) == null ? void 0 : n.columns) ?? [],
      pivotMode: this.colModel.isPivotMode()
    };
    return t(s);
  }
}, aE = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmStoreUtils";
  }
  wireBeans(e) {
    this.colModel = e.colModel, this.serverSideRowModel = e.rowModel, this.storeFactory = e.ssrmStoreFactory;
  }
  getChildStore(e, t, s) {
    if (!(e != null && e.length))
      return t;
    const i = e[0], o = s(i);
    if (o) {
      if (e.length === 1 && !o.childStore) {
        const a = this.serverSideRowModel.getParams();
        o.childStore = this.createBean(this.storeFactory.createStore(a, o));
      }
      const n = e.slice(1, e.length), r = o.childStore;
      return r ? r.getChildStore(n) : null;
    }
    return null;
  }
  isServerRefreshNeeded(e, t, s) {
    if (s.valueColChanged || s.secondaryColChanged)
      return !0;
    const i = e.level + 1;
    if (!(i < t.length))
      return !0;
    const r = t[i].id;
    return s.changedColumns.indexOf(r) > -1 ? !0 : this.colModel.getCols().filter((c) => c.getColDef().showRowGroup && s.changedColumns.includes(c.getId())).map((c) => c.getColDef().showRowGroup).some((c) => c === !0 || c === r);
  }
  getServerSideInitialRowCount() {
    return this.gos.get("serverSideInitialRowCount");
  }
  isServerSideSortAllLevels() {
    return this.gos.get("serverSideSortAllLevels") && nt(this.gos);
  }
  isServerSideOnlyRefreshFilteredGroups() {
    return this.gos.get("serverSideOnlyRefreshFilteredGroups") && nt(this.gos);
  }
}, lE = class extends S {
  constructor() {
    super(...arguments), this.beanName = "ssrmTxnManager", this.asyncTransactions = [];
  }
  wireBeans(e) {
    this.valueCache = e.valueCache, this.serverSideRowModel = e.rowModel, this.selectionSvc = e.selectionSvc;
  }
  postConstruct() {
    nt(this.gos);
  }
  applyTransactionAsync(e, t) {
    this.asyncTransactionsTimeout == null && this.scheduleExecuteAsync(), this.asyncTransactions.push({ transaction: e, callback: t });
  }
  scheduleExecuteAsync() {
    const e = this.gos.get("asyncTransactionWaitMillis");
    this.asyncTransactionsTimeout = window.setTimeout(() => {
      this.executeAsyncTransactions();
    }, e);
  }
  executeAsyncTransactions() {
    var o;
    if (!this.asyncTransactions)
      return;
    const e = [], t = [], s = [];
    let i = !1;
    this.asyncTransactions.forEach((n) => {
      let r;
      if (this.serverSideRowModel.executeOnStore(n.transaction.route, (d) => {
        r = d.applyTransaction(n.transaction);
      }) ? r == null && (r = { status: Ft.StoreNotFound }) : r = { status: Ft.StoreNotStarted }, t.push(r), r.status == Ft.StoreLoading) {
        s.push(n);
        return;
      }
      n.callback && e.push(() => n.callback(r)), r.status === Ft.Applied && (i = !0);
    }), e.length > 0 && window.setTimeout(() => {
      e.forEach((n) => n());
    }, 0), this.asyncTransactionsTimeout = void 0, this.asyncTransactions = s, i && ((o = this.valueCache) == null || o.onDataChanged(), this.eventSvc.dispatchEvent({ type: "storeUpdated" })), t.length > 0 && this.eventSvc.dispatchEvent({
      type: "asyncTransactionsFlushed",
      results: t
    });
  }
  flushAsyncTransactions() {
    this.asyncTransactionsTimeout != null && clearTimeout(this.asyncTransactionsTimeout), this.executeAsyncTransactions();
  }
  applyTransaction(e) {
    var i;
    let t;
    if (this.serverSideRowModel.executeOnStore(e.route, (o) => {
      t = o.applyTransaction(e);
    }))
      if (t) {
        if ((i = this.valueCache) == null || i.onDataChanged(), t.remove && this.selectionSvc) {
          const o = t.remove.map((n) => n.id);
          this.selectionSvc.deleteSelectionStateFromParent(e.route || [], o);
        }
        return this.eventSvc.dispatchEvent({ type: "storeUpdated" }), t;
      } else
        return { status: Ft.StoreNotFound };
    else return { status: Ft.StoreNotStarted };
  }
}, dE = {
  moduleName: "ServerSideRowModel",
  version: ce,
  rowModels: ["serverSide"],
  beans: [
    XM,
    KM,
    aE,
    $M,
    QM,
    lE,
    qM,
    rE,
    YM,
    eE,
    sE,
    tE,
    JM,
    ZM
  ],
  dependsOn: [
    Ie,
    ll,
    HF,
    zM,
    UM,
    FM,
    PM
  ]
}, cE = ["number", "category", "grouped-category", "log", "time"];
cE.reduce(
  (e, t) => ({ ...e, [t]: { title: { _enabledFromTheme: !0 } } }),
  {}
);
function Hg(e) {
  return e.map(
    (t, s, i) => t.map((o, n) => i.slice(0, s + 1).reduce((r, a) => r + a[n], 0))
  );
}
function Vg(e) {
  const t = e.map((s, i) => e.reduce((o, n) => Math.max(o, n[i]), 0));
  return e.map((s) => s.map((i, o) => i / t[o] * 19));
}
var _g = [
  [1, 3, 5],
  [2, 6, 4],
  [5, 3, 1]
], uE = Hg(_g);
Vg(uE);
var hE = _g, gE = Hg(hE);
Vg(gE);
var pE = /* @__PURE__ */ re("<div></div>");
const fE = {
  hash: "svelte-1ivzqeq",
  code: `
  /* Hide filter and menu icons by default */.ag-header-cell .ag-header-cell-menu-button,
  .ag-header-cell .ag-floating-filter-button {opacity:0;transition:opacity 0.2s ease-in-out;pointer-events:none;}

  /* Show filter and menu icons on column header hover */.ag-header-cell:hover .ag-header-cell-menu-button,
  .ag-header-cell:hover .ag-floating-filter-button {opacity:1;pointer-events:auto;}

  /* Also handle the filter icon specifically */.ag-header-cell .ag-icon-filter {opacity:0;transition:opacity 0.2s ease-in-out;}.ag-header-cell:hover .ag-icon-filter {opacity:1;}

  /* Dynamic width adjustment for header text */.ag-header-cell-text {overflow:hidden;text-overflow:ellipsis;white-space:nowrap;transition:margin-right 0.2s ease-in-out;margin-right:2px; /* Small margin when icons are hidden */}

  /* Reduce header text width when hovering to make space for icons */.ag-header-cell:hover .ag-header-cell-text {margin-right:2px; /* Space for menu + filter icons when visible */}

  /* Ensure proper positioning of the header content */.ag-header-cell-comp-wrapper {position:relative;width:100%;display:flex;align-items:center;}

  /* Position icons at the right edge */.ag-header-cell .ag-header-cell-menu-button {position:absolute;right:24px;top:50%;transform:translateY(-50%);z-index:1;}.ag-header-cell .ag-floating-filter-button {position:absolute;right:4px;top:50%;transform:translateY(-50%);z-index:1;}`
};
function jt(e, t) {
  _e(t, !0), $e(e, fE), qC.registerModules([
    $F,
    MF,
    dE,
    yD,
    bM,
    $D,
    v0,
    c0,
    hl,
    cM,
    UR
  ]);
  let s = ge(t, "columnDefs", 19, () => []), i = ge(t, "rowData", 19, () => []), o = ge(t, "height", 3, "400px"), n = ge(t, "rowModelType", 3, "clientSide"), r = ge(t, "cacheBlockSize", 3, 50), a = ge(t, "maxBlocksInCache", 3, 10);
  const l = Uh.withPart(SS).withParams({
    backgroundColor: "#2c3e50",
    foregroundColor: "#ecf0f1",
    headerBackgroundColor: "#1a252f",
    headerTextColor: "#ecf0f1",
    oddRowBackgroundColor: "#34495e",
    rowHoverColor: "#3e566d",
    borderColor: "#34495e"
  });
  let d, c;
  Ic(() => {
    try {
      const h = {
        columnDefs: s(),
        rowData: n() === "clientSide" ? i() : void 0,
        rowModelType: n(),
        theme: l,
        rowHeight: n() === "serverSide" ? 40 : void 0,
        defaultColDef: {
          resizable: !0,
          sortable: !0,
          filter: n() === "serverSide" ? "agTextColumnFilter" : !0,
          filterParams: n() === "serverSide" ? {
            filterOptions: ["equals", "contains"],
            defaultOption: "contains",
            suppressAndOrCondition: !0,
            textMatcher: ({ filterOption: g, value: p, filterText: f }) => g === "equals" ? p === f : g === "contains" ? p != null && p.toString().toLowerCase().includes(f.toLowerCase()) : !1
          } : void 0
        },
        cacheBlockSize: r(),
        maxBlocksInCache: a(),
        // Note: serverSideDatasource will be set in the onGridReady callback
        onGridReady: (g) => {
          c = g.api, t.onGridReady && t.onGridReady(g.api);
        }
      };
      c = IR(d, h);
    } catch (h) {
      console.error("AgGrid: Error creating grid:", h);
    }
  }), st(() => {
    c && i() && n() === "clientSide" && c.setGridOption("rowData", i());
  }), st(() => {
    c && s() && c.setGridOption("columnDefs", s());
  });
  var u = pE();
  If(u, (h) => d = h, () => d), Se(() => Ff(u, `height: ${o() ?? ""}; width: 100%;`)), $(e, u), We();
}
class Gt {
  constructor(t = "") {
    Js(this, "baseUrl");
    this.baseUrl = t;
  }
  async request(t, s) {
    const i = `${this.baseUrl}/api/gateway/proxy/dict${t}`, o = await fetch(i, s);
    if (!o.ok)
      throw new Error(`API request failed: ${o.status} ${o.statusText}`);
    return o.json();
  }
  async postRequest(t, s) {
    return this.request(t, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(s)
    });
  }
  // SSRM API method for AG Grid Server-Side Row Model
  async getSSRMData(t, s, i = "FIX.5.0SP2", o) {
    const n = new URLSearchParams({
      datasource: t,
      version: i
    });
    o && o.trim() && n.append("search", o.trim());
    const r = `${this.baseUrl}/api/gateway/proxy/dict/ssrm?${n}`, a = await fetch(r, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(s)
    });
    if (!a.ok)
      throw new Error(`SSRM API request failed: ${a.status} ${a.statusText}`);
    return a.json();
  }
  async getVersions() {
    return this.request("/versions");
  }
  async search(t, s = "FIX.5.0SP2") {
    const i = new URLSearchParams({
      query: t,
      version: s
    }), o = await this.request(`/search?${i}`), n = [], r = [], a = [];
    for (const l of o.results)
      switch (l.type) {
        case "message":
          n.push({
            msg_type: l.msg_type || "",
            name: l.name,
            abbr_name: l.abbr_name,
            component_id: 0,
            // Will be filled by actual API
            category_id: l.category || "",
            description: l.description,
            pedigree: ""
          });
          break;
        case "field":
          r.push({
            tag: l.tag || 0,
            name: l.name,
            abbr_name: l.abbr_name,
            datatype: "String",
            // Will be filled by actual API
            description: l.description,
            pedigree: ""
          });
          break;
        case "component":
          a.push({
            component_id: parseInt(l.id || "0"),
            name: l.name,
            abbr_name: l.abbr_name,
            category_id: l.category || "",
            component_type: "Component",
            is_repeating_group: !1,
            description: l.description,
            pedigree: ""
          });
          break;
      }
    return { messages: n, fields: r, components: a };
  }
  async getMessages(t = "FIX.5.0SP2", s = 1, i = 50) {
    const o = new URLSearchParams({
      version: t,
      page: s.toString(),
      page_size: i.toString()
    });
    return this.request(`/messages?${o}`);
  }
  async getMessage(t, s = "FIX.5.0SP2") {
    const i = new URLSearchParams({ version: s });
    return this.request(`/messages/${t}?${i}`);
  }
  async getFields(t = "FIX.5.0SP2", s = 1, i = 50) {
    const o = new URLSearchParams({
      version: t,
      page: s.toString(),
      page_size: i.toString()
    });
    return this.request(`/fields?${o}`);
  }
  async getField(t, s = "FIX.5.0SP2") {
    const i = new URLSearchParams({ version: s });
    return this.request(`/fields/${t}?${i}`);
  }
  async getComponents(t = "FIX.5.0SP2", s = 1, i = 50) {
    const o = new URLSearchParams({
      version: t,
      page: s.toString(),
      page_size: i.toString()
    });
    return this.request(`/components?${o}`);
  }
  async getComponent(t, s = "FIX.5.0SP2") {
    const i = new URLSearchParams({ version: s });
    return this.request(`/components/${t}?${i}`);
  }
}
var mE = /* @__PURE__ */ re('<span class="loading-indicator svelte-1irc11m">Loading...</span>'), CE = /* @__PURE__ */ re('<div class="message-list svelte-1irc11m"><div class="list-header svelte-1irc11m"><h3 class="svelte-1irc11m">Messages</h3> <div class="count-info svelte-1irc11m"> <!></div></div> <div class="grid-container svelte-1irc11m"><!></div></div>');
const vE = {
  hash: "svelte-1irc11m",
  code: ".message-list.svelte-1irc11m {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-1irc11m {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-1irc11m {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-1irc11m {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-1irc11m {color:#3498db;font-style:italic;}.grid-container.svelte-1irc11m {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function zd(e, t) {
  _e(t, !0), $e(e, vE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "msg_type",
      headerName: "Type",
      width: 80,
      minWidth: 60,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "name",
      headerName: "Message Name",
      width: 250,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "abbr_name",
      headerName: "Abbreviation",
      width: 150,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "category_id",
      headerName: "Category",
      width: 120,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "component_id",
      headerName: "Component ID",
      width: 120,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 300,
      minWidth: 200,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("messages", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("MessageList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = CE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = mE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} messages `)), $(e, u), We();
}
var wE = /* @__PURE__ */ re('<span class="loading-indicator svelte-1wghnej">Loading...</span>'), bE = /* @__PURE__ */ re('<div class="field-list svelte-1wghnej"><div class="list-header svelte-1wghnej"><h3 class="svelte-1wghnej">Fields</h3> <div class="count-info svelte-1wghnej"> <!></div></div> <div class="grid-container svelte-1wghnej"><!></div></div>');
const yE = {
  hash: "svelte-1wghnej",
  code: ".field-list.svelte-1wghnej {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-1wghnej {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-1wghnej {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-1wghnej {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-1wghnej {color:#3498db;font-style:italic;}.grid-container.svelte-1wghnej {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function Ud(e, t) {
  _e(t, !0), $e(e, yE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "tag",
      headerName: "Tag",
      width: 80,
      minWidth: 60,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "name",
      headerName: "Field Name",
      width: 250,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "abbr_name",
      headerName: "Abbreviation",
      width: 150,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "type",
      headerName: "Data Type",
      width: 120,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 300,
      minWidth: 200,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("fields", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("FieldList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = bE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = wE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} fields `)), $(e, u), We();
}
var SE = /* @__PURE__ */ re('<span class="loading-indicator svelte-oqspe2">Loading...</span>'), xE = /* @__PURE__ */ re('<div class="component-list svelte-oqspe2"><div class="list-header svelte-oqspe2"><h3 class="svelte-oqspe2">Components</h3> <div class="count-info svelte-oqspe2"> <!></div></div> <div class="grid-container svelte-oqspe2"><!></div></div>');
const RE = {
  hash: "svelte-oqspe2",
  code: ".component-list.svelte-oqspe2 {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-oqspe2 {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-oqspe2 {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-oqspe2 {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-oqspe2 {color:#3498db;font-style:italic;}.grid-container.svelte-oqspe2 {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function jd(e, t) {
  _e(t, !0), $e(e, RE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "component_id",
      headerName: "ID",
      width: 80,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "name",
      headerName: "Component Name",
      width: 250,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "abbr_name",
      headerName: "Abbreviation",
      width: 150,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "component_type",
      headerName: "Type",
      width: 120,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "category_id",
      headerName: "Category",
      width: 120,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 300,
      minWidth: 200,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("components", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("ComponentList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = xE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = SE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} components `)), $(e, u), We();
}
var FE = /* @__PURE__ */ re('<span class="loading-indicator svelte-5bq8k3">Loading...</span>'), PE = /* @__PURE__ */ re('<div class="enum-list svelte-5bq8k3"><div class="list-header svelte-5bq8k3"><h3 class="svelte-5bq8k3">Enums</h3> <div class="count-info svelte-5bq8k3"> <!></div></div> <div class="grid-container svelte-5bq8k3"><!></div></div>');
const DE = {
  hash: "svelte-5bq8k3",
  code: ".enum-list.svelte-5bq8k3 {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-5bq8k3 {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-5bq8k3 {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-5bq8k3 {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-5bq8k3 {color:#3498db;font-style:italic;}.grid-container.svelte-5bq8k3 {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function ME(e, t) {
  _e(t, !0), $e(e, DE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "tag",
      headerName: "Tag",
      width: 80,
      minWidth: 60,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "value",
      headerName: "Value",
      width: 120,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "symbolic_name",
      headerName: "Symbolic Name",
      width: 250,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "group",
      headerName: "Group",
      width: 120,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "sort",
      headerName: "Sort",
      width: 80,
      minWidth: 60,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 300,
      minWidth: 200,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("enums", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("EnumList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = PE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = FE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} enums `)), $(e, u), We();
}
var EE = /* @__PURE__ */ re('<span class="loading-indicator svelte-16mclmq">Loading...</span>'), AE = /* @__PURE__ */ re('<div class="category-list svelte-16mclmq"><div class="list-header svelte-16mclmq"><h3 class="svelte-16mclmq">Categories</h3> <div class="count-info svelte-16mclmq"> <!></div></div> <div class="grid-container svelte-16mclmq"><!></div></div>');
const IE = {
  hash: "svelte-16mclmq",
  code: ".category-list.svelte-16mclmq {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-16mclmq {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-16mclmq {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-16mclmq {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-16mclmq {color:#3498db;font-style:italic;}.grid-container.svelte-16mclmq {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function TE(e, t) {
  _e(t, !0), $e(e, IE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "category_id",
      headerName: "Category ID",
      width: 120,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "fixml_filename",
      headerName: "FIXML File",
      width: 150,
      minWidth: 120,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "component_type",
      headerName: "Component Type",
      width: 150,
      minWidth: 120,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "section_id",
      headerName: "Section",
      width: 120,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "volume",
      headerName: "Volume",
      width: 100,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 300,
      minWidth: 200,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("categories", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("CategoryList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = AE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = EE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} categories `)), $(e, u), We();
}
var LE = /* @__PURE__ */ re('<span class="loading-indicator svelte-rnhc6z">Loading...</span>'), kE = /* @__PURE__ */ re('<div class="section-list svelte-rnhc6z"><div class="list-header svelte-rnhc6z"><h3 class="svelte-rnhc6z">Sections</h3> <div class="count-info svelte-rnhc6z"> <!></div></div> <div class="grid-container svelte-rnhc6z"><!></div></div>');
const GE = {
  hash: "svelte-rnhc6z",
  code: ".section-list.svelte-rnhc6z {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-rnhc6z {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-rnhc6z {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-rnhc6z {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-rnhc6z {color:#3498db;font-style:italic;}.grid-container.svelte-rnhc6z {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function OE(e, t) {
  _e(t, !0), $e(e, GE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "section_id",
      headerName: "Section ID",
      width: 120,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "name",
      headerName: "Name",
      width: 200,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "display_order",
      headerName: "Display Order",
      width: 120,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "volume",
      headerName: "Volume",
      width: 100,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "fixml_filename",
      headerName: "FIXML File",
      width: 150,
      minWidth: 120,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 300,
      minWidth: 200,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("sections", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("SectionList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = kE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = LE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} sections `)), $(e, u), We();
}
var BE = /* @__PURE__ */ re('<span class="loading-indicator svelte-j3uo16">Loading...</span>'), NE = /* @__PURE__ */ re('<div class="datatype-list svelte-j3uo16"><div class="list-header svelte-j3uo16"><h3 class="svelte-j3uo16">Data Types</h3> <div class="count-info svelte-j3uo16"> <!></div></div> <div class="grid-container svelte-j3uo16"><!></div></div>');
const HE = {
  hash: "svelte-j3uo16",
  code: ".datatype-list.svelte-j3uo16 {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-j3uo16 {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-j3uo16 {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-j3uo16 {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-j3uo16 {color:#3498db;font-style:italic;}.grid-container.svelte-j3uo16 {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function VE(e, t) {
  _e(t, !0), $e(e, HE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "name",
      headerName: "Name",
      width: 200,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "base_type",
      headerName: "Base Type",
      width: 150,
      minWidth: 120,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "example",
      headerName: "Examples",
      width: 200,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 400,
      minWidth: 250,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("datatypes", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("DatatypeList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = NE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = BE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} datatypes `)), $(e, u), We();
}
var _E = /* @__PURE__ */ re('<span class="loading-indicator svelte-ehmcbq">Loading...</span>'), WE = /* @__PURE__ */ re('<div class="abbreviation-list svelte-ehmcbq"><div class="list-header svelte-ehmcbq"><h3 class="svelte-ehmcbq">Abbreviations</h3> <div class="count-info svelte-ehmcbq"> <!></div></div> <div class="grid-container svelte-ehmcbq"><!></div></div>');
const zE = {
  hash: "svelte-ehmcbq",
  code: ".abbreviation-list.svelte-ehmcbq {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-ehmcbq {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-ehmcbq {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-ehmcbq {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-ehmcbq {color:#3498db;font-style:italic;}.grid-container.svelte-ehmcbq {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function UE(e, t) {
  _e(t, !0), $e(e, zE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "term",
      headerName: "Term",
      width: 200,
      minWidth: 150,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "abbr_term",
      headerName: "Abbreviation",
      width: 150,
      minWidth: 120,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "description",
      headerName: "Description",
      width: 400,
      minWidth: 250,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("abbreviations", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("AbbreviationList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = WE(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = _E();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} abbreviations `)), $(e, u), We();
}
var jE = /* @__PURE__ */ re('<span class="loading-indicator svelte-1mfsowg">Loading...</span>'), $E = /* @__PURE__ */ re('<div class="msgcontent-list svelte-1mfsowg"><div class="list-header svelte-1mfsowg"><h3 class="svelte-1mfsowg">Message Contents</h3> <div class="count-info svelte-1mfsowg"> <!></div></div> <div class="grid-container svelte-1mfsowg"><!></div></div>');
const KE = {
  hash: "svelte-1mfsowg",
  code: ".msgcontent-list.svelte-1mfsowg {margin-bottom:30px;height:100%;display:flex;flex-direction:column;}.list-header.svelte-1mfsowg {display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding:0 10px;}h3.svelte-1mfsowg {color:#ecf0f1;font-size:1.25rem;margin:0;border-bottom:2px solid #34495e;padding-bottom:10px;}.count-info.svelte-1mfsowg {color:#95a5a6;font-size:0.9rem;display:flex;align-items:center;gap:10px;}.loading-indicator.svelte-1mfsowg {color:#3498db;font-style:italic;}.grid-container.svelte-1mfsowg {flex:1;background:#2c3e50;border-radius:8px;border:1px solid #34495e;overflow:hidden;min-height:500px;}"
};
function qE(e, t) {
  _e(t, !0), $e(e, KE);
  let s = ge(t, "searchQuery", 3, "");
  const i = new Gt();
  let o, n, r = /* @__PURE__ */ U(0), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U(!1);
  st(() => {
    o && (t.selectedVersion || s()) && o.refreshServerSide({ purge: !0 });
  });
  const d = [
    {
      field: "component_id",
      headerName: "Component ID",
      width: 120,
      minWidth: 100,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "tag_text",
      headerName: "Tag Text",
      width: 150,
      minWidth: 120,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "indent",
      headerName: "Indent",
      width: 80,
      minWidth: 60,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "position",
      headerName: "Position",
      width: 100,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter"
    },
    {
      field: "reqd",
      headerName: "Required",
      width: 100,
      minWidth: 80,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      cellRenderer: (C) => C.value ? "Yes" : "No"
    },
    {
      field: "description",
      headerName: "Description",
      width: 300,
      minWidth: 200,
      resizable: !0,
      sortable: !0,
      filter: "agTextColumnFilter",
      wrapText: !0
    }
  ];
  function c(C) {
    o = C, n = {
      getRows: async (v) => {
        const F = v.request.startRow || 0, R = v.request.endRow || 100;
        try {
          O(a, !0), O(l, !0);
          const D = {
            startRow: F,
            endRow: R,
            rowGroupCols: v.request.rowGroupCols || [],
            valueCols: v.request.valueCols || [],
            pivotCols: v.request.pivotCols || [],
            pivotMode: v.request.pivotMode || !1,
            groupKeys: v.request.groupKeys || [],
            filterModel: v.request.filterModel || void 0,
            sortModel: v.request.sortModel || []
          }, M = await i.getSSRMData("msgcontents", D, t.selectedVersion, s());
          M.rowCount !== void 0 && O(r, M.rowCount, !0), v.success({ rowData: M.rowData, rowCount: M.rowCount });
        } catch (D) {
          console.error("MsgContentList SSRM error:", D), v.fail();
        } finally {
          O(a, !1);
        }
      }
    }, C.setGridOption("serverSideDatasource", n);
  }
  var u = $E(), h = B(u), g = V(B(h), 2), p = B(g), f = V(p);
  {
    var m = (C) => {
      var v = jE();
      $(C, v);
    };
    le(f, (C) => {
      A(a) && C(m);
    });
  }
  var b = V(h, 2), w = B(b);
  jt(w, {
    get columnDefs() {
      return d;
    },
    height: "500px",
    onGridReady: c,
    rowModelType: "serverSide",
    cacheBlockSize: 100,
    maxBlocksInCache: 10
  }), Se(() => it(p, `Total: ${A(r) ?? ""} message contents `)), $(e, u), We();
}
var YE = (e, t) => t("search"), ZE = (e, t) => t("messages"), QE = (e, t) => t("fields"), XE = (e, t) => t("components"), JE = (e, t) => t("enums"), eA = (e, t) => t("categories"), tA = (e, t) => t("sections"), sA = (e, t) => t("datatypes"), iA = (e, t) => t("abbreviations"), oA = (e, t) => t("msgcontents"), nA = /* @__PURE__ */ re('<div class="loading svelte-ja5n1l">Loading...</div>'), rA = /* @__PURE__ */ re('<div class="no-results svelte-ja5n1l"><p> </p></div>'), aA = /* @__PURE__ */ re('<div class="search-results svelte-ja5n1l"><h2 class="svelte-ja5n1l"> </h2> <!> <!> <!> <!></div>'), lA = /* @__PURE__ */ re('<div class="search-tab svelte-ja5n1l"><!> <!></div>'), dA = /* @__PURE__ */ re('<div class="fix-dictionary-app svelte-ja5n1l"><header class="app-header svelte-ja5n1l"><h1 class="svelte-ja5n1l">FIX Dictionary Browser</h1> <!></header> <nav class="tab-navigation svelte-ja5n1l"><button>Search</button> <button>Messages</button> <button>Fields</button> <button>Components</button> <button>Enums</button> <button>Categories</button> <button>Sections</button> <button>Data Types</button> <button>Abbreviations</button> <button>Msg Contents</button></nav> <main class="app-content svelte-ja5n1l"><!> <!></main></div>');
const cA = {
  hash: "svelte-ja5n1l",
  code: `.fix-dictionary-app.svelte-ja5n1l {font-family:-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;margin:0 auto;padding:20px;background:#1a1a1a;color:#e1e5e9;}.app-header.svelte-ja5n1l {display:flex;justify-content:space-between;align-items:center;margin-bottom:30px;padding-bottom:20px;border-bottom:2px solid #34495e;}.app-header.svelte-ja5n1l h1:where(.svelte-ja5n1l) {color:#ecf0f1;margin:0;font-size:2.5rem;font-weight:600;background:linear-gradient(45deg, #3498db, #2ecc71);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;}.tab-navigation.svelte-ja5n1l {display:flex;gap:2px;margin-bottom:30px;border-bottom:2px solid #34495e;flex-wrap:wrap;overflow-x:auto;}.tab-button.svelte-ja5n1l {padding:12px 16px;background:#2c3e50;border:none;border-bottom:3px solid transparent;cursor:pointer;font-size:0.9rem;font-weight:500;color:#bdc3c7;transition:all 0.2s ease;white-space:nowrap;flex-shrink:0;}.tab-button.svelte-ja5n1l:hover {background:#34495e;color:#ecf0f1;}.tab-button.active.svelte-ja5n1l {background:#3498db;color:#ffffff;border-bottom-color:#2ecc71;}.app-content.svelte-ja5n1l {min-height:500px;}.loading.svelte-ja5n1l {display:flex;justify-content:center;align-items:center;height:200px;font-size:1.2rem;color:#95a5a6;}.search-tab.svelte-ja5n1l {max-width:100%;}.search-results.svelte-ja5n1l {margin-top:30px;padding-top:30px;border-top:2px solid #34495e;}.search-results.svelte-ja5n1l h2:where(.svelte-ja5n1l) {color:#ecf0f1;margin-bottom:20px;font-size:1.5rem;}.no-results.svelte-ja5n1l {text-align:center;padding:40px 20px;color:#95a5a6;background:#2c3e50;border-radius:8px;margin-top:20px;border:1px solid #34495e;}

  @media (max-width: 768px) {.fix-dictionary-app.svelte-ja5n1l {padding:10px;}.app-header.svelte-ja5n1l {flex-direction:column;gap:15px;align-items:flex-start;}.app-header.svelte-ja5n1l h1:where(.svelte-ja5n1l) {font-size:2rem;}.tab-navigation.svelte-ja5n1l {flex-wrap:wrap;gap:1px;}.tab-button.svelte-ja5n1l {flex:1;min-width:80px;padding:10px 8px;font-size:0.8rem;}
  }

  @media (max-width: 480px) {.tab-button.svelte-ja5n1l {min-width:70px;padding:8px 6px;font-size:0.75rem;}
  }`
};
function uA(e, t) {
  _e(t, !0), $e(e, cA), ge(t, "name", 3, "fix-dictionary");
  let s = ge(t, "singleSpa", 3, !1), i = /* @__PURE__ */ U("search"), o = /* @__PURE__ */ U("FIX.5.0SP2"), n, r = /* @__PURE__ */ U(null), a = /* @__PURE__ */ U(!1), l = /* @__PURE__ */ U("");
  Ic(() => {
    const ne = s() ? window.location.origin : "http://localhost:8000";
    n = new Gt(ne);
  });
  async function d(ne) {
    if (n) {
      O(a, !0), O(l, ne, !0);
      try {
        O(r, await n.search(ne, A(o)), !0);
      } catch (Te) {
        console.error("Search failed:", Te), O(r, { messages: [], fields: [], components: [] }, !0);
      } finally {
        O(a, !1);
      }
    }
  }
  function c(ne) {
    O(o, ne, !0);
  }
  function u(ne) {
    O(i, ne, !0);
  }
  var h = dA(), g = B(h), p = V(B(g), 2);
  zf(p, {
    get selectedVersion() {
      return A(o);
    },
    onVersionChange: c
  });
  var f = V(g, 2), m = B(f);
  let b;
  m.__click = [YE, u];
  var w = V(m, 2);
  let C;
  w.__click = [ZE, u];
  var v = V(w, 2);
  let F;
  v.__click = [QE, u];
  var R = V(v, 2);
  let D;
  R.__click = [XE, u];
  var M = V(R, 2);
  let I;
  M.__click = [JE, u];
  var J = V(M, 2);
  let W;
  J.__click = [eA, u];
  var E = V(J, 2);
  let oe;
  E.__click = [tA, u];
  var j = V(E, 2);
  let Ce;
  j.__click = [sA, u];
  var z = V(j, 2);
  let se;
  z.__click = [iA, u];
  var Re = V(z, 2);
  let bt;
  Re.__click = [oA, u];
  var Ot = V(f, 2), Bt = B(Ot);
  {
    var js = (ne) => {
      var Te = nA();
      $(ne, Te);
    };
    le(Bt, (ne) => {
      A(a) && ne(js);
    });
  }
  var ve = V(Bt, 2);
  {
    var Cs = (ne) => {
      var Te = lA(), $s = B(Te);
      Nf($s, {
        get searchQuery() {
          return A(l);
        },
        get isSearching() {
          return A(a);
        },
        onSearch: d
      });
      var ki = V($s, 2);
      {
        var Gi = (qe) => {
          var vs = aA(), Ks = B(vs), Oi = B(Ks), qs = V(Ks, 2);
          {
            var $t = (we) => {
              zd(we, {
                get selectedVersion() {
                  return A(o);
                },
                get searchQuery() {
                  return A(l);
                }
              });
            };
            le(qs, (we) => {
              A(r).messages.length > 0 && we($t);
            });
          }
          var Bi = V(qs, 2);
          {
            var Yn = (we) => {
              Ud(we, {
                get selectedVersion() {
                  return A(o);
                },
                get searchQuery() {
                  return A(l);
                }
              });
            };
            le(Bi, (we) => {
              A(r).fields.length > 0 && we(Yn);
            });
          }
          var Po = V(Bi, 2);
          {
            var Zn = (we) => {
              jd(we, {
                get selectedVersion() {
                  return A(o);
                },
                get searchQuery() {
                  return A(l);
                }
              });
            };
            le(Po, (we) => {
              A(r).components.length > 0 && we(Zn);
            });
          }
          var Kt = V(Po, 2);
          {
            var Do = (we) => {
              var Mo = rA(), Qn = B(Mo), qt = B(Qn);
              Se(() => it(qt, `No results found for "${A(l) ?? ""}" in ${A(o) ?? ""}`)), $(we, Mo);
            };
            le(Kt, (we) => {
              A(r).messages.length === 0 && A(r).fields.length === 0 && A(r).components.length === 0 && we(Do);
            });
          }
          Se(() => it(Oi, `Search Results for "${A(l) ?? ""}" (${A(o) ?? ""})`)), $(qe, vs);
        };
        le(ki, (qe) => {
          A(r) && qe(Gi);
        });
      }
      $(ne, Te);
    }, Li = (ne) => {
      var Te = Ht(), $s = Nt(Te);
      {
        var ki = (qe) => {
          zd(qe, {
            get selectedVersion() {
              return A(o);
            }
          });
        }, Gi = (qe) => {
          var vs = Ht(), Ks = Nt(vs);
          {
            var Oi = ($t) => {
              Ud($t, {
                get selectedVersion() {
                  return A(o);
                }
              });
            }, qs = ($t) => {
              var Bi = Ht(), Yn = Nt(Bi);
              {
                var Po = (Kt) => {
                  jd(Kt, {
                    get selectedVersion() {
                      return A(o);
                    }
                  });
                }, Zn = (Kt) => {
                  var Do = Ht(), we = Nt(Do);
                  {
                    var Mo = (qt) => {
                      ME(qt, {
                        get selectedVersion() {
                          return A(o);
                        }
                      });
                    }, Qn = (qt) => {
                      var Cl = Ht(), zg = Nt(Cl);
                      {
                        var Ug = (Ys) => {
                          TE(Ys, {
                            get selectedVersion() {
                              return A(o);
                            }
                          });
                        }, jg = (Ys) => {
                          var vl = Ht(), $g = Nt(vl);
                          {
                            var Kg = (Zs) => {
                              OE(Zs, {
                                get selectedVersion() {
                                  return A(o);
                                }
                              });
                            }, qg = (Zs) => {
                              var wl = Ht(), Yg = Nt(wl);
                              {
                                var Zg = (Qs) => {
                                  VE(Qs, {
                                    get selectedVersion() {
                                      return A(o);
                                    }
                                  });
                                }, Qg = (Qs) => {
                                  var bl = Ht(), Xg = Nt(bl);
                                  {
                                    var Jg = (Xs) => {
                                      UE(Xs, {
                                        get selectedVersion() {
                                          return A(o);
                                        }
                                      });
                                    }, ep = (Xs) => {
                                      var yl = Ht(), tp = Nt(yl);
                                      {
                                        var sp = (Xn) => {
                                          qE(Xn, {
                                            get selectedVersion() {
                                              return A(o);
                                            }
                                          });
                                        };
                                        le(
                                          tp,
                                          (Xn) => {
                                            A(i) === "msgcontents" && Xn(sp);
                                          },
                                          !0
                                        );
                                      }
                                      $(Xs, yl);
                                    };
                                    le(
                                      Xg,
                                      (Xs) => {
                                        A(i) === "abbreviations" ? Xs(Jg) : Xs(ep, !1);
                                      },
                                      !0
                                    );
                                  }
                                  $(Qs, bl);
                                };
                                le(
                                  Yg,
                                  (Qs) => {
                                    A(i) === "datatypes" ? Qs(Zg) : Qs(Qg, !1);
                                  },
                                  !0
                                );
                              }
                              $(Zs, wl);
                            };
                            le(
                              $g,
                              (Zs) => {
                                A(i) === "sections" ? Zs(Kg) : Zs(qg, !1);
                              },
                              !0
                            );
                          }
                          $(Ys, vl);
                        };
                        le(
                          zg,
                          (Ys) => {
                            A(i) === "categories" ? Ys(Ug) : Ys(jg, !1);
                          },
                          !0
                        );
                      }
                      $(qt, Cl);
                    };
                    le(
                      we,
                      (qt) => {
                        A(i) === "enums" ? qt(Mo) : qt(Qn, !1);
                      },
                      !0
                    );
                  }
                  $(Kt, Do);
                };
                le(
                  Yn,
                  (Kt) => {
                    A(i) === "components" ? Kt(Po) : Kt(Zn, !1);
                  },
                  !0
                );
              }
              $($t, Bi);
            };
            le(
              Ks,
              ($t) => {
                A(i) === "fields" ? $t(Oi) : $t(qs, !1);
              },
              !0
            );
          }
          $(qe, vs);
        };
        le(
          $s,
          (qe) => {
            A(i) === "messages" ? qe(ki) : qe(Gi, !1);
          },
          !0
        );
      }
      $(ne, Te);
    };
    le(ve, (ne) => {
      A(i) === "search" ? ne(Cs) : ne(Li, !1);
    });
  }
  Se(
    (ne, Te, $s, ki, Gi, qe, vs, Ks, Oi, qs) => {
      b = yt(m, 1, "tab-button svelte-ja5n1l", null, b, ne), C = yt(w, 1, "tab-button svelte-ja5n1l", null, C, Te), F = yt(v, 1, "tab-button svelte-ja5n1l", null, F, $s), D = yt(R, 1, "tab-button svelte-ja5n1l", null, D, ki), I = yt(M, 1, "tab-button svelte-ja5n1l", null, I, Gi), W = yt(J, 1, "tab-button svelte-ja5n1l", null, W, qe), oe = yt(E, 1, "tab-button svelte-ja5n1l", null, oe, vs), Ce = yt(j, 1, "tab-button svelte-ja5n1l", null, Ce, Ks), se = yt(z, 1, "tab-button svelte-ja5n1l", null, se, Oi), bt = yt(Re, 1, "tab-button svelte-ja5n1l", null, bt, qs);
    },
    [
      () => ({ active: A(i) === "search" }),
      () => ({ active: A(i) === "messages" }),
      () => ({ active: A(i) === "fields" }),
      () => ({ active: A(i) === "components" }),
      () => ({ active: A(i) === "enums" }),
      () => ({ active: A(i) === "categories" }),
      () => ({ active: A(i) === "sections" }),
      () => ({ active: A(i) === "datatypes" }),
      () => ({ active: A(i) === "abbreviations" }),
      () => ({ active: A(i) === "msgcontents" })
    ]
  ), $(e, h), We();
}
xa(["click"]);
let Jo = null;
async function hA() {
  return console.log("FIX Dictionary app bootstrapping..."), Promise.resolve();
}
async function Wg(e) {
  var i;
  console.log("FIX Dictionary app mounting...");
  let t = ((i = document.currentScript) == null ? void 0 : i.parentElement) || (e == null ? void 0 : e.domElement) || (e == null ? void 0 : e.container) || document.getElementById("mfe-chat-container") || document.body;
  const s = document.createElement("div");
  return s.id = "mfe-data-dictionary-app", s.style.overflow = "auto", s.className = "w-full h-full", t.appendChild(s), Jo = mf(uA, {
    target: s,
    props: {
      ...e,
      name: "fix-dictionary",
      singleSpa: !0
    }
  }), Promise.resolve();
}
async function gA() {
  return console.log("FIX Dictionary app unmounting..."), Jo && (vf(Jo), Jo = null), Promise.resolve();
}
typeof window < "u" && (window.bootstrap = hA, window.mount = Wg, window.unmount = gA);
if (!window.singleSpaNavigate) {
  const e = document.createElement("div");
  e.id = "fix-dictionary-app", document.body.appendChild(e), Wg().catch(console.error);
}
export {
  hA as bootstrap,
  Wg as mount,
  gA as unmount
};
